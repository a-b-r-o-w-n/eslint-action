var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __pow = Math.pow;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {enumerable: true, configurable: true, writable: true, value}) : obj[key] = value;
var __objSpread = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __objRest = (source, exclude) => {
  var target = {};
  for (var prop in source)
    if (__hasOwnProp.call(source, prop) && exclude.indexOf(prop) < 0)
      target[prop] = source[prop];
  if (source != null && __getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop) < 0 && __propIsEnum.call(source, prop))
        target[prop] = source[prop];
    }
  return target;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = {exports: {}}).exports, mod), mod.exports);
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, {get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable});
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? {get: () => module2.default, enumerable: true} : {value: module2, enumerable: true})), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// node_modules/@actions/core/lib/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function toCommandValue(input) {
    if (input === null || input === void 0) {
      return "";
    } else if (typeof input === "string" || input instanceof String) {
      return input;
    }
    return JSON.stringify(input);
  }
  exports2.toCommandValue = toCommandValue;
});

// node_modules/@actions/core/lib/command.js
var require_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var os = __importStar(require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, properties, message) {
    const cmd = new Command(command, properties, message);
    process.stdout.write(cmd.toString() + os.EOL);
  }
  exports2.issueCommand = issueCommand;
  function issue(name, message = "") {
    issueCommand(name, {}, message);
  }
  exports2.issue = issue;
  var CMD_STRING = "::";
  var Command = class {
    constructor(command, properties, message) {
      if (!command) {
        command = "missing.command";
      }
      this.command = command;
      this.properties = properties;
      this.message = message;
    }
    toString() {
      let cmdStr = CMD_STRING + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        cmdStr += " ";
        let first = true;
        for (const key in this.properties) {
          if (this.properties.hasOwnProperty(key)) {
            const val = this.properties[key];
            if (val) {
              if (first) {
                first = false;
              } else {
                cmdStr += ",";
              }
              cmdStr += `${key}=${escapeProperty(val)}`;
            }
          }
        }
      }
      cmdStr += `${CMD_STRING}${escapeData(this.message)}`;
      return cmdStr;
    }
  };
  function escapeData(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A");
  }
  function escapeProperty(s) {
    return utils_1.toCommandValue(s).replace(/%/g, "%25").replace(/\r/g, "%0D").replace(/\n/g, "%0A").replace(/:/g, "%3A").replace(/,/g, "%2C");
  }
});

// node_modules/@actions/core/lib/file-command.js
var require_file_command = __commonJS((exports2) => {
  "use strict";
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var fs2 = __importStar(require("fs"));
  var os = __importStar(require("os"));
  var utils_1 = require_utils();
  function issueCommand(command, message) {
    const filePath = process.env[`GITHUB_${command}`];
    if (!filePath) {
      throw new Error(`Unable to find environment variable for file command ${command}`);
    }
    if (!fs2.existsSync(filePath)) {
      throw new Error(`Missing file at path: ${filePath}`);
    }
    fs2.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {
      encoding: "utf8"
    });
  }
  exports2.issueCommand = issueCommand;
});

// node_modules/@actions/core/lib/core.js
var require_core = __commonJS((exports2) => {
  "use strict";
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          result[k] = mod[k];
    }
    result["default"] = mod;
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  var command_1 = require_command();
  var file_command_1 = require_file_command();
  var utils_1 = require_utils();
  var os = __importStar(require("os"));
  var path3 = __importStar(require("path"));
  var ExitCode;
  (function(ExitCode2) {
    ExitCode2[ExitCode2["Success"] = 0] = "Success";
    ExitCode2[ExitCode2["Failure"] = 1] = "Failure";
  })(ExitCode = exports2.ExitCode || (exports2.ExitCode = {}));
  function exportVariable(name, val) {
    const convertedVal = utils_1.toCommandValue(val);
    process.env[name] = convertedVal;
    const filePath = process.env["GITHUB_ENV"] || "";
    if (filePath) {
      const delimiter = "_GitHubActionsFileCommandDelimeter_";
      const commandValue = `${name}<<${delimiter}${os.EOL}${convertedVal}${os.EOL}${delimiter}`;
      file_command_1.issueCommand("ENV", commandValue);
    } else {
      command_1.issueCommand("set-env", {name}, convertedVal);
    }
  }
  exports2.exportVariable = exportVariable;
  function setSecret(secret) {
    command_1.issueCommand("add-mask", {}, secret);
  }
  exports2.setSecret = setSecret;
  function addPath(inputPath) {
    const filePath = process.env["GITHUB_PATH"] || "";
    if (filePath) {
      file_command_1.issueCommand("PATH", inputPath);
    } else {
      command_1.issueCommand("add-path", {}, inputPath);
    }
    process.env["PATH"] = `${inputPath}${path3.delimiter}${process.env["PATH"]}`;
  }
  exports2.addPath = addPath;
  function getInput2(name, options) {
    const val = process.env[`INPUT_${name.replace(/ /g, "_").toUpperCase()}`] || "";
    if (options && options.required && !val) {
      throw new Error(`Input required and not supplied: ${name}`);
    }
    return val.trim();
  }
  exports2.getInput = getInput2;
  function setOutput(name, value) {
    command_1.issueCommand("set-output", {name}, value);
  }
  exports2.setOutput = setOutput;
  function setCommandEcho(enabled) {
    command_1.issue("echo", enabled ? "on" : "off");
  }
  exports2.setCommandEcho = setCommandEcho;
  function setFailed4(message) {
    process.exitCode = ExitCode.Failure;
    error5(message);
  }
  exports2.setFailed = setFailed4;
  function isDebug2() {
    return process.env["RUNNER_DEBUG"] === "1";
  }
  exports2.isDebug = isDebug2;
  function debug5(message) {
    command_1.issueCommand("debug", {}, message);
  }
  exports2.debug = debug5;
  function error5(message) {
    command_1.issue("error", message instanceof Error ? message.toString() : message);
  }
  exports2.error = error5;
  function warning3(message) {
    command_1.issue("warning", message instanceof Error ? message.toString() : message);
  }
  exports2.warning = warning3;
  function info3(message) {
    process.stdout.write(message + os.EOL);
  }
  exports2.info = info3;
  function startGroup2(name) {
    command_1.issue("group", name);
  }
  exports2.startGroup = startGroup2;
  function endGroup2() {
    command_1.issue("endgroup");
  }
  exports2.endGroup = endGroup2;
  function group(name, fn) {
    return __awaiter(this, void 0, void 0, function* () {
      startGroup2(name);
      let result;
      try {
        result = yield fn();
      } finally {
        endGroup2();
      }
      return result;
    });
  }
  exports2.group = group;
  function saveState(name, value) {
    command_1.issueCommand("save-state", {name}, value);
  }
  exports2.saveState = saveState;
  function getState(name) {
    return process.env[`STATE_${name}`] || "";
  }
  exports2.getState = getState;
});

// node_modules/@actions/github/lib/context.js
var require_context = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Context = void 0;
  var fs_1 = require("fs");
  var os_1 = require("os");
  var Context = class {
    constructor() {
      this.payload = {};
      if (process.env.GITHUB_EVENT_PATH) {
        if (fs_1.existsSync(process.env.GITHUB_EVENT_PATH)) {
          this.payload = JSON.parse(fs_1.readFileSync(process.env.GITHUB_EVENT_PATH, {encoding: "utf8"}));
        } else {
          const path3 = process.env.GITHUB_EVENT_PATH;
          process.stdout.write(`GITHUB_EVENT_PATH ${path3} does not exist${os_1.EOL}`);
        }
      }
      this.eventName = process.env.GITHUB_EVENT_NAME;
      this.sha = process.env.GITHUB_SHA;
      this.ref = process.env.GITHUB_REF;
      this.workflow = process.env.GITHUB_WORKFLOW;
      this.action = process.env.GITHUB_ACTION;
      this.actor = process.env.GITHUB_ACTOR;
      this.job = process.env.GITHUB_JOB;
      this.runNumber = parseInt(process.env.GITHUB_RUN_NUMBER, 10);
      this.runId = parseInt(process.env.GITHUB_RUN_ID, 10);
    }
    get issue() {
      const payload = this.payload;
      return Object.assign(Object.assign({}, this.repo), {number: (payload.issue || payload.pull_request || payload).number});
    }
    get repo() {
      if (process.env.GITHUB_REPOSITORY) {
        const [owner, repo] = process.env.GITHUB_REPOSITORY.split("/");
        return {owner, repo};
      }
      if (this.payload.repository) {
        return {
          owner: this.payload.repository.owner.login,
          repo: this.payload.repository.name
        };
      }
      throw new Error("context.repo requires a GITHUB_REPOSITORY environment variable like 'owner/repo'");
    }
  };
  exports2.Context = Context;
});

// node_modules/@actions/http-client/proxy.js
var require_proxy = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function getProxyUrl(reqUrl) {
    let usingSsl = reqUrl.protocol === "https:";
    let proxyUrl;
    if (checkBypass(reqUrl)) {
      return proxyUrl;
    }
    let proxyVar;
    if (usingSsl) {
      proxyVar = process.env["https_proxy"] || process.env["HTTPS_PROXY"];
    } else {
      proxyVar = process.env["http_proxy"] || process.env["HTTP_PROXY"];
    }
    if (proxyVar) {
      proxyUrl = new URL(proxyVar);
    }
    return proxyUrl;
  }
  exports2.getProxyUrl = getProxyUrl;
  function checkBypass(reqUrl) {
    if (!reqUrl.hostname) {
      return false;
    }
    let noProxy = process.env["no_proxy"] || process.env["NO_PROXY"] || "";
    if (!noProxy) {
      return false;
    }
    let reqPort;
    if (reqUrl.port) {
      reqPort = Number(reqUrl.port);
    } else if (reqUrl.protocol === "http:") {
      reqPort = 80;
    } else if (reqUrl.protocol === "https:") {
      reqPort = 443;
    }
    let upperReqHosts = [reqUrl.hostname.toUpperCase()];
    if (typeof reqPort === "number") {
      upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);
    }
    for (let upperNoProxyItem of noProxy.split(",").map((x) => x.trim().toUpperCase()).filter((x) => x)) {
      if (upperReqHosts.some((x) => x === upperNoProxyItem)) {
        return true;
      }
    }
    return false;
  }
  exports2.checkBypass = checkBypass;
});

// node_modules/tunnel/lib/tunnel.js
var require_tunnel = __commonJS((exports2) => {
  "use strict";
  var net = require("net");
  var tls = require("tls");
  var http = require("http");
  var https = require("https");
  var events = require("events");
  var assert = require("assert");
  var util = require("util");
  exports2.httpOverHttp = httpOverHttp;
  exports2.httpsOverHttp = httpsOverHttp;
  exports2.httpOverHttps = httpOverHttps;
  exports2.httpsOverHttps = httpsOverHttps;
  function httpOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    return agent;
  }
  function httpsOverHttp(options) {
    var agent = new TunnelingAgent(options);
    agent.request = http.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function httpOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    return agent;
  }
  function httpsOverHttps(options) {
    var agent = new TunnelingAgent(options);
    agent.request = https.request;
    agent.createSocket = createSecureSocket;
    agent.defaultPort = 443;
    return agent;
  }
  function TunnelingAgent(options) {
    var self2 = this;
    self2.options = options || {};
    self2.proxyOptions = self2.options.proxy || {};
    self2.maxSockets = self2.options.maxSockets || http.Agent.defaultMaxSockets;
    self2.requests = [];
    self2.sockets = [];
    self2.on("free", function onFree(socket, host, port, localAddress) {
      var options2 = toOptions(host, port, localAddress);
      for (var i = 0, len = self2.requests.length; i < len; ++i) {
        var pending = self2.requests[i];
        if (pending.host === options2.host && pending.port === options2.port) {
          self2.requests.splice(i, 1);
          pending.request.onSocket(socket);
          return;
        }
      }
      socket.destroy();
      self2.removeSocket(socket);
    });
  }
  util.inherits(TunnelingAgent, events.EventEmitter);
  TunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {
    var self2 = this;
    var options = mergeOptions({request: req}, self2.options, toOptions(host, port, localAddress));
    if (self2.sockets.length >= this.maxSockets) {
      self2.requests.push(options);
      return;
    }
    self2.createSocket(options, function(socket) {
      socket.on("free", onFree);
      socket.on("close", onCloseOrRemove);
      socket.on("agentRemove", onCloseOrRemove);
      req.onSocket(socket);
      function onFree() {
        self2.emit("free", socket, options);
      }
      function onCloseOrRemove(err) {
        self2.removeSocket(socket);
        socket.removeListener("free", onFree);
        socket.removeListener("close", onCloseOrRemove);
        socket.removeListener("agentRemove", onCloseOrRemove);
      }
    });
  };
  TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
    var self2 = this;
    var placeholder = {};
    self2.sockets.push(placeholder);
    var connectOptions = mergeOptions({}, self2.proxyOptions, {
      method: "CONNECT",
      path: options.host + ":" + options.port,
      agent: false,
      headers: {
        host: options.host + ":" + options.port
      }
    });
    if (options.localAddress) {
      connectOptions.localAddress = options.localAddress;
    }
    if (connectOptions.proxyAuth) {
      connectOptions.headers = connectOptions.headers || {};
      connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
    }
    debug5("making CONNECT request");
    var connectReq = self2.request(connectOptions);
    connectReq.useChunkedEncodingByDefault = false;
    connectReq.once("response", onResponse);
    connectReq.once("upgrade", onUpgrade);
    connectReq.once("connect", onConnect);
    connectReq.once("error", onError);
    connectReq.end();
    function onResponse(res) {
      res.upgrade = true;
    }
    function onUpgrade(res, socket, head) {
      process.nextTick(function() {
        onConnect(res, socket, head);
      });
    }
    function onConnect(res, socket, head) {
      connectReq.removeAllListeners();
      socket.removeAllListeners();
      if (res.statusCode !== 200) {
        debug5("tunneling socket could not be established, statusCode=%d", res.statusCode);
        socket.destroy();
        var error5 = new Error("tunneling socket could not be established, statusCode=" + res.statusCode);
        error5.code = "ECONNRESET";
        options.request.emit("error", error5);
        self2.removeSocket(placeholder);
        return;
      }
      if (head.length > 0) {
        debug5("got illegal response body from proxy");
        socket.destroy();
        var error5 = new Error("got illegal response body from proxy");
        error5.code = "ECONNRESET";
        options.request.emit("error", error5);
        self2.removeSocket(placeholder);
        return;
      }
      debug5("tunneling connection has established");
      self2.sockets[self2.sockets.indexOf(placeholder)] = socket;
      return cb(socket);
    }
    function onError(cause) {
      connectReq.removeAllListeners();
      debug5("tunneling socket could not be established, cause=%s\n", cause.message, cause.stack);
      var error5 = new Error("tunneling socket could not be established, cause=" + cause.message);
      error5.code = "ECONNRESET";
      options.request.emit("error", error5);
      self2.removeSocket(placeholder);
    }
  };
  TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
    var pos = this.sockets.indexOf(socket);
    if (pos === -1) {
      return;
    }
    this.sockets.splice(pos, 1);
    var pending = this.requests.shift();
    if (pending) {
      this.createSocket(pending, function(socket2) {
        pending.request.onSocket(socket2);
      });
    }
  };
  function createSecureSocket(options, cb) {
    var self2 = this;
    TunnelingAgent.prototype.createSocket.call(self2, options, function(socket) {
      var hostHeader = options.request.getHeader("host");
      var tlsOptions = mergeOptions({}, self2.options, {
        socket,
        servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
      });
      var secureSocket = tls.connect(0, tlsOptions);
      self2.sockets[self2.sockets.indexOf(socket)] = secureSocket;
      cb(secureSocket);
    });
  }
  function toOptions(host, port, localAddress) {
    if (typeof host === "string") {
      return {
        host,
        port,
        localAddress
      };
    }
    return host;
  }
  function mergeOptions(target) {
    for (var i = 1, len = arguments.length; i < len; ++i) {
      var overrides = arguments[i];
      if (typeof overrides === "object") {
        var keys = Object.keys(overrides);
        for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
          var k = keys[j];
          if (overrides[k] !== void 0) {
            target[k] = overrides[k];
          }
        }
      }
    }
    return target;
  }
  var debug5;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
    debug5 = function() {
      var args = Array.prototype.slice.call(arguments);
      if (typeof args[0] === "string") {
        args[0] = "TUNNEL: " + args[0];
      } else {
        args.unshift("TUNNEL:");
      }
      console.error.apply(console, args);
    };
  } else {
    debug5 = function() {
    };
  }
  exports2.debug = debug5;
});

// node_modules/tunnel/index.js
var require_tunnel2 = __commonJS((exports2, module2) => {
  module2.exports = require_tunnel();
});

// node_modules/@actions/http-client/index.js
var require_http_client = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var http = require("http");
  var https = require("https");
  var pm = require_proxy();
  var tunnel;
  var HttpCodes;
  (function(HttpCodes2) {
    HttpCodes2[HttpCodes2["OK"] = 200] = "OK";
    HttpCodes2[HttpCodes2["MultipleChoices"] = 300] = "MultipleChoices";
    HttpCodes2[HttpCodes2["MovedPermanently"] = 301] = "MovedPermanently";
    HttpCodes2[HttpCodes2["ResourceMoved"] = 302] = "ResourceMoved";
    HttpCodes2[HttpCodes2["SeeOther"] = 303] = "SeeOther";
    HttpCodes2[HttpCodes2["NotModified"] = 304] = "NotModified";
    HttpCodes2[HttpCodes2["UseProxy"] = 305] = "UseProxy";
    HttpCodes2[HttpCodes2["SwitchProxy"] = 306] = "SwitchProxy";
    HttpCodes2[HttpCodes2["TemporaryRedirect"] = 307] = "TemporaryRedirect";
    HttpCodes2[HttpCodes2["PermanentRedirect"] = 308] = "PermanentRedirect";
    HttpCodes2[HttpCodes2["BadRequest"] = 400] = "BadRequest";
    HttpCodes2[HttpCodes2["Unauthorized"] = 401] = "Unauthorized";
    HttpCodes2[HttpCodes2["PaymentRequired"] = 402] = "PaymentRequired";
    HttpCodes2[HttpCodes2["Forbidden"] = 403] = "Forbidden";
    HttpCodes2[HttpCodes2["NotFound"] = 404] = "NotFound";
    HttpCodes2[HttpCodes2["MethodNotAllowed"] = 405] = "MethodNotAllowed";
    HttpCodes2[HttpCodes2["NotAcceptable"] = 406] = "NotAcceptable";
    HttpCodes2[HttpCodes2["ProxyAuthenticationRequired"] = 407] = "ProxyAuthenticationRequired";
    HttpCodes2[HttpCodes2["RequestTimeout"] = 408] = "RequestTimeout";
    HttpCodes2[HttpCodes2["Conflict"] = 409] = "Conflict";
    HttpCodes2[HttpCodes2["Gone"] = 410] = "Gone";
    HttpCodes2[HttpCodes2["TooManyRequests"] = 429] = "TooManyRequests";
    HttpCodes2[HttpCodes2["InternalServerError"] = 500] = "InternalServerError";
    HttpCodes2[HttpCodes2["NotImplemented"] = 501] = "NotImplemented";
    HttpCodes2[HttpCodes2["BadGateway"] = 502] = "BadGateway";
    HttpCodes2[HttpCodes2["ServiceUnavailable"] = 503] = "ServiceUnavailable";
    HttpCodes2[HttpCodes2["GatewayTimeout"] = 504] = "GatewayTimeout";
  })(HttpCodes = exports2.HttpCodes || (exports2.HttpCodes = {}));
  var Headers;
  (function(Headers2) {
    Headers2["Accept"] = "accept";
    Headers2["ContentType"] = "content-type";
  })(Headers = exports2.Headers || (exports2.Headers = {}));
  var MediaTypes;
  (function(MediaTypes2) {
    MediaTypes2["ApplicationJson"] = "application/json";
  })(MediaTypes = exports2.MediaTypes || (exports2.MediaTypes = {}));
  function getProxyUrl(serverUrl) {
    let proxyUrl = pm.getProxyUrl(new URL(serverUrl));
    return proxyUrl ? proxyUrl.href : "";
  }
  exports2.getProxyUrl = getProxyUrl;
  var HttpRedirectCodes = [
    HttpCodes.MovedPermanently,
    HttpCodes.ResourceMoved,
    HttpCodes.SeeOther,
    HttpCodes.TemporaryRedirect,
    HttpCodes.PermanentRedirect
  ];
  var HttpResponseRetryCodes = [
    HttpCodes.BadGateway,
    HttpCodes.ServiceUnavailable,
    HttpCodes.GatewayTimeout
  ];
  var RetryableHttpVerbs = ["OPTIONS", "GET", "DELETE", "HEAD"];
  var ExponentialBackoffCeiling = 10;
  var ExponentialBackoffTimeSlice = 5;
  var HttpClientError = class extends Error {
    constructor(message, statusCode) {
      super(message);
      this.name = "HttpClientError";
      this.statusCode = statusCode;
      Object.setPrototypeOf(this, HttpClientError.prototype);
    }
  };
  exports2.HttpClientError = HttpClientError;
  var HttpClientResponse = class {
    constructor(message) {
      this.message = message;
    }
    readBody() {
      return new Promise((resolve, reject) => __async(this, null, function* () {
        let output = Buffer.alloc(0);
        this.message.on("data", (chunk) => {
          output = Buffer.concat([output, chunk]);
        });
        this.message.on("end", () => {
          resolve(output.toString());
        });
      }));
    }
  };
  exports2.HttpClientResponse = HttpClientResponse;
  function isHttps(requestUrl) {
    let parsedUrl = new URL(requestUrl);
    return parsedUrl.protocol === "https:";
  }
  exports2.isHttps = isHttps;
  var HttpClient = class {
    constructor(userAgent, handlers, requestOptions) {
      this._ignoreSslError = false;
      this._allowRedirects = true;
      this._allowRedirectDowngrade = false;
      this._maxRedirects = 50;
      this._allowRetries = false;
      this._maxRetries = 1;
      this._keepAlive = false;
      this._disposed = false;
      this.userAgent = userAgent;
      this.handlers = handlers || [];
      this.requestOptions = requestOptions;
      if (requestOptions) {
        if (requestOptions.ignoreSslError != null) {
          this._ignoreSslError = requestOptions.ignoreSslError;
        }
        this._socketTimeout = requestOptions.socketTimeout;
        if (requestOptions.allowRedirects != null) {
          this._allowRedirects = requestOptions.allowRedirects;
        }
        if (requestOptions.allowRedirectDowngrade != null) {
          this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;
        }
        if (requestOptions.maxRedirects != null) {
          this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);
        }
        if (requestOptions.keepAlive != null) {
          this._keepAlive = requestOptions.keepAlive;
        }
        if (requestOptions.allowRetries != null) {
          this._allowRetries = requestOptions.allowRetries;
        }
        if (requestOptions.maxRetries != null) {
          this._maxRetries = requestOptions.maxRetries;
        }
      }
    }
    options(requestUrl, additionalHeaders) {
      return this.request("OPTIONS", requestUrl, null, additionalHeaders || {});
    }
    get(requestUrl, additionalHeaders) {
      return this.request("GET", requestUrl, null, additionalHeaders || {});
    }
    del(requestUrl, additionalHeaders) {
      return this.request("DELETE", requestUrl, null, additionalHeaders || {});
    }
    post(requestUrl, data, additionalHeaders) {
      return this.request("POST", requestUrl, data, additionalHeaders || {});
    }
    patch(requestUrl, data, additionalHeaders) {
      return this.request("PATCH", requestUrl, data, additionalHeaders || {});
    }
    put(requestUrl, data, additionalHeaders) {
      return this.request("PUT", requestUrl, data, additionalHeaders || {});
    }
    head(requestUrl, additionalHeaders) {
      return this.request("HEAD", requestUrl, null, additionalHeaders || {});
    }
    sendStream(verb, requestUrl, stream, additionalHeaders) {
      return this.request(verb, requestUrl, stream, additionalHeaders);
    }
    getJson(_0) {
      return __async(this, arguments, function* (requestUrl, additionalHeaders = {}) {
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        let res = yield this.get(requestUrl, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    postJson(_0, _1) {
      return __async(this, arguments, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.post(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    putJson(_0, _1) {
      return __async(this, arguments, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.put(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    patchJson(_0, _1) {
      return __async(this, arguments, function* (requestUrl, obj, additionalHeaders = {}) {
        let data = JSON.stringify(obj, null, 2);
        additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);
        additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);
        let res = yield this.patch(requestUrl, data, additionalHeaders);
        return this._processResponse(res, this.requestOptions);
      });
    }
    request(verb, requestUrl, data, headers) {
      return __async(this, null, function* () {
        if (this._disposed) {
          throw new Error("Client has already been disposed.");
        }
        let parsedUrl = new URL(requestUrl);
        let info3 = this._prepareRequest(verb, parsedUrl, headers);
        let maxTries = this._allowRetries && RetryableHttpVerbs.indexOf(verb) != -1 ? this._maxRetries + 1 : 1;
        let numTries = 0;
        let response;
        while (numTries < maxTries) {
          response = yield this.requestRaw(info3, data);
          if (response && response.message && response.message.statusCode === HttpCodes.Unauthorized) {
            let authenticationHandler;
            for (let i = 0; i < this.handlers.length; i++) {
              if (this.handlers[i].canHandleAuthentication(response)) {
                authenticationHandler = this.handlers[i];
                break;
              }
            }
            if (authenticationHandler) {
              return authenticationHandler.handleAuthentication(this, info3, data);
            } else {
              return response;
            }
          }
          let redirectsRemaining = this._maxRedirects;
          while (HttpRedirectCodes.indexOf(response.message.statusCode) != -1 && this._allowRedirects && redirectsRemaining > 0) {
            const redirectUrl = response.message.headers["location"];
            if (!redirectUrl) {
              break;
            }
            let parsedRedirectUrl = new URL(redirectUrl);
            if (parsedUrl.protocol == "https:" && parsedUrl.protocol != parsedRedirectUrl.protocol && !this._allowRedirectDowngrade) {
              throw new Error("Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.");
            }
            yield response.readBody();
            if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {
              for (let header in headers) {
                if (header.toLowerCase() === "authorization") {
                  delete headers[header];
                }
              }
            }
            info3 = this._prepareRequest(verb, parsedRedirectUrl, headers);
            response = yield this.requestRaw(info3, data);
            redirectsRemaining--;
          }
          if (HttpResponseRetryCodes.indexOf(response.message.statusCode) == -1) {
            return response;
          }
          numTries += 1;
          if (numTries < maxTries) {
            yield response.readBody();
            yield this._performExponentialBackoff(numTries);
          }
        }
        return response;
      });
    }
    dispose() {
      if (this._agent) {
        this._agent.destroy();
      }
      this._disposed = true;
    }
    requestRaw(info3, data) {
      return new Promise((resolve, reject) => {
        let callbackForResult = function(err, res) {
          if (err) {
            reject(err);
          }
          resolve(res);
        };
        this.requestRawWithCallback(info3, data, callbackForResult);
      });
    }
    requestRawWithCallback(info3, data, onResult) {
      let socket;
      if (typeof data === "string") {
        info3.options.headers["Content-Length"] = Buffer.byteLength(data, "utf8");
      }
      let callbackCalled = false;
      let handleResult = (err, res) => {
        if (!callbackCalled) {
          callbackCalled = true;
          onResult(err, res);
        }
      };
      let req = info3.httpModule.request(info3.options, (msg) => {
        let res = new HttpClientResponse(msg);
        handleResult(null, res);
      });
      req.on("socket", (sock) => {
        socket = sock;
      });
      req.setTimeout(this._socketTimeout || 3 * 6e4, () => {
        if (socket) {
          socket.end();
        }
        handleResult(new Error("Request timeout: " + info3.options.path), null);
      });
      req.on("error", function(err) {
        handleResult(err, null);
      });
      if (data && typeof data === "string") {
        req.write(data, "utf8");
      }
      if (data && typeof data !== "string") {
        data.on("close", function() {
          req.end();
        });
        data.pipe(req);
      } else {
        req.end();
      }
    }
    getAgent(serverUrl) {
      let parsedUrl = new URL(serverUrl);
      return this._getAgent(parsedUrl);
    }
    _prepareRequest(method, requestUrl, headers) {
      const info3 = {};
      info3.parsedUrl = requestUrl;
      const usingSsl = info3.parsedUrl.protocol === "https:";
      info3.httpModule = usingSsl ? https : http;
      const defaultPort = usingSsl ? 443 : 80;
      info3.options = {};
      info3.options.host = info3.parsedUrl.hostname;
      info3.options.port = info3.parsedUrl.port ? parseInt(info3.parsedUrl.port) : defaultPort;
      info3.options.path = (info3.parsedUrl.pathname || "") + (info3.parsedUrl.search || "");
      info3.options.method = method;
      info3.options.headers = this._mergeHeaders(headers);
      if (this.userAgent != null) {
        info3.options.headers["user-agent"] = this.userAgent;
      }
      info3.options.agent = this._getAgent(info3.parsedUrl);
      if (this.handlers) {
        this.handlers.forEach((handler) => {
          handler.prepareRequest(info3.options);
        });
      }
      return info3;
    }
    _mergeHeaders(headers) {
      const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
      if (this.requestOptions && this.requestOptions.headers) {
        return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers));
      }
      return lowercaseKeys(headers || {});
    }
    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {
      const lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => (c[k.toLowerCase()] = obj[k], c), {});
      let clientHeader;
      if (this.requestOptions && this.requestOptions.headers) {
        clientHeader = lowercaseKeys(this.requestOptions.headers)[header];
      }
      return additionalHeaders[header] || clientHeader || _default;
    }
    _getAgent(parsedUrl) {
      let agent;
      let proxyUrl = pm.getProxyUrl(parsedUrl);
      let useProxy = proxyUrl && proxyUrl.hostname;
      if (this._keepAlive && useProxy) {
        agent = this._proxyAgent;
      }
      if (this._keepAlive && !useProxy) {
        agent = this._agent;
      }
      if (!!agent) {
        return agent;
      }
      const usingSsl = parsedUrl.protocol === "https:";
      let maxSockets = 100;
      if (!!this.requestOptions) {
        maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;
      }
      if (useProxy) {
        if (!tunnel) {
          tunnel = require_tunnel2();
        }
        const agentOptions = {
          maxSockets,
          keepAlive: this._keepAlive,
          proxy: {
            proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`,
            host: proxyUrl.hostname,
            port: proxyUrl.port
          }
        };
        let tunnelAgent;
        const overHttps = proxyUrl.protocol === "https:";
        if (usingSsl) {
          tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;
        } else {
          tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;
        }
        agent = tunnelAgent(agentOptions);
        this._proxyAgent = agent;
      }
      if (this._keepAlive && !agent) {
        const options = {keepAlive: this._keepAlive, maxSockets};
        agent = usingSsl ? new https.Agent(options) : new http.Agent(options);
        this._agent = agent;
      }
      if (!agent) {
        agent = usingSsl ? https.globalAgent : http.globalAgent;
      }
      if (usingSsl && this._ignoreSslError) {
        agent.options = Object.assign(agent.options || {}, {
          rejectUnauthorized: false
        });
      }
      return agent;
    }
    _performExponentialBackoff(retryNumber) {
      retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);
      const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);
      return new Promise((resolve) => setTimeout(() => resolve(), ms));
    }
    static dateTimeDeserializer(key, value) {
      if (typeof value === "string") {
        let a = new Date(value);
        if (!isNaN(a.valueOf())) {
          return a;
        }
      }
      return value;
    }
    _processResponse(res, options) {
      return __async(this, null, function* () {
        return new Promise((resolve, reject) => __async(this, null, function* () {
          const statusCode = res.message.statusCode;
          const response = {
            statusCode,
            result: null,
            headers: {}
          };
          if (statusCode == HttpCodes.NotFound) {
            resolve(response);
          }
          let obj;
          let contents;
          try {
            contents = yield res.readBody();
            if (contents && contents.length > 0) {
              if (options && options.deserializeDates) {
                obj = JSON.parse(contents, HttpClient.dateTimeDeserializer);
              } else {
                obj = JSON.parse(contents);
              }
              response.result = obj;
            }
            response.headers = res.message.headers;
          } catch (err) {
          }
          if (statusCode > 299) {
            let msg;
            if (obj && obj.message) {
              msg = obj.message;
            } else if (contents && contents.length > 0) {
              msg = contents;
            } else {
              msg = "Failed request: (" + statusCode + ")";
            }
            let err = new HttpClientError(msg, statusCode);
            err.result = response.result;
            reject(err);
          } else {
            resolve(response);
          }
        }));
      });
    }
  };
  exports2.HttpClient = HttpClient;
});

// node_modules/@actions/github/lib/internal/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getApiBaseUrl = exports2.getProxyAgent = exports2.getAuthString = void 0;
  var httpClient = __importStar(require_http_client());
  function getAuthString(token, options) {
    if (!token && !options.auth) {
      throw new Error("Parameter token or opts.auth is required");
    } else if (token && options.auth) {
      throw new Error("Parameters token and opts.auth may not both be specified");
    }
    return typeof options.auth === "string" ? options.auth : `token ${token}`;
  }
  exports2.getAuthString = getAuthString;
  function getProxyAgent(destinationUrl) {
    const hc = new httpClient.HttpClient();
    return hc.getAgent(destinationUrl);
  }
  exports2.getProxyAgent = getProxyAgent;
  function getApiBaseUrl() {
    return process.env["GITHUB_API_URL"] || "https://api.github.com";
  }
  exports2.getApiBaseUrl = getApiBaseUrl;
});

// node_modules/universal-user-agent/dist-node/index.js
var require_dist_node = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function getUserAgent() {
    if (typeof navigator === "object" && "userAgent" in navigator) {
      return navigator.userAgent;
    }
    if (typeof process === "object" && "version" in process) {
      return `Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`;
    }
    return "<environment undetectable>";
  }
  exports2.getUserAgent = getUserAgent;
});

// node_modules/before-after-hook/lib/register.js
var require_register = __commonJS((exports2, module2) => {
  module2.exports = register;
  function register(state, name, method, options) {
    if (typeof method !== "function") {
      throw new Error("method for before hook must be a function");
    }
    if (!options) {
      options = {};
    }
    if (Array.isArray(name)) {
      return name.reverse().reduce(function(callback, name2) {
        return register.bind(null, state, name2, callback, options);
      }, method)();
    }
    return Promise.resolve().then(function() {
      if (!state.registry[name]) {
        return method(options);
      }
      return state.registry[name].reduce(function(method2, registered) {
        return registered.hook.bind(null, method2, options);
      }, method)();
    });
  }
});

// node_modules/before-after-hook/lib/add.js
var require_add = __commonJS((exports2, module2) => {
  module2.exports = addHook;
  function addHook(state, kind, name, hook) {
    var orig = hook;
    if (!state.registry[name]) {
      state.registry[name] = [];
    }
    if (kind === "before") {
      hook = function(method, options) {
        return Promise.resolve().then(orig.bind(null, options)).then(method.bind(null, options));
      };
    }
    if (kind === "after") {
      hook = function(method, options) {
        var result;
        return Promise.resolve().then(method.bind(null, options)).then(function(result_) {
          result = result_;
          return orig(result, options);
        }).then(function() {
          return result;
        });
      };
    }
    if (kind === "error") {
      hook = function(method, options) {
        return Promise.resolve().then(method.bind(null, options)).catch(function(error5) {
          return orig(error5, options);
        });
      };
    }
    state.registry[name].push({
      hook,
      orig
    });
  }
});

// node_modules/before-after-hook/lib/remove.js
var require_remove = __commonJS((exports2, module2) => {
  module2.exports = removeHook;
  function removeHook(state, name, method) {
    if (!state.registry[name]) {
      return;
    }
    var index = state.registry[name].map(function(registered) {
      return registered.orig;
    }).indexOf(method);
    if (index === -1) {
      return;
    }
    state.registry[name].splice(index, 1);
  }
});

// node_modules/before-after-hook/index.js
var require_before_after_hook = __commonJS((exports2, module2) => {
  var register = require_register();
  var addHook = require_add();
  var removeHook = require_remove();
  var bind = Function.bind;
  var bindable = bind.bind(bind);
  function bindApi(hook, state, name) {
    var removeHookRef = bindable(removeHook, null).apply(null, name ? [state, name] : [state]);
    hook.api = {remove: removeHookRef};
    hook.remove = removeHookRef;
    ["before", "error", "after", "wrap"].forEach(function(kind) {
      var args = name ? [state, kind, name] : [state, kind];
      hook[kind] = hook.api[kind] = bindable(addHook, null).apply(null, args);
    });
  }
  function HookSingular() {
    var singularHookName = "h";
    var singularHookState = {
      registry: {}
    };
    var singularHook = register.bind(null, singularHookState, singularHookName);
    bindApi(singularHook, singularHookState, singularHookName);
    return singularHook;
  }
  function HookCollection() {
    var state = {
      registry: {}
    };
    var hook = register.bind(null, state);
    bindApi(hook, state);
    return hook;
  }
  var collectionHookDeprecationMessageDisplayed = false;
  function Hook() {
    if (!collectionHookDeprecationMessageDisplayed) {
      console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4');
      collectionHookDeprecationMessageDisplayed = true;
    }
    return HookCollection();
  }
  Hook.Singular = HookSingular.bind();
  Hook.Collection = HookCollection.bind();
  module2.exports = Hook;
  module2.exports.Hook = Hook;
  module2.exports.Singular = Hook.Singular;
  module2.exports.Collection = Hook.Collection;
});

// node_modules/is-plain-object/dist/is-plain-object.js
var require_is_plain_object = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  /*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  function isObject(o) {
    return Object.prototype.toString.call(o) === "[object Object]";
  }
  function isPlainObject(o) {
    var ctor, prot;
    if (isObject(o) === false)
      return false;
    ctor = o.constructor;
    if (ctor === void 0)
      return true;
    prot = ctor.prototype;
    if (isObject(prot) === false)
      return false;
    if (prot.hasOwnProperty("isPrototypeOf") === false) {
      return false;
    }
    return true;
  }
  exports2.isPlainObject = isPlainObject;
});

// node_modules/@octokit/endpoint/dist-node/index.js
var require_dist_node2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var isPlainObject = require_is_plain_object();
  var universalUserAgent = require_dist_node();
  function lowercaseKeys(object) {
    if (!object) {
      return {};
    }
    return Object.keys(object).reduce((newObj, key) => {
      newObj[key.toLowerCase()] = object[key];
      return newObj;
    }, {});
  }
  function mergeDeep(defaults, options) {
    const result = Object.assign({}, defaults);
    Object.keys(options).forEach((key) => {
      if (isPlainObject.isPlainObject(options[key])) {
        if (!(key in defaults))
          Object.assign(result, {
            [key]: options[key]
          });
        else
          result[key] = mergeDeep(defaults[key], options[key]);
      } else {
        Object.assign(result, {
          [key]: options[key]
        });
      }
    });
    return result;
  }
  function removeUndefinedProperties(obj) {
    for (const key in obj) {
      if (obj[key] === void 0) {
        delete obj[key];
      }
    }
    return obj;
  }
  function merge(defaults, route, options) {
    if (typeof route === "string") {
      let [method, url] = route.split(" ");
      options = Object.assign(url ? {
        method,
        url
      } : {
        url: method
      }, options);
    } else {
      options = Object.assign({}, route);
    }
    options.headers = lowercaseKeys(options.headers);
    removeUndefinedProperties(options);
    removeUndefinedProperties(options.headers);
    const mergedOptions = mergeDeep(defaults || {}, options);
    if (defaults && defaults.mediaType.previews.length) {
      mergedOptions.mediaType.previews = defaults.mediaType.previews.filter((preview) => !mergedOptions.mediaType.previews.includes(preview)).concat(mergedOptions.mediaType.previews);
    }
    mergedOptions.mediaType.previews = mergedOptions.mediaType.previews.map((preview) => preview.replace(/-preview/, ""));
    return mergedOptions;
  }
  function addQueryParameters(url, parameters) {
    const separator = /\?/.test(url) ? "&" : "?";
    const names = Object.keys(parameters);
    if (names.length === 0) {
      return url;
    }
    return url + separator + names.map((name) => {
      if (name === "q") {
        return "q=" + parameters.q.split("+").map(encodeURIComponent).join("+");
      }
      return `${name}=${encodeURIComponent(parameters[name])}`;
    }).join("&");
  }
  var urlVariableRegex = /\{[^}]+\}/g;
  function removeNonChars(variableName) {
    return variableName.replace(/^\W+|\W+$/g, "").split(/,/);
  }
  function extractUrlVariableNames(url) {
    const matches = url.match(urlVariableRegex);
    if (!matches) {
      return [];
    }
    return matches.map(removeNonChars).reduce((a, b) => a.concat(b), []);
  }
  function omit(object, keysToOmit) {
    return Object.keys(object).filter((option) => !keysToOmit.includes(option)).reduce((obj, key) => {
      obj[key] = object[key];
      return obj;
    }, {});
  }
  function encodeReserved(str) {
    return str.split(/(%[0-9A-Fa-f]{2})/g).map(function(part) {
      if (!/%[0-9A-Fa-f]/.test(part)) {
        part = encodeURI(part).replace(/%5B/g, "[").replace(/%5D/g, "]");
      }
      return part;
    }).join("");
  }
  function encodeUnreserved(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
      return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function encodeValue(operator, value, key) {
    value = operator === "+" || operator === "#" ? encodeReserved(value) : encodeUnreserved(value);
    if (key) {
      return encodeUnreserved(key) + "=" + value;
    } else {
      return value;
    }
  }
  function isDefined(value) {
    return value !== void 0 && value !== null;
  }
  function isKeyOperator(operator) {
    return operator === ";" || operator === "&" || operator === "?";
  }
  function getValues(context4, operator, key, modifier) {
    var value = context4[key], result = [];
    if (isDefined(value) && value !== "") {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        value = value.toString();
        if (modifier && modifier !== "*") {
          value = value.substring(0, parseInt(modifier, 10));
        }
        result.push(encodeValue(operator, value, isKeyOperator(operator) ? key : ""));
      } else {
        if (modifier === "*") {
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              result.push(encodeValue(operator, value2, isKeyOperator(operator) ? key : ""));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                result.push(encodeValue(operator, value[k], k));
              }
            });
          }
        } else {
          const tmp = [];
          if (Array.isArray(value)) {
            value.filter(isDefined).forEach(function(value2) {
              tmp.push(encodeValue(operator, value2));
            });
          } else {
            Object.keys(value).forEach(function(k) {
              if (isDefined(value[k])) {
                tmp.push(encodeUnreserved(k));
                tmp.push(encodeValue(operator, value[k].toString()));
              }
            });
          }
          if (isKeyOperator(operator)) {
            result.push(encodeUnreserved(key) + "=" + tmp.join(","));
          } else if (tmp.length !== 0) {
            result.push(tmp.join(","));
          }
        }
      }
    } else {
      if (operator === ";") {
        if (isDefined(value)) {
          result.push(encodeUnreserved(key));
        }
      } else if (value === "" && (operator === "&" || operator === "?")) {
        result.push(encodeUnreserved(key) + "=");
      } else if (value === "") {
        result.push("");
      }
    }
    return result;
  }
  function parseUrl(template) {
    return {
      expand: expand.bind(null, template)
    };
  }
  function expand(template, context4) {
    var operators = ["+", "#", ".", "/", ";", "?", "&"];
    return template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g, function(_, expression, literal) {
      if (expression) {
        let operator = "";
        const values = [];
        if (operators.indexOf(expression.charAt(0)) !== -1) {
          operator = expression.charAt(0);
          expression = expression.substr(1);
        }
        expression.split(/,/g).forEach(function(variable) {
          var tmp = /([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);
          values.push(getValues(context4, operator, tmp[1], tmp[2] || tmp[3]));
        });
        if (operator && operator !== "+") {
          var separator = ",";
          if (operator === "?") {
            separator = "&";
          } else if (operator !== "#") {
            separator = operator;
          }
          return (values.length !== 0 ? operator : "") + values.join(separator);
        } else {
          return values.join(",");
        }
      } else {
        return encodeReserved(literal);
      }
    });
  }
  function parse(options) {
    let method = options.method.toUpperCase();
    let url = (options.url || "/").replace(/:([a-z]\w+)/g, "{$1}");
    let headers = Object.assign({}, options.headers);
    let body;
    let parameters = omit(options, ["method", "baseUrl", "url", "headers", "request", "mediaType"]);
    const urlVariableNames = extractUrlVariableNames(url);
    url = parseUrl(url).expand(parameters);
    if (!/^http/.test(url)) {
      url = options.baseUrl + url;
    }
    const omittedParameters = Object.keys(options).filter((option) => urlVariableNames.includes(option)).concat("baseUrl");
    const remainingParameters = omit(parameters, omittedParameters);
    const isBinaryRequest = /application\/octet-stream/i.test(headers.accept);
    if (!isBinaryRequest) {
      if (options.mediaType.format) {
        headers.accept = headers.accept.split(/,/).map((preview) => preview.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/, `application/vnd$1$2.${options.mediaType.format}`)).join(",");
      }
      if (options.mediaType.previews.length) {
        const previewsFromAcceptHeader = headers.accept.match(/[\w-]+(?=-preview)/g) || [];
        headers.accept = previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview) => {
          const format = options.mediaType.format ? `.${options.mediaType.format}` : "+json";
          return `application/vnd.github.${preview}-preview${format}`;
        }).join(",");
      }
    }
    if (["GET", "HEAD"].includes(method)) {
      url = addQueryParameters(url, remainingParameters);
    } else {
      if ("data" in remainingParameters) {
        body = remainingParameters.data;
      } else {
        if (Object.keys(remainingParameters).length) {
          body = remainingParameters;
        } else {
          headers["content-length"] = 0;
        }
      }
    }
    if (!headers["content-type"] && typeof body !== "undefined") {
      headers["content-type"] = "application/json; charset=utf-8";
    }
    if (["PATCH", "PUT"].includes(method) && typeof body === "undefined") {
      body = "";
    }
    return Object.assign({
      method,
      url,
      headers
    }, typeof body !== "undefined" ? {
      body
    } : null, options.request ? {
      request: options.request
    } : null);
  }
  function endpointWithDefaults(defaults, route, options) {
    return parse(merge(defaults, route, options));
  }
  function withDefaults(oldDefaults, newDefaults) {
    const DEFAULTS2 = merge(oldDefaults, newDefaults);
    const endpoint2 = endpointWithDefaults.bind(null, DEFAULTS2);
    return Object.assign(endpoint2, {
      DEFAULTS: DEFAULTS2,
      defaults: withDefaults.bind(null, DEFAULTS2),
      merge: merge.bind(null, DEFAULTS2),
      parse
    });
  }
  var VERSION = "6.0.9";
  var userAgent = `octokit-endpoint.js/${VERSION} ${universalUserAgent.getUserAgent()}`;
  var DEFAULTS = {
    method: "GET",
    baseUrl: "https://api.github.com",
    headers: {
      accept: "application/vnd.github.v3+json",
      "user-agent": userAgent
    },
    mediaType: {
      format: "",
      previews: []
    }
  };
  var endpoint = withDefaults(null, DEFAULTS);
  exports2.endpoint = endpoint;
});

// node_modules/node-fetch/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var Stream = _interopDefault(require("stream"));
  var http = _interopDefault(require("http"));
  var Url = _interopDefault(require("url"));
  var https = _interopDefault(require("https"));
  var zlib = _interopDefault(require("zlib"));
  var Readable = Stream.Readable;
  var BUFFER = Symbol("buffer");
  var TYPE = Symbol("type");
  var Blob = class {
    constructor() {
      this[TYPE] = "";
      const blobParts = arguments[0];
      const options = arguments[1];
      const buffers = [];
      let size = 0;
      if (blobParts) {
        const a = blobParts;
        const length = Number(a.length);
        for (let i = 0; i < length; i++) {
          const element = a[i];
          let buffer;
          if (element instanceof Buffer) {
            buffer = element;
          } else if (ArrayBuffer.isView(element)) {
            buffer = Buffer.from(element.buffer, element.byteOffset, element.byteLength);
          } else if (element instanceof ArrayBuffer) {
            buffer = Buffer.from(element);
          } else if (element instanceof Blob) {
            buffer = element[BUFFER];
          } else {
            buffer = Buffer.from(typeof element === "string" ? element : String(element));
          }
          size += buffer.length;
          buffers.push(buffer);
        }
      }
      this[BUFFER] = Buffer.concat(buffers);
      let type = options && options.type !== void 0 && String(options.type).toLowerCase();
      if (type && !/[^\u0020-\u007E]/.test(type)) {
        this[TYPE] = type;
      }
    }
    get size() {
      return this[BUFFER].length;
    }
    get type() {
      return this[TYPE];
    }
    text() {
      return Promise.resolve(this[BUFFER].toString());
    }
    arrayBuffer() {
      const buf = this[BUFFER];
      const ab = buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      return Promise.resolve(ab);
    }
    stream() {
      const readable = new Readable();
      readable._read = function() {
      };
      readable.push(this[BUFFER]);
      readable.push(null);
      return readable;
    }
    toString() {
      return "[object Blob]";
    }
    slice() {
      const size = this.size;
      const start = arguments[0];
      const end = arguments[1];
      let relativeStart, relativeEnd;
      if (start === void 0) {
        relativeStart = 0;
      } else if (start < 0) {
        relativeStart = Math.max(size + start, 0);
      } else {
        relativeStart = Math.min(start, size);
      }
      if (end === void 0) {
        relativeEnd = size;
      } else if (end < 0) {
        relativeEnd = Math.max(size + end, 0);
      } else {
        relativeEnd = Math.min(end, size);
      }
      const span = Math.max(relativeEnd - relativeStart, 0);
      const buffer = this[BUFFER];
      const slicedBuffer = buffer.slice(relativeStart, relativeStart + span);
      const blob = new Blob([], {type: arguments[2]});
      blob[BUFFER] = slicedBuffer;
      return blob;
    }
  };
  Object.defineProperties(Blob.prototype, {
    size: {enumerable: true},
    type: {enumerable: true},
    slice: {enumerable: true}
  });
  Object.defineProperty(Blob.prototype, Symbol.toStringTag, {
    value: "Blob",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function FetchError(message, type, systemError) {
    Error.call(this, message);
    this.message = message;
    this.type = type;
    if (systemError) {
      this.code = this.errno = systemError.code;
    }
    Error.captureStackTrace(this, this.constructor);
  }
  FetchError.prototype = Object.create(Error.prototype);
  FetchError.prototype.constructor = FetchError;
  FetchError.prototype.name = "FetchError";
  var convert;
  try {
    convert = require("encoding").convert;
  } catch (e) {
  }
  var INTERNALS = Symbol("Body internals");
  var PassThrough = Stream.PassThrough;
  function Body(body) {
    var _this = this;
    var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$size = _ref.size;
    let size = _ref$size === void 0 ? 0 : _ref$size;
    var _ref$timeout = _ref.timeout;
    let timeout = _ref$timeout === void 0 ? 0 : _ref$timeout;
    if (body == null) {
      body = null;
    } else if (isURLSearchParams(body)) {
      body = Buffer.from(body.toString());
    } else if (isBlob(body))
      ;
    else if (Buffer.isBuffer(body))
      ;
    else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      body = Buffer.from(body);
    } else if (ArrayBuffer.isView(body)) {
      body = Buffer.from(body.buffer, body.byteOffset, body.byteLength);
    } else if (body instanceof Stream)
      ;
    else {
      body = Buffer.from(String(body));
    }
    this[INTERNALS] = {
      body,
      disturbed: false,
      error: null
    };
    this.size = size;
    this.timeout = timeout;
    if (body instanceof Stream) {
      body.on("error", function(err) {
        const error5 = err.name === "AbortError" ? err : new FetchError(`Invalid response body while trying to fetch ${_this.url}: ${err.message}`, "system", err);
        _this[INTERNALS].error = error5;
      });
    }
  }
  Body.prototype = {
    get body() {
      return this[INTERNALS].body;
    },
    get bodyUsed() {
      return this[INTERNALS].disturbed;
    },
    arrayBuffer() {
      return consumeBody.call(this).then(function(buf) {
        return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
      });
    },
    blob() {
      let ct = this.headers && this.headers.get("content-type") || "";
      return consumeBody.call(this).then(function(buf) {
        return Object.assign(new Blob([], {
          type: ct.toLowerCase()
        }), {
          [BUFFER]: buf
        });
      });
    },
    json() {
      var _this2 = this;
      return consumeBody.call(this).then(function(buffer) {
        try {
          return JSON.parse(buffer.toString());
        } catch (err) {
          return Body.Promise.reject(new FetchError(`invalid json response body at ${_this2.url} reason: ${err.message}`, "invalid-json"));
        }
      });
    },
    text() {
      return consumeBody.call(this).then(function(buffer) {
        return buffer.toString();
      });
    },
    buffer() {
      return consumeBody.call(this);
    },
    textConverted() {
      var _this3 = this;
      return consumeBody.call(this).then(function(buffer) {
        return convertBody(buffer, _this3.headers);
      });
    }
  };
  Object.defineProperties(Body.prototype, {
    body: {enumerable: true},
    bodyUsed: {enumerable: true},
    arrayBuffer: {enumerable: true},
    blob: {enumerable: true},
    json: {enumerable: true},
    text: {enumerable: true}
  });
  Body.mixIn = function(proto) {
    for (const name of Object.getOwnPropertyNames(Body.prototype)) {
      if (!(name in proto)) {
        const desc = Object.getOwnPropertyDescriptor(Body.prototype, name);
        Object.defineProperty(proto, name, desc);
      }
    }
  };
  function consumeBody() {
    var _this4 = this;
    if (this[INTERNALS].disturbed) {
      return Body.Promise.reject(new TypeError(`body used already for: ${this.url}`));
    }
    this[INTERNALS].disturbed = true;
    if (this[INTERNALS].error) {
      return Body.Promise.reject(this[INTERNALS].error);
    }
    let body = this.body;
    if (body === null) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    if (isBlob(body)) {
      body = body.stream();
    }
    if (Buffer.isBuffer(body)) {
      return Body.Promise.resolve(body);
    }
    if (!(body instanceof Stream)) {
      return Body.Promise.resolve(Buffer.alloc(0));
    }
    let accum = [];
    let accumBytes = 0;
    let abort = false;
    return new Body.Promise(function(resolve, reject) {
      let resTimeout;
      if (_this4.timeout) {
        resTimeout = setTimeout(function() {
          abort = true;
          reject(new FetchError(`Response timeout while trying to fetch ${_this4.url} (over ${_this4.timeout}ms)`, "body-timeout"));
        }, _this4.timeout);
      }
      body.on("error", function(err) {
        if (err.name === "AbortError") {
          abort = true;
          reject(err);
        } else {
          reject(new FetchError(`Invalid response body while trying to fetch ${_this4.url}: ${err.message}`, "system", err));
        }
      });
      body.on("data", function(chunk) {
        if (abort || chunk === null) {
          return;
        }
        if (_this4.size && accumBytes + chunk.length > _this4.size) {
          abort = true;
          reject(new FetchError(`content size at ${_this4.url} over limit: ${_this4.size}`, "max-size"));
          return;
        }
        accumBytes += chunk.length;
        accum.push(chunk);
      });
      body.on("end", function() {
        if (abort) {
          return;
        }
        clearTimeout(resTimeout);
        try {
          resolve(Buffer.concat(accum, accumBytes));
        } catch (err) {
          reject(new FetchError(`Could not create Buffer from response body for ${_this4.url}: ${err.message}`, "system", err));
        }
      });
    });
  }
  function convertBody(buffer, headers) {
    if (typeof convert !== "function") {
      throw new Error("The package `encoding` must be installed to use the textConverted() function");
    }
    const ct = headers.get("content-type");
    let charset = "utf-8";
    let res, str;
    if (ct) {
      res = /charset=([^;]*)/i.exec(ct);
    }
    str = buffer.slice(0, 1024).toString();
    if (!res && str) {
      res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
    }
    if (!res && str) {
      res = /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(str);
      if (!res) {
        res = /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(str);
        if (res) {
          res.pop();
        }
      }
      if (res) {
        res = /charset=(.*)/i.exec(res.pop());
      }
    }
    if (!res && str) {
      res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
    }
    if (res) {
      charset = res.pop();
      if (charset === "gb2312" || charset === "gbk") {
        charset = "gb18030";
      }
    }
    return convert(buffer, "UTF-8", charset).toString();
  }
  function isURLSearchParams(obj) {
    if (typeof obj !== "object" || typeof obj.append !== "function" || typeof obj.delete !== "function" || typeof obj.get !== "function" || typeof obj.getAll !== "function" || typeof obj.has !== "function" || typeof obj.set !== "function") {
      return false;
    }
    return obj.constructor.name === "URLSearchParams" || Object.prototype.toString.call(obj) === "[object URLSearchParams]" || typeof obj.sort === "function";
  }
  function isBlob(obj) {
    return typeof obj === "object" && typeof obj.arrayBuffer === "function" && typeof obj.type === "string" && typeof obj.stream === "function" && typeof obj.constructor === "function" && typeof obj.constructor.name === "string" && /^(Blob|File)$/.test(obj.constructor.name) && /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
  }
  function clone(instance) {
    let p1, p2;
    let body = instance.body;
    if (instance.bodyUsed) {
      throw new Error("cannot clone body after it is used");
    }
    if (body instanceof Stream && typeof body.getBoundary !== "function") {
      p1 = new PassThrough();
      p2 = new PassThrough();
      body.pipe(p1);
      body.pipe(p2);
      instance[INTERNALS].body = p1;
      body = p2;
    }
    return body;
  }
  function extractContentType(body) {
    if (body === null) {
      return null;
    } else if (typeof body === "string") {
      return "text/plain;charset=UTF-8";
    } else if (isURLSearchParams(body)) {
      return "application/x-www-form-urlencoded;charset=UTF-8";
    } else if (isBlob(body)) {
      return body.type || null;
    } else if (Buffer.isBuffer(body)) {
      return null;
    } else if (Object.prototype.toString.call(body) === "[object ArrayBuffer]") {
      return null;
    } else if (ArrayBuffer.isView(body)) {
      return null;
    } else if (typeof body.getBoundary === "function") {
      return `multipart/form-data;boundary=${body.getBoundary()}`;
    } else if (body instanceof Stream) {
      return null;
    } else {
      return "text/plain;charset=UTF-8";
    }
  }
  function getTotalBytes(instance) {
    const body = instance.body;
    if (body === null) {
      return 0;
    } else if (isBlob(body)) {
      return body.size;
    } else if (Buffer.isBuffer(body)) {
      return body.length;
    } else if (body && typeof body.getLengthSync === "function") {
      if (body._lengthRetrievers && body._lengthRetrievers.length == 0 || body.hasKnownLength && body.hasKnownLength()) {
        return body.getLengthSync();
      }
      return null;
    } else {
      return null;
    }
  }
  function writeToStream(dest, instance) {
    const body = instance.body;
    if (body === null) {
      dest.end();
    } else if (isBlob(body)) {
      body.stream().pipe(dest);
    } else if (Buffer.isBuffer(body)) {
      dest.write(body);
      dest.end();
    } else {
      body.pipe(dest);
    }
  }
  Body.Promise = global.Promise;
  var invalidTokenRegex = /[^\^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
  var invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
  function validateName(name) {
    name = `${name}`;
    if (invalidTokenRegex.test(name) || name === "") {
      throw new TypeError(`${name} is not a legal HTTP header name`);
    }
  }
  function validateValue(value) {
    value = `${value}`;
    if (invalidHeaderCharRegex.test(value)) {
      throw new TypeError(`${value} is not a legal HTTP header value`);
    }
  }
  function find(map, name) {
    name = name.toLowerCase();
    for (const key in map) {
      if (key.toLowerCase() === name) {
        return key;
      }
    }
    return void 0;
  }
  var MAP = Symbol("map");
  var Headers = class {
    constructor() {
      let init = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : void 0;
      this[MAP] = Object.create(null);
      if (init instanceof Headers) {
        const rawHeaders = init.raw();
        const headerNames = Object.keys(rawHeaders);
        for (const headerName of headerNames) {
          for (const value of rawHeaders[headerName]) {
            this.append(headerName, value);
          }
        }
        return;
      }
      if (init == null)
        ;
      else if (typeof init === "object") {
        const method = init[Symbol.iterator];
        if (method != null) {
          if (typeof method !== "function") {
            throw new TypeError("Header pairs must be iterable");
          }
          const pairs = [];
          for (const pair of init) {
            if (typeof pair !== "object" || typeof pair[Symbol.iterator] !== "function") {
              throw new TypeError("Each header pair must be iterable");
            }
            pairs.push(Array.from(pair));
          }
          for (const pair of pairs) {
            if (pair.length !== 2) {
              throw new TypeError("Each header pair must be a name/value tuple");
            }
            this.append(pair[0], pair[1]);
          }
        } else {
          for (const key of Object.keys(init)) {
            const value = init[key];
            this.append(key, value);
          }
        }
      } else {
        throw new TypeError("Provided initializer must be an object");
      }
    }
    get(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key === void 0) {
        return null;
      }
      return this[MAP][key].join(", ");
    }
    forEach(callback) {
      let thisArg = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : void 0;
      let pairs = getHeaders(this);
      let i = 0;
      while (i < pairs.length) {
        var _pairs$i = pairs[i];
        const name = _pairs$i[0], value = _pairs$i[1];
        callback.call(thisArg, value, name, this);
        pairs = getHeaders(this);
        i++;
      }
    }
    set(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      this[MAP][key !== void 0 ? key : name] = [value];
    }
    append(name, value) {
      name = `${name}`;
      value = `${value}`;
      validateName(name);
      validateValue(value);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        this[MAP][key].push(value);
      } else {
        this[MAP][name] = [value];
      }
    }
    has(name) {
      name = `${name}`;
      validateName(name);
      return find(this[MAP], name) !== void 0;
    }
    delete(name) {
      name = `${name}`;
      validateName(name);
      const key = find(this[MAP], name);
      if (key !== void 0) {
        delete this[MAP][key];
      }
    }
    raw() {
      return this[MAP];
    }
    keys() {
      return createHeadersIterator(this, "key");
    }
    values() {
      return createHeadersIterator(this, "value");
    }
    [Symbol.iterator]() {
      return createHeadersIterator(this, "key+value");
    }
  };
  Headers.prototype.entries = Headers.prototype[Symbol.iterator];
  Object.defineProperty(Headers.prototype, Symbol.toStringTag, {
    value: "Headers",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Headers.prototype, {
    get: {enumerable: true},
    forEach: {enumerable: true},
    set: {enumerable: true},
    append: {enumerable: true},
    has: {enumerable: true},
    delete: {enumerable: true},
    keys: {enumerable: true},
    values: {enumerable: true},
    entries: {enumerable: true}
  });
  function getHeaders(headers) {
    let kind = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "key+value";
    const keys = Object.keys(headers[MAP]).sort();
    return keys.map(kind === "key" ? function(k) {
      return k.toLowerCase();
    } : kind === "value" ? function(k) {
      return headers[MAP][k].join(", ");
    } : function(k) {
      return [k.toLowerCase(), headers[MAP][k].join(", ")];
    });
  }
  var INTERNAL = Symbol("internal");
  function createHeadersIterator(target, kind) {
    const iterator = Object.create(HeadersIteratorPrototype);
    iterator[INTERNAL] = {
      target,
      kind,
      index: 0
    };
    return iterator;
  }
  var HeadersIteratorPrototype = Object.setPrototypeOf({
    next() {
      if (!this || Object.getPrototypeOf(this) !== HeadersIteratorPrototype) {
        throw new TypeError("Value of `this` is not a HeadersIterator");
      }
      var _INTERNAL = this[INTERNAL];
      const target = _INTERNAL.target, kind = _INTERNAL.kind, index = _INTERNAL.index;
      const values = getHeaders(target, kind);
      const len = values.length;
      if (index >= len) {
        return {
          value: void 0,
          done: true
        };
      }
      this[INTERNAL].index = index + 1;
      return {
        value: values[index],
        done: false
      };
    }
  }, Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())));
  Object.defineProperty(HeadersIteratorPrototype, Symbol.toStringTag, {
    value: "HeadersIterator",
    writable: false,
    enumerable: false,
    configurable: true
  });
  function exportNodeCompatibleHeaders(headers) {
    const obj = Object.assign({__proto__: null}, headers[MAP]);
    const hostHeaderKey = find(headers[MAP], "Host");
    if (hostHeaderKey !== void 0) {
      obj[hostHeaderKey] = obj[hostHeaderKey][0];
    }
    return obj;
  }
  function createHeadersLenient(obj) {
    const headers = new Headers();
    for (const name of Object.keys(obj)) {
      if (invalidTokenRegex.test(name)) {
        continue;
      }
      if (Array.isArray(obj[name])) {
        for (const val of obj[name]) {
          if (invalidHeaderCharRegex.test(val)) {
            continue;
          }
          if (headers[MAP][name] === void 0) {
            headers[MAP][name] = [val];
          } else {
            headers[MAP][name].push(val);
          }
        }
      } else if (!invalidHeaderCharRegex.test(obj[name])) {
        headers[MAP][name] = [obj[name]];
      }
    }
    return headers;
  }
  var INTERNALS$1 = Symbol("Response internals");
  var STATUS_CODES = http.STATUS_CODES;
  var Response = class {
    constructor() {
      let body = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
      let opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      Body.call(this, body, opts);
      const status = opts.status || 200;
      const headers = new Headers(opts.headers);
      if (body != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(body);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      this[INTERNALS$1] = {
        url: opts.url,
        status,
        statusText: opts.statusText || STATUS_CODES[status],
        headers,
        counter: opts.counter
      };
    }
    get url() {
      return this[INTERNALS$1].url || "";
    }
    get status() {
      return this[INTERNALS$1].status;
    }
    get ok() {
      return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
    }
    get redirected() {
      return this[INTERNALS$1].counter > 0;
    }
    get statusText() {
      return this[INTERNALS$1].statusText;
    }
    get headers() {
      return this[INTERNALS$1].headers;
    }
    clone() {
      return new Response(clone(this), {
        url: this.url,
        status: this.status,
        statusText: this.statusText,
        headers: this.headers,
        ok: this.ok,
        redirected: this.redirected
      });
    }
  };
  Body.mixIn(Response.prototype);
  Object.defineProperties(Response.prototype, {
    url: {enumerable: true},
    status: {enumerable: true},
    ok: {enumerable: true},
    redirected: {enumerable: true},
    statusText: {enumerable: true},
    headers: {enumerable: true},
    clone: {enumerable: true}
  });
  Object.defineProperty(Response.prototype, Symbol.toStringTag, {
    value: "Response",
    writable: false,
    enumerable: false,
    configurable: true
  });
  var INTERNALS$2 = Symbol("Request internals");
  var parse_url = Url.parse;
  var format_url = Url.format;
  var streamDestructionSupported = "destroy" in Stream.Readable.prototype;
  function isRequest(input) {
    return typeof input === "object" && typeof input[INTERNALS$2] === "object";
  }
  function isAbortSignal(signal) {
    const proto = signal && typeof signal === "object" && Object.getPrototypeOf(signal);
    return !!(proto && proto.constructor.name === "AbortSignal");
  }
  var Request = class {
    constructor(input) {
      let init = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      let parsedURL;
      if (!isRequest(input)) {
        if (input && input.href) {
          parsedURL = parse_url(input.href);
        } else {
          parsedURL = parse_url(`${input}`);
        }
        input = {};
      } else {
        parsedURL = parse_url(input.url);
      }
      let method = init.method || input.method || "GET";
      method = method.toUpperCase();
      if ((init.body != null || isRequest(input) && input.body !== null) && (method === "GET" || method === "HEAD")) {
        throw new TypeError("Request with GET/HEAD method cannot have body");
      }
      let inputBody = init.body != null ? init.body : isRequest(input) && input.body !== null ? clone(input) : null;
      Body.call(this, inputBody, {
        timeout: init.timeout || input.timeout || 0,
        size: init.size || input.size || 0
      });
      const headers = new Headers(init.headers || input.headers || {});
      if (inputBody != null && !headers.has("Content-Type")) {
        const contentType = extractContentType(inputBody);
        if (contentType) {
          headers.append("Content-Type", contentType);
        }
      }
      let signal = isRequest(input) ? input.signal : null;
      if ("signal" in init)
        signal = init.signal;
      if (signal != null && !isAbortSignal(signal)) {
        throw new TypeError("Expected signal to be an instanceof AbortSignal");
      }
      this[INTERNALS$2] = {
        method,
        redirect: init.redirect || input.redirect || "follow",
        headers,
        parsedURL,
        signal
      };
      this.follow = init.follow !== void 0 ? init.follow : input.follow !== void 0 ? input.follow : 20;
      this.compress = init.compress !== void 0 ? init.compress : input.compress !== void 0 ? input.compress : true;
      this.counter = init.counter || input.counter || 0;
      this.agent = init.agent || input.agent;
    }
    get method() {
      return this[INTERNALS$2].method;
    }
    get url() {
      return format_url(this[INTERNALS$2].parsedURL);
    }
    get headers() {
      return this[INTERNALS$2].headers;
    }
    get redirect() {
      return this[INTERNALS$2].redirect;
    }
    get signal() {
      return this[INTERNALS$2].signal;
    }
    clone() {
      return new Request(this);
    }
  };
  Body.mixIn(Request.prototype);
  Object.defineProperty(Request.prototype, Symbol.toStringTag, {
    value: "Request",
    writable: false,
    enumerable: false,
    configurable: true
  });
  Object.defineProperties(Request.prototype, {
    method: {enumerable: true},
    url: {enumerable: true},
    headers: {enumerable: true},
    redirect: {enumerable: true},
    clone: {enumerable: true},
    signal: {enumerable: true}
  });
  function getNodeRequestOptions(request) {
    const parsedURL = request[INTERNALS$2].parsedURL;
    const headers = new Headers(request[INTERNALS$2].headers);
    if (!headers.has("Accept")) {
      headers.set("Accept", "*/*");
    }
    if (!parsedURL.protocol || !parsedURL.hostname) {
      throw new TypeError("Only absolute URLs are supported");
    }
    if (!/^https?:$/.test(parsedURL.protocol)) {
      throw new TypeError("Only HTTP(S) protocols are supported");
    }
    if (request.signal && request.body instanceof Stream.Readable && !streamDestructionSupported) {
      throw new Error("Cancellation of streamed requests with AbortSignal is not supported in node < 8");
    }
    let contentLengthValue = null;
    if (request.body == null && /^(POST|PUT)$/i.test(request.method)) {
      contentLengthValue = "0";
    }
    if (request.body != null) {
      const totalBytes = getTotalBytes(request);
      if (typeof totalBytes === "number") {
        contentLengthValue = String(totalBytes);
      }
    }
    if (contentLengthValue) {
      headers.set("Content-Length", contentLengthValue);
    }
    if (!headers.has("User-Agent")) {
      headers.set("User-Agent", "node-fetch/1.0 (+https://github.com/bitinn/node-fetch)");
    }
    if (request.compress && !headers.has("Accept-Encoding")) {
      headers.set("Accept-Encoding", "gzip,deflate");
    }
    let agent = request.agent;
    if (typeof agent === "function") {
      agent = agent(parsedURL);
    }
    if (!headers.has("Connection") && !agent) {
      headers.set("Connection", "close");
    }
    return Object.assign({}, parsedURL, {
      method: request.method,
      headers: exportNodeCompatibleHeaders(headers),
      agent
    });
  }
  function AbortError(message) {
    Error.call(this, message);
    this.type = "aborted";
    this.message = message;
    Error.captureStackTrace(this, this.constructor);
  }
  AbortError.prototype = Object.create(Error.prototype);
  AbortError.prototype.constructor = AbortError;
  AbortError.prototype.name = "AbortError";
  var PassThrough$1 = Stream.PassThrough;
  var resolve_url = Url.resolve;
  function fetch(url, opts) {
    if (!fetch.Promise) {
      throw new Error("native promise missing, set fetch.Promise to your favorite alternative");
    }
    Body.Promise = fetch.Promise;
    return new fetch.Promise(function(resolve, reject) {
      const request = new Request(url, opts);
      const options = getNodeRequestOptions(request);
      const send = (options.protocol === "https:" ? https : http).request;
      const signal = request.signal;
      let response = null;
      const abort = function abort2() {
        let error5 = new AbortError("The user aborted a request.");
        reject(error5);
        if (request.body && request.body instanceof Stream.Readable) {
          request.body.destroy(error5);
        }
        if (!response || !response.body)
          return;
        response.body.emit("error", error5);
      };
      if (signal && signal.aborted) {
        abort();
        return;
      }
      const abortAndFinalize = function abortAndFinalize2() {
        abort();
        finalize();
      };
      const req = send(options);
      let reqTimeout;
      if (signal) {
        signal.addEventListener("abort", abortAndFinalize);
      }
      function finalize() {
        req.abort();
        if (signal)
          signal.removeEventListener("abort", abortAndFinalize);
        clearTimeout(reqTimeout);
      }
      if (request.timeout) {
        req.once("socket", function(socket) {
          reqTimeout = setTimeout(function() {
            reject(new FetchError(`network timeout at: ${request.url}`, "request-timeout"));
            finalize();
          }, request.timeout);
        });
      }
      req.on("error", function(err) {
        reject(new FetchError(`request to ${request.url} failed, reason: ${err.message}`, "system", err));
        finalize();
      });
      req.on("response", function(res) {
        clearTimeout(reqTimeout);
        const headers = createHeadersLenient(res.headers);
        if (fetch.isRedirect(res.statusCode)) {
          const location = headers.get("Location");
          const locationURL = location === null ? null : resolve_url(request.url, location);
          switch (request.redirect) {
            case "error":
              reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, "no-redirect"));
              finalize();
              return;
            case "manual":
              if (locationURL !== null) {
                try {
                  headers.set("Location", locationURL);
                } catch (err) {
                  reject(err);
                }
              }
              break;
            case "follow":
              if (locationURL === null) {
                break;
              }
              if (request.counter >= request.follow) {
                reject(new FetchError(`maximum redirect reached at: ${request.url}`, "max-redirect"));
                finalize();
                return;
              }
              const requestOpts = {
                headers: new Headers(request.headers),
                follow: request.follow,
                counter: request.counter + 1,
                agent: request.agent,
                compress: request.compress,
                method: request.method,
                body: request.body,
                signal: request.signal,
                timeout: request.timeout,
                size: request.size
              };
              if (res.statusCode !== 303 && request.body && getTotalBytes(request) === null) {
                reject(new FetchError("Cannot follow redirect with body being a readable stream", "unsupported-redirect"));
                finalize();
                return;
              }
              if (res.statusCode === 303 || (res.statusCode === 301 || res.statusCode === 302) && request.method === "POST") {
                requestOpts.method = "GET";
                requestOpts.body = void 0;
                requestOpts.headers.delete("content-length");
              }
              resolve(fetch(new Request(locationURL, requestOpts)));
              finalize();
              return;
          }
        }
        res.once("end", function() {
          if (signal)
            signal.removeEventListener("abort", abortAndFinalize);
        });
        let body = res.pipe(new PassThrough$1());
        const response_options = {
          url: request.url,
          status: res.statusCode,
          statusText: res.statusMessage,
          headers,
          size: request.size,
          timeout: request.timeout,
          counter: request.counter
        };
        const codings = headers.get("Content-Encoding");
        if (!request.compress || request.method === "HEAD" || codings === null || res.statusCode === 204 || res.statusCode === 304) {
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        const zlibOptions = {
          flush: zlib.Z_SYNC_FLUSH,
          finishFlush: zlib.Z_SYNC_FLUSH
        };
        if (codings == "gzip" || codings == "x-gzip") {
          body = body.pipe(zlib.createGunzip(zlibOptions));
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        if (codings == "deflate" || codings == "x-deflate") {
          const raw = res.pipe(new PassThrough$1());
          raw.once("data", function(chunk) {
            if ((chunk[0] & 15) === 8) {
              body = body.pipe(zlib.createInflate());
            } else {
              body = body.pipe(zlib.createInflateRaw());
            }
            response = new Response(body, response_options);
            resolve(response);
          });
          return;
        }
        if (codings == "br" && typeof zlib.createBrotliDecompress === "function") {
          body = body.pipe(zlib.createBrotliDecompress());
          response = new Response(body, response_options);
          resolve(response);
          return;
        }
        response = new Response(body, response_options);
        resolve(response);
      });
      writeToStream(req, request);
    });
  }
  fetch.isRedirect = function(code) {
    return code === 301 || code === 302 || code === 303 || code === 307 || code === 308;
  };
  fetch.Promise = global.Promise;
  module2.exports = exports2 = fetch;
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.default = exports2;
  exports2.Headers = Headers;
  exports2.Request = Request;
  exports2.Response = Response;
  exports2.FetchError = FetchError;
});

// node_modules/deprecation/dist-node/index.js
var require_dist_node3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Deprecation = class extends Error {
    constructor(message) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "Deprecation";
    }
  };
  exports2.Deprecation = Deprecation;
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS((exports2, module2) => {
  module2.exports = wrappy;
  function wrappy(fn, cb) {
    if (fn && cb)
      return wrappy(fn)(cb);
    if (typeof fn !== "function")
      throw new TypeError("need wrapper function");
    Object.keys(fn).forEach(function(k) {
      wrapper[k] = fn[k];
    });
    return wrapper;
    function wrapper() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      var ret = fn.apply(this, args);
      var cb2 = args[args.length - 1];
      if (typeof ret === "function" && ret !== cb2) {
        Object.keys(cb2).forEach(function(k) {
          ret[k] = cb2[k];
        });
      }
      return ret;
    }
  }
});

// node_modules/once/once.js
var require_once = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  module2.exports = wrappy(once);
  module2.exports.strict = wrappy(onceStrict);
  once.proto = once(function() {
    Object.defineProperty(Function.prototype, "once", {
      value: function() {
        return once(this);
      },
      configurable: true
    });
    Object.defineProperty(Function.prototype, "onceStrict", {
      value: function() {
        return onceStrict(this);
      },
      configurable: true
    });
  });
  function once(fn) {
    var f = function() {
      if (f.called)
        return f.value;
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    f.called = false;
    return f;
  }
  function onceStrict(fn) {
    var f = function() {
      if (f.called)
        throw new Error(f.onceError);
      f.called = true;
      return f.value = fn.apply(this, arguments);
    };
    var name = fn.name || "Function wrapped with `once`";
    f.onceError = name + " shouldn't be called more than once";
    f.called = false;
    return f;
  }
});

// node_modules/@octokit/request-error/dist-node/index.js
var require_dist_node4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var deprecation = require_dist_node3();
  var once = _interopDefault(require_once());
  var logOnce = once((deprecation2) => console.warn(deprecation2));
  var RequestError = class extends Error {
    constructor(message, statusCode, options) {
      super(message);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "HttpError";
      this.status = statusCode;
      Object.defineProperty(this, "code", {
        get() {
          logOnce(new deprecation.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`."));
          return statusCode;
        }
      });
      this.headers = options.headers || {};
      const requestCopy = Object.assign({}, options.request);
      if (options.request.headers.authorization) {
        requestCopy.headers = Object.assign({}, options.request.headers, {
          authorization: options.request.headers.authorization.replace(/ .*$/, " [REDACTED]")
        });
      }
      requestCopy.url = requestCopy.url.replace(/\bclient_secret=\w+/g, "client_secret=[REDACTED]").replace(/\baccess_token=\w+/g, "access_token=[REDACTED]");
      this.request = requestCopy;
    }
  };
  exports2.RequestError = RequestError;
});

// node_modules/@octokit/request/dist-node/index.js
var require_dist_node5 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var endpoint = require_dist_node2();
  var universalUserAgent = require_dist_node();
  var isPlainObject = require_is_plain_object();
  var nodeFetch = _interopDefault(require_lib());
  var requestError = require_dist_node4();
  var VERSION = "5.4.10";
  function getBufferResponse(response) {
    return response.arrayBuffer();
  }
  function fetchWrapper(requestOptions) {
    if (isPlainObject.isPlainObject(requestOptions.body) || Array.isArray(requestOptions.body)) {
      requestOptions.body = JSON.stringify(requestOptions.body);
    }
    let headers = {};
    let status;
    let url;
    const fetch = requestOptions.request && requestOptions.request.fetch || nodeFetch;
    return fetch(requestOptions.url, Object.assign({
      method: requestOptions.method,
      body: requestOptions.body,
      headers: requestOptions.headers,
      redirect: requestOptions.redirect
    }, requestOptions.request)).then((response) => {
      url = response.url;
      status = response.status;
      for (const keyAndValue of response.headers) {
        headers[keyAndValue[0]] = keyAndValue[1];
      }
      if (status === 204 || status === 205) {
        return;
      }
      if (requestOptions.method === "HEAD") {
        if (status < 400) {
          return;
        }
        throw new requestError.RequestError(response.statusText, status, {
          headers,
          request: requestOptions
        });
      }
      if (status === 304) {
        throw new requestError.RequestError("Not modified", status, {
          headers,
          request: requestOptions
        });
      }
      if (status >= 400) {
        return response.text().then((message) => {
          const error5 = new requestError.RequestError(message, status, {
            headers,
            request: requestOptions
          });
          try {
            let responseBody = JSON.parse(error5.message);
            Object.assign(error5, responseBody);
            let errors = responseBody.errors;
            error5.message = error5.message + ": " + errors.map(JSON.stringify).join(", ");
          } catch (e) {
          }
          throw error5;
        });
      }
      const contentType = response.headers.get("content-type");
      if (/application\/json/.test(contentType)) {
        return response.json();
      }
      if (!contentType || /^text\/|charset=utf-8$/.test(contentType)) {
        return response.text();
      }
      return getBufferResponse(response);
    }).then((data) => {
      return {
        status,
        url,
        headers,
        data
      };
    }).catch((error5) => {
      if (error5 instanceof requestError.RequestError) {
        throw error5;
      }
      throw new requestError.RequestError(error5.message, 500, {
        headers,
        request: requestOptions
      });
    });
  }
  function withDefaults(oldEndpoint, newDefaults) {
    const endpoint2 = oldEndpoint.defaults(newDefaults);
    const newApi = function(route, parameters) {
      const endpointOptions = endpoint2.merge(route, parameters);
      if (!endpointOptions.request || !endpointOptions.request.hook) {
        return fetchWrapper(endpoint2.parse(endpointOptions));
      }
      const request2 = (route2, parameters2) => {
        return fetchWrapper(endpoint2.parse(endpoint2.merge(route2, parameters2)));
      };
      Object.assign(request2, {
        endpoint: endpoint2,
        defaults: withDefaults.bind(null, endpoint2)
      });
      return endpointOptions.request.hook(request2, endpointOptions);
    };
    return Object.assign(newApi, {
      endpoint: endpoint2,
      defaults: withDefaults.bind(null, endpoint2)
    });
  }
  var request = withDefaults(endpoint.endpoint, {
    headers: {
      "user-agent": `octokit-request.js/${VERSION} ${universalUserAgent.getUserAgent()}`
    }
  });
  exports2.request = request;
});

// node_modules/@octokit/graphql/dist-node/index.js
var require_dist_node6 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var request = require_dist_node5();
  var universalUserAgent = require_dist_node();
  var VERSION = "4.5.7";
  var GraphqlError = class extends Error {
    constructor(request2, response) {
      const message = response.data.errors[0].message;
      super(message);
      Object.assign(this, response.data);
      Object.assign(this, {
        headers: response.headers
      });
      this.name = "GraphqlError";
      this.request = request2;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
    }
  };
  var NON_VARIABLE_OPTIONS = ["method", "baseUrl", "url", "headers", "request", "query", "mediaType"];
  var GHES_V3_SUFFIX_REGEX = /\/api\/v3\/?$/;
  function graphql(request2, query, options) {
    if (typeof query === "string" && options && "query" in options) {
      return Promise.reject(new Error(`[@octokit/graphql] "query" cannot be used as variable name`));
    }
    const parsedOptions = typeof query === "string" ? Object.assign({
      query
    }, options) : query;
    const requestOptions = Object.keys(parsedOptions).reduce((result, key) => {
      if (NON_VARIABLE_OPTIONS.includes(key)) {
        result[key] = parsedOptions[key];
        return result;
      }
      if (!result.variables) {
        result.variables = {};
      }
      result.variables[key] = parsedOptions[key];
      return result;
    }, {});
    const baseUrl = parsedOptions.baseUrl || request2.endpoint.DEFAULTS.baseUrl;
    if (GHES_V3_SUFFIX_REGEX.test(baseUrl)) {
      requestOptions.url = baseUrl.replace(GHES_V3_SUFFIX_REGEX, "/api/graphql");
    }
    return request2(requestOptions).then((response) => {
      if (response.data.errors) {
        const headers = {};
        for (const key of Object.keys(response.headers)) {
          headers[key] = response.headers[key];
        }
        throw new GraphqlError(requestOptions, {
          headers,
          data: response.data
        });
      }
      return response.data.data;
    });
  }
  function withDefaults(request$1, newDefaults) {
    const newRequest = request$1.defaults(newDefaults);
    const newApi = (query, options) => {
      return graphql(newRequest, query, options);
    };
    return Object.assign(newApi, {
      defaults: withDefaults.bind(null, newRequest),
      endpoint: request.request.endpoint
    });
  }
  var graphql$1 = withDefaults(request.request, {
    headers: {
      "user-agent": `octokit-graphql.js/${VERSION} ${universalUserAgent.getUserAgent()}`
    },
    method: "POST",
    url: "/graphql"
  });
  function withCustomRequest(customRequest) {
    return withDefaults(customRequest, {
      method: "POST",
      url: "/graphql"
    });
  }
  exports2.graphql = graphql$1;
  exports2.withCustomRequest = withCustomRequest;
});

// node_modules/@octokit/auth-token/dist-node/index.js
var require_dist_node7 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function auth(token) {
    return __async(this, null, function* () {
      const tokenType = token.split(/\./).length === 3 ? "app" : /^v\d+\./.test(token) ? "installation" : "oauth";
      return {
        type: "token",
        token,
        tokenType
      };
    });
  }
  function withAuthorizationPrefix(token) {
    if (token.split(/\./).length === 3) {
      return `bearer ${token}`;
    }
    return `token ${token}`;
  }
  function hook(token, request, route, parameters) {
    return __async(this, null, function* () {
      const endpoint = request.endpoint.merge(route, parameters);
      endpoint.headers.authorization = withAuthorizationPrefix(token);
      return request(endpoint);
    });
  }
  var createTokenAuth = function createTokenAuth2(token) {
    if (!token) {
      throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");
    }
    if (typeof token !== "string") {
      throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");
    }
    token = token.replace(/^(token|bearer) +/i, "");
    return Object.assign(auth.bind(null, token), {
      hook: hook.bind(null, token)
    });
  };
  exports2.createTokenAuth = createTokenAuth;
});

// node_modules/@octokit/core/dist-node/index.js
var require_dist_node8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var universalUserAgent = require_dist_node();
  var beforeAfterHook = require_before_after_hook();
  var request = require_dist_node5();
  var graphql = require_dist_node6();
  var authToken = require_dist_node7();
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  var VERSION = "3.2.1";
  var Octokit2 = class {
    constructor(options = {}) {
      const hook = new beforeAfterHook.Collection();
      const requestDefaults = {
        baseUrl: request.request.endpoint.DEFAULTS.baseUrl,
        headers: {},
        request: Object.assign({}, options.request, {
          hook: hook.bind(null, "request")
        }),
        mediaType: {
          previews: [],
          format: ""
        }
      };
      requestDefaults.headers["user-agent"] = [options.userAgent, `octokit-core.js/${VERSION} ${universalUserAgent.getUserAgent()}`].filter(Boolean).join(" ");
      if (options.baseUrl) {
        requestDefaults.baseUrl = options.baseUrl;
      }
      if (options.previews) {
        requestDefaults.mediaType.previews = options.previews;
      }
      if (options.timeZone) {
        requestDefaults.headers["time-zone"] = options.timeZone;
      }
      this.request = request.request.defaults(requestDefaults);
      this.graphql = graphql.withCustomRequest(this.request).defaults(requestDefaults);
      this.log = Object.assign({
        debug: () => {
        },
        info: () => {
        },
        warn: console.warn.bind(console),
        error: console.error.bind(console)
      }, options.log);
      this.hook = hook;
      if (!options.authStrategy) {
        if (!options.auth) {
          this.auth = () => __async(this, null, function* () {
            return {
              type: "unauthenticated"
            };
          });
        } else {
          const auth = authToken.createTokenAuth(options.auth);
          hook.wrap("request", auth.hook);
          this.auth = auth;
        }
      } else {
        const {
          authStrategy
        } = options, otherOptions = _objectWithoutProperties(options, ["authStrategy"]);
        const auth = authStrategy(Object.assign({
          request: this.request,
          log: this.log,
          octokit: this,
          octokitOptions: otherOptions
        }, options.auth));
        hook.wrap("request", auth.hook);
        this.auth = auth;
      }
      const classConstructor = this.constructor;
      classConstructor.plugins.forEach((plugin) => {
        Object.assign(this, plugin(this, options));
      });
    }
    static defaults(defaults) {
      const OctokitWithDefaults = class extends this {
        constructor(...args) {
          const options = args[0] || {};
          if (typeof defaults === "function") {
            super(defaults(options));
            return;
          }
          super(Object.assign({}, defaults, options, options.userAgent && defaults.userAgent ? {
            userAgent: `${options.userAgent} ${defaults.userAgent}`
          } : null));
        }
      };
      return OctokitWithDefaults;
    }
    static plugin(...newPlugins) {
      var _a;
      const currentPlugins = this.plugins;
      const NewOctokit = (_a = class extends this {
      }, _a.plugins = currentPlugins.concat(newPlugins.filter((plugin) => !currentPlugins.includes(plugin))), _a);
      return NewOctokit;
    }
  };
  Octokit2.VERSION = VERSION;
  Octokit2.plugins = [];
  exports2.Octokit = Octokit2;
});

// node_modules/@octokit/plugin-rest-endpoint-methods/dist-node/index.js
var require_dist_node9 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var Endpoints = {
    actions: {
      addSelectedRepoToOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
      cancelWorkflowRun: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],
      createOrUpdateOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}"],
      createOrUpdateRepoSecret: ["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      createRegistrationTokenForOrg: ["POST /orgs/{org}/actions/runners/registration-token"],
      createRegistrationTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/registration-token"],
      createRemoveTokenForOrg: ["POST /orgs/{org}/actions/runners/remove-token"],
      createRemoveTokenForRepo: ["POST /repos/{owner}/{repo}/actions/runners/remove-token"],
      createWorkflowDispatch: ["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],
      deleteArtifact: ["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      deleteOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}"],
      deleteRepoSecret: ["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      deleteSelfHostedRunnerFromOrg: ["DELETE /orgs/{org}/actions/runners/{runner_id}"],
      deleteSelfHostedRunnerFromRepo: ["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],
      deleteWorkflowRun: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],
      deleteWorkflowRunLogs: ["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
      downloadArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],
      downloadJobLogsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],
      downloadWorkflowRunLogs: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],
      getArtifact: ["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],
      getJobForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],
      getOrgPublicKey: ["GET /orgs/{org}/actions/secrets/public-key"],
      getOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}"],
      getRepoPublicKey: ["GET /repos/{owner}/{repo}/actions/secrets/public-key"],
      getRepoSecret: ["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],
      getSelfHostedRunnerForOrg: ["GET /orgs/{org}/actions/runners/{runner_id}"],
      getSelfHostedRunnerForRepo: ["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],
      getWorkflow: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],
      getWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],
      getWorkflowRunUsage: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],
      getWorkflowUsage: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],
      listArtifactsForRepo: ["GET /repos/{owner}/{repo}/actions/artifacts"],
      listJobsForWorkflowRun: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],
      listOrgSecrets: ["GET /orgs/{org}/actions/secrets"],
      listRepoSecrets: ["GET /repos/{owner}/{repo}/actions/secrets"],
      listRepoWorkflows: ["GET /repos/{owner}/{repo}/actions/workflows"],
      listRunnerApplicationsForOrg: ["GET /orgs/{org}/actions/runners/downloads"],
      listRunnerApplicationsForRepo: ["GET /repos/{owner}/{repo}/actions/runners/downloads"],
      listSelectedReposForOrgSecret: ["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],
      listSelfHostedRunnersForOrg: ["GET /orgs/{org}/actions/runners"],
      listSelfHostedRunnersForRepo: ["GET /repos/{owner}/{repo}/actions/runners"],
      listWorkflowRunArtifacts: ["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],
      listWorkflowRuns: ["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],
      listWorkflowRunsForRepo: ["GET /repos/{owner}/{repo}/actions/runs"],
      reRunWorkflow: ["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],
      removeSelectedRepoFromOrgSecret: ["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],
      setSelectedReposForOrgSecret: ["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"]
    },
    activity: {
      checkRepoIsStarredByAuthenticatedUser: ["GET /user/starred/{owner}/{repo}"],
      deleteRepoSubscription: ["DELETE /repos/{owner}/{repo}/subscription"],
      deleteThreadSubscription: ["DELETE /notifications/threads/{thread_id}/subscription"],
      getFeeds: ["GET /feeds"],
      getRepoSubscription: ["GET /repos/{owner}/{repo}/subscription"],
      getThread: ["GET /notifications/threads/{thread_id}"],
      getThreadSubscriptionForAuthenticatedUser: ["GET /notifications/threads/{thread_id}/subscription"],
      listEventsForAuthenticatedUser: ["GET /users/{username}/events"],
      listNotificationsForAuthenticatedUser: ["GET /notifications"],
      listOrgEventsForAuthenticatedUser: ["GET /users/{username}/events/orgs/{org}"],
      listPublicEvents: ["GET /events"],
      listPublicEventsForRepoNetwork: ["GET /networks/{owner}/{repo}/events"],
      listPublicEventsForUser: ["GET /users/{username}/events/public"],
      listPublicOrgEvents: ["GET /orgs/{org}/events"],
      listReceivedEventsForUser: ["GET /users/{username}/received_events"],
      listReceivedPublicEventsForUser: ["GET /users/{username}/received_events/public"],
      listRepoEvents: ["GET /repos/{owner}/{repo}/events"],
      listRepoNotificationsForAuthenticatedUser: ["GET /repos/{owner}/{repo}/notifications"],
      listReposStarredByAuthenticatedUser: ["GET /user/starred"],
      listReposStarredByUser: ["GET /users/{username}/starred"],
      listReposWatchedByUser: ["GET /users/{username}/subscriptions"],
      listStargazersForRepo: ["GET /repos/{owner}/{repo}/stargazers"],
      listWatchedReposForAuthenticatedUser: ["GET /user/subscriptions"],
      listWatchersForRepo: ["GET /repos/{owner}/{repo}/subscribers"],
      markNotificationsAsRead: ["PUT /notifications"],
      markRepoNotificationsAsRead: ["PUT /repos/{owner}/{repo}/notifications"],
      markThreadAsRead: ["PATCH /notifications/threads/{thread_id}"],
      setRepoSubscription: ["PUT /repos/{owner}/{repo}/subscription"],
      setThreadSubscription: ["PUT /notifications/threads/{thread_id}/subscription"],
      starRepoForAuthenticatedUser: ["PUT /user/starred/{owner}/{repo}"],
      unstarRepoForAuthenticatedUser: ["DELETE /user/starred/{owner}/{repo}"]
    },
    apps: {
      addRepoToInstallation: ["PUT /user/installations/{installation_id}/repositories/{repository_id}"],
      checkToken: ["POST /applications/{client_id}/token"],
      createContentAttachment: ["POST /content_references/{content_reference_id}/attachments", {
        mediaType: {
          previews: ["corsair"]
        }
      }],
      createFromManifest: ["POST /app-manifests/{code}/conversions"],
      createInstallationAccessToken: ["POST /app/installations/{installation_id}/access_tokens"],
      deleteAuthorization: ["DELETE /applications/{client_id}/grant"],
      deleteInstallation: ["DELETE /app/installations/{installation_id}"],
      deleteToken: ["DELETE /applications/{client_id}/token"],
      getAuthenticated: ["GET /app"],
      getBySlug: ["GET /apps/{app_slug}"],
      getInstallation: ["GET /app/installations/{installation_id}"],
      getOrgInstallation: ["GET /orgs/{org}/installation"],
      getRepoInstallation: ["GET /repos/{owner}/{repo}/installation"],
      getSubscriptionPlanForAccount: ["GET /marketplace_listing/accounts/{account_id}"],
      getSubscriptionPlanForAccountStubbed: ["GET /marketplace_listing/stubbed/accounts/{account_id}"],
      getUserInstallation: ["GET /users/{username}/installation"],
      listAccountsForPlan: ["GET /marketplace_listing/plans/{plan_id}/accounts"],
      listAccountsForPlanStubbed: ["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],
      listInstallationReposForAuthenticatedUser: ["GET /user/installations/{installation_id}/repositories"],
      listInstallations: ["GET /app/installations"],
      listInstallationsForAuthenticatedUser: ["GET /user/installations"],
      listPlans: ["GET /marketplace_listing/plans"],
      listPlansStubbed: ["GET /marketplace_listing/stubbed/plans"],
      listReposAccessibleToInstallation: ["GET /installation/repositories"],
      listSubscriptionsForAuthenticatedUser: ["GET /user/marketplace_purchases"],
      listSubscriptionsForAuthenticatedUserStubbed: ["GET /user/marketplace_purchases/stubbed"],
      removeRepoFromInstallation: ["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],
      resetToken: ["PATCH /applications/{client_id}/token"],
      revokeInstallationAccessToken: ["DELETE /installation/token"],
      suspendInstallation: ["PUT /app/installations/{installation_id}/suspended"],
      unsuspendInstallation: ["DELETE /app/installations/{installation_id}/suspended"]
    },
    billing: {
      getGithubActionsBillingOrg: ["GET /orgs/{org}/settings/billing/actions"],
      getGithubActionsBillingUser: ["GET /users/{username}/settings/billing/actions"],
      getGithubPackagesBillingOrg: ["GET /orgs/{org}/settings/billing/packages"],
      getGithubPackagesBillingUser: ["GET /users/{username}/settings/billing/packages"],
      getSharedStorageBillingOrg: ["GET /orgs/{org}/settings/billing/shared-storage"],
      getSharedStorageBillingUser: ["GET /users/{username}/settings/billing/shared-storage"]
    },
    checks: {
      create: ["POST /repos/{owner}/{repo}/check-runs", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      createSuite: ["POST /repos/{owner}/{repo}/check-suites", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      get: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      getSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      listAnnotations: ["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      listForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-runs", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      listForSuite: ["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      listSuitesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/check-suites", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      rerequestSuite: ["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      setSuitesPreferences: ["PATCH /repos/{owner}/{repo}/check-suites/preferences", {
        mediaType: {
          previews: ["antiope"]
        }
      }],
      update: ["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}", {
        mediaType: {
          previews: ["antiope"]
        }
      }]
    },
    codeScanning: {
      getAlert: ["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}", {}, {
        renamedParameters: {
          alert_id: "alert_number"
        }
      }],
      listAlertsForRepo: ["GET /repos/{owner}/{repo}/code-scanning/alerts"],
      listRecentAnalyses: ["GET /repos/{owner}/{repo}/code-scanning/analyses"],
      updateAlert: ["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],
      uploadSarif: ["POST /repos/{owner}/{repo}/code-scanning/sarifs"]
    },
    codesOfConduct: {
      getAllCodesOfConduct: ["GET /codes_of_conduct", {
        mediaType: {
          previews: ["scarlet-witch"]
        }
      }],
      getConductCode: ["GET /codes_of_conduct/{key}", {
        mediaType: {
          previews: ["scarlet-witch"]
        }
      }],
      getForRepo: ["GET /repos/{owner}/{repo}/community/code_of_conduct", {
        mediaType: {
          previews: ["scarlet-witch"]
        }
      }]
    },
    emojis: {
      get: ["GET /emojis"]
    },
    gists: {
      checkIsStarred: ["GET /gists/{gist_id}/star"],
      create: ["POST /gists"],
      createComment: ["POST /gists/{gist_id}/comments"],
      delete: ["DELETE /gists/{gist_id}"],
      deleteComment: ["DELETE /gists/{gist_id}/comments/{comment_id}"],
      fork: ["POST /gists/{gist_id}/forks"],
      get: ["GET /gists/{gist_id}"],
      getComment: ["GET /gists/{gist_id}/comments/{comment_id}"],
      getRevision: ["GET /gists/{gist_id}/{sha}"],
      list: ["GET /gists"],
      listComments: ["GET /gists/{gist_id}/comments"],
      listCommits: ["GET /gists/{gist_id}/commits"],
      listForUser: ["GET /users/{username}/gists"],
      listForks: ["GET /gists/{gist_id}/forks"],
      listPublic: ["GET /gists/public"],
      listStarred: ["GET /gists/starred"],
      star: ["PUT /gists/{gist_id}/star"],
      unstar: ["DELETE /gists/{gist_id}/star"],
      update: ["PATCH /gists/{gist_id}"],
      updateComment: ["PATCH /gists/{gist_id}/comments/{comment_id}"]
    },
    git: {
      createBlob: ["POST /repos/{owner}/{repo}/git/blobs"],
      createCommit: ["POST /repos/{owner}/{repo}/git/commits"],
      createRef: ["POST /repos/{owner}/{repo}/git/refs"],
      createTag: ["POST /repos/{owner}/{repo}/git/tags"],
      createTree: ["POST /repos/{owner}/{repo}/git/trees"],
      deleteRef: ["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],
      getBlob: ["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],
      getCommit: ["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],
      getRef: ["GET /repos/{owner}/{repo}/git/ref/{ref}"],
      getTag: ["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],
      getTree: ["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],
      listMatchingRefs: ["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],
      updateRef: ["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]
    },
    gitignore: {
      getAllTemplates: ["GET /gitignore/templates"],
      getTemplate: ["GET /gitignore/templates/{name}"]
    },
    interactions: {
      getRestrictionsForOrg: ["GET /orgs/{org}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }],
      getRestrictionsForRepo: ["GET /repos/{owner}/{repo}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }],
      removeRestrictionsForOrg: ["DELETE /orgs/{org}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }],
      removeRestrictionsForRepo: ["DELETE /repos/{owner}/{repo}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }],
      setRestrictionsForOrg: ["PUT /orgs/{org}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }],
      setRestrictionsForRepo: ["PUT /repos/{owner}/{repo}/interaction-limits", {
        mediaType: {
          previews: ["sombra"]
        }
      }]
    },
    issues: {
      addAssignees: ["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
      addLabels: ["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      checkUserCanBeAssigned: ["GET /repos/{owner}/{repo}/assignees/{assignee}"],
      create: ["POST /repos/{owner}/{repo}/issues"],
      createComment: ["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      createLabel: ["POST /repos/{owner}/{repo}/labels"],
      createMilestone: ["POST /repos/{owner}/{repo}/milestones"],
      deleteComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      deleteLabel: ["DELETE /repos/{owner}/{repo}/labels/{name}"],
      deleteMilestone: ["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],
      get: ["GET /repos/{owner}/{repo}/issues/{issue_number}"],
      getComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      getEvent: ["GET /repos/{owner}/{repo}/issues/events/{event_id}"],
      getLabel: ["GET /repos/{owner}/{repo}/labels/{name}"],
      getMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],
      list: ["GET /issues"],
      listAssignees: ["GET /repos/{owner}/{repo}/assignees"],
      listComments: ["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],
      listCommentsForRepo: ["GET /repos/{owner}/{repo}/issues/comments"],
      listEvents: ["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],
      listEventsForRepo: ["GET /repos/{owner}/{repo}/issues/events"],
      listEventsForTimeline: ["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline", {
        mediaType: {
          previews: ["mockingbird"]
        }
      }],
      listForAuthenticatedUser: ["GET /user/issues"],
      listForOrg: ["GET /orgs/{org}/issues"],
      listForRepo: ["GET /repos/{owner}/{repo}/issues"],
      listLabelsForMilestone: ["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],
      listLabelsForRepo: ["GET /repos/{owner}/{repo}/labels"],
      listLabelsOnIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      listMilestones: ["GET /repos/{owner}/{repo}/milestones"],
      lock: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      removeAllLabels: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      removeAssignees: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],
      removeLabel: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],
      setLabels: ["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],
      unlock: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],
      update: ["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],
      updateComment: ["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],
      updateLabel: ["PATCH /repos/{owner}/{repo}/labels/{name}"],
      updateMilestone: ["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]
    },
    licenses: {
      get: ["GET /licenses/{license}"],
      getAllCommonlyUsed: ["GET /licenses"],
      getForRepo: ["GET /repos/{owner}/{repo}/license"]
    },
    markdown: {
      render: ["POST /markdown"],
      renderRaw: ["POST /markdown/raw", {
        headers: {
          "content-type": "text/plain; charset=utf-8"
        }
      }]
    },
    meta: {
      get: ["GET /meta"]
    },
    migrations: {
      cancelImport: ["DELETE /repos/{owner}/{repo}/import"],
      deleteArchiveForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/archive", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      deleteArchiveForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/archive", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      downloadArchiveForOrg: ["GET /orgs/{org}/migrations/{migration_id}/archive", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      getArchiveForAuthenticatedUser: ["GET /user/migrations/{migration_id}/archive", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      getCommitAuthors: ["GET /repos/{owner}/{repo}/import/authors"],
      getImportStatus: ["GET /repos/{owner}/{repo}/import"],
      getLargeFiles: ["GET /repos/{owner}/{repo}/import/large_files"],
      getStatusForAuthenticatedUser: ["GET /user/migrations/{migration_id}", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      getStatusForOrg: ["GET /orgs/{org}/migrations/{migration_id}", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      listForAuthenticatedUser: ["GET /user/migrations", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      listForOrg: ["GET /orgs/{org}/migrations", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      listReposForOrg: ["GET /orgs/{org}/migrations/{migration_id}/repositories", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      listReposForUser: ["GET /user/migrations/{migration_id}/repositories", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      mapCommitAuthor: ["PATCH /repos/{owner}/{repo}/import/authors/{author_id}"],
      setLfsPreference: ["PATCH /repos/{owner}/{repo}/import/lfs"],
      startForAuthenticatedUser: ["POST /user/migrations"],
      startForOrg: ["POST /orgs/{org}/migrations"],
      startImport: ["PUT /repos/{owner}/{repo}/import"],
      unlockRepoForAuthenticatedUser: ["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      unlockRepoForOrg: ["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock", {
        mediaType: {
          previews: ["wyandotte"]
        }
      }],
      updateImport: ["PATCH /repos/{owner}/{repo}/import"]
    },
    orgs: {
      blockUser: ["PUT /orgs/{org}/blocks/{username}"],
      checkBlockedUser: ["GET /orgs/{org}/blocks/{username}"],
      checkMembershipForUser: ["GET /orgs/{org}/members/{username}"],
      checkPublicMembershipForUser: ["GET /orgs/{org}/public_members/{username}"],
      convertMemberToOutsideCollaborator: ["PUT /orgs/{org}/outside_collaborators/{username}"],
      createInvitation: ["POST /orgs/{org}/invitations"],
      createWebhook: ["POST /orgs/{org}/hooks"],
      deleteWebhook: ["DELETE /orgs/{org}/hooks/{hook_id}"],
      get: ["GET /orgs/{org}"],
      getMembershipForAuthenticatedUser: ["GET /user/memberships/orgs/{org}"],
      getMembershipForUser: ["GET /orgs/{org}/memberships/{username}"],
      getWebhook: ["GET /orgs/{org}/hooks/{hook_id}"],
      list: ["GET /organizations"],
      listAppInstallations: ["GET /orgs/{org}/installations"],
      listBlockedUsers: ["GET /orgs/{org}/blocks"],
      listForAuthenticatedUser: ["GET /user/orgs"],
      listForUser: ["GET /users/{username}/orgs"],
      listInvitationTeams: ["GET /orgs/{org}/invitations/{invitation_id}/teams"],
      listMembers: ["GET /orgs/{org}/members"],
      listMembershipsForAuthenticatedUser: ["GET /user/memberships/orgs"],
      listOutsideCollaborators: ["GET /orgs/{org}/outside_collaborators"],
      listPendingInvitations: ["GET /orgs/{org}/invitations"],
      listPublicMembers: ["GET /orgs/{org}/public_members"],
      listWebhooks: ["GET /orgs/{org}/hooks"],
      pingWebhook: ["POST /orgs/{org}/hooks/{hook_id}/pings"],
      removeMember: ["DELETE /orgs/{org}/members/{username}"],
      removeMembershipForUser: ["DELETE /orgs/{org}/memberships/{username}"],
      removeOutsideCollaborator: ["DELETE /orgs/{org}/outside_collaborators/{username}"],
      removePublicMembershipForAuthenticatedUser: ["DELETE /orgs/{org}/public_members/{username}"],
      setMembershipForUser: ["PUT /orgs/{org}/memberships/{username}"],
      setPublicMembershipForAuthenticatedUser: ["PUT /orgs/{org}/public_members/{username}"],
      unblockUser: ["DELETE /orgs/{org}/blocks/{username}"],
      update: ["PATCH /orgs/{org}"],
      updateMembershipForAuthenticatedUser: ["PATCH /user/memberships/orgs/{org}"],
      updateWebhook: ["PATCH /orgs/{org}/hooks/{hook_id}"]
    },
    projects: {
      addCollaborator: ["PUT /projects/{project_id}/collaborators/{username}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      createCard: ["POST /projects/columns/{column_id}/cards", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      createColumn: ["POST /projects/{project_id}/columns", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      createForAuthenticatedUser: ["POST /user/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      createForOrg: ["POST /orgs/{org}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      createForRepo: ["POST /repos/{owner}/{repo}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      delete: ["DELETE /projects/{project_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      deleteCard: ["DELETE /projects/columns/cards/{card_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      deleteColumn: ["DELETE /projects/columns/{column_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      get: ["GET /projects/{project_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      getCard: ["GET /projects/columns/cards/{card_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      getColumn: ["GET /projects/columns/{column_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      getPermissionForUser: ["GET /projects/{project_id}/collaborators/{username}/permission", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listCards: ["GET /projects/columns/{column_id}/cards", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listCollaborators: ["GET /projects/{project_id}/collaborators", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listColumns: ["GET /projects/{project_id}/columns", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listForOrg: ["GET /orgs/{org}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listForRepo: ["GET /repos/{owner}/{repo}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listForUser: ["GET /users/{username}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      moveCard: ["POST /projects/columns/cards/{card_id}/moves", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      moveColumn: ["POST /projects/columns/{column_id}/moves", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      removeCollaborator: ["DELETE /projects/{project_id}/collaborators/{username}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      update: ["PATCH /projects/{project_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      updateCard: ["PATCH /projects/columns/cards/{card_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      updateColumn: ["PATCH /projects/columns/{column_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }]
    },
    pulls: {
      checkIfMerged: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      create: ["POST /repos/{owner}/{repo}/pulls"],
      createReplyForReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],
      createReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      createReviewComment: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
      deletePendingReview: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
      deleteReviewComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      dismissReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],
      get: ["GET /repos/{owner}/{repo}/pulls/{pull_number}"],
      getReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
      getReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],
      list: ["GET /repos/{owner}/{repo}/pulls"],
      listCommentsForReview: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],
      listCommits: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],
      listFiles: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],
      listRequestedReviewers: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
      listReviewComments: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],
      listReviewCommentsForRepo: ["GET /repos/{owner}/{repo}/pulls/comments"],
      listReviews: ["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],
      merge: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],
      removeRequestedReviewers: ["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
      requestReviewers: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],
      submitReview: ["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],
      update: ["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],
      updateBranch: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch", {
        mediaType: {
          previews: ["lydian"]
        }
      }],
      updateReview: ["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],
      updateReviewComment: ["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]
    },
    rateLimit: {
      get: ["GET /rate_limit"]
    },
    reactions: {
      createForCommitComment: ["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      createForIssue: ["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      createForIssueComment: ["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      createForPullRequestReviewComment: ["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      createForTeamDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      createForTeamDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForIssue: ["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForIssueComment: ["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForPullRequestComment: ["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForTeamDiscussion: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteForTeamDiscussionComment: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      deleteLegacy: ["DELETE /reactions/{reaction_id}", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }, {
        deprecated: "octokit.reactions.deleteLegacy() is deprecated, see https://developer.github.com/v3/reactions/#delete-a-reaction-legacy"
      }],
      listForCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      listForIssue: ["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      listForIssueComment: ["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      listForPullRequestReviewComment: ["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      listForTeamDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }],
      listForTeamDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions", {
        mediaType: {
          previews: ["squirrel-girl"]
        }
      }]
    },
    repos: {
      acceptInvitation: ["PATCH /user/repository_invitations/{invitation_id}"],
      addAppAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
        mapToData: "apps"
      }],
      addCollaborator: ["PUT /repos/{owner}/{repo}/collaborators/{username}"],
      addStatusCheckContexts: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
        mapToData: "contexts"
      }],
      addTeamAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
        mapToData: "teams"
      }],
      addUserAccessRestrictions: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
        mapToData: "users"
      }],
      checkCollaborator: ["GET /repos/{owner}/{repo}/collaborators/{username}"],
      checkVulnerabilityAlerts: ["GET /repos/{owner}/{repo}/vulnerability-alerts", {
        mediaType: {
          previews: ["dorian"]
        }
      }],
      compareCommits: ["GET /repos/{owner}/{repo}/compare/{base}...{head}"],
      createCommitComment: ["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
      createCommitSignatureProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
        mediaType: {
          previews: ["zzzax"]
        }
      }],
      createCommitStatus: ["POST /repos/{owner}/{repo}/statuses/{sha}"],
      createDeployKey: ["POST /repos/{owner}/{repo}/keys"],
      createDeployment: ["POST /repos/{owner}/{repo}/deployments"],
      createDeploymentStatus: ["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
      createDispatchEvent: ["POST /repos/{owner}/{repo}/dispatches"],
      createForAuthenticatedUser: ["POST /user/repos"],
      createFork: ["POST /repos/{owner}/{repo}/forks"],
      createInOrg: ["POST /orgs/{org}/repos"],
      createOrUpdateFileContents: ["PUT /repos/{owner}/{repo}/contents/{path}"],
      createPagesSite: ["POST /repos/{owner}/{repo}/pages", {
        mediaType: {
          previews: ["switcheroo"]
        }
      }],
      createRelease: ["POST /repos/{owner}/{repo}/releases"],
      createUsingTemplate: ["POST /repos/{template_owner}/{template_repo}/generate", {
        mediaType: {
          previews: ["baptiste"]
        }
      }],
      createWebhook: ["POST /repos/{owner}/{repo}/hooks"],
      declineInvitation: ["DELETE /user/repository_invitations/{invitation_id}"],
      delete: ["DELETE /repos/{owner}/{repo}"],
      deleteAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
      deleteAdminBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
      deleteBranchProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],
      deleteCommitComment: ["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],
      deleteCommitSignatureProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
        mediaType: {
          previews: ["zzzax"]
        }
      }],
      deleteDeployKey: ["DELETE /repos/{owner}/{repo}/keys/{key_id}"],
      deleteDeployment: ["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],
      deleteFile: ["DELETE /repos/{owner}/{repo}/contents/{path}"],
      deleteInvitation: ["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],
      deletePagesSite: ["DELETE /repos/{owner}/{repo}/pages", {
        mediaType: {
          previews: ["switcheroo"]
        }
      }],
      deletePullRequestReviewProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
      deleteRelease: ["DELETE /repos/{owner}/{repo}/releases/{release_id}"],
      deleteReleaseAsset: ["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      deleteWebhook: ["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],
      disableAutomatedSecurityFixes: ["DELETE /repos/{owner}/{repo}/automated-security-fixes", {
        mediaType: {
          previews: ["london"]
        }
      }],
      disableVulnerabilityAlerts: ["DELETE /repos/{owner}/{repo}/vulnerability-alerts", {
        mediaType: {
          previews: ["dorian"]
        }
      }],
      downloadArchive: ["GET /repos/{owner}/{repo}/{archive_format}/{ref}"],
      enableAutomatedSecurityFixes: ["PUT /repos/{owner}/{repo}/automated-security-fixes", {
        mediaType: {
          previews: ["london"]
        }
      }],
      enableVulnerabilityAlerts: ["PUT /repos/{owner}/{repo}/vulnerability-alerts", {
        mediaType: {
          previews: ["dorian"]
        }
      }],
      get: ["GET /repos/{owner}/{repo}"],
      getAccessRestrictions: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],
      getAdminBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
      getAllStatusCheckContexts: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],
      getAllTopics: ["GET /repos/{owner}/{repo}/topics", {
        mediaType: {
          previews: ["mercy"]
        }
      }],
      getAppsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],
      getBranch: ["GET /repos/{owner}/{repo}/branches/{branch}"],
      getBranchProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection"],
      getClones: ["GET /repos/{owner}/{repo}/traffic/clones"],
      getCodeFrequencyStats: ["GET /repos/{owner}/{repo}/stats/code_frequency"],
      getCollaboratorPermissionLevel: ["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],
      getCombinedStatusForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/status"],
      getCommit: ["GET /repos/{owner}/{repo}/commits/{ref}"],
      getCommitActivityStats: ["GET /repos/{owner}/{repo}/stats/commit_activity"],
      getCommitComment: ["GET /repos/{owner}/{repo}/comments/{comment_id}"],
      getCommitSignatureProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures", {
        mediaType: {
          previews: ["zzzax"]
        }
      }],
      getCommunityProfileMetrics: ["GET /repos/{owner}/{repo}/community/profile", {
        mediaType: {
          previews: ["black-panther"]
        }
      }],
      getContent: ["GET /repos/{owner}/{repo}/contents/{path}"],
      getContributorsStats: ["GET /repos/{owner}/{repo}/stats/contributors"],
      getDeployKey: ["GET /repos/{owner}/{repo}/keys/{key_id}"],
      getDeployment: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],
      getDeploymentStatus: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],
      getLatestPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/latest"],
      getLatestRelease: ["GET /repos/{owner}/{repo}/releases/latest"],
      getPages: ["GET /repos/{owner}/{repo}/pages"],
      getPagesBuild: ["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],
      getParticipationStats: ["GET /repos/{owner}/{repo}/stats/participation"],
      getPullRequestReviewProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
      getPunchCardStats: ["GET /repos/{owner}/{repo}/stats/punch_card"],
      getReadme: ["GET /repos/{owner}/{repo}/readme"],
      getRelease: ["GET /repos/{owner}/{repo}/releases/{release_id}"],
      getReleaseAsset: ["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      getReleaseByTag: ["GET /repos/{owner}/{repo}/releases/tags/{tag}"],
      getStatusChecksProtection: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
      getTeamsWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],
      getTopPaths: ["GET /repos/{owner}/{repo}/traffic/popular/paths"],
      getTopReferrers: ["GET /repos/{owner}/{repo}/traffic/popular/referrers"],
      getUsersWithAccessToProtectedBranch: ["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],
      getViews: ["GET /repos/{owner}/{repo}/traffic/views"],
      getWebhook: ["GET /repos/{owner}/{repo}/hooks/{hook_id}"],
      listBranches: ["GET /repos/{owner}/{repo}/branches"],
      listBranchesForHeadCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head", {
        mediaType: {
          previews: ["groot"]
        }
      }],
      listCollaborators: ["GET /repos/{owner}/{repo}/collaborators"],
      listCommentsForCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],
      listCommitCommentsForRepo: ["GET /repos/{owner}/{repo}/comments"],
      listCommitStatusesForRef: ["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],
      listCommits: ["GET /repos/{owner}/{repo}/commits"],
      listContributors: ["GET /repos/{owner}/{repo}/contributors"],
      listDeployKeys: ["GET /repos/{owner}/{repo}/keys"],
      listDeploymentStatuses: ["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],
      listDeployments: ["GET /repos/{owner}/{repo}/deployments"],
      listForAuthenticatedUser: ["GET /user/repos"],
      listForOrg: ["GET /orgs/{org}/repos"],
      listForUser: ["GET /users/{username}/repos"],
      listForks: ["GET /repos/{owner}/{repo}/forks"],
      listInvitations: ["GET /repos/{owner}/{repo}/invitations"],
      listInvitationsForAuthenticatedUser: ["GET /user/repository_invitations"],
      listLanguages: ["GET /repos/{owner}/{repo}/languages"],
      listPagesBuilds: ["GET /repos/{owner}/{repo}/pages/builds"],
      listPublic: ["GET /repositories"],
      listPullRequestsAssociatedWithCommit: ["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls", {
        mediaType: {
          previews: ["groot"]
        }
      }],
      listReleaseAssets: ["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],
      listReleases: ["GET /repos/{owner}/{repo}/releases"],
      listTags: ["GET /repos/{owner}/{repo}/tags"],
      listTeams: ["GET /repos/{owner}/{repo}/teams"],
      listWebhooks: ["GET /repos/{owner}/{repo}/hooks"],
      merge: ["POST /repos/{owner}/{repo}/merges"],
      pingWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],
      removeAppAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
        mapToData: "apps"
      }],
      removeCollaborator: ["DELETE /repos/{owner}/{repo}/collaborators/{username}"],
      removeStatusCheckContexts: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
        mapToData: "contexts"
      }],
      removeStatusCheckProtection: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
      removeTeamAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
        mapToData: "teams"
      }],
      removeUserAccessRestrictions: ["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
        mapToData: "users"
      }],
      replaceAllTopics: ["PUT /repos/{owner}/{repo}/topics", {
        mediaType: {
          previews: ["mercy"]
        }
      }],
      requestPagesBuild: ["POST /repos/{owner}/{repo}/pages/builds"],
      setAdminBranchProtection: ["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],
      setAppAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps", {}, {
        mapToData: "apps"
      }],
      setStatusCheckContexts: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts", {}, {
        mapToData: "contexts"
      }],
      setTeamAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams", {}, {
        mapToData: "teams"
      }],
      setUserAccessRestrictions: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users", {}, {
        mapToData: "users"
      }],
      testPushWebhook: ["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],
      transfer: ["POST /repos/{owner}/{repo}/transfer"],
      update: ["PATCH /repos/{owner}/{repo}"],
      updateBranchProtection: ["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],
      updateCommitComment: ["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],
      updateInformationAboutPagesSite: ["PUT /repos/{owner}/{repo}/pages"],
      updateInvitation: ["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],
      updatePullRequestReviewProtection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],
      updateRelease: ["PATCH /repos/{owner}/{repo}/releases/{release_id}"],
      updateReleaseAsset: ["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],
      updateStatusCheckPotection: ["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],
      updateWebhook: ["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],
      uploadReleaseAsset: ["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}", {
        baseUrl: "https://uploads.github.com"
      }]
    },
    search: {
      code: ["GET /search/code"],
      commits: ["GET /search/commits", {
        mediaType: {
          previews: ["cloak"]
        }
      }],
      issuesAndPullRequests: ["GET /search/issues"],
      labels: ["GET /search/labels"],
      repos: ["GET /search/repositories"],
      topics: ["GET /search/topics", {
        mediaType: {
          previews: ["mercy"]
        }
      }],
      users: ["GET /search/users"]
    },
    teams: {
      addOrUpdateMembershipForUserInOrg: ["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],
      addOrUpdateProjectPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      addOrUpdateRepoPermissionsInOrg: ["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
      checkPermissionsForProjectInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      checkPermissionsForRepoInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
      create: ["POST /orgs/{org}/teams"],
      createDiscussionCommentInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
      createDiscussionInOrg: ["POST /orgs/{org}/teams/{team_slug}/discussions"],
      deleteDiscussionCommentInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
      deleteDiscussionInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
      deleteInOrg: ["DELETE /orgs/{org}/teams/{team_slug}"],
      getByName: ["GET /orgs/{org}/teams/{team_slug}"],
      getDiscussionCommentInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
      getDiscussionInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
      getMembershipForUserInOrg: ["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],
      list: ["GET /orgs/{org}/teams"],
      listChildInOrg: ["GET /orgs/{org}/teams/{team_slug}/teams"],
      listDiscussionCommentsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],
      listDiscussionsInOrg: ["GET /orgs/{org}/teams/{team_slug}/discussions"],
      listForAuthenticatedUser: ["GET /user/teams"],
      listMembersInOrg: ["GET /orgs/{org}/teams/{team_slug}/members"],
      listPendingInvitationsInOrg: ["GET /orgs/{org}/teams/{team_slug}/invitations"],
      listProjectsInOrg: ["GET /orgs/{org}/teams/{team_slug}/projects", {
        mediaType: {
          previews: ["inertia"]
        }
      }],
      listReposInOrg: ["GET /orgs/{org}/teams/{team_slug}/repos"],
      removeMembershipForUserInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],
      removeProjectInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],
      removeRepoInOrg: ["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],
      updateDiscussionCommentInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],
      updateDiscussionInOrg: ["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],
      updateInOrg: ["PATCH /orgs/{org}/teams/{team_slug}"]
    },
    users: {
      addEmailForAuthenticated: ["POST /user/emails"],
      block: ["PUT /user/blocks/{username}"],
      checkBlocked: ["GET /user/blocks/{username}"],
      checkFollowingForUser: ["GET /users/{username}/following/{target_user}"],
      checkPersonIsFollowedByAuthenticated: ["GET /user/following/{username}"],
      createGpgKeyForAuthenticated: ["POST /user/gpg_keys"],
      createPublicSshKeyForAuthenticated: ["POST /user/keys"],
      deleteEmailForAuthenticated: ["DELETE /user/emails"],
      deleteGpgKeyForAuthenticated: ["DELETE /user/gpg_keys/{gpg_key_id}"],
      deletePublicSshKeyForAuthenticated: ["DELETE /user/keys/{key_id}"],
      follow: ["PUT /user/following/{username}"],
      getAuthenticated: ["GET /user"],
      getByUsername: ["GET /users/{username}"],
      getContextForUser: ["GET /users/{username}/hovercard"],
      getGpgKeyForAuthenticated: ["GET /user/gpg_keys/{gpg_key_id}"],
      getPublicSshKeyForAuthenticated: ["GET /user/keys/{key_id}"],
      list: ["GET /users"],
      listBlockedByAuthenticated: ["GET /user/blocks"],
      listEmailsForAuthenticated: ["GET /user/emails"],
      listFollowedByAuthenticated: ["GET /user/following"],
      listFollowersForAuthenticatedUser: ["GET /user/followers"],
      listFollowersForUser: ["GET /users/{username}/followers"],
      listFollowingForUser: ["GET /users/{username}/following"],
      listGpgKeysForAuthenticated: ["GET /user/gpg_keys"],
      listGpgKeysForUser: ["GET /users/{username}/gpg_keys"],
      listPublicEmailsForAuthenticated: ["GET /user/public_emails"],
      listPublicKeysForUser: ["GET /users/{username}/keys"],
      listPublicSshKeysForAuthenticated: ["GET /user/keys"],
      setPrimaryEmailVisibilityForAuthenticated: ["PATCH /user/email/visibility"],
      unblock: ["DELETE /user/blocks/{username}"],
      unfollow: ["DELETE /user/following/{username}"],
      updateAuthenticated: ["PATCH /user"]
    }
  };
  var VERSION = "4.2.1";
  function endpointsToMethods(octokit, endpointsMap) {
    const newMethods = {};
    for (const [scope, endpoints] of Object.entries(endpointsMap)) {
      for (const [methodName, endpoint] of Object.entries(endpoints)) {
        const [route, defaults, decorations] = endpoint;
        const [method, url] = route.split(/ /);
        const endpointDefaults = Object.assign({
          method,
          url
        }, defaults);
        if (!newMethods[scope]) {
          newMethods[scope] = {};
        }
        const scopeMethods = newMethods[scope];
        if (decorations) {
          scopeMethods[methodName] = decorate(octokit, scope, methodName, endpointDefaults, decorations);
          continue;
        }
        scopeMethods[methodName] = octokit.request.defaults(endpointDefaults);
      }
    }
    return newMethods;
  }
  function decorate(octokit, scope, methodName, defaults, decorations) {
    const requestWithDefaults = octokit.request.defaults(defaults);
    function withDecorations(...args) {
      let options = requestWithDefaults.endpoint.merge(...args);
      if (decorations.mapToData) {
        options = Object.assign({}, options, {
          data: options[decorations.mapToData],
          [decorations.mapToData]: void 0
        });
        return requestWithDefaults(options);
      }
      if (decorations.renamed) {
        const [newScope, newMethodName] = decorations.renamed;
        octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`);
      }
      if (decorations.deprecated) {
        octokit.log.warn(decorations.deprecated);
      }
      if (decorations.renamedParameters) {
        const options2 = requestWithDefaults.endpoint.merge(...args);
        for (const [name, alias] of Object.entries(decorations.renamedParameters)) {
          if (name in options2) {
            octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`);
            if (!(alias in options2)) {
              options2[alias] = options2[name];
            }
            delete options2[name];
          }
        }
        return requestWithDefaults(options2);
      }
      return requestWithDefaults(...args);
    }
    return Object.assign(withDecorations, requestWithDefaults);
  }
  function restEndpointMethods(octokit) {
    return endpointsToMethods(octokit, Endpoints);
  }
  restEndpointMethods.VERSION = VERSION;
  exports2.restEndpointMethods = restEndpointMethods;
});

// node_modules/@octokit/plugin-paginate-rest/dist-node/index.js
var require_dist_node10 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var VERSION = "2.6.0";
  function normalizePaginatedListResponse(response) {
    const responseNeedsNormalization = "total_count" in response.data && !("url" in response.data);
    if (!responseNeedsNormalization)
      return response;
    const incompleteResults = response.data.incomplete_results;
    const repositorySelection = response.data.repository_selection;
    const totalCount = response.data.total_count;
    delete response.data.incomplete_results;
    delete response.data.repository_selection;
    delete response.data.total_count;
    const namespaceKey = Object.keys(response.data)[0];
    const data = response.data[namespaceKey];
    response.data = data;
    if (typeof incompleteResults !== "undefined") {
      response.data.incomplete_results = incompleteResults;
    }
    if (typeof repositorySelection !== "undefined") {
      response.data.repository_selection = repositorySelection;
    }
    response.data.total_count = totalCount;
    return response;
  }
  function iterator(octokit, route, parameters) {
    const options = typeof route === "function" ? route.endpoint(parameters) : octokit.request.endpoint(route, parameters);
    const requestMethod = typeof route === "function" ? route : octokit.request;
    const method = options.method;
    const headers = options.headers;
    let url = options.url;
    return {
      [Symbol.asyncIterator]: () => ({
        next() {
          return __async(this, null, function* () {
            if (!url)
              return {
                done: true
              };
            const response = yield requestMethod({
              method,
              url,
              headers
            });
            const normalizedResponse = normalizePaginatedListResponse(response);
            url = ((normalizedResponse.headers.link || "").match(/<([^>]+)>;\s*rel="next"/) || [])[1];
            return {
              value: normalizedResponse
            };
          });
        }
      })
    };
  }
  function paginate(octokit, route, parameters, mapFn) {
    if (typeof parameters === "function") {
      mapFn = parameters;
      parameters = void 0;
    }
    return gather(octokit, [], iterator(octokit, route, parameters)[Symbol.asyncIterator](), mapFn);
  }
  function gather(octokit, results, iterator2, mapFn) {
    return iterator2.next().then((result) => {
      if (result.done) {
        return results;
      }
      let earlyExit = false;
      function done() {
        earlyExit = true;
      }
      results = results.concat(mapFn ? mapFn(result.value, done) : result.value.data);
      if (earlyExit) {
        return results;
      }
      return gather(octokit, results, iterator2, mapFn);
    });
  }
  var composePaginateRest = Object.assign(paginate, {
    iterator
  });
  function paginateRest(octokit) {
    return {
      paginate: Object.assign(paginate.bind(null, octokit), {
        iterator: iterator.bind(null, octokit)
      })
    };
  }
  paginateRest.VERSION = VERSION;
  exports2.composePaginateRest = composePaginateRest;
  exports2.paginateRest = paginateRest;
});

// node_modules/@actions/github/lib/utils.js
var require_utils3 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getOctokitOptions = exports2.GitHub = exports2.context = void 0;
  var Context = __importStar(require_context());
  var Utils = __importStar(require_utils2());
  var core_1 = require_dist_node8();
  var plugin_rest_endpoint_methods_1 = require_dist_node9();
  var plugin_paginate_rest_1 = require_dist_node10();
  exports2.context = new Context.Context();
  var baseUrl = Utils.getApiBaseUrl();
  var defaults = {
    baseUrl,
    request: {
      agent: Utils.getProxyAgent(baseUrl)
    }
  };
  exports2.GitHub = core_1.Octokit.plugin(plugin_rest_endpoint_methods_1.restEndpointMethods, plugin_paginate_rest_1.paginateRest).defaults(defaults);
  function getOctokitOptions(token, options) {
    const opts = Object.assign({}, options || {});
    const auth = Utils.getAuthString(token, opts);
    if (auth) {
      opts.auth = auth;
    }
    return opts;
  }
  exports2.getOctokitOptions = getOctokitOptions;
});

// node_modules/@actions/github/lib/github.js
var require_github = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (Object.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getOctokit = exports2.context = void 0;
  var Context = __importStar(require_context());
  var utils_1 = require_utils3();
  exports2.context = new Context.Context();
  function getOctokit(token, options) {
    return new utils_1.GitHub(utils_1.getOctokitOptions(token, options));
  }
  exports2.getOctokit = getOctokit;
});

// node_modules/@octokit/plugin-request-log/dist-node/index.js
var require_dist_node11 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var VERSION = "1.0.2";
  function requestLog(octokit) {
    octokit.hook.wrap("request", (request, options) => {
      octokit.log.debug("request", options);
      const start = Date.now();
      const requestOptions = octokit.request.endpoint.parse(options);
      const path3 = requestOptions.url.replace(options.baseUrl, "");
      return request(options).then((response) => {
        octokit.log.info(`${requestOptions.method} ${path3} - ${response.status} in ${Date.now() - start}ms`);
        return response;
      }).catch((error5) => {
        octokit.log.info(`${requestOptions.method} ${path3} - ${error5.status} in ${Date.now() - start}ms`);
        throw error5;
      });
    });
  }
  requestLog.VERSION = VERSION;
  exports2.requestLog = requestLog;
});

// node_modules/@octokit/rest/dist-node/index.js
var require_dist_node12 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var core7 = require_dist_node8();
  var pluginRequestLog = require_dist_node11();
  var pluginPaginateRest = require_dist_node10();
  var pluginRestEndpointMethods = require_dist_node9();
  var VERSION = "18.0.9";
  var Octokit2 = core7.Octokit.plugin(pluginRequestLog.requestLog, pluginRestEndpointMethods.restEndpointMethods, pluginPaginateRest.paginateRest).defaults({
    userAgent: `octokit-rest.js/${VERSION}`
  });
  exports2.Octokit = Octokit2;
});

// node_modules/braces/lib/utils.js
var require_utils4 = __commonJS((exports2) => {
  "use strict";
  exports2.isInteger = (num) => {
    if (typeof num === "number") {
      return Number.isInteger(num);
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isInteger(Number(num));
    }
    return false;
  };
  exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
  exports2.exceedsLimit = (min, max, step = 1, limit) => {
    if (limit === false)
      return false;
    if (!exports2.isInteger(min) || !exports2.isInteger(max))
      return false;
    return (Number(max) - Number(min)) / Number(step) >= limit;
  };
  exports2.escapeNode = (block, n = 0, type) => {
    let node = block.nodes[n];
    if (!node)
      return;
    if (type && node.type === type || node.type === "open" || node.type === "close") {
      if (node.escaped !== true) {
        node.value = "\\" + node.value;
        node.escaped = true;
      }
    }
  };
  exports2.encloseBrace = (node) => {
    if (node.type !== "brace")
      return false;
    if (node.commas >> 0 + node.ranges >> 0 === 0) {
      node.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isInvalidBrace = (block) => {
    if (block.type !== "brace")
      return false;
    if (block.invalid === true || block.dollar)
      return true;
    if (block.commas >> 0 + block.ranges >> 0 === 0) {
      block.invalid = true;
      return true;
    }
    if (block.open !== true || block.close !== true) {
      block.invalid = true;
      return true;
    }
    return false;
  };
  exports2.isOpenOrClose = (node) => {
    if (node.type === "open" || node.type === "close") {
      return true;
    }
    return node.open === true || node.close === true;
  };
  exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
    if (node.type === "text")
      acc.push(node.value);
    if (node.type === "range")
      node.type = "text";
    return acc;
  }, []);
  exports2.flatten = (...args) => {
    const result = [];
    const flat = (arr) => {
      for (let i = 0; i < arr.length; i++) {
        let ele = arr[i];
        Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
      }
      return result;
    };
    flat(args);
    return result;
  };
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  module2.exports = (ast, options = {}) => {
    let stringify = (node, parent = {}) => {
      let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let output = "";
      if (node.value) {
        if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
          return "\\" + node.value;
        }
        return node.value;
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += stringify(child);
        }
      }
      return output;
    };
    return stringify(ast);
  };
});

// node_modules/is-number/index.js
var require_is_number = __commonJS((exports2, module2) => {
  /*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  module2.exports = function(num) {
    if (typeof num === "number") {
      return num - num === 0;
    }
    if (typeof num === "string" && num.trim() !== "") {
      return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
    }
    return false;
  };
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS((exports2, module2) => {
  /*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   */
  "use strict";
  var isNumber = require_is_number();
  var toRegexRange = (min, max, options) => {
    if (isNumber(min) === false) {
      throw new TypeError("toRegexRange: expected the first argument to be a number");
    }
    if (max === void 0 || min === max) {
      return String(min);
    }
    if (isNumber(max) === false) {
      throw new TypeError("toRegexRange: expected the second argument to be a number.");
    }
    let opts = __objSpread({relaxZeros: true}, options);
    if (typeof opts.strictZeros === "boolean") {
      opts.relaxZeros = opts.strictZeros === false;
    }
    let relax = String(opts.relaxZeros);
    let shorthand = String(opts.shorthand);
    let capture = String(opts.capture);
    let wrap = String(opts.wrap);
    let cacheKey = min + ":" + max + "=" + relax + shorthand + capture + wrap;
    if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
      return toRegexRange.cache[cacheKey].result;
    }
    let a = Math.min(min, max);
    let b = Math.max(min, max);
    if (Math.abs(a - b) === 1) {
      let result = min + "|" + max;
      if (opts.capture) {
        return `(${result})`;
      }
      if (opts.wrap === false) {
        return result;
      }
      return `(?:${result})`;
    }
    let isPadded = hasPadding(min) || hasPadding(max);
    let state = {min, max, a, b};
    let positives = [];
    let negatives = [];
    if (isPadded) {
      state.isPadded = isPadded;
      state.maxLen = String(state.max).length;
    }
    if (a < 0) {
      let newMin = b < 0 ? Math.abs(b) : 1;
      negatives = splitToPatterns(newMin, Math.abs(a), state, opts);
      a = state.a = 0;
    }
    if (b >= 0) {
      positives = splitToPatterns(a, b, state, opts);
    }
    state.negatives = negatives;
    state.positives = positives;
    state.result = collatePatterns(negatives, positives, opts);
    if (opts.capture === true) {
      state.result = `(${state.result})`;
    } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
      state.result = `(?:${state.result})`;
    }
    toRegexRange.cache[cacheKey] = state;
    return state.result;
  };
  function collatePatterns(neg, pos, options) {
    let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
    let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
    let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
    let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
    return subpatterns.join("|");
  }
  function splitToRanges(min, max) {
    let nines = 1;
    let zeros = 1;
    let stop = countNines(min, nines);
    let stops = new Set([max]);
    while (min <= stop && stop <= max) {
      stops.add(stop);
      nines += 1;
      stop = countNines(min, nines);
    }
    stop = countZeros(max + 1, zeros) - 1;
    while (min < stop && stop <= max) {
      stops.add(stop);
      zeros += 1;
      stop = countZeros(max + 1, zeros) - 1;
    }
    stops = [...stops];
    stops.sort(compare);
    return stops;
  }
  function rangeToPattern(start, stop, options) {
    if (start === stop) {
      return {pattern: start, count: [], digits: 0};
    }
    let zipped = zip(start, stop);
    let digits = zipped.length;
    let pattern = "";
    let count = 0;
    for (let i = 0; i < digits; i++) {
      let [startDigit, stopDigit] = zipped[i];
      if (startDigit === stopDigit) {
        pattern += startDigit;
      } else if (startDigit !== "0" || stopDigit !== "9") {
        pattern += toCharacterClass(startDigit, stopDigit, options);
      } else {
        count++;
      }
    }
    if (count) {
      pattern += options.shorthand === true ? "\\d" : "[0-9]";
    }
    return {pattern, count: [count], digits};
  }
  function splitToPatterns(min, max, tok, options) {
    let ranges = splitToRanges(min, max);
    let tokens = [];
    let start = min;
    let prev;
    for (let i = 0; i < ranges.length; i++) {
      let max2 = ranges[i];
      let obj = rangeToPattern(String(start), String(max2), options);
      let zeros = "";
      if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
        if (prev.count.length > 1) {
          prev.count.pop();
        }
        prev.count.push(obj.count[0]);
        prev.string = prev.pattern + toQuantifier(prev.count);
        start = max2 + 1;
        continue;
      }
      if (tok.isPadded) {
        zeros = padZeros(max2, tok, options);
      }
      obj.string = zeros + obj.pattern + toQuantifier(obj.count);
      tokens.push(obj);
      start = max2 + 1;
      prev = obj;
    }
    return tokens;
  }
  function filterPatterns(arr, comparison, prefix, intersection, options) {
    let result = [];
    for (let ele of arr) {
      let {string} = ele;
      if (!intersection && !contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
      if (intersection && contains(comparison, "string", string)) {
        result.push(prefix + string);
      }
    }
    return result;
  }
  function zip(a, b) {
    let arr = [];
    for (let i = 0; i < a.length; i++)
      arr.push([a[i], b[i]]);
    return arr;
  }
  function compare(a, b) {
    return a > b ? 1 : b > a ? -1 : 0;
  }
  function contains(arr, key, val) {
    return arr.some((ele) => ele[key] === val);
  }
  function countNines(min, len) {
    return Number(String(min).slice(0, -len) + "9".repeat(len));
  }
  function countZeros(integer, zeros) {
    return integer - integer % Math.pow(10, zeros);
  }
  function toQuantifier(digits) {
    let [start = 0, stop = ""] = digits;
    if (stop || start > 1) {
      return `{${start + (stop ? "," + stop : "")}}`;
    }
    return "";
  }
  function toCharacterClass(a, b, options) {
    return `[${a}${b - a === 1 ? "" : "-"}${b}]`;
  }
  function hasPadding(str) {
    return /^-?(0+)\d/.test(str);
  }
  function padZeros(value, tok, options) {
    if (!tok.isPadded) {
      return value;
    }
    let diff = Math.abs(tok.maxLen - String(value).length);
    let relax = options.relaxZeros !== false;
    switch (diff) {
      case 0:
        return "";
      case 1:
        return relax ? "0?" : "0";
      case 2:
        return relax ? "0{0,2}" : "00";
      default: {
        return relax ? `0{0,${diff}}` : `0{${diff}}`;
      }
    }
  }
  toRegexRange.cache = {};
  toRegexRange.clearCache = () => toRegexRange.cache = {};
  module2.exports = toRegexRange;
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS((exports2, module2) => {
  /*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  "use strict";
  var util = require("util");
  var toRegexRange = require_to_regex_range();
  var isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  var transform = (toNumber) => {
    return (value) => toNumber === true ? Number(value) : String(value);
  };
  var isValidValue = (value) => {
    return typeof value === "number" || typeof value === "string" && value !== "";
  };
  var isNumber = (num) => Number.isInteger(+num);
  var zeros = (input) => {
    let value = `${input}`;
    let index = -1;
    if (value[0] === "-")
      value = value.slice(1);
    if (value === "0")
      return false;
    while (value[++index] === "0")
      ;
    return index > 0;
  };
  var stringify = (start, end, options) => {
    if (typeof start === "string" || typeof end === "string") {
      return true;
    }
    return options.stringify === true;
  };
  var pad = (input, maxLength, toNumber) => {
    if (maxLength > 0) {
      let dash = input[0] === "-" ? "-" : "";
      if (dash)
        input = input.slice(1);
      input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
    }
    if (toNumber === false) {
      return String(input);
    }
    return input;
  };
  var toMaxLen = (input, maxLength) => {
    let negative = input[0] === "-" ? "-" : "";
    if (negative) {
      input = input.slice(1);
      maxLength--;
    }
    while (input.length < maxLength)
      input = "0" + input;
    return negative ? "-" + input : input;
  };
  var toSequence = (parts, options) => {
    parts.negatives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    parts.positives.sort((a, b) => a < b ? -1 : a > b ? 1 : 0);
    let prefix = options.capture ? "" : "?:";
    let positives = "";
    let negatives = "";
    let result;
    if (parts.positives.length) {
      positives = parts.positives.join("|");
    }
    if (parts.negatives.length) {
      negatives = `-(${prefix}${parts.negatives.join("|")})`;
    }
    if (positives && negatives) {
      result = `${positives}|${negatives}`;
    } else {
      result = positives || negatives;
    }
    if (options.wrap) {
      return `(${prefix}${result})`;
    }
    return result;
  };
  var toRange = (a, b, isNumbers, options) => {
    if (isNumbers) {
      return toRegexRange(a, b, __objSpread({wrap: false}, options));
    }
    let start = String.fromCharCode(a);
    if (a === b)
      return start;
    let stop = String.fromCharCode(b);
    return `[${start}-${stop}]`;
  };
  var toRegex = (start, end, options) => {
    if (Array.isArray(start)) {
      let wrap = options.wrap === true;
      let prefix = options.capture ? "" : "?:";
      return wrap ? `(${prefix}${start.join("|")})` : start.join("|");
    }
    return toRegexRange(start, end, options);
  };
  var rangeError = (...args) => {
    return new RangeError("Invalid range arguments: " + util.inspect(...args));
  };
  var invalidRange = (start, end, options) => {
    if (options.strictRanges === true)
      throw rangeError([start, end]);
    return [];
  };
  var invalidStep = (step, options) => {
    if (options.strictRanges === true) {
      throw new TypeError(`Expected step "${step}" to be a number`);
    }
    return [];
  };
  var fillNumbers = (start, end, step = 1, options = {}) => {
    let a = Number(start);
    let b = Number(end);
    if (!Number.isInteger(a) || !Number.isInteger(b)) {
      if (options.strictRanges === true)
        throw rangeError([start, end]);
      return [];
    }
    if (a === 0)
      a = 0;
    if (b === 0)
      b = 0;
    let descending = a > b;
    let startString = String(start);
    let endString = String(end);
    let stepString = String(step);
    step = Math.max(Math.abs(step), 1);
    let padded = zeros(startString) || zeros(endString) || zeros(stepString);
    let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
    let toNumber = padded === false && stringify(start, end, options) === false;
    let format = options.transform || transform(toNumber);
    if (options.toRegex && step === 1) {
      return toRange(toMaxLen(start, maxLen), toMaxLen(end, maxLen), true, options);
    }
    let parts = {negatives: [], positives: []};
    let push = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      if (options.toRegex === true && step > 1) {
        push(a);
      } else {
        range.push(pad(format(a, index), maxLen, toNumber));
      }
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return step > 1 ? toSequence(parts, options) : toRegex(range, null, __objSpread({wrap: false}, options));
    }
    return range;
  };
  var fillLetters = (start, end, step = 1, options = {}) => {
    if (!isNumber(start) && start.length > 1 || !isNumber(end) && end.length > 1) {
      return invalidRange(start, end, options);
    }
    let format = options.transform || ((val) => String.fromCharCode(val));
    let a = `${start}`.charCodeAt(0);
    let b = `${end}`.charCodeAt(0);
    let descending = a > b;
    let min = Math.min(a, b);
    let max = Math.max(a, b);
    if (options.toRegex && step === 1) {
      return toRange(min, max, false, options);
    }
    let range = [];
    let index = 0;
    while (descending ? a >= b : a <= b) {
      range.push(format(a, index));
      a = descending ? a - step : a + step;
      index++;
    }
    if (options.toRegex === true) {
      return toRegex(range, null, {wrap: false, options});
    }
    return range;
  };
  var fill = (start, end, step, options = {}) => {
    if (end == null && isValidValue(start)) {
      return [start];
    }
    if (!isValidValue(start) || !isValidValue(end)) {
      return invalidRange(start, end, options);
    }
    if (typeof step === "function") {
      return fill(start, end, 1, {transform: step});
    }
    if (isObject(step)) {
      return fill(start, end, 0, step);
    }
    let opts = __objSpread({}, options);
    if (opts.capture === true)
      opts.wrap = true;
    step = step || opts.step || 1;
    if (!isNumber(step)) {
      if (step != null && !isObject(step))
        return invalidStep(step, opts);
      return fill(start, end, 1, step);
    }
    if (isNumber(start) && isNumber(end)) {
      return fillNumbers(start, end, step, opts);
    }
    return fillLetters(start, end, Math.max(Math.abs(step), 1), opts);
  };
  module2.exports = fill;
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var utils = require_utils4();
  var compile = (ast, options = {}) => {
    let walk = (node, parent = {}) => {
      let invalidBlock = utils.isInvalidBrace(parent);
      let invalidNode = node.invalid === true && options.escapeInvalid === true;
      let invalid = invalidBlock === true || invalidNode === true;
      let prefix = options.escapeInvalid === true ? "\\" : "";
      let output = "";
      if (node.isOpen === true) {
        return prefix + node.value;
      }
      if (node.isClose === true) {
        return prefix + node.value;
      }
      if (node.type === "open") {
        return invalid ? prefix + node.value : "(";
      }
      if (node.type === "close") {
        return invalid ? prefix + node.value : ")";
      }
      if (node.type === "comma") {
        return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
      }
      if (node.value) {
        return node.value;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        let range = fill(...args, __objSpread(__objSpread({}, options), {wrap: false, toRegex: true}));
        if (range.length !== 0) {
          return args.length > 1 && range.length > 1 ? `(${range})` : range;
        }
      }
      if (node.nodes) {
        for (let child of node.nodes) {
          output += walk(child, node);
        }
      }
      return output;
    };
    return walk(ast);
  };
  module2.exports = compile;
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS((exports2, module2) => {
  "use strict";
  var fill = require_fill_range();
  var stringify = require_stringify();
  var utils = require_utils4();
  var append = (queue = "", stash = "", enclose = false) => {
    let result = [];
    queue = [].concat(queue);
    stash = [].concat(stash);
    if (!stash.length)
      return queue;
    if (!queue.length) {
      return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
    }
    for (let item of queue) {
      if (Array.isArray(item)) {
        for (let value of item) {
          result.push(append(value, stash, enclose));
        }
      } else {
        for (let ele of stash) {
          if (enclose === true && typeof ele === "string")
            ele = `{${ele}}`;
          result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
        }
      }
    }
    return utils.flatten(result);
  };
  var expand = (ast, options = {}) => {
    let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
    let walk = (node, parent = {}) => {
      node.queue = [];
      let p = parent;
      let q = parent.queue;
      while (p.type !== "brace" && p.type !== "root" && p.parent) {
        p = p.parent;
        q = p.queue;
      }
      if (node.invalid || node.dollar) {
        q.push(append(q.pop(), stringify(node, options)));
        return;
      }
      if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
        q.push(append(q.pop(), ["{}"]));
        return;
      }
      if (node.nodes && node.ranges > 0) {
        let args = utils.reduce(node.nodes);
        if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
          throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
        }
        let range = fill(...args, options);
        if (range.length === 0) {
          range = stringify(node, options);
        }
        q.push(append(q.pop(), range));
        node.nodes = [];
        return;
      }
      let enclose = utils.encloseBrace(node);
      let queue = node.queue;
      let block = node;
      while (block.type !== "brace" && block.type !== "root" && block.parent) {
        block = block.parent;
        queue = block.queue;
      }
      for (let i = 0; i < node.nodes.length; i++) {
        let child = node.nodes[i];
        if (child.type === "comma" && node.type === "brace") {
          if (i === 1)
            queue.push("");
          queue.push("");
          continue;
        }
        if (child.type === "close") {
          q.push(append(q.pop(), queue, enclose));
          continue;
        }
        if (child.value && child.type !== "open") {
          queue.push(append(queue.pop(), child.value));
          continue;
        }
        if (child.nodes) {
          walk(child, node);
        }
      }
      return queue;
    };
    return utils.flatten(walk(ast));
  };
  module2.exports = expand;
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    CHAR_0: "0",
    CHAR_9: "9",
    CHAR_UPPERCASE_A: "A",
    CHAR_LOWERCASE_A: "a",
    CHAR_UPPERCASE_Z: "Z",
    CHAR_LOWERCASE_Z: "z",
    CHAR_LEFT_PARENTHESES: "(",
    CHAR_RIGHT_PARENTHESES: ")",
    CHAR_ASTERISK: "*",
    CHAR_AMPERSAND: "&",
    CHAR_AT: "@",
    CHAR_BACKSLASH: "\\",
    CHAR_BACKTICK: "`",
    CHAR_CARRIAGE_RETURN: "\r",
    CHAR_CIRCUMFLEX_ACCENT: "^",
    CHAR_COLON: ":",
    CHAR_COMMA: ",",
    CHAR_DOLLAR: "$",
    CHAR_DOT: ".",
    CHAR_DOUBLE_QUOTE: '"',
    CHAR_EQUAL: "=",
    CHAR_EXCLAMATION_MARK: "!",
    CHAR_FORM_FEED: "\f",
    CHAR_FORWARD_SLASH: "/",
    CHAR_HASH: "#",
    CHAR_HYPHEN_MINUS: "-",
    CHAR_LEFT_ANGLE_BRACKET: "<",
    CHAR_LEFT_CURLY_BRACE: "{",
    CHAR_LEFT_SQUARE_BRACKET: "[",
    CHAR_LINE_FEED: "\n",
    CHAR_NO_BREAK_SPACE: "\xA0",
    CHAR_PERCENT: "%",
    CHAR_PLUS: "+",
    CHAR_QUESTION_MARK: "?",
    CHAR_RIGHT_ANGLE_BRACKET: ">",
    CHAR_RIGHT_CURLY_BRACE: "}",
    CHAR_RIGHT_SQUARE_BRACKET: "]",
    CHAR_SEMICOLON: ";",
    CHAR_SINGLE_QUOTE: "'",
    CHAR_SPACE: " ",
    CHAR_TAB: "	",
    CHAR_UNDERSCORE: "_",
    CHAR_VERTICAL_LINE: "|",
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
  };
});

// node_modules/braces/lib/parse.js
var require_parse = __commonJS((exports2, module2) => {
  "use strict";
  var stringify = require_stringify();
  var {
    MAX_LENGTH,
    CHAR_BACKSLASH,
    CHAR_BACKTICK,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_LEFT_PARENTHESES,
    CHAR_RIGHT_PARENTHESES,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_RIGHT_SQUARE_BRACKET,
    CHAR_DOUBLE_QUOTE,
    CHAR_SINGLE_QUOTE,
    CHAR_NO_BREAK_SPACE,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE
  } = require_constants();
  var parse = (input, options = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    let opts = options || {};
    let max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    if (input.length > max) {
      throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max})`);
    }
    let ast = {type: "root", input, nodes: []};
    let stack = [ast];
    let block = ast;
    let prev = ast;
    let brackets = 0;
    let length = input.length;
    let index = 0;
    let depth = 0;
    let value;
    let memo = {};
    const advance = () => input[index++];
    const push = (node) => {
      if (node.type === "text" && prev.type === "dot") {
        prev.type = "text";
      }
      if (prev && prev.type === "text" && node.type === "text") {
        prev.value += node.value;
        return;
      }
      block.nodes.push(node);
      node.parent = block;
      node.prev = prev;
      prev = node;
      return node;
    };
    push({type: "bos"});
    while (index < length) {
      block = stack[stack.length - 1];
      value = advance();
      if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
        continue;
      }
      if (value === CHAR_BACKSLASH) {
        push({type: "text", value: (options.keepEscaping ? value : "") + advance()});
        continue;
      }
      if (value === CHAR_RIGHT_SQUARE_BRACKET) {
        push({type: "text", value: "\\" + value});
        continue;
      }
      if (value === CHAR_LEFT_SQUARE_BRACKET) {
        brackets++;
        let closed = true;
        let next;
        while (index < length && (next = advance())) {
          value += next;
          if (next === CHAR_LEFT_SQUARE_BRACKET) {
            brackets++;
            continue;
          }
          if (next === CHAR_BACKSLASH) {
            value += advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            brackets--;
            if (brackets === 0) {
              break;
            }
          }
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_PARENTHESES) {
        block = push({type: "paren", nodes: []});
        stack.push(block);
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_RIGHT_PARENTHESES) {
        if (block.type !== "paren") {
          push({type: "text", value});
          continue;
        }
        block = stack.pop();
        push({type: "text", value});
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
        let open = value;
        let next;
        if (options.keepQuotes !== true) {
          value = "";
        }
        while (index < length && (next = advance())) {
          if (next === CHAR_BACKSLASH) {
            value += next + advance();
            continue;
          }
          if (next === open) {
            if (options.keepQuotes === true)
              value += next;
            break;
          }
          value += next;
        }
        push({type: "text", value});
        continue;
      }
      if (value === CHAR_LEFT_CURLY_BRACE) {
        depth++;
        let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
        let brace = {
          type: "brace",
          open: true,
          close: false,
          dollar,
          depth,
          commas: 0,
          ranges: 0,
          nodes: []
        };
        block = push(brace);
        stack.push(block);
        push({type: "open", value});
        continue;
      }
      if (value === CHAR_RIGHT_CURLY_BRACE) {
        if (block.type !== "brace") {
          push({type: "text", value});
          continue;
        }
        let type = "close";
        block = stack.pop();
        block.close = true;
        push({type, value});
        depth--;
        block = stack[stack.length - 1];
        continue;
      }
      if (value === CHAR_COMMA && depth > 0) {
        if (block.ranges > 0) {
          block.ranges = 0;
          let open = block.nodes.shift();
          block.nodes = [open, {type: "text", value: stringify(block)}];
        }
        push({type: "comma", value});
        block.commas++;
        continue;
      }
      if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
        let siblings = block.nodes;
        if (depth === 0 || siblings.length === 0) {
          push({type: "text", value});
          continue;
        }
        if (prev.type === "dot") {
          block.range = [];
          prev.value += value;
          prev.type = "range";
          if (block.nodes.length !== 3 && block.nodes.length !== 5) {
            block.invalid = true;
            block.ranges = 0;
            prev.type = "text";
            continue;
          }
          block.ranges++;
          block.args = [];
          continue;
        }
        if (prev.type === "range") {
          siblings.pop();
          let before = siblings[siblings.length - 1];
          before.value += prev.value + value;
          prev = before;
          block.ranges--;
          continue;
        }
        push({type: "dot", value});
        continue;
      }
      push({type: "text", value});
    }
    do {
      block = stack.pop();
      if (block.type !== "root") {
        block.nodes.forEach((node) => {
          if (!node.nodes) {
            if (node.type === "open")
              node.isOpen = true;
            if (node.type === "close")
              node.isClose = true;
            if (!node.nodes)
              node.type = "text";
            node.invalid = true;
          }
        });
        let parent = stack[stack.length - 1];
        let index2 = parent.nodes.indexOf(block);
        parent.nodes.splice(index2, 1, ...block.nodes);
      }
    } while (stack.length > 0);
    push({type: "eos"});
    return ast;
  };
  module2.exports = parse;
});

// node_modules/braces/index.js
var require_braces = __commonJS((exports2, module2) => {
  "use strict";
  var stringify = require_stringify();
  var compile = require_compile();
  var expand = require_expand();
  var parse = require_parse();
  var braces = (input, options = {}) => {
    let output = [];
    if (Array.isArray(input)) {
      for (let pattern of input) {
        let result = braces.create(pattern, options);
        if (Array.isArray(result)) {
          output.push(...result);
        } else {
          output.push(result);
        }
      }
    } else {
      output = [].concat(braces.create(input, options));
    }
    if (options && options.expand === true && options.nodupes === true) {
      output = [...new Set(output)];
    }
    return output;
  };
  braces.parse = (input, options = {}) => parse(input, options);
  braces.stringify = (input, options = {}) => {
    if (typeof input === "string") {
      return stringify(braces.parse(input, options), options);
    }
    return stringify(input, options);
  };
  braces.compile = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    return compile(input, options);
  };
  braces.expand = (input, options = {}) => {
    if (typeof input === "string") {
      input = braces.parse(input, options);
    }
    let result = expand(input, options);
    if (options.noempty === true) {
      result = result.filter(Boolean);
    }
    if (options.nodupes === true) {
      result = [...new Set(result)];
    }
    return result;
  };
  braces.create = (input, options = {}) => {
    if (input === "" || input.length < 3) {
      return [input];
    }
    return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
  };
  module2.exports = braces;
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var WIN_SLASH = "\\\\/";
  var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
  var DOT_LITERAL = "\\.";
  var PLUS_LITERAL = "\\+";
  var QMARK_LITERAL = "\\?";
  var SLASH_LITERAL = "\\/";
  var ONE_CHAR = "(?=.)";
  var QMARK = "[^/]";
  var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
  var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
  var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
  var NO_DOT = `(?!${DOT_LITERAL})`;
  var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
  var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
  var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
  var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
  var STAR = `${QMARK}*?`;
  var POSIX_CHARS = {
    DOT_LITERAL,
    PLUS_LITERAL,
    QMARK_LITERAL,
    SLASH_LITERAL,
    ONE_CHAR,
    QMARK,
    END_ANCHOR,
    DOTS_SLASH,
    NO_DOT,
    NO_DOTS,
    NO_DOT_SLASH,
    NO_DOTS_SLASH,
    QMARK_NO_DOT,
    STAR,
    START_ANCHOR
  };
  var WINDOWS_CHARS = __objSpread(__objSpread({}, POSIX_CHARS), {
    SLASH_LITERAL: `[${WIN_SLASH}]`,
    QMARK: WIN_NO_SLASH,
    STAR: `${WIN_NO_SLASH}*?`,
    DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
    NO_DOT: `(?!${DOT_LITERAL})`,
    NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
    NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
    QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
    START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
    END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
  });
  var POSIX_REGEX_SOURCE = {
    alnum: "a-zA-Z0-9",
    alpha: "a-zA-Z",
    ascii: "\\x00-\\x7F",
    blank: " \\t",
    cntrl: "\\x00-\\x1F\\x7F",
    digit: "0-9",
    graph: "\\x21-\\x7E",
    lower: "a-z",
    print: "\\x20-\\x7E ",
    punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
    space: " \\t\\r\\n\\v\\f",
    upper: "A-Z",
    word: "A-Za-z0-9_",
    xdigit: "A-Fa-f0-9"
  };
  module2.exports = {
    MAX_LENGTH: 1024 * 64,
    POSIX_REGEX_SOURCE,
    REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
    REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
    REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
    REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
    REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
    REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
    REPLACEMENTS: {
      "***": "*",
      "**/**": "**",
      "**/**/**": "**"
    },
    CHAR_0: 48,
    CHAR_9: 57,
    CHAR_UPPERCASE_A: 65,
    CHAR_LOWERCASE_A: 97,
    CHAR_UPPERCASE_Z: 90,
    CHAR_LOWERCASE_Z: 122,
    CHAR_LEFT_PARENTHESES: 40,
    CHAR_RIGHT_PARENTHESES: 41,
    CHAR_ASTERISK: 42,
    CHAR_AMPERSAND: 38,
    CHAR_AT: 64,
    CHAR_BACKWARD_SLASH: 92,
    CHAR_CARRIAGE_RETURN: 13,
    CHAR_CIRCUMFLEX_ACCENT: 94,
    CHAR_COLON: 58,
    CHAR_COMMA: 44,
    CHAR_DOT: 46,
    CHAR_DOUBLE_QUOTE: 34,
    CHAR_EQUAL: 61,
    CHAR_EXCLAMATION_MARK: 33,
    CHAR_FORM_FEED: 12,
    CHAR_FORWARD_SLASH: 47,
    CHAR_GRAVE_ACCENT: 96,
    CHAR_HASH: 35,
    CHAR_HYPHEN_MINUS: 45,
    CHAR_LEFT_ANGLE_BRACKET: 60,
    CHAR_LEFT_CURLY_BRACE: 123,
    CHAR_LEFT_SQUARE_BRACKET: 91,
    CHAR_LINE_FEED: 10,
    CHAR_NO_BREAK_SPACE: 160,
    CHAR_PERCENT: 37,
    CHAR_PLUS: 43,
    CHAR_QUESTION_MARK: 63,
    CHAR_RIGHT_ANGLE_BRACKET: 62,
    CHAR_RIGHT_CURLY_BRACE: 125,
    CHAR_RIGHT_SQUARE_BRACKET: 93,
    CHAR_SEMICOLON: 59,
    CHAR_SINGLE_QUOTE: 39,
    CHAR_SPACE: 32,
    CHAR_TAB: 9,
    CHAR_UNDERSCORE: 95,
    CHAR_VERTICAL_LINE: 124,
    CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
    SEP: path3.sep,
    extglobChars(chars) {
      return {
        "!": {type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})`},
        "?": {type: "qmark", open: "(?:", close: ")?"},
        "+": {type: "plus", open: "(?:", close: ")+"},
        "*": {type: "star", open: "(?:", close: ")*"},
        "@": {type: "at", open: "(?:", close: ")"}
      };
    },
    globChars(win32) {
      return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
    }
  };
});

// node_modules/picomatch/lib/utils.js
var require_utils5 = __commonJS((exports2) => {
  "use strict";
  var path3 = require("path");
  var win32 = process.platform === "win32";
  var {
    REGEX_BACKSLASH,
    REGEX_REMOVE_BACKSLASH,
    REGEX_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_GLOBAL
  } = require_constants2();
  exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
  exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
  exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
  exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
  exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
  exports2.removeBackslashes = (str) => {
    return str.replace(REGEX_REMOVE_BACKSLASH, (match) => {
      return match === "\\" ? "" : match;
    });
  };
  exports2.supportsLookbehinds = () => {
    const segs = process.version.slice(1).split(".").map(Number);
    if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
      return true;
    }
    return false;
  };
  exports2.isWindows = (options) => {
    if (options && typeof options.windows === "boolean") {
      return options.windows;
    }
    return win32 === true || path3.sep === "\\";
  };
  exports2.escapeLast = (input, char, lastIdx) => {
    const idx = input.lastIndexOf(char, lastIdx);
    if (idx === -1)
      return input;
    if (input[idx - 1] === "\\")
      return exports2.escapeLast(input, char, idx - 1);
    return input.slice(0, idx) + "\\" + input.slice(idx);
  };
  exports2.removePrefix = (input, state = {}) => {
    let output = input;
    if (output.startsWith("./")) {
      output = output.slice(2);
      state.prefix = "./";
    }
    return output;
  };
  exports2.wrapOutput = (input, state = {}, options = {}) => {
    const prepend = options.contains ? "" : "^";
    const append = options.contains ? "" : "$";
    let output = `${prepend}(?:${input})${append}`;
    if (state.negated === true) {
      output = `(?:^(?!${output}).*$)`;
    }
    return output;
  };
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils5();
  var {
    CHAR_ASTERISK,
    CHAR_AT,
    CHAR_BACKWARD_SLASH,
    CHAR_COMMA,
    CHAR_DOT,
    CHAR_EXCLAMATION_MARK,
    CHAR_FORWARD_SLASH,
    CHAR_LEFT_CURLY_BRACE,
    CHAR_LEFT_PARENTHESES,
    CHAR_LEFT_SQUARE_BRACKET,
    CHAR_PLUS,
    CHAR_QUESTION_MARK,
    CHAR_RIGHT_CURLY_BRACE,
    CHAR_RIGHT_PARENTHESES,
    CHAR_RIGHT_SQUARE_BRACKET
  } = require_constants2();
  var isPathSeparator = (code) => {
    return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
  };
  module2.exports = (input, options) => {
    const opts = options || {};
    const length = input.length - 1;
    let index = -1;
    let start = 0;
    let lastIndex = 0;
    let isGlob = false;
    let backslashes = false;
    let negated = false;
    let braces = 0;
    let prev;
    let code;
    let braceEscaped = false;
    const eos = () => index >= length;
    const advance = () => {
      prev = code;
      return input.charCodeAt(++index);
    };
    while (index < length) {
      code = advance();
      let next;
      if (code === CHAR_BACKWARD_SLASH) {
        backslashes = true;
        next = advance();
        if (next === CHAR_LEFT_CURLY_BRACE) {
          braceEscaped = true;
        }
        continue;
      }
      if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
        braces++;
        while (!eos() && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            next = advance();
            continue;
          }
          if (next === CHAR_LEFT_CURLY_BRACE) {
            braces++;
            continue;
          }
          if (!braceEscaped && next === CHAR_DOT && (next = advance()) === CHAR_DOT) {
            isGlob = true;
            break;
          }
          if (!braceEscaped && next === CHAR_COMMA) {
            isGlob = true;
            break;
          }
          if (next === CHAR_RIGHT_CURLY_BRACE) {
            braces--;
            if (braces === 0) {
              braceEscaped = false;
              break;
            }
          }
        }
      }
      if (code === CHAR_FORWARD_SLASH) {
        if (prev === CHAR_DOT && index === start + 1) {
          start += 2;
          continue;
        }
        lastIndex = index + 1;
        continue;
      }
      if (code === CHAR_ASTERISK) {
        isGlob = true;
        break;
      }
      if (code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK) {
        isGlob = true;
        break;
      }
      if (code === CHAR_LEFT_SQUARE_BRACKET) {
        while (!eos() && (next = advance())) {
          if (next === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            next = advance();
            continue;
          }
          if (next === CHAR_RIGHT_SQUARE_BRACKET) {
            isGlob = true;
            break;
          }
        }
      }
      const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_EXCLAMATION_MARK;
      if (isExtglobChar && input.charCodeAt(index + 1) === CHAR_LEFT_PARENTHESES) {
        isGlob = true;
        break;
      }
      if (!opts.nonegate && code === CHAR_EXCLAMATION_MARK && index === start) {
        negated = true;
        start++;
        continue;
      }
      if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
        while (!eos() && (code = advance())) {
          if (code === CHAR_BACKWARD_SLASH) {
            backslashes = true;
            code = advance();
            continue;
          }
          if (code === CHAR_RIGHT_PARENTHESES) {
            isGlob = true;
            break;
          }
        }
      }
      if (isGlob) {
        break;
      }
    }
    if (opts.noext === true) {
      isGlob = false;
    }
    let prefix = "";
    const orig = input;
    let base = input;
    let glob = "";
    if (start > 0) {
      prefix = input.slice(0, start);
      input = input.slice(start);
      lastIndex -= start;
    }
    if (base && isGlob === true && lastIndex > 0) {
      base = input.slice(0, lastIndex);
      glob = input.slice(lastIndex);
    } else if (isGlob === true) {
      base = "";
      glob = input;
    } else {
      base = input;
    }
    if (base && base !== "" && base !== "/" && base !== input) {
      if (isPathSeparator(base.charCodeAt(base.length - 1))) {
        base = base.slice(0, -1);
      }
    }
    if (opts.unescape === true) {
      if (glob)
        glob = utils.removeBackslashes(glob);
      if (base && backslashes === true) {
        base = utils.removeBackslashes(base);
      }
    }
    return {prefix, input: orig, base, glob, negated, isGlob};
  };
});

// node_modules/picomatch/lib/parse.js
var require_parse2 = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants2();
  var utils = require_utils5();
  var {
    MAX_LENGTH,
    POSIX_REGEX_SOURCE,
    REGEX_NON_SPECIAL_CHARS,
    REGEX_SPECIAL_CHARS_BACKREF,
    REPLACEMENTS
  } = constants;
  var expandRange = (args, options) => {
    if (typeof options.expandRange === "function") {
      return options.expandRange(...args, options);
    }
    args.sort();
    const value = `[${args.join("-")}]`;
    try {
      new RegExp(value);
    } catch (ex) {
      return args.map((v) => utils.escapeRegex(v)).join("..");
    }
    return value;
  };
  var syntaxError = (type, char) => {
    return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
  };
  var parse = (input, options) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected a string");
    }
    input = REPLACEMENTS[input] || input;
    const opts = __objSpread({}, options);
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    let len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    const bos = {type: "bos", value: "", output: opts.prepend || ""};
    const tokens = [bos];
    const capture = opts.capture ? "" : "?:";
    const win32 = utils.isWindows(options);
    const PLATFORM_CHARS = constants.globChars(win32);
    const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
    const {
      DOT_LITERAL,
      PLUS_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    } = PLATFORM_CHARS;
    const globstar = (opts2) => {
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const nodot = opts.dot ? "" : NO_DOT;
    const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
    let star = opts.bash === true ? globstar(opts) : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    if (typeof opts.noext === "boolean") {
      opts.noextglob = opts.noext;
    }
    const state = {
      input,
      index: -1,
      start: 0,
      dot: opts.dot === true,
      consumed: "",
      output: "",
      prefix: "",
      backtrack: false,
      negated: false,
      brackets: 0,
      braces: 0,
      parens: 0,
      quotes: 0,
      tokens
    };
    input = utils.removePrefix(input, state);
    len = input.length;
    const extglobs = [];
    const stack = [];
    let prev = bos;
    let value;
    const eos = () => state.index === len - 1;
    const peek = state.peek = (n = 1) => input[state.index + n];
    const advance = state.advance = () => input[++state.index];
    const remaining = () => input.slice(state.index + 1);
    const consume = (value2 = "", num = 0) => {
      state.consumed += value2;
      state.index += num;
    };
    const append = (token) => {
      state.output += token.output != null ? token.output : token.value;
      consume(token.value);
    };
    const negate = () => {
      let count = 1;
      while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
        advance();
        state.start++;
        count++;
      }
      if (count % 2 === 0) {
        return false;
      }
      state.negated = true;
      state.start++;
      return true;
    };
    const increment = (type) => {
      state[type]++;
      stack.push(type);
    };
    const decrement = (type) => {
      state[type]--;
      stack.pop();
    };
    const push = (tok) => {
      if (prev.type === "globstar") {
        const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
        const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
        if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "star";
          prev.value = "*";
          prev.output = star;
          state.output += prev.output;
        }
      }
      if (extglobs.length && tok.type !== "paren" && !EXTGLOB_CHARS[tok.value]) {
        extglobs[extglobs.length - 1].inner += tok.value;
      }
      if (tok.value || tok.output)
        append(tok);
      if (prev && prev.type === "text" && tok.type === "text") {
        prev.value += tok.value;
        return;
      }
      tok.prev = prev;
      tokens.push(tok);
      prev = tok;
    };
    const extglobOpen = (type, value2) => {
      const token = __objSpread(__objSpread({}, EXTGLOB_CHARS[value2]), {conditions: 1, inner: ""});
      token.prev = prev;
      token.parens = state.parens;
      token.output = state.output;
      const output = (opts.capture ? "(" : "") + token.open;
      increment("parens");
      push({type, value: value2, output: state.output ? "" : ONE_CHAR});
      push({type: "paren", extglob: true, value: advance(), output});
      extglobs.push(token);
    };
    const extglobClose = (token) => {
      let output = token.close + (opts.capture ? ")" : "");
      if (token.type === "negate") {
        let extglobStar = star;
        if (token.inner && token.inner.length > 1 && token.inner.includes("/")) {
          extglobStar = globstar(opts);
        }
        if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
          output = token.close = ")$))" + extglobStar;
        }
        if (token.prev.type === "bos" && eos()) {
          state.negatedExtglob = true;
        }
      }
      push({type: "paren", extglob: true, value, output});
      decrement("parens");
    };
    if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
      let backslashes = false;
      let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m, esc, chars, first, rest, index) => {
        if (first === "\\") {
          backslashes = true;
          return m;
        }
        if (first === "?") {
          if (esc) {
            return esc + first + (rest ? QMARK.repeat(rest.length) : "");
          }
          if (index === 0) {
            return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
          }
          return QMARK.repeat(chars.length);
        }
        if (first === ".") {
          return DOT_LITERAL.repeat(chars.length);
        }
        if (first === "*") {
          if (esc) {
            return esc + first + (rest ? star : "");
          }
          return star;
        }
        return esc ? m : "\\" + m;
      });
      if (backslashes === true) {
        if (opts.unescape === true) {
          output = output.replace(/\\/g, "");
        } else {
          output = output.replace(/\\+/g, (m) => {
            return m.length % 2 === 0 ? "\\\\" : m ? "\\" : "";
          });
        }
      }
      if (output === input && opts.contains === true) {
        state.output = input;
        return state;
      }
      state.output = utils.wrapOutput(output, state, options);
      return state;
    }
    while (!eos()) {
      value = advance();
      if (value === "\0") {
        continue;
      }
      if (value === "\\") {
        const next = peek();
        if (next === "/" && opts.bash !== true) {
          continue;
        }
        if (next === "." || next === ";") {
          continue;
        }
        if (!next) {
          value += "\\";
          push({type: "text", value});
          continue;
        }
        const match = /^\\+/.exec(remaining());
        let slashes = 0;
        if (match && match[0].length > 2) {
          slashes = match[0].length;
          state.index += slashes;
          if (slashes % 2 !== 0) {
            value += "\\";
          }
        }
        if (opts.unescape === true) {
          value = advance() || "";
        } else {
          value += advance() || "";
        }
        if (state.brackets === 0) {
          push({type: "text", value});
          continue;
        }
      }
      if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
        if (opts.posix !== false && value === ":") {
          const inner = prev.value.slice(1);
          if (inner.includes("[")) {
            prev.posix = true;
            if (inner.includes(":")) {
              const idx = prev.value.lastIndexOf("[");
              const pre = prev.value.slice(0, idx);
              const rest2 = prev.value.slice(idx + 2);
              const posix = POSIX_REGEX_SOURCE[rest2];
              if (posix) {
                prev.value = pre + posix;
                state.backtrack = true;
                advance();
                if (!bos.output && tokens.indexOf(prev) === 1) {
                  bos.output = ONE_CHAR;
                }
                continue;
              }
            }
          }
        }
        if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
          value = "\\" + value;
        }
        if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
          value = "\\" + value;
        }
        if (opts.posix === true && value === "!" && prev.value === "[") {
          value = "^";
        }
        prev.value += value;
        append({value});
        continue;
      }
      if (state.quotes === 1 && value !== '"') {
        value = utils.escapeRegex(value);
        prev.value += value;
        append({value});
        continue;
      }
      if (value === '"') {
        state.quotes = state.quotes === 1 ? 0 : 1;
        if (opts.keepQuotes === true) {
          push({type: "text", value});
        }
        continue;
      }
      if (value === "(") {
        increment("parens");
        push({type: "paren", value});
        continue;
      }
      if (value === ")") {
        if (state.parens === 0 && opts.strictBrackets === true) {
          throw new SyntaxError(syntaxError("opening", "("));
        }
        const extglob = extglobs[extglobs.length - 1];
        if (extglob && state.parens === extglob.parens + 1) {
          extglobClose(extglobs.pop());
          continue;
        }
        push({type: "paren", value, output: state.parens ? ")" : "\\)"});
        decrement("parens");
        continue;
      }
      if (value === "[") {
        if (opts.nobracket === true || !remaining().includes("]")) {
          if (opts.nobracket !== true && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("closing", "]"));
          }
          value = "\\" + value;
        } else {
          increment("brackets");
        }
        push({type: "bracket", value});
        continue;
      }
      if (value === "]") {
        if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
          push({type: "text", value, output: "\\" + value});
          continue;
        }
        if (state.brackets === 0) {
          if (opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "["));
          }
          push({type: "text", value, output: "\\" + value});
          continue;
        }
        decrement("brackets");
        const prevValue = prev.value.slice(1);
        if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
          value = "/" + value;
        }
        prev.value += value;
        append({value});
        if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
          continue;
        }
        const escaped = utils.escapeRegex(prev.value);
        state.output = state.output.slice(0, -prev.value.length);
        if (opts.literalBrackets === true) {
          state.output += escaped;
          prev.value = escaped;
          continue;
        }
        prev.value = `(${capture}${escaped}|${prev.value})`;
        state.output += prev.value;
        continue;
      }
      if (value === "{" && opts.nobrace !== true) {
        increment("braces");
        push({type: "brace", value, output: "("});
        continue;
      }
      if (value === "}") {
        if (opts.nobrace === true || state.braces === 0) {
          push({type: "text", value, output: value});
          continue;
        }
        let output = ")";
        if (state.dots === true) {
          const arr = tokens.slice();
          const range = [];
          for (let i = arr.length - 1; i >= 0; i--) {
            tokens.pop();
            if (arr[i].type === "brace") {
              break;
            }
            if (arr[i].type !== "dots") {
              range.unshift(arr[i].value);
            }
          }
          output = expandRange(range, opts);
          state.backtrack = true;
        }
        push({type: "brace", value, output});
        decrement("braces");
        continue;
      }
      if (value === "|") {
        if (extglobs.length > 0) {
          extglobs[extglobs.length - 1].conditions++;
        }
        push({type: "text", value});
        continue;
      }
      if (value === ",") {
        let output = value;
        if (state.braces > 0 && stack[stack.length - 1] === "braces") {
          output = "|";
        }
        push({type: "comma", value, output});
        continue;
      }
      if (value === "/") {
        if (prev.type === "dot" && state.index === state.start + 1) {
          state.start = state.index + 1;
          state.consumed = "";
          state.output = "";
          tokens.pop();
          prev = bos;
          continue;
        }
        push({type: "slash", value, output: SLASH_LITERAL});
        continue;
      }
      if (value === ".") {
        if (state.braces > 0 && prev.type === "dot") {
          if (prev.value === ".")
            prev.output = DOT_LITERAL;
          prev.type = "dots";
          prev.output += value;
          prev.value += value;
          state.dots = true;
          continue;
        }
        if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
          push({type: "text", value, output: DOT_LITERAL});
          continue;
        }
        push({type: "dot", value, output: DOT_LITERAL});
        continue;
      }
      if (value === "?") {
        const isGroup = prev && prev.value === "(";
        if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("qmark", value);
          continue;
        }
        if (prev && prev.type === "paren") {
          const next = peek();
          let output = value;
          if (next === "<" && !utils.supportsLookbehinds()) {
            throw new Error("Node.js v10 or higher is required for regex lookbehinds");
          }
          if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
            output = "\\" + value;
          }
          push({type: "text", value, output});
          continue;
        }
        if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
          push({type: "qmark", value, output: QMARK_NO_DOT});
          continue;
        }
        push({type: "qmark", value, output: QMARK});
        continue;
      }
      if (value === "!") {
        if (opts.noextglob !== true && peek() === "(") {
          if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
            extglobOpen("negate", value);
            continue;
          }
        }
        if (opts.nonegate !== true && state.index === 0) {
          negate(state);
          continue;
        }
      }
      if (value === "+") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          extglobOpen("plus", value);
          continue;
        }
        if (prev && prev.value === "(" || opts.regex === false) {
          push({type: "plus", value, output: PLUS_LITERAL});
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
          push({type: "plus", value});
          continue;
        }
        push({type: "plus", value: PLUS_LITERAL});
        continue;
      }
      if (value === "@") {
        if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
          push({type: "at", extglob: true, value, output: ""});
          continue;
        }
        push({type: "text", value});
        continue;
      }
      if (value !== "*") {
        if (value === "$" || value === "^") {
          value = "\\" + value;
        }
        const match = REGEX_NON_SPECIAL_CHARS.exec(remaining());
        if (match) {
          value += match[0];
          state.index += match[0].length;
        }
        push({type: "text", value});
        continue;
      }
      if (prev && (prev.type === "globstar" || prev.star === true)) {
        prev.type = "star";
        prev.star = true;
        prev.value += value;
        prev.output = star;
        state.backtrack = true;
        consume(value);
        continue;
      }
      let rest = remaining();
      if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
        extglobOpen("star", value);
        continue;
      }
      if (prev.type === "star") {
        if (opts.noglobstar === true) {
          consume(value);
          continue;
        }
        const prior = prev.prev;
        const before = prior.prev;
        const isStart = prior.type === "slash" || prior.type === "bos";
        const afterStar = before && (before.type === "star" || before.type === "globstar");
        if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
          push({type: "star", value, output: ""});
          continue;
        }
        const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
        const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
        if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
          push({type: "star", value, output: ""});
          continue;
        }
        while (rest.slice(0, 3) === "/**") {
          const after = input[state.index + 4];
          if (after && after !== "/") {
            break;
          }
          rest = rest.slice(3);
          consume("/**", 3);
        }
        if (prior.type === "bos" && eos()) {
          prev.type = "globstar";
          prev.value += value;
          prev.output = globstar(opts);
          state.output = prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:" + prior.output;
          prev.type = "globstar";
          prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
          prev.value += value;
          state.output += prior.output + prev.output;
          consume(value);
          continue;
        }
        if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
          const end = rest[1] !== void 0 ? "|$" : "";
          state.output = state.output.slice(0, -(prior.output + prev.output).length);
          prior.output = "(?:" + prior.output;
          prev.type = "globstar";
          prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end})`;
          prev.value += value;
          state.output += prior.output + prev.output;
          consume(value + advance());
          push({type: "slash", value, output: ""});
          continue;
        }
        if (prior.type === "bos" && rest[0] === "/") {
          prev.type = "globstar";
          prev.value += value;
          prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
          state.output = prev.output;
          consume(value + advance());
          push({type: "slash", value, output: ""});
          continue;
        }
        state.output = state.output.slice(0, -prev.output.length);
        prev.type = "globstar";
        prev.output = globstar(opts);
        prev.value += value;
        state.output += prev.output;
        consume(value);
        continue;
      }
      const token = {type: "star", value, output: star};
      if (opts.bash === true) {
        token.output = ".*?";
        if (prev.type === "bos" || prev.type === "slash") {
          token.output = nodot + token.output;
        }
        push(token);
        continue;
      }
      if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
        token.output = value;
        push(token);
        continue;
      }
      if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
        if (prev.type === "dot") {
          state.output += NO_DOT_SLASH;
          prev.output += NO_DOT_SLASH;
        } else if (opts.dot === true) {
          state.output += NO_DOTS_SLASH;
          prev.output += NO_DOTS_SLASH;
        } else {
          state.output += nodot;
          prev.output += nodot;
        }
        if (peek() !== "*") {
          state.output += ONE_CHAR;
          prev.output += ONE_CHAR;
        }
      }
      push(token);
    }
    while (state.brackets > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "]"));
      state.output = utils.escapeLast(state.output, "[");
      decrement("brackets");
    }
    while (state.parens > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", ")"));
      state.output = utils.escapeLast(state.output, "(");
      decrement("parens");
    }
    while (state.braces > 0) {
      if (opts.strictBrackets === true)
        throw new SyntaxError(syntaxError("closing", "}"));
      state.output = utils.escapeLast(state.output, "{");
      decrement("braces");
    }
    if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
      push({type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?`});
    }
    if (state.backtrack === true) {
      state.output = "";
      for (const token of state.tokens) {
        state.output += token.output != null ? token.output : token.value;
        if (token.suffix) {
          state.output += token.suffix;
        }
      }
    }
    return state;
  };
  parse.fastpaths = (input, options) => {
    const opts = __objSpread({}, options);
    const max = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
    const len = input.length;
    if (len > max) {
      throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max}`);
    }
    input = REPLACEMENTS[input] || input;
    const win32 = utils.isWindows(options);
    const {
      DOT_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOTS_SLASH,
      STAR,
      START_ANCHOR
    } = constants.globChars(win32);
    const nodot = opts.dot ? NO_DOTS : NO_DOT;
    const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
    const capture = opts.capture ? "" : "?:";
    const state = {negated: false, prefix: ""};
    let star = opts.bash === true ? ".*?" : STAR;
    if (opts.capture) {
      star = `(${star})`;
    }
    const globstar = (opts2) => {
      if (opts2.noglobstar === true)
        return star;
      return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
    };
    const create = (str) => {
      switch (str) {
        case "*":
          return `${nodot}${ONE_CHAR}${star}`;
        case ".*":
          return `${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*.*":
          return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "*/*":
          return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
        case "**":
          return nodot + globstar(opts);
        case "**/*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
        case "**/*.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
        case "**/.*":
          return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
        default: {
          const match = /^(.*?)\.(\w+)$/.exec(str);
          if (!match)
            return;
          const source2 = create(match[1], options);
          if (!source2)
            return;
          return source2 + DOT_LITERAL + match[2];
        }
      }
    };
    const output = utils.removePrefix(input, state);
    let source = create(output);
    if (source && opts.strictSlashes !== true) {
      source += `${SLASH_LITERAL}?`;
    }
    return source;
  };
  module2.exports = parse;
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var scan = require_scan();
  var parse = require_parse2();
  var utils = require_utils5();
  var constants = require_constants2();
  var picomatch = (glob, options, returnState = false) => {
    if (Array.isArray(glob)) {
      const fns = glob.map((input) => picomatch(input, options, returnState));
      return (str) => {
        for (const isMatch of fns) {
          const state2 = isMatch(str);
          if (state2)
            return state2;
        }
        return false;
      };
    }
    if (typeof glob !== "string" || glob === "") {
      throw new TypeError("Expected pattern to be a non-empty string");
    }
    const opts = options || {};
    const posix = utils.isWindows(options);
    const regex = picomatch.makeRe(glob, options, false, true);
    const state = regex.state;
    delete regex.state;
    let isIgnored = () => false;
    if (opts.ignore) {
      const ignoreOpts = __objSpread(__objSpread({}, options), {ignore: null, onMatch: null, onResult: null});
      isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
    }
    const matcher = (input, returnObject = false) => {
      const {isMatch, match, output} = picomatch.test(input, regex, options, {glob, posix});
      const result = {glob, state, regex, posix, input, output, match, isMatch};
      if (typeof opts.onResult === "function") {
        opts.onResult(result);
      }
      if (isMatch === false) {
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (isIgnored(input)) {
        if (typeof opts.onIgnore === "function") {
          opts.onIgnore(result);
        }
        result.isMatch = false;
        return returnObject ? result : false;
      }
      if (typeof opts.onMatch === "function") {
        opts.onMatch(result);
      }
      return returnObject ? result : true;
    };
    if (returnState) {
      matcher.state = state;
    }
    return matcher;
  };
  picomatch.test = (input, regex, options, {glob, posix} = {}) => {
    if (typeof input !== "string") {
      throw new TypeError("Expected input to be a string");
    }
    if (input === "") {
      return {isMatch: false, output: ""};
    }
    const opts = options || {};
    const format = opts.format || (posix ? utils.toPosixSlashes : null);
    let match = input === glob;
    let output = match && format ? format(input) : input;
    if (match === false) {
      output = format ? format(input) : input;
      match = output === glob;
    }
    if (match === false || opts.capture === true) {
      if (opts.matchBase === true || opts.basename === true) {
        match = picomatch.matchBase(input, regex, options, posix);
      } else {
        match = regex.exec(output);
      }
    }
    return {isMatch: !!match, match, output};
  };
  picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
    const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
    return regex.test(path3.basename(input));
  };
  picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  picomatch.parse = (glob, options) => parse(glob, options);
  picomatch.scan = (input, options) => scan(input, options);
  picomatch.makeRe = (input, options, returnOutput = false, returnState = false) => {
    if (!input || typeof input !== "string") {
      throw new TypeError("Expected a non-empty string");
    }
    const opts = options || {};
    const prepend = opts.contains ? "" : "^";
    const append = opts.contains ? "" : "$";
    let state = {negated: false, fastpaths: true};
    let prefix = "";
    let output;
    if (input.startsWith("./")) {
      input = input.slice(2);
      prefix = state.prefix = "./";
    }
    if (opts.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
      output = parse.fastpaths(input, options);
    }
    if (output === void 0) {
      state = picomatch.parse(input, options);
      state.prefix = prefix + (state.prefix || "");
      output = state.output;
    }
    if (returnOutput === true) {
      return output;
    }
    let source = `${prepend}(?:${output})${append}`;
    if (state && state.negated === true) {
      source = `^(?!${source}).*$`;
    }
    const regex = picomatch.toRegex(source, options);
    if (returnState === true) {
      regex.state = state;
    }
    return regex;
  };
  picomatch.toRegex = (source, options) => {
    try {
      const opts = options || {};
      return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
    } catch (err) {
      if (options && options.debug === true)
        throw err;
      return /$^/;
    }
  };
  picomatch.constants = constants;
  module2.exports = picomatch;
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_picomatch();
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var braces = require_braces();
  var picomatch = require_picomatch2();
  var utils = require_utils5();
  var isEmptyString = (val) => typeof val === "string" && (val === "" || val === "./");
  var micromatch2 = (list, patterns, options) => {
    patterns = [].concat(patterns);
    list = [].concat(list);
    let omit = new Set();
    let keep = new Set();
    let items = new Set();
    let negatives = 0;
    let onResult = (state) => {
      items.add(state.output);
      if (options && options.onResult) {
        options.onResult(state);
      }
    };
    for (let i = 0; i < patterns.length; i++) {
      let isMatch = picomatch(String(patterns[i]), __objSpread(__objSpread({}, options), {onResult}), true);
      let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
      if (negated)
        negatives++;
      for (let item of list) {
        let matched = isMatch(item, true);
        let match = negated ? !matched.isMatch : matched.isMatch;
        if (!match)
          continue;
        if (negated) {
          omit.add(matched.output);
        } else {
          omit.delete(matched.output);
          keep.add(matched.output);
        }
      }
    }
    let result = negatives === patterns.length ? [...items] : [...keep];
    let matches = result.filter((item) => !omit.has(item));
    if (options && matches.length === 0) {
      if (options.failglob === true) {
        throw new Error(`No matches found for "${patterns.join(", ")}"`);
      }
      if (options.nonull === true || options.nullglob === true) {
        return options.unescape ? patterns.map((p) => p.replace(/\\/g, "")) : patterns;
      }
    }
    return matches;
  };
  micromatch2.match = micromatch2;
  micromatch2.matcher = (pattern, options) => picomatch(pattern, options);
  micromatch2.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
  micromatch2.any = micromatch2.isMatch;
  micromatch2.not = (list, patterns, options = {}) => {
    patterns = [].concat(patterns).map(String);
    let result = new Set();
    let items = [];
    let onResult = (state) => {
      if (options.onResult)
        options.onResult(state);
      items.push(state.output);
    };
    let matches = micromatch2(list, patterns, __objSpread(__objSpread({}, options), {onResult}));
    for (let item of items) {
      if (!matches.includes(item)) {
        result.add(item);
      }
    }
    return [...result];
  };
  micromatch2.contains = (str, pattern, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    if (Array.isArray(pattern)) {
      return pattern.some((p) => micromatch2.contains(str, p, options));
    }
    if (typeof pattern === "string") {
      if (isEmptyString(str) || isEmptyString(pattern)) {
        return false;
      }
      if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
        return true;
      }
    }
    return micromatch2.isMatch(str, pattern, __objSpread(__objSpread({}, options), {contains: true}));
  };
  micromatch2.matchKeys = (obj, patterns, options) => {
    if (!utils.isObject(obj)) {
      throw new TypeError("Expected the first argument to be an object");
    }
    let keys = micromatch2(Object.keys(obj), patterns, options);
    let res = {};
    for (let key of keys)
      res[key] = obj[key];
    return res;
  };
  micromatch2.some = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (items.some((item) => isMatch(item))) {
        return true;
      }
    }
    return false;
  };
  micromatch2.every = (list, patterns, options) => {
    let items = [].concat(list);
    for (let pattern of [].concat(patterns)) {
      let isMatch = picomatch(String(pattern), options);
      if (!items.every((item) => isMatch(item))) {
        return false;
      }
    }
    return true;
  };
  micromatch2.all = (str, patterns, options) => {
    if (typeof str !== "string") {
      throw new TypeError(`Expected a string: "${util.inspect(str)}"`);
    }
    return [].concat(patterns).every((p) => picomatch(p, options)(str));
  };
  micromatch2.capture = (glob, input, options) => {
    let posix = utils.isWindows(options);
    let regex = picomatch.makeRe(String(glob), __objSpread(__objSpread({}, options), {capture: true}));
    let match = regex.exec(posix ? utils.toPosixSlashes(input) : input);
    if (match) {
      return match.slice(1).map((v) => v === void 0 ? "" : v);
    }
  };
  micromatch2.makeRe = (...args) => picomatch.makeRe(...args);
  micromatch2.scan = (...args) => picomatch.scan(...args);
  micromatch2.parse = (patterns, options) => {
    let res = [];
    for (let pattern of [].concat(patterns || [])) {
      for (let str of braces(String(pattern), options)) {
        res.push(picomatch.parse(str, options));
      }
    }
    return res;
  };
  micromatch2.braces = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
      return [pattern];
    }
    return braces(pattern, options);
  };
  micromatch2.braceExpand = (pattern, options) => {
    if (typeof pattern !== "string")
      throw new TypeError("Expected a string");
    return micromatch2.braces(pattern, __objSpread(__objSpread({}, options), {expand: true}));
  };
  module2.exports = micromatch2;
});

// node_modules/eslint/conf/default-cli-options.js
var require_default_cli_options = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    configFile: null,
    baseConfig: false,
    rulePaths: [],
    useEslintrc: true,
    envs: [],
    globals: [],
    extensions: null,
    ignore: true,
    ignorePath: void 0,
    cache: false,
    cacheLocation: "",
    cacheFile: ".eslintcache",
    cacheStrategy: "metadata",
    fix: false,
    allowInlineConfig: true,
    reportUnusedDisableDirectives: void 0,
    globInputPaths: true
  };
});

// node_modules/eslint/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "eslint",
    version: "7.23.0",
    author: "Nicholas C. Zakas <nicholas+npm@nczconsulting.com>",
    description: "An AST-based pattern checker for JavaScript.",
    bin: {
      eslint: "./bin/eslint.js"
    },
    main: "./lib/api.js",
    scripts: {
      test: "node Makefile.js test",
      "test:cli": "mocha",
      lint: "node Makefile.js lint",
      fix: "node Makefile.js lint -- fix",
      fuzz: "node Makefile.js fuzz",
      "generate-release": "node Makefile.js generateRelease",
      "generate-alpharelease": "node Makefile.js generatePrerelease -- alpha",
      "generate-betarelease": "node Makefile.js generatePrerelease -- beta",
      "generate-rcrelease": "node Makefile.js generatePrerelease -- rc",
      "publish-release": "node Makefile.js publishRelease",
      docs: "node Makefile.js docs",
      gensite: "node Makefile.js gensite",
      webpack: "node Makefile.js webpack",
      perf: "node Makefile.js perf"
    },
    gitHooks: {
      "pre-commit": "lint-staged"
    },
    "lint-staged": {
      "*.js": [
        "eslint --fix",
        "git add"
      ],
      "*.md": "markdownlint"
    },
    files: [
      "LICENSE",
      "README.md",
      "bin",
      "conf",
      "lib",
      "messages"
    ],
    repository: "eslint/eslint",
    funding: "https://opencollective.com/eslint",
    homepage: "https://eslint.org",
    bugs: "https://github.com/eslint/eslint/issues/",
    dependencies: {
      "@babel/code-frame": "7.12.11",
      "@eslint/eslintrc": "^0.4.0",
      ajv: "^6.10.0",
      chalk: "^4.0.0",
      "cross-spawn": "^7.0.2",
      debug: "^4.0.1",
      doctrine: "^3.0.0",
      enquirer: "^2.3.5",
      "eslint-scope": "^5.1.1",
      "eslint-utils": "^2.1.0",
      "eslint-visitor-keys": "^2.0.0",
      espree: "^7.3.1",
      esquery: "^1.4.0",
      esutils: "^2.0.2",
      "file-entry-cache": "^6.0.1",
      "functional-red-black-tree": "^1.0.1",
      "glob-parent": "^5.0.0",
      globals: "^13.6.0",
      ignore: "^4.0.6",
      "import-fresh": "^3.0.0",
      imurmurhash: "^0.1.4",
      "is-glob": "^4.0.0",
      "js-yaml": "^3.13.1",
      "json-stable-stringify-without-jsonify": "^1.0.1",
      levn: "^0.4.1",
      lodash: "^4.17.21",
      minimatch: "^3.0.4",
      "natural-compare": "^1.4.0",
      optionator: "^0.9.1",
      progress: "^2.0.0",
      regexpp: "^3.1.0",
      semver: "^7.2.1",
      "strip-ansi": "^6.0.0",
      "strip-json-comments": "^3.1.0",
      table: "^6.0.4",
      "text-table": "^0.2.0",
      "v8-compile-cache": "^2.0.3"
    },
    devDependencies: {
      "@babel/core": "^7.4.3",
      "@babel/preset-env": "^7.4.3",
      acorn: "^7.2.0",
      "babel-loader": "^8.0.5",
      chai: "^4.0.1",
      cheerio: "^0.22.0",
      "common-tags": "^1.8.0",
      "core-js": "^3.1.3",
      dateformat: "^3.0.3",
      ejs: "^3.0.2",
      "escape-string-regexp": "^3.0.0",
      eslint: "file:.",
      "eslint-config-eslint": "file:packages/eslint-config-eslint",
      "eslint-plugin-eslint-plugin": "^2.2.1",
      "eslint-plugin-internal-rules": "file:tools/internal-rules",
      "eslint-plugin-jsdoc": "^25.4.3",
      "eslint-plugin-node": "^11.1.0",
      "eslint-release": "^2.0.0",
      eslump: "^2.0.0",
      esprima: "^4.0.1",
      "fs-teardown": "^0.1.0",
      glob: "^7.1.6",
      jsdoc: "^3.5.5",
      karma: "^6.1.1",
      "karma-chrome-launcher": "^3.1.0",
      "karma-mocha": "^2.0.1",
      "karma-mocha-reporter": "^2.2.5",
      "karma-webpack": "^5.0.0",
      "lint-staged": "^10.1.2",
      "load-perf": "^0.2.0",
      markdownlint: "^0.19.0",
      "markdownlint-cli": "^0.22.0",
      memfs: "^3.0.1",
      mocha: "^7.1.1",
      "mocha-junit-reporter": "^1.23.0",
      "node-polyfill-webpack-plugin": "^1.0.3",
      "npm-license": "^0.3.3",
      nyc: "^15.0.1",
      proxyquire: "^2.0.1",
      puppeteer: "^7.1.0",
      recast: "^0.19.0",
      "regenerator-runtime": "^0.13.2",
      shelljs: "^0.8.2",
      sinon: "^9.0.1",
      temp: "^0.9.0",
      webpack: "^5.23.0",
      "webpack-cli": "^4.5.0",
      yorkie: "^2.0.0"
    },
    keywords: [
      "ast",
      "lint",
      "javascript",
      "ecmascript",
      "espree"
    ],
    license: "MIT",
    engines: {
      node: "^10.12.0 || >=12.0.0"
    }
  };
});

// node_modules/resolve-from/index.js
var require_resolve_from = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var Module = require("module");
  var fs2 = require("fs");
  var resolveFrom = (fromDir, moduleId, silent) => {
    if (typeof fromDir !== "string") {
      throw new TypeError(`Expected \`fromDir\` to be of type \`string\`, got \`${typeof fromDir}\``);
    }
    if (typeof moduleId !== "string") {
      throw new TypeError(`Expected \`moduleId\` to be of type \`string\`, got \`${typeof moduleId}\``);
    }
    try {
      fromDir = fs2.realpathSync(fromDir);
    } catch (err) {
      if (err.code === "ENOENT") {
        fromDir = path3.resolve(fromDir);
      } else if (silent) {
        return null;
      } else {
        throw err;
      }
    }
    const fromFile = path3.join(fromDir, "noop.js");
    const resolveFileName = () => Module._resolveFilename(moduleId, {
      id: fromFile,
      filename: fromFile,
      paths: Module._nodeModulePaths(fromDir)
    });
    if (silent) {
      try {
        return resolveFileName();
      } catch (err) {
        return null;
      }
    }
    return resolveFileName();
  };
  module2.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId);
  module2.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true);
});

// node_modules/callsites/index.js
var require_callsites = __commonJS((exports2, module2) => {
  "use strict";
  var callsites = () => {
    const _prepareStackTrace = Error.prepareStackTrace;
    Error.prepareStackTrace = (_, stack2) => stack2;
    const stack = new Error().stack.slice(1);
    Error.prepareStackTrace = _prepareStackTrace;
    return stack;
  };
  module2.exports = callsites;
  module2.exports.default = callsites;
});

// node_modules/parent-module/index.js
var require_parent_module = __commonJS((exports2, module2) => {
  "use strict";
  var callsites = require_callsites();
  module2.exports = (filepath) => {
    const stacks = callsites();
    if (!filepath) {
      return stacks[2].getFileName();
    }
    let seenVal = false;
    stacks.shift();
    for (const stack of stacks) {
      const parentFilepath = stack.getFileName();
      if (typeof parentFilepath !== "string") {
        continue;
      }
      if (parentFilepath === filepath) {
        seenVal = true;
        continue;
      }
      if (parentFilepath === "module.js") {
        continue;
      }
      if (seenVal && parentFilepath !== filepath) {
        return parentFilepath;
      }
    }
  };
});

// node_modules/import-fresh/index.js
var require_import_fresh = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var resolveFrom = require_resolve_from();
  var parentModule = require_parent_module();
  module2.exports = (moduleId) => {
    if (typeof moduleId !== "string") {
      throw new TypeError("Expected a string");
    }
    const parentPath = parentModule(__filename);
    const cwd = parentPath ? path3.dirname(parentPath) : __dirname;
    const filePath = resolveFrom(cwd, moduleId);
    const oldModule = require.cache[filePath];
    if (oldModule && oldModule.parent) {
      let i = oldModule.parent.children.length;
      while (i--) {
        if (oldModule.parent.children[i].id === filePath) {
          oldModule.parent.children.splice(i, 1);
        }
      }
    }
    delete require.cache[filePath];
    const parent = require.cache[parentPath];
    return parent === void 0 ? require(filePath) : parent.require(filePath);
  };
});

// node_modules/strip-json-comments/index.js
var require_strip_json_comments = __commonJS((exports2, module2) => {
  "use strict";
  var singleComment = Symbol("singleComment");
  var multiComment = Symbol("multiComment");
  var stripWithoutWhitespace = () => "";
  var stripWithWhitespace = (string, start, end) => string.slice(start, end).replace(/\S/g, " ");
  var isEscaped = (jsonString, quotePosition) => {
    let index = quotePosition - 1;
    let backslashCount = 0;
    while (jsonString[index] === "\\") {
      index -= 1;
      backslashCount += 1;
    }
    return Boolean(backslashCount % 2);
  };
  module2.exports = (jsonString, options = {}) => {
    if (typeof jsonString !== "string") {
      throw new TypeError(`Expected argument \`jsonString\` to be a \`string\`, got \`${typeof jsonString}\``);
    }
    const strip = options.whitespace === false ? stripWithoutWhitespace : stripWithWhitespace;
    let insideString = false;
    let insideComment = false;
    let offset = 0;
    let result = "";
    for (let i = 0; i < jsonString.length; i++) {
      const currentCharacter = jsonString[i];
      const nextCharacter = jsonString[i + 1];
      if (!insideComment && currentCharacter === '"') {
        const escaped = isEscaped(jsonString, i);
        if (!escaped) {
          insideString = !insideString;
        }
      }
      if (insideString) {
        continue;
      }
      if (!insideComment && currentCharacter + nextCharacter === "//") {
        result += jsonString.slice(offset, i);
        offset = i;
        insideComment = singleComment;
        i++;
      } else if (insideComment === singleComment && currentCharacter + nextCharacter === "\r\n") {
        i++;
        insideComment = false;
        result += strip(jsonString, offset, i);
        offset = i;
        continue;
      } else if (insideComment === singleComment && currentCharacter === "\n") {
        insideComment = false;
        result += strip(jsonString, offset, i);
        offset = i;
      } else if (!insideComment && currentCharacter + nextCharacter === "/*") {
        result += jsonString.slice(offset, i);
        offset = i;
        insideComment = multiComment;
        i++;
        continue;
      } else if (insideComment === multiComment && currentCharacter + nextCharacter === "*/") {
        i++;
        insideComment = false;
        result += strip(jsonString, offset, i + 1);
        offset = i + 1;
        continue;
      }
    }
    return result + (insideComment ? strip(jsonString.slice(offset)) : jsonString.slice(offset));
  };
});

// node_modules/@eslint/eslintrc/conf/config-schema.js
var require_config_schema = __commonJS((exports2, module2) => {
  "use strict";
  var baseConfigProperties = {
    $schema: {type: "string"},
    env: {type: "object"},
    extends: {$ref: "#/definitions/stringOrStrings"},
    globals: {type: "object"},
    overrides: {
      type: "array",
      items: {$ref: "#/definitions/overrideConfig"},
      additionalItems: false
    },
    parser: {type: ["string", "null"]},
    parserOptions: {type: "object"},
    plugins: {type: "array"},
    processor: {type: "string"},
    rules: {type: "object"},
    settings: {type: "object"},
    noInlineConfig: {type: "boolean"},
    reportUnusedDisableDirectives: {type: "boolean"},
    ecmaFeatures: {type: "object"}
  };
  var configSchema = {
    definitions: {
      stringOrStrings: {
        oneOf: [
          {type: "string"},
          {
            type: "array",
            items: {type: "string"},
            additionalItems: false
          }
        ]
      },
      stringOrStringsRequired: {
        oneOf: [
          {type: "string"},
          {
            type: "array",
            items: {type: "string"},
            additionalItems: false,
            minItems: 1
          }
        ]
      },
      objectConfig: {
        type: "object",
        properties: __objSpread({
          root: {type: "boolean"},
          ignorePatterns: {$ref: "#/definitions/stringOrStrings"}
        }, baseConfigProperties),
        additionalProperties: false
      },
      overrideConfig: {
        type: "object",
        properties: __objSpread({
          excludedFiles: {$ref: "#/definitions/stringOrStrings"},
          files: {$ref: "#/definitions/stringOrStringsRequired"}
        }, baseConfigProperties),
        required: ["files"],
        additionalProperties: false
      }
    },
    $ref: "#/definitions/objectConfig"
  };
  module2.exports = configSchema;
});

// node_modules/@eslint/eslintrc/node_modules/globals/globals.json
var require_globals = __commonJS((exports2, module2) => {
  module2.exports = {
    builtin: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      globalThis: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es5: {
      Array: false,
      Boolean: false,
      constructor: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      propertyIsEnumerable: false,
      RangeError: false,
      ReferenceError: false,
      RegExp: false,
      String: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false
    },
    es2015: {
      Array: false,
      ArrayBuffer: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es2017: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    browser: {
      AbortController: false,
      AbortSignal: false,
      addEventListener: false,
      alert: false,
      AnalyserNode: false,
      Animation: false,
      AnimationEffectReadOnly: false,
      AnimationEffectTiming: false,
      AnimationEffectTimingReadOnly: false,
      AnimationEvent: false,
      AnimationPlaybackEvent: false,
      AnimationTimeline: false,
      applicationCache: false,
      ApplicationCache: false,
      ApplicationCacheErrorEvent: false,
      atob: false,
      Attr: false,
      Audio: false,
      AudioBuffer: false,
      AudioBufferSourceNode: false,
      AudioContext: false,
      AudioDestinationNode: false,
      AudioListener: false,
      AudioNode: false,
      AudioParam: false,
      AudioProcessingEvent: false,
      AudioScheduledSourceNode: false,
      "AudioWorkletGlobalScope ": false,
      AudioWorkletNode: false,
      AudioWorkletProcessor: false,
      BarProp: false,
      BaseAudioContext: false,
      BatteryManager: false,
      BeforeUnloadEvent: false,
      BiquadFilterNode: false,
      Blob: false,
      BlobEvent: false,
      blur: false,
      BroadcastChannel: false,
      btoa: false,
      BudgetService: false,
      ByteLengthQueuingStrategy: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      cancelAnimationFrame: false,
      cancelIdleCallback: false,
      CanvasCaptureMediaStreamTrack: false,
      CanvasGradient: false,
      CanvasPattern: false,
      CanvasRenderingContext2D: false,
      ChannelMergerNode: false,
      ChannelSplitterNode: false,
      CharacterData: false,
      clearInterval: false,
      clearTimeout: false,
      clientInformation: false,
      ClipboardEvent: false,
      close: false,
      closed: false,
      CloseEvent: false,
      Comment: false,
      CompositionEvent: false,
      confirm: false,
      console: false,
      ConstantSourceNode: false,
      ConvolverNode: false,
      CountQueuingStrategy: false,
      createImageBitmap: false,
      Credential: false,
      CredentialsContainer: false,
      crypto: false,
      Crypto: false,
      CryptoKey: false,
      CSS: false,
      CSSConditionRule: false,
      CSSFontFaceRule: false,
      CSSGroupingRule: false,
      CSSImportRule: false,
      CSSKeyframeRule: false,
      CSSKeyframesRule: false,
      CSSMediaRule: false,
      CSSNamespaceRule: false,
      CSSPageRule: false,
      CSSRule: false,
      CSSRuleList: false,
      CSSStyleDeclaration: false,
      CSSStyleRule: false,
      CSSStyleSheet: false,
      CSSSupportsRule: false,
      CustomElementRegistry: false,
      customElements: false,
      CustomEvent: false,
      DataTransfer: false,
      DataTransferItem: false,
      DataTransferItemList: false,
      defaultstatus: false,
      defaultStatus: false,
      DelayNode: false,
      DeviceMotionEvent: false,
      DeviceOrientationEvent: false,
      devicePixelRatio: false,
      dispatchEvent: false,
      document: false,
      Document: false,
      DocumentFragment: false,
      DocumentType: false,
      DOMError: false,
      DOMException: false,
      DOMImplementation: false,
      DOMMatrix: false,
      DOMMatrixReadOnly: false,
      DOMParser: false,
      DOMPoint: false,
      DOMPointReadOnly: false,
      DOMQuad: false,
      DOMRect: false,
      DOMRectReadOnly: false,
      DOMStringList: false,
      DOMStringMap: false,
      DOMTokenList: false,
      DragEvent: false,
      DynamicsCompressorNode: false,
      Element: false,
      ErrorEvent: false,
      event: false,
      Event: false,
      EventSource: false,
      EventTarget: false,
      external: false,
      fetch: false,
      File: false,
      FileList: false,
      FileReader: false,
      find: false,
      focus: false,
      FocusEvent: false,
      FontFace: false,
      FontFaceSetLoadEvent: false,
      FormData: false,
      frameElement: false,
      frames: false,
      GainNode: false,
      Gamepad: false,
      GamepadButton: false,
      GamepadEvent: false,
      getComputedStyle: false,
      getSelection: false,
      HashChangeEvent: false,
      Headers: false,
      history: false,
      History: false,
      HTMLAllCollection: false,
      HTMLAnchorElement: false,
      HTMLAreaElement: false,
      HTMLAudioElement: false,
      HTMLBaseElement: false,
      HTMLBodyElement: false,
      HTMLBRElement: false,
      HTMLButtonElement: false,
      HTMLCanvasElement: false,
      HTMLCollection: false,
      HTMLContentElement: false,
      HTMLDataElement: false,
      HTMLDataListElement: false,
      HTMLDetailsElement: false,
      HTMLDialogElement: false,
      HTMLDirectoryElement: false,
      HTMLDivElement: false,
      HTMLDListElement: false,
      HTMLDocument: false,
      HTMLElement: false,
      HTMLEmbedElement: false,
      HTMLFieldSetElement: false,
      HTMLFontElement: false,
      HTMLFormControlsCollection: false,
      HTMLFormElement: false,
      HTMLFrameElement: false,
      HTMLFrameSetElement: false,
      HTMLHeadElement: false,
      HTMLHeadingElement: false,
      HTMLHRElement: false,
      HTMLHtmlElement: false,
      HTMLIFrameElement: false,
      HTMLImageElement: false,
      HTMLInputElement: false,
      HTMLLabelElement: false,
      HTMLLegendElement: false,
      HTMLLIElement: false,
      HTMLLinkElement: false,
      HTMLMapElement: false,
      HTMLMarqueeElement: false,
      HTMLMediaElement: false,
      HTMLMenuElement: false,
      HTMLMetaElement: false,
      HTMLMeterElement: false,
      HTMLModElement: false,
      HTMLObjectElement: false,
      HTMLOListElement: false,
      HTMLOptGroupElement: false,
      HTMLOptionElement: false,
      HTMLOptionsCollection: false,
      HTMLOutputElement: false,
      HTMLParagraphElement: false,
      HTMLParamElement: false,
      HTMLPictureElement: false,
      HTMLPreElement: false,
      HTMLProgressElement: false,
      HTMLQuoteElement: false,
      HTMLScriptElement: false,
      HTMLSelectElement: false,
      HTMLShadowElement: false,
      HTMLSlotElement: false,
      HTMLSourceElement: false,
      HTMLSpanElement: false,
      HTMLStyleElement: false,
      HTMLTableCaptionElement: false,
      HTMLTableCellElement: false,
      HTMLTableColElement: false,
      HTMLTableElement: false,
      HTMLTableRowElement: false,
      HTMLTableSectionElement: false,
      HTMLTemplateElement: false,
      HTMLTextAreaElement: false,
      HTMLTimeElement: false,
      HTMLTitleElement: false,
      HTMLTrackElement: false,
      HTMLUListElement: false,
      HTMLUnknownElement: false,
      HTMLVideoElement: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      IdleDeadline: false,
      IIRFilterNode: false,
      Image: false,
      ImageBitmap: false,
      ImageBitmapRenderingContext: false,
      ImageCapture: false,
      ImageData: false,
      indexedDB: false,
      innerHeight: false,
      innerWidth: false,
      InputEvent: false,
      IntersectionObserver: false,
      IntersectionObserverEntry: false,
      Intl: false,
      isSecureContext: false,
      KeyboardEvent: false,
      KeyframeEffect: false,
      KeyframeEffectReadOnly: false,
      length: false,
      localStorage: false,
      location: true,
      Location: false,
      locationbar: false,
      matchMedia: false,
      MediaDeviceInfo: false,
      MediaDevices: false,
      MediaElementAudioSourceNode: false,
      MediaEncryptedEvent: false,
      MediaError: false,
      MediaKeyMessageEvent: false,
      MediaKeySession: false,
      MediaKeyStatusMap: false,
      MediaKeySystemAccess: false,
      MediaList: false,
      MediaQueryList: false,
      MediaQueryListEvent: false,
      MediaRecorder: false,
      MediaSettingsRange: false,
      MediaSource: false,
      MediaStream: false,
      MediaStreamAudioDestinationNode: false,
      MediaStreamAudioSourceNode: false,
      MediaStreamEvent: false,
      MediaStreamTrack: false,
      MediaStreamTrackEvent: false,
      menubar: false,
      MessageChannel: false,
      MessageEvent: false,
      MessagePort: false,
      MIDIAccess: false,
      MIDIConnectionEvent: false,
      MIDIInput: false,
      MIDIInputMap: false,
      MIDIMessageEvent: false,
      MIDIOutput: false,
      MIDIOutputMap: false,
      MIDIPort: false,
      MimeType: false,
      MimeTypeArray: false,
      MouseEvent: false,
      moveBy: false,
      moveTo: false,
      MutationEvent: false,
      MutationObserver: false,
      MutationRecord: false,
      name: false,
      NamedNodeMap: false,
      NavigationPreloadManager: false,
      navigator: false,
      Navigator: false,
      NetworkInformation: false,
      Node: false,
      NodeFilter: false,
      NodeIterator: false,
      NodeList: false,
      Notification: false,
      OfflineAudioCompletionEvent: false,
      OfflineAudioContext: false,
      offscreenBuffering: false,
      OffscreenCanvas: true,
      onabort: true,
      onafterprint: true,
      onanimationend: true,
      onanimationiteration: true,
      onanimationstart: true,
      onappinstalled: true,
      onauxclick: true,
      onbeforeinstallprompt: true,
      onbeforeprint: true,
      onbeforeunload: true,
      onblur: true,
      oncancel: true,
      oncanplay: true,
      oncanplaythrough: true,
      onchange: true,
      onclick: true,
      onclose: true,
      oncontextmenu: true,
      oncuechange: true,
      ondblclick: true,
      ondevicemotion: true,
      ondeviceorientation: true,
      ondeviceorientationabsolute: true,
      ondrag: true,
      ondragend: true,
      ondragenter: true,
      ondragleave: true,
      ondragover: true,
      ondragstart: true,
      ondrop: true,
      ondurationchange: true,
      onemptied: true,
      onended: true,
      onerror: true,
      onfocus: true,
      ongotpointercapture: true,
      onhashchange: true,
      oninput: true,
      oninvalid: true,
      onkeydown: true,
      onkeypress: true,
      onkeyup: true,
      onlanguagechange: true,
      onload: true,
      onloadeddata: true,
      onloadedmetadata: true,
      onloadstart: true,
      onlostpointercapture: true,
      onmessage: true,
      onmessageerror: true,
      onmousedown: true,
      onmouseenter: true,
      onmouseleave: true,
      onmousemove: true,
      onmouseout: true,
      onmouseover: true,
      onmouseup: true,
      onmousewheel: true,
      onoffline: true,
      ononline: true,
      onpagehide: true,
      onpageshow: true,
      onpause: true,
      onplay: true,
      onplaying: true,
      onpointercancel: true,
      onpointerdown: true,
      onpointerenter: true,
      onpointerleave: true,
      onpointermove: true,
      onpointerout: true,
      onpointerover: true,
      onpointerup: true,
      onpopstate: true,
      onprogress: true,
      onratechange: true,
      onrejectionhandled: true,
      onreset: true,
      onresize: true,
      onscroll: true,
      onsearch: true,
      onseeked: true,
      onseeking: true,
      onselect: true,
      onstalled: true,
      onstorage: true,
      onsubmit: true,
      onsuspend: true,
      ontimeupdate: true,
      ontoggle: true,
      ontransitionend: true,
      onunhandledrejection: true,
      onunload: true,
      onvolumechange: true,
      onwaiting: true,
      onwheel: true,
      open: false,
      openDatabase: false,
      opener: false,
      Option: false,
      origin: false,
      OscillatorNode: false,
      outerHeight: false,
      outerWidth: false,
      PageTransitionEvent: false,
      pageXOffset: false,
      pageYOffset: false,
      PannerNode: false,
      parent: false,
      Path2D: false,
      PaymentAddress: false,
      PaymentRequest: false,
      PaymentRequestUpdateEvent: false,
      PaymentResponse: false,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceLongTaskTiming: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceNavigationTiming: false,
      PerformanceObserver: false,
      PerformanceObserverEntryList: false,
      PerformancePaintTiming: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      PeriodicWave: false,
      Permissions: false,
      PermissionStatus: false,
      personalbar: false,
      PhotoCapabilities: false,
      Plugin: false,
      PluginArray: false,
      PointerEvent: false,
      PopStateEvent: false,
      postMessage: false,
      Presentation: false,
      PresentationAvailability: false,
      PresentationConnection: false,
      PresentationConnectionAvailableEvent: false,
      PresentationConnectionCloseEvent: false,
      PresentationConnectionList: false,
      PresentationReceiver: false,
      PresentationRequest: false,
      print: false,
      ProcessingInstruction: false,
      ProgressEvent: false,
      PromiseRejectionEvent: false,
      prompt: false,
      PushManager: false,
      PushSubscription: false,
      PushSubscriptionOptions: false,
      queueMicrotask: false,
      RadioNodeList: false,
      Range: false,
      ReadableStream: false,
      registerProcessor: false,
      RemotePlayback: false,
      removeEventListener: false,
      Request: false,
      requestAnimationFrame: false,
      requestIdleCallback: false,
      resizeBy: false,
      ResizeObserver: false,
      ResizeObserverEntry: false,
      resizeTo: false,
      Response: false,
      RTCCertificate: false,
      RTCDataChannel: false,
      RTCDataChannelEvent: false,
      RTCDtlsTransport: false,
      RTCIceCandidate: false,
      RTCIceGatherer: false,
      RTCIceTransport: false,
      RTCPeerConnection: false,
      RTCPeerConnectionIceEvent: false,
      RTCRtpContributingSource: false,
      RTCRtpReceiver: false,
      RTCRtpSender: false,
      RTCSctpTransport: false,
      RTCSessionDescription: false,
      RTCStatsReport: false,
      RTCTrackEvent: false,
      screen: false,
      Screen: false,
      screenLeft: false,
      ScreenOrientation: false,
      screenTop: false,
      screenX: false,
      screenY: false,
      ScriptProcessorNode: false,
      scroll: false,
      scrollbars: false,
      scrollBy: false,
      scrollTo: false,
      scrollX: false,
      scrollY: false,
      SecurityPolicyViolationEvent: false,
      Selection: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerRegistration: false,
      sessionStorage: false,
      setInterval: false,
      setTimeout: false,
      ShadowRoot: false,
      SharedWorker: false,
      SourceBuffer: false,
      SourceBufferList: false,
      speechSynthesis: false,
      SpeechSynthesisEvent: false,
      SpeechSynthesisUtterance: false,
      StaticRange: false,
      status: false,
      statusbar: false,
      StereoPannerNode: false,
      stop: false,
      Storage: false,
      StorageEvent: false,
      StorageManager: false,
      styleMedia: false,
      StyleSheet: false,
      StyleSheetList: false,
      SubtleCrypto: false,
      SVGAElement: false,
      SVGAngle: false,
      SVGAnimatedAngle: false,
      SVGAnimatedBoolean: false,
      SVGAnimatedEnumeration: false,
      SVGAnimatedInteger: false,
      SVGAnimatedLength: false,
      SVGAnimatedLengthList: false,
      SVGAnimatedNumber: false,
      SVGAnimatedNumberList: false,
      SVGAnimatedPreserveAspectRatio: false,
      SVGAnimatedRect: false,
      SVGAnimatedString: false,
      SVGAnimatedTransformList: false,
      SVGAnimateElement: false,
      SVGAnimateMotionElement: false,
      SVGAnimateTransformElement: false,
      SVGAnimationElement: false,
      SVGCircleElement: false,
      SVGClipPathElement: false,
      SVGComponentTransferFunctionElement: false,
      SVGDefsElement: false,
      SVGDescElement: false,
      SVGDiscardElement: false,
      SVGElement: false,
      SVGEllipseElement: false,
      SVGFEBlendElement: false,
      SVGFEColorMatrixElement: false,
      SVGFEComponentTransferElement: false,
      SVGFECompositeElement: false,
      SVGFEConvolveMatrixElement: false,
      SVGFEDiffuseLightingElement: false,
      SVGFEDisplacementMapElement: false,
      SVGFEDistantLightElement: false,
      SVGFEDropShadowElement: false,
      SVGFEFloodElement: false,
      SVGFEFuncAElement: false,
      SVGFEFuncBElement: false,
      SVGFEFuncGElement: false,
      SVGFEFuncRElement: false,
      SVGFEGaussianBlurElement: false,
      SVGFEImageElement: false,
      SVGFEMergeElement: false,
      SVGFEMergeNodeElement: false,
      SVGFEMorphologyElement: false,
      SVGFEOffsetElement: false,
      SVGFEPointLightElement: false,
      SVGFESpecularLightingElement: false,
      SVGFESpotLightElement: false,
      SVGFETileElement: false,
      SVGFETurbulenceElement: false,
      SVGFilterElement: false,
      SVGForeignObjectElement: false,
      SVGGElement: false,
      SVGGeometryElement: false,
      SVGGradientElement: false,
      SVGGraphicsElement: false,
      SVGImageElement: false,
      SVGLength: false,
      SVGLengthList: false,
      SVGLinearGradientElement: false,
      SVGLineElement: false,
      SVGMarkerElement: false,
      SVGMaskElement: false,
      SVGMatrix: false,
      SVGMetadataElement: false,
      SVGMPathElement: false,
      SVGNumber: false,
      SVGNumberList: false,
      SVGPathElement: false,
      SVGPatternElement: false,
      SVGPoint: false,
      SVGPointList: false,
      SVGPolygonElement: false,
      SVGPolylineElement: false,
      SVGPreserveAspectRatio: false,
      SVGRadialGradientElement: false,
      SVGRect: false,
      SVGRectElement: false,
      SVGScriptElement: false,
      SVGSetElement: false,
      SVGStopElement: false,
      SVGStringList: false,
      SVGStyleElement: false,
      SVGSVGElement: false,
      SVGSwitchElement: false,
      SVGSymbolElement: false,
      SVGTextContentElement: false,
      SVGTextElement: false,
      SVGTextPathElement: false,
      SVGTextPositioningElement: false,
      SVGTitleElement: false,
      SVGTransform: false,
      SVGTransformList: false,
      SVGTSpanElement: false,
      SVGUnitTypes: false,
      SVGUseElement: false,
      SVGViewElement: false,
      TaskAttributionTiming: false,
      Text: false,
      TextDecoder: false,
      TextEncoder: false,
      TextEvent: false,
      TextMetrics: false,
      TextTrack: false,
      TextTrackCue: false,
      TextTrackCueList: false,
      TextTrackList: false,
      TimeRanges: false,
      toolbar: false,
      top: false,
      Touch: false,
      TouchEvent: false,
      TouchList: false,
      TrackEvent: false,
      TransitionEvent: false,
      TreeWalker: false,
      UIEvent: false,
      URL: false,
      URLSearchParams: false,
      ValidityState: false,
      visualViewport: false,
      VisualViewport: false,
      VTTCue: false,
      WaveShaperNode: false,
      WebAssembly: false,
      WebGL2RenderingContext: false,
      WebGLActiveInfo: false,
      WebGLBuffer: false,
      WebGLContextEvent: false,
      WebGLFramebuffer: false,
      WebGLProgram: false,
      WebGLQuery: false,
      WebGLRenderbuffer: false,
      WebGLRenderingContext: false,
      WebGLSampler: false,
      WebGLShader: false,
      WebGLShaderPrecisionFormat: false,
      WebGLSync: false,
      WebGLTexture: false,
      WebGLTransformFeedback: false,
      WebGLUniformLocation: false,
      WebGLVertexArrayObject: false,
      WebSocket: false,
      WheelEvent: false,
      window: false,
      Window: false,
      Worker: false,
      WritableStream: false,
      XMLDocument: false,
      XMLHttpRequest: false,
      XMLHttpRequestEventTarget: false,
      XMLHttpRequestUpload: false,
      XMLSerializer: false,
      XPathEvaluator: false,
      XPathExpression: false,
      XPathResult: false,
      XSLTProcessor: false
    },
    worker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      clearInterval: false,
      clearTimeout: false,
      close: true,
      console: false,
      fetch: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: true,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onlanguagechange: true,
      onmessage: true,
      onoffline: true,
      ononline: true,
      onrejectionhandled: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: true,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    node: {
      __dirname: false,
      __filename: false,
      Buffer: false,
      clearImmediate: false,
      clearInterval: false,
      clearTimeout: false,
      console: false,
      exports: true,
      global: false,
      Intl: false,
      module: false,
      process: false,
      queueMicrotask: false,
      require: false,
      setImmediate: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false
    },
    nodeBuiltin: {
      Buffer: false,
      clearImmediate: false,
      clearInterval: false,
      clearTimeout: false,
      console: false,
      global: false,
      Intl: false,
      process: false,
      queueMicrotask: false,
      setImmediate: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false
    },
    commonjs: {
      exports: true,
      global: false,
      module: false,
      require: false
    },
    amd: {
      define: false,
      require: false
    },
    mocha: {
      after: false,
      afterEach: false,
      before: false,
      beforeEach: false,
      context: false,
      describe: false,
      it: false,
      mocha: false,
      run: false,
      setup: false,
      specify: false,
      suite: false,
      suiteSetup: false,
      suiteTeardown: false,
      teardown: false,
      test: false,
      xcontext: false,
      xdescribe: false,
      xit: false,
      xspecify: false
    },
    jasmine: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      expectAsync: false,
      fail: false,
      fdescribe: false,
      fit: false,
      it: false,
      jasmine: false,
      pending: false,
      runs: false,
      spyOn: false,
      spyOnAllFunctions: false,
      spyOnProperty: false,
      waits: false,
      waitsFor: false,
      xdescribe: false,
      xit: false
    },
    jest: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      fdescribe: false,
      fit: false,
      it: false,
      jest: false,
      pit: false,
      require: false,
      test: false,
      xdescribe: false,
      xit: false,
      xtest: false
    },
    qunit: {
      asyncTest: false,
      deepEqual: false,
      equal: false,
      expect: false,
      module: false,
      notDeepEqual: false,
      notEqual: false,
      notOk: false,
      notPropEqual: false,
      notStrictEqual: false,
      ok: false,
      propEqual: false,
      QUnit: false,
      raises: false,
      start: false,
      stop: false,
      strictEqual: false,
      test: false,
      throws: false
    },
    phantomjs: {
      console: true,
      exports: true,
      phantom: true,
      require: true,
      WebPage: true
    },
    couch: {
      emit: false,
      exports: false,
      getRow: false,
      log: false,
      module: false,
      provides: false,
      require: false,
      respond: false,
      send: false,
      start: false,
      sum: false
    },
    rhino: {
      defineClass: false,
      deserialize: false,
      gc: false,
      help: false,
      importClass: false,
      importPackage: false,
      java: false,
      load: false,
      loadClass: false,
      Packages: false,
      print: false,
      quit: false,
      readFile: false,
      readUrl: false,
      runCommand: false,
      seal: false,
      serialize: false,
      spawn: false,
      sync: false,
      toint32: false,
      version: false
    },
    nashorn: {
      __DIR__: false,
      __FILE__: false,
      __LINE__: false,
      com: false,
      edu: false,
      exit: false,
      java: false,
      Java: false,
      javafx: false,
      JavaImporter: false,
      javax: false,
      JSAdapter: false,
      load: false,
      loadWithNewGlobal: false,
      org: false,
      Packages: false,
      print: false,
      quit: false
    },
    wsh: {
      ActiveXObject: true,
      CollectGarbage: true,
      Debug: true,
      Enumerator: true,
      GetObject: true,
      RuntimeObject: true,
      ScriptEngine: true,
      ScriptEngineBuildVersion: true,
      ScriptEngineMajorVersion: true,
      ScriptEngineMinorVersion: true,
      VBArray: true,
      WScript: true,
      WSH: true,
      XDomainRequest: true
    },
    jquery: {
      $: false,
      jQuery: false
    },
    yui: {
      YAHOO: false,
      YAHOO_config: false,
      YUI: false,
      YUI_config: false
    },
    shelljs: {
      cat: false,
      cd: false,
      chmod: false,
      config: false,
      cp: false,
      dirs: false,
      echo: false,
      env: false,
      error: false,
      exec: false,
      exit: false,
      find: false,
      grep: false,
      ln: false,
      ls: false,
      mkdir: false,
      mv: false,
      popd: false,
      pushd: false,
      pwd: false,
      rm: false,
      sed: false,
      set: false,
      target: false,
      tempdir: false,
      test: false,
      touch: false,
      which: false
    },
    prototypejs: {
      $: false,
      $$: false,
      $A: false,
      $break: false,
      $continue: false,
      $F: false,
      $H: false,
      $R: false,
      $w: false,
      Abstract: false,
      Ajax: false,
      Autocompleter: false,
      Builder: false,
      Class: false,
      Control: false,
      Draggable: false,
      Draggables: false,
      Droppables: false,
      Effect: false,
      Element: false,
      Enumerable: false,
      Event: false,
      Field: false,
      Form: false,
      Hash: false,
      Insertion: false,
      ObjectRange: false,
      PeriodicalExecuter: false,
      Position: false,
      Prototype: false,
      Scriptaculous: false,
      Selector: false,
      Sortable: false,
      SortableObserver: false,
      Sound: false,
      Template: false,
      Toggle: false,
      Try: false
    },
    meteor: {
      _: false,
      $: false,
      Accounts: false,
      AccountsClient: false,
      AccountsCommon: false,
      AccountsServer: false,
      App: false,
      Assets: false,
      Blaze: false,
      check: false,
      Cordova: false,
      DDP: false,
      DDPRateLimiter: false,
      DDPServer: false,
      Deps: false,
      EJSON: false,
      Email: false,
      HTTP: false,
      Log: false,
      Match: false,
      Meteor: false,
      Mongo: false,
      MongoInternals: false,
      Npm: false,
      Package: false,
      Plugin: false,
      process: false,
      Random: false,
      ReactiveDict: false,
      ReactiveVar: false,
      Router: false,
      ServiceConfiguration: false,
      Session: false,
      share: false,
      Spacebars: false,
      Template: false,
      Tinytest: false,
      Tracker: false,
      UI: false,
      Utils: false,
      WebApp: false,
      WebAppInternals: false
    },
    mongo: {
      _isWindows: false,
      _rand: false,
      BulkWriteResult: false,
      cat: false,
      cd: false,
      connect: false,
      db: false,
      getHostName: false,
      getMemInfo: false,
      hostname: false,
      ISODate: false,
      listFiles: false,
      load: false,
      ls: false,
      md5sumFile: false,
      mkdir: false,
      Mongo: false,
      NumberInt: false,
      NumberLong: false,
      ObjectId: false,
      PlanCache: false,
      print: false,
      printjson: false,
      pwd: false,
      quit: false,
      removeFile: false,
      rs: false,
      sh: false,
      UUID: false,
      version: false,
      WriteResult: false
    },
    applescript: {
      $: false,
      Application: false,
      Automation: false,
      console: false,
      delay: false,
      Library: false,
      ObjC: false,
      ObjectSpecifier: false,
      Path: false,
      Progress: false,
      Ref: false
    },
    serviceworker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      clearInterval: false,
      clearTimeout: false,
      Client: false,
      clients: false,
      Clients: false,
      close: true,
      console: false,
      ExtendableEvent: false,
      ExtendableMessageEvent: false,
      fetch: false,
      FetchEvent: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: false,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onfetch: true,
      oninstall: true,
      onlanguagechange: true,
      onmessage: true,
      onmessageerror: true,
      onnotificationclick: true,
      onnotificationclose: true,
      onoffline: true,
      ononline: true,
      onpush: true,
      onpushsubscriptionchange: true,
      onrejectionhandled: true,
      onsync: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      registration: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerGlobalScope: false,
      ServiceWorkerMessageEvent: false,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      skipWaiting: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      WindowClient: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    atomtest: {
      advanceClock: false,
      fakeClearInterval: false,
      fakeClearTimeout: false,
      fakeSetInterval: false,
      fakeSetTimeout: false,
      resetTimeouts: false,
      waitsForPromise: false
    },
    embertest: {
      andThen: false,
      click: false,
      currentPath: false,
      currentRouteName: false,
      currentURL: false,
      fillIn: false,
      find: false,
      findAll: false,
      findWithAssert: false,
      keyEvent: false,
      pauseTest: false,
      resumeTest: false,
      triggerEvent: false,
      visit: false,
      wait: false
    },
    protractor: {
      $: false,
      $$: false,
      browser: false,
      by: false,
      By: false,
      DartObject: false,
      element: false,
      protractor: false
    },
    "shared-node-browser": {
      clearInterval: false,
      clearTimeout: false,
      console: false,
      setInterval: false,
      setTimeout: false,
      URL: false,
      URLSearchParams: false
    },
    webextensions: {
      browser: false,
      chrome: false,
      opr: false
    },
    greasemonkey: {
      cloneInto: false,
      createObjectIn: false,
      exportFunction: false,
      GM: false,
      GM_addStyle: false,
      GM_deleteValue: false,
      GM_getResourceText: false,
      GM_getResourceURL: false,
      GM_getValue: false,
      GM_info: false,
      GM_listValues: false,
      GM_log: false,
      GM_openInTab: false,
      GM_registerMenuCommand: false,
      GM_setClipboard: false,
      GM_setValue: false,
      GM_xmlhttpRequest: false,
      unsafeWindow: false
    },
    devtools: {
      $: false,
      $_: false,
      $$: false,
      $0: false,
      $1: false,
      $2: false,
      $3: false,
      $4: false,
      $x: false,
      chrome: false,
      clear: false,
      copy: false,
      debug: false,
      dir: false,
      dirxml: false,
      getEventListeners: false,
      inspect: false,
      keys: false,
      monitor: false,
      monitorEvents: false,
      profile: false,
      profileEnd: false,
      queryObjects: false,
      table: false,
      undebug: false,
      unmonitor: false,
      unmonitorEvents: false,
      values: false
    }
  };
});

// node_modules/@eslint/eslintrc/node_modules/globals/index.js
var require_globals2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_globals();
});

// node_modules/@eslint/eslintrc/conf/environments.js
var require_environments = __commonJS((exports2, module2) => {
  "use strict";
  var globals = require_globals2();
  function getDiff(current, prev) {
    const retv = {};
    for (const [key, value] of Object.entries(current)) {
      if (!Object.hasOwnProperty.call(prev, key)) {
        retv[key] = value;
      }
    }
    return retv;
  }
  var newGlobals2015 = getDiff(globals.es2015, globals.es5);
  var newGlobals2017 = {
    Atomics: false,
    SharedArrayBuffer: false
  };
  var newGlobals2020 = {
    BigInt: false,
    BigInt64Array: false,
    BigUint64Array: false,
    globalThis: false
  };
  var newGlobals2021 = {
    AggregateError: false,
    FinalizationRegistry: false,
    WeakRef: false
  };
  module2.exports = new Map(Object.entries({
    builtin: {
      globals: globals.es5
    },
    es6: {
      globals: newGlobals2015,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2015: {
      globals: newGlobals2015,
      parserOptions: {
        ecmaVersion: 6
      }
    },
    es2017: {
      globals: __objSpread(__objSpread({}, newGlobals2015), newGlobals2017),
      parserOptions: {
        ecmaVersion: 8
      }
    },
    es2020: {
      globals: __objSpread(__objSpread(__objSpread({}, newGlobals2015), newGlobals2017), newGlobals2020),
      parserOptions: {
        ecmaVersion: 11
      }
    },
    es2021: {
      globals: __objSpread(__objSpread(__objSpread(__objSpread({}, newGlobals2015), newGlobals2017), newGlobals2020), newGlobals2021),
      parserOptions: {
        ecmaVersion: 12
      }
    },
    browser: {
      globals: globals.browser
    },
    node: {
      globals: globals.node,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: true
        }
      }
    },
    "shared-node-browser": {
      globals: globals["shared-node-browser"]
    },
    worker: {
      globals: globals.worker
    },
    serviceworker: {
      globals: globals.serviceworker
    },
    commonjs: {
      globals: globals.commonjs,
      parserOptions: {
        ecmaFeatures: {
          globalReturn: true
        }
      }
    },
    amd: {
      globals: globals.amd
    },
    mocha: {
      globals: globals.mocha
    },
    jasmine: {
      globals: globals.jasmine
    },
    jest: {
      globals: globals.jest
    },
    phantomjs: {
      globals: globals.phantomjs
    },
    jquery: {
      globals: globals.jquery
    },
    qunit: {
      globals: globals.qunit
    },
    prototypejs: {
      globals: globals.prototypejs
    },
    shelljs: {
      globals: globals.shelljs
    },
    meteor: {
      globals: globals.meteor
    },
    mongo: {
      globals: globals.mongo
    },
    protractor: {
      globals: globals.protractor
    },
    applescript: {
      globals: globals.applescript
    },
    nashorn: {
      globals: globals.nashorn
    },
    atomtest: {
      globals: globals.atomtest
    },
    embertest: {
      globals: globals.embertest
    },
    webextensions: {
      globals: globals.webextensions
    },
    greasemonkey: {
      globals: globals.greasemonkey
    }
  }));
});

// node_modules/@eslint/eslintrc/lib/shared/config-ops.js
var require_config_ops = __commonJS((exports2, module2) => {
  "use strict";
  var RULE_SEVERITY_STRINGS = ["off", "warn", "error"];
  var RULE_SEVERITY = RULE_SEVERITY_STRINGS.reduce((map, value, index) => {
    map[value] = index;
    return map;
  }, {});
  var VALID_SEVERITIES = [0, 1, 2, "off", "warn", "error"];
  module2.exports = {
    getRuleSeverity(ruleConfig) {
      const severityValue = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
      if (severityValue === 0 || severityValue === 1 || severityValue === 2) {
        return severityValue;
      }
      if (typeof severityValue === "string") {
        return RULE_SEVERITY[severityValue.toLowerCase()] || 0;
      }
      return 0;
    },
    normalizeToStrings(config) {
      if (config.rules) {
        Object.keys(config.rules).forEach((ruleId) => {
          const ruleConfig = config.rules[ruleId];
          if (typeof ruleConfig === "number") {
            config.rules[ruleId] = RULE_SEVERITY_STRINGS[ruleConfig] || RULE_SEVERITY_STRINGS[0];
          } else if (Array.isArray(ruleConfig) && typeof ruleConfig[0] === "number") {
            ruleConfig[0] = RULE_SEVERITY_STRINGS[ruleConfig[0]] || RULE_SEVERITY_STRINGS[0];
          }
        });
      }
    },
    isErrorSeverity(ruleConfig) {
      return module2.exports.getRuleSeverity(ruleConfig) === 2;
    },
    isValidSeverity(ruleConfig) {
      let severity = Array.isArray(ruleConfig) ? ruleConfig[0] : ruleConfig;
      if (typeof severity === "string") {
        severity = severity.toLowerCase();
      }
      return VALID_SEVERITIES.indexOf(severity) !== -1;
    },
    isEverySeverityValid(config) {
      return Object.keys(config).every((ruleId) => this.isValidSeverity(config[ruleId]));
    },
    normalizeConfigGlobal(configuredValue) {
      switch (configuredValue) {
        case "off":
          return "off";
        case true:
        case "true":
        case "writeable":
        case "writable":
          return "writable";
        case null:
        case false:
        case "false":
        case "readable":
        case "readonly":
          return "readonly";
        default:
          throw new Error(`'${configuredValue}' is not a valid configuration for a global (use 'readonly', 'writable', or 'off')`);
      }
    }
  };
});

// node_modules/@eslint/eslintrc/lib/shared/deprecation-warnings.js
var require_deprecation_warnings = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var deprecationWarningMessages = {
    ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
    ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
    ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
  };
  var sourceFileErrorCache = new Set();
  function emitDeprecationWarning(source, errorCode) {
    const cacheKey = JSON.stringify({source, errorCode});
    if (sourceFileErrorCache.has(cacheKey)) {
      return;
    }
    sourceFileErrorCache.add(cacheKey);
    const rel = path3.relative(process.cwd(), source);
    const message = deprecationWarningMessages[errorCode];
    process.emitWarning(`${message} (found in "${rel}")`, "DeprecationWarning", errorCode);
  }
  module2.exports = {
    emitDeprecationWarning
  };
});

// node_modules/uri-js/dist/es5/uri.all.js
var require_uri_all = __commonJS((exports2, module2) => {
  /** @license URI.js v4.2.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? factory(exports2) : typeof define === "function" && define.amd ? define(["exports"], factory) : factory(global2.URI = global2.URI || {});
  })(exports2, function(exports3) {
    "use strict";
    function merge() {
      for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
      }
      if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
          sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join("");
      } else {
        return sets[0];
      }
    }
    function subexp(str) {
      return "(?:" + str + ")";
    }
    function typeOf(o) {
      return o === void 0 ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
    }
    function toUpperCase(str) {
      return str.toUpperCase();
    }
    function toArray(obj) {
      return obj !== void 0 && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
    }
    function assign(target, source) {
      var obj = target;
      if (source) {
        for (var key in source) {
          obj[key] = source[key];
        }
      }
      return obj;
    }
    function buildExps(isIRI2) {
      var ALPHA$$ = "[A-Za-z]", CR$ = "[\\x0D]", DIGIT$$ = "[0-9]", DQUOTE$$ = "[\\x22]", HEXDIG$$2 = merge(DIGIT$$, "[A-Fa-f]"), LF$$ = "[\\x0A]", SP$$ = "[\\x20]", PCT_ENCODED$2 = subexp(subexp("%[EFef]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$2 + "%" + HEXDIG$$2 + HEXDIG$$2) + "|" + subexp("%" + HEXDIG$$2 + HEXDIG$$2)), GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]", SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]", RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$), UCSCHAR$$ = isIRI2 ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]", IPRIVATE$$ = isIRI2 ? "[\\uE000-\\uF8FF]" : "[]", UNRESERVED$$2 = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$), SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*"), USERINFO$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]")) + "*"), DEC_OCTET$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("[1-9]" + DIGIT$$) + "|" + DIGIT$$), DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$), IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$), H16$ = subexp(HEXDIG$$2 + "{1,4}"), LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$), IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$), IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$), IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$), IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$), IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$), IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$), IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$), IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$), IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"), IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")), ZONEID$ = subexp(subexp(UNRESERVED$$2 + "|" + PCT_ENCODED$2) + "+"), IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + "\\%25" + ZONEID$), IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + ZONEID$), IPVFUTURE$ = subexp("[vV]" + HEXDIG$$2 + "+\\." + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:]") + "+"), IP_LITERAL$ = subexp("\\[" + subexp(IPV6ADDRZ_RELAXED$ + "|" + IPV6ADDRESS$ + "|" + IPVFUTURE$) + "\\]"), REG_NAME$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$)) + "*"), HOST$ = subexp(IP_LITERAL$ + "|" + IPV4ADDRESS$ + "(?!" + REG_NAME$ + ")|" + REG_NAME$), PORT$ = subexp(DIGIT$$ + "*"), AUTHORITY$ = subexp(subexp(USERINFO$ + "@") + "?" + HOST$ + subexp("\\:" + PORT$) + "?"), PCHAR$ = subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@]")), SEGMENT$ = subexp(PCHAR$ + "*"), SEGMENT_NZ$ = subexp(PCHAR$ + "+"), SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$2 + "|" + merge(UNRESERVED$$2, SUB_DELIMS$$, "[\\@]")) + "+"), PATH_ABEMPTY$ = subexp(subexp("\\/" + SEGMENT$) + "*"), PATH_ABSOLUTE$ = subexp("\\/" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + "?"), PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$), PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$), PATH_EMPTY$ = "(?!" + PCHAR$ + ")", PATH$ = subexp(PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), QUERY$ = subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*"), FRAGMENT$ = subexp(subexp(PCHAR$ + "|[\\/\\?]") + "*"), HIER_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$), URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), RELATIVE_PART$ = subexp(subexp("\\/\\/" + AUTHORITY$ + PATH_ABEMPTY$) + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$), RELATIVE$ = subexp(RELATIVE_PART$ + subexp("\\?" + QUERY$) + "?" + subexp("\\#" + FRAGMENT$) + "?"), URI_REFERENCE$ = subexp(URI$ + "|" + RELATIVE$), ABSOLUTE_URI$ = subexp(SCHEME$ + "\\:" + HIER_PART$ + subexp("\\?" + QUERY$) + "?"), GENERIC_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", RELATIVE_REF$ = "^(){0}" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_NOSCHEME$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", ABSOLUTE_REF$ = "^(" + SCHEME$ + ")\\:" + subexp(subexp("\\/\\/(" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?)") + "?(" + PATH_ABEMPTY$ + "|" + PATH_ABSOLUTE$ + "|" + PATH_ROOTLESS$ + "|" + PATH_EMPTY$ + ")") + subexp("\\?(" + QUERY$ + ")") + "?$", SAMEDOC_REF$ = "^" + subexp("\\#(" + FRAGMENT$ + ")") + "?$", AUTHORITY_REF$ = "^" + subexp("(" + USERINFO$ + ")@") + "?(" + HOST$ + ")" + subexp("\\:(" + PORT$ + ")") + "?$";
      return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$2, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$2, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$2, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$2, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$2, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$2 + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$")
      };
    }
    var URI_PROTOCOL = buildExps(false);
    var IRI_PROTOCOL = buildExps(true);
    var slicedToArray = function() {
      function sliceIterator(arr, i) {
        var _arr = [];
        var _n = true;
        var _d = false;
        var _e = void 0;
        try {
          for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
            _arr.push(_s.value);
            if (i && _arr.length === i)
              break;
          }
        } catch (err) {
          _d = true;
          _e = err;
        } finally {
          try {
            if (!_n && _i["return"])
              _i["return"]();
          } finally {
            if (_d)
              throw _e;
          }
        }
        return _arr;
      }
      return function(arr, i) {
        if (Array.isArray(arr)) {
          return arr;
        } else if (Symbol.iterator in Object(arr)) {
          return sliceIterator(arr, i);
        } else {
          throw new TypeError("Invalid attempt to destructure non-iterable instance");
        }
      };
    }();
    var toConsumableArray = function(arr) {
      if (Array.isArray(arr)) {
        for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++)
          arr2[i] = arr[i];
        return arr2;
      } else {
        return Array.from(arr);
      }
    };
    var maxInt = 2147483647;
    var base = 36;
    var tMin = 1;
    var tMax = 26;
    var skew = 38;
    var damp = 700;
    var initialBias = 72;
    var initialN = 128;
    var delimiter = "-";
    var regexPunycode = /^xn--/;
    var regexNonASCII = /[^\0-\x7E]/;
    var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
    var errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    };
    var baseMinusTMin = base - tMin;
    var floor = Math.floor;
    var stringFromCharCode = String.fromCharCode;
    function error$1(type) {
      throw new RangeError(errors[type]);
    }
    function map(array, fn) {
      var result = [];
      var length = array.length;
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [];
      var counter = 0;
      var length = string.length;
      while (counter < length) {
        var value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          var extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    var ucs2encode = function ucs2encode2(array) {
      return String.fromCodePoint.apply(String, toConsumableArray(array));
    };
    var basicToDigit = function basicToDigit2(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    };
    var digitToBasic = function digitToBasic2(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    };
    var adapt = function adapt2(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    };
    var decode = function decode2(input) {
      var output = [];
      var inputLength = input.length;
      var i = 0;
      var n = initialN;
      var bias = initialBias;
      var basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (var j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error$1("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (var index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        var oldi = i;
        for (var w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error$1("invalid-input");
          }
          var digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error$1("overflow");
          }
          i += digit * w;
          var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          var baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error$1("overflow");
          }
          w *= baseMinusT;
        }
        var out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error$1("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return String.fromCodePoint.apply(String, output);
    };
    var encode = function encode2(input) {
      var output = [];
      input = ucs2decode(input);
      var inputLength = input.length;
      var n = initialN;
      var delta = 0;
      var bias = initialBias;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var _currentValue2 = _step.value;
          if (_currentValue2 < 128) {
            output.push(stringFromCharCode(_currentValue2));
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      var basicLength = output.length;
      var handledCPCount = basicLength;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        var m = maxInt;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = void 0;
        try {
          for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var currentValue = _step2.value;
            if (currentValue >= n && currentValue < m) {
              m = currentValue;
            }
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
        var handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error$1("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = void 0;
        try {
          for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var _currentValue = _step3.value;
            if (_currentValue < n && ++delta > maxInt) {
              error$1("overflow");
            }
            if (_currentValue == n) {
              var q = delta;
              for (var k = base; ; k += base) {
                var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                if (q < t) {
                  break;
                }
                var qMinusT = q - t;
                var baseMinusT = base - t;
                output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                q = floor(qMinusT / baseMinusT);
              }
              output.push(stringFromCharCode(digitToBasic(q, 0)));
              bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
              delta = 0;
              ++handledCPCount;
            }
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    };
    var toUnicode = function toUnicode2(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    };
    var toASCII = function toASCII2(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    };
    var punycode = {
      version: "2.1.0",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    var SCHEMES = {};
    function pctEncChar(chr) {
      var c = chr.charCodeAt(0);
      var e = void 0;
      if (c < 16)
        e = "%0" + c.toString(16).toUpperCase();
      else if (c < 128)
        e = "%" + c.toString(16).toUpperCase();
      else if (c < 2048)
        e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      else
        e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
      return e;
    }
    function pctDecChars(str) {
      var newStr = "";
      var i = 0;
      var il = str.length;
      while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
          newStr += String.fromCharCode(c);
          i += 3;
        } else if (c >= 194 && c < 224) {
          if (il - i >= 6) {
            var c2 = parseInt(str.substr(i + 4, 2), 16);
            newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
          } else {
            newStr += str.substr(i, 6);
          }
          i += 6;
        } else if (c >= 224) {
          if (il - i >= 9) {
            var _c = parseInt(str.substr(i + 4, 2), 16);
            var c3 = parseInt(str.substr(i + 7, 2), 16);
            newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
          } else {
            newStr += str.substr(i, 9);
          }
          i += 9;
        } else {
          newStr += str.substr(i, 3);
          i += 3;
        }
      }
      return newStr;
    }
    function _normalizeComponentEncoding(components, protocol) {
      function decodeUnreserved2(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
      }
      if (components.scheme)
        components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_SCHEME, "");
      if (components.userinfo !== void 0)
        components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.host !== void 0)
        components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved2).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.path !== void 0)
        components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.query !== void 0)
        components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      if (components.fragment !== void 0)
        components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved2).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
      return components;
    }
    function _stripLeadingZeros(str) {
      return str.replace(/^0*(.*)/, "$1") || "0";
    }
    function _normalizeIPv4(host, protocol) {
      var matches = host.match(protocol.IPV4ADDRESS) || [];
      var _matches = slicedToArray(matches, 2), address = _matches[1];
      if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
      } else {
        return host;
      }
    }
    function _normalizeIPv6(host, protocol) {
      var matches = host.match(protocol.IPV6ADDRESS) || [];
      var _matches2 = slicedToArray(matches, 3), address = _matches2[1], zone = _matches2[2];
      if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split("::").reverse(), _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2), last = _address$toLowerCase$2[0], first = _address$toLowerCase$2[1];
        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
          fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || "";
        }
        if (isLastFieldIPv4Address) {
          fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function(acc, field, index) {
          if (!field || field === "0") {
            var lastLongest = acc[acc.length - 1];
            if (lastLongest && lastLongest.index + lastLongest.length === index) {
              lastLongest.length++;
            } else {
              acc.push({index, length: 1});
            }
          }
          return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function(a, b) {
          return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
          var newFirst = fields.slice(0, longestZeroFields.index);
          var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
          newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
          newHost = fields.join(":");
        }
        if (zone) {
          newHost += "%" + zone;
        }
        return newHost;
      } else {
        return host;
      }
    }
    var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
    var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === void 0;
    function parse(uriString) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var components = {};
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      if (options.reference === "suffix")
        uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
      var matches = uriString.match(URI_PARSE);
      if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
          components.scheme = matches[1];
          components.userinfo = matches[3];
          components.host = matches[4];
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = matches[7];
          components.fragment = matches[8];
          if (isNaN(components.port)) {
            components.port = matches[5];
          }
        } else {
          components.scheme = matches[1] || void 0;
          components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : void 0;
          components.host = uriString.indexOf("//") !== -1 ? matches[4] : void 0;
          components.port = parseInt(matches[5], 10);
          components.path = matches[6] || "";
          components.query = uriString.indexOf("?") !== -1 ? matches[7] : void 0;
          components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : void 0;
          if (isNaN(components.port)) {
            components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : void 0;
          }
        }
        if (components.host) {
          components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        if (components.scheme === void 0 && components.userinfo === void 0 && components.host === void 0 && components.port === void 0 && !components.path && components.query === void 0) {
          components.reference = "same-document";
        } else if (components.scheme === void 0) {
          components.reference = "relative";
        } else if (components.fragment === void 0) {
          components.reference = "absolute";
        } else {
          components.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
          components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
            try {
              components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
            } catch (e) {
              components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
            }
          }
          _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
          _normalizeComponentEncoding(components, protocol);
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(components, options);
        }
      } else {
        components.error = components.error || "URI can not be parsed.";
      }
      return components;
    }
    function _recomposeAuthority(components, options) {
      var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      if (components.userinfo !== void 0) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
      }
      if (components.host !== void 0) {
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function(_, $1, $2) {
          return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
      }
      if (typeof components.port === "number") {
        uriTokens.push(":");
        uriTokens.push(components.port.toString(10));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    var RDS1 = /^\.\.?\//;
    var RDS2 = /^\/\.(\/|$)/;
    var RDS3 = /^\/\.\.(\/|$)/;
    var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
    function removeDotSegments(input) {
      var output = [];
      while (input.length) {
        if (input.match(RDS1)) {
          input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
          input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
          input = input.replace(RDS3, "/");
          output.pop();
        } else if (input === "." || input === "..") {
          input = "";
        } else {
          var im = input.match(RDS5);
          if (im) {
            var s = im[0];
            input = input.slice(s.length);
            output.push(s);
          } else {
            throw new Error("Unexpected dot segment condition");
          }
        }
      }
      return output.join("");
    }
    function serialize(components) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
      var uriTokens = [];
      var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
      if (schemeHandler && schemeHandler.serialize)
        schemeHandler.serialize(components, options);
      if (components.host) {
        if (protocol.IPV6ADDRESS.test(components.host)) {
        } else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
          try {
            components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
          } catch (e) {
            components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
          }
        }
      }
      _normalizeComponentEncoding(components, protocol);
      if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
      }
      var authority = _recomposeAuthority(components, options);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
          uriTokens.push("/");
        }
      }
      if (components.path !== void 0) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0) {
          s = s.replace(/^\/\//, "/%2F");
        }
        uriTokens.push(s);
      }
      if (components.query !== void 0) {
        uriTokens.push("?");
        uriTokens.push(components.query);
      }
      if (components.fragment !== void 0) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
      }
      return uriTokens.join("");
    }
    function resolveComponents(base2, relative) {
      var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
      var skipNormalization = arguments[3];
      var target = {};
      if (!skipNormalization) {
        base2 = parse(serialize(base2, options), options);
        relative = parse(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base2.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base2.query;
            }
          } else {
            if (relative.path.charAt(0) === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base2.userinfo !== void 0 || base2.host !== void 0 || base2.port !== void 0) && !base2.path) {
                target.path = "/" + relative.path;
              } else if (!base2.path) {
                target.path = relative.path;
              } else {
                target.path = base2.path.slice(0, base2.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base2.userinfo;
          target.host = base2.host;
          target.port = base2.port;
        }
        target.scheme = base2.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function resolve(baseURI, relativeURI, options) {
      var schemelessOptions = assign({scheme: "null"}, options);
      return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
    }
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
      } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
      }
      return uri;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
      } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
      }
      if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
      } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
      }
      return uriA === uriB;
    }
    function escapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
    }
    function unescapeComponent(str, options) {
      return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
    }
    var handler = {
      scheme: "http",
      domainHost: true,
      parse: function parse2(components, options) {
        if (!components.host) {
          components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
      },
      serialize: function serialize2(components, options) {
        if (components.port === (String(components.scheme).toLowerCase() !== "https" ? 80 : 443) || components.port === "") {
          components.port = void 0;
        }
        if (!components.path) {
          components.path = "/";
        }
        return components;
      }
    };
    var handler$1 = {
      scheme: "https",
      domainHost: handler.domainHost,
      parse: handler.parse,
      serialize: handler.serialize
    };
    var O = {};
    var isIRI = true;
    var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + (isIRI ? "\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" : "") + "]";
    var HEXDIG$$ = "[0-9A-Fa-f]";
    var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$));
    var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
    var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
    var VCHAR$$ = merge(QTEXT$$, '[\\"\\\\]');
    var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
    var UNRESERVED = new RegExp(UNRESERVED$$, "g");
    var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
    var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
    var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
    var NOT_HFVALUE = NOT_HFNAME;
    function decodeUnreserved(str) {
      var decStr = pctDecChars(str);
      return !decStr.match(UNRESERVED) ? str : decStr;
    }
    var handler$2 = {
      scheme: "mailto",
      parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = void 0;
        if (mailtoComponents.query) {
          var unknownHeaders = false;
          var headers = {};
          var hfields = mailtoComponents.query.split("&");
          for (var x = 0, xl = hfields.length; x < xl; ++x) {
            var hfield = hfields[x].split("=");
            switch (hfield[0]) {
              case "to":
                var toAddrs = hfield[1].split(",");
                for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                  to.push(toAddrs[_x]);
                }
                break;
              case "subject":
                mailtoComponents.subject = unescapeComponent(hfield[1], options);
                break;
              case "body":
                mailtoComponents.body = unescapeComponent(hfield[1], options);
                break;
              default:
                unknownHeaders = true;
                headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                break;
            }
          }
          if (unknownHeaders)
            mailtoComponents.headers = headers;
        }
        mailtoComponents.query = void 0;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
          var addr = to[_x2].split("@");
          addr[0] = unescapeComponent(addr[0]);
          if (!options.unicodeSupport) {
            try {
              addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
            } catch (e) {
              mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
            }
          } else {
            addr[1] = unescapeComponent(addr[1], options).toLowerCase();
          }
          to[_x2] = addr.join("@");
        }
        return mailtoComponents;
      },
      serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
          for (var x = 0, xl = to.length; x < xl; ++x) {
            var toAddr = String(to[x]);
            var atIdx = toAddr.lastIndexOf("@");
            var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
            var domain = toAddr.slice(atIdx + 1);
            try {
              domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
            } catch (e) {
              components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
            }
            to[x] = localPart + "@" + domain;
          }
          components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject)
          headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body)
          headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
          if (headers[name] !== O[name]) {
            fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
          }
        }
        if (fields.length) {
          components.query = fields.join("&");
        }
        return components;
      }
    };
    var URN_PARSE = /^([^\:]+)\:(.*)/;
    var handler$3 = {
      scheme: "urn",
      parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
          var scheme = options.scheme || urnComponents.scheme || "urn";
          var nid = matches[1].toLowerCase();
          var nss = matches[2];
          var urnScheme = scheme + ":" + (options.nid || nid);
          var schemeHandler = SCHEMES[urnScheme];
          urnComponents.nid = nid;
          urnComponents.nss = nss;
          urnComponents.path = void 0;
          if (schemeHandler) {
            urnComponents = schemeHandler.parse(urnComponents, options);
          }
        } else {
          urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
      },
      serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
          urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
      }
    };
    var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
    var handler$4 = {
      scheme: "urn:uuid",
      parse: function parse2(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = void 0;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
          uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
      },
      serialize: function serialize2(uuidComponents, options) {
        var urnComponents = uuidComponents;
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
      }
    };
    SCHEMES[handler.scheme] = handler;
    SCHEMES[handler$1.scheme] = handler$1;
    SCHEMES[handler$2.scheme] = handler$2;
    SCHEMES[handler$3.scheme] = handler$3;
    SCHEMES[handler$4.scheme] = handler$4;
    exports3.SCHEMES = SCHEMES;
    exports3.pctEncChar = pctEncChar;
    exports3.pctDecChars = pctDecChars;
    exports3.parse = parse;
    exports3.removeDotSegments = removeDotSegments;
    exports3.serialize = serialize;
    exports3.resolveComponents = resolveComponents;
    exports3.resolve = resolve;
    exports3.normalize = normalize;
    exports3.equal = equal;
    exports3.escapeComponent = escapeComponent;
    exports3.unescapeComponent = unescapeComponent;
    Object.defineProperty(exports3, "__esModule", {value: true});
  });
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function equal(a, b) {
    if (a === b)
      return true;
    if (a && b && typeof a == "object" && typeof b == "object") {
      if (a.constructor !== b.constructor)
        return false;
      var length, i, keys;
      if (Array.isArray(a)) {
        length = a.length;
        if (length != b.length)
          return false;
        for (i = length; i-- !== 0; )
          if (!equal(a[i], b[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b.source && a.flags === b.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b.toString();
      keys = Object.keys(a);
      length = keys.length;
      if (length !== Object.keys(b).length)
        return false;
      for (i = length; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b, keys[i]))
          return false;
      for (i = length; i-- !== 0; ) {
        var key = keys[i];
        if (!equal(a[key], b[key]))
          return false;
      }
      return true;
    }
    return a !== a && b !== b;
  };
});

// node_modules/ajv/lib/compile/ucs2length.js
var require_ucs2length = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function ucs2length(str) {
    var length = 0, len = str.length, pos = 0, value;
    while (pos < len) {
      length++;
      value = str.charCodeAt(pos++);
      if (value >= 55296 && value <= 56319 && pos < len) {
        value = str.charCodeAt(pos);
        if ((value & 64512) == 56320)
          pos++;
      }
    }
    return length;
  };
});

// node_modules/ajv/lib/compile/util.js
var require_util = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    copy,
    checkDataType,
    checkDataTypes,
    coerceToTypes,
    toHash,
    getProperty,
    escapeQuotes,
    equal: require_fast_deep_equal(),
    ucs2length: require_ucs2length(),
    varOccurences,
    varReplace,
    schemaHasRules,
    schemaHasRulesExcept,
    schemaUnknownRules,
    toQuotedString,
    getPathExpr,
    getPath,
    getData,
    unescapeFragment,
    unescapeJsonPointer,
    escapeFragment,
    escapeJsonPointer
  };
  function copy(o, to) {
    to = to || {};
    for (var key in o)
      to[key] = o[key];
    return to;
  }
  function checkDataType(dataType, data, strictNumbers, negate) {
    var EQUAL = negate ? " !== " : " === ", AND = negate ? " || " : " && ", OK = negate ? "!" : "", NOT = negate ? "" : "!";
    switch (dataType) {
      case "null":
        return data + EQUAL + "null";
      case "array":
        return OK + "Array.isArray(" + data + ")";
      case "object":
        return "(" + OK + data + AND + "typeof " + data + EQUAL + '"object"' + AND + NOT + "Array.isArray(" + data + "))";
      case "integer":
        return "(typeof " + data + EQUAL + '"number"' + AND + NOT + "(" + data + " % 1)" + AND + data + EQUAL + data + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
      case "number":
        return "(typeof " + data + EQUAL + '"' + dataType + '"' + (strictNumbers ? AND + OK + "isFinite(" + data + ")" : "") + ")";
      default:
        return "typeof " + data + EQUAL + '"' + dataType + '"';
    }
  }
  function checkDataTypes(dataTypes, data, strictNumbers) {
    switch (dataTypes.length) {
      case 1:
        return checkDataType(dataTypes[0], data, strictNumbers, true);
      default:
        var code = "";
        var types = toHash(dataTypes);
        if (types.array && types.object) {
          code = types.null ? "(" : "(!" + data + " || ";
          code += "typeof " + data + ' !== "object")';
          delete types.null;
          delete types.array;
          delete types.object;
        }
        if (types.number)
          delete types.integer;
        for (var t in types)
          code += (code ? " && " : "") + checkDataType(t, data, strictNumbers, true);
        return code;
    }
  }
  var COERCE_TO_TYPES = toHash(["string", "number", "integer", "boolean", "null"]);
  function coerceToTypes(optionCoerceTypes, dataTypes) {
    if (Array.isArray(dataTypes)) {
      var types = [];
      for (var i = 0; i < dataTypes.length; i++) {
        var t = dataTypes[i];
        if (COERCE_TO_TYPES[t])
          types[types.length] = t;
        else if (optionCoerceTypes === "array" && t === "array")
          types[types.length] = t;
      }
      if (types.length)
        return types;
    } else if (COERCE_TO_TYPES[dataTypes]) {
      return [dataTypes];
    } else if (optionCoerceTypes === "array" && dataTypes === "array") {
      return ["array"];
    }
  }
  function toHash(arr) {
    var hash = {};
    for (var i = 0; i < arr.length; i++)
      hash[arr[i]] = true;
    return hash;
  }
  var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
  var SINGLE_QUOTE = /'|\\/g;
  function getProperty(key) {
    return typeof key == "number" ? "[" + key + "]" : IDENTIFIER.test(key) ? "." + key : "['" + escapeQuotes(key) + "']";
  }
  function escapeQuotes(str) {
    return str.replace(SINGLE_QUOTE, "\\$&").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/\f/g, "\\f").replace(/\t/g, "\\t");
  }
  function varOccurences(str, dataVar) {
    dataVar += "[^0-9]";
    var matches = str.match(new RegExp(dataVar, "g"));
    return matches ? matches.length : 0;
  }
  function varReplace(str, dataVar, expr) {
    dataVar += "([^0-9])";
    expr = expr.replace(/\$/g, "$$$$");
    return str.replace(new RegExp(dataVar, "g"), expr + "$1");
  }
  function schemaHasRules(schema, rules) {
    if (typeof schema == "boolean")
      return !schema;
    for (var key in schema)
      if (rules[key])
        return true;
  }
  function schemaHasRulesExcept(schema, rules, exceptKeyword) {
    if (typeof schema == "boolean")
      return !schema && exceptKeyword != "not";
    for (var key in schema)
      if (key != exceptKeyword && rules[key])
        return true;
  }
  function schemaUnknownRules(schema, rules) {
    if (typeof schema == "boolean")
      return;
    for (var key in schema)
      if (!rules[key])
        return key;
  }
  function toQuotedString(str) {
    return "'" + escapeQuotes(str) + "'";
  }
  function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
    var path3 = jsonPointers ? "'/' + " + expr + (isNumber ? "" : ".replace(/~/g, '~0').replace(/\\//g, '~1')") : isNumber ? "'[' + " + expr + " + ']'" : "'[\\'' + " + expr + " + '\\']'";
    return joinPaths(currentPath, path3);
  }
  function getPath(currentPath, prop, jsonPointers) {
    var path3 = jsonPointers ? toQuotedString("/" + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
    return joinPaths(currentPath, path3);
  }
  var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
  var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
  function getData($data, lvl, paths) {
    var up, jsonPointer, data, matches;
    if ($data === "")
      return "rootData";
    if ($data[0] == "/") {
      if (!JSON_POINTER.test($data))
        throw new Error("Invalid JSON-pointer: " + $data);
      jsonPointer = $data;
      data = "rootData";
    } else {
      matches = $data.match(RELATIVE_JSON_POINTER);
      if (!matches)
        throw new Error("Invalid JSON-pointer: " + $data);
      up = +matches[1];
      jsonPointer = matches[2];
      if (jsonPointer == "#") {
        if (up >= lvl)
          throw new Error("Cannot access property/index " + up + " levels up, current level is " + lvl);
        return paths[lvl - up];
      }
      if (up > lvl)
        throw new Error("Cannot access data " + up + " levels up, current level is " + lvl);
      data = "data" + (lvl - up || "");
      if (!jsonPointer)
        return data;
    }
    var expr = data;
    var segments = jsonPointer.split("/");
    for (var i = 0; i < segments.length; i++) {
      var segment = segments[i];
      if (segment) {
        data += getProperty(unescapeJsonPointer(segment));
        expr += " && " + data;
      }
    }
    return expr;
  }
  function joinPaths(a, b) {
    if (a == '""')
      return b;
    return (a + " + " + b).replace(/([^\\])' \+ '/g, "$1");
  }
  function unescapeFragment(str) {
    return unescapeJsonPointer(decodeURIComponent(str));
  }
  function escapeFragment(str) {
    return encodeURIComponent(escapeJsonPointer(str));
  }
  function escapeJsonPointer(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
  function unescapeJsonPointer(str) {
    return str.replace(/~1/g, "/").replace(/~0/g, "~");
  }
});

// node_modules/ajv/lib/compile/schema_obj.js
var require_schema_obj = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_util();
  module2.exports = SchemaObject;
  function SchemaObject(obj) {
    util.copy(obj, this);
  }
});

// node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS((exports2, module2) => {
  "use strict";
  var traverse = module2.exports = function(schema, opts, cb) {
    if (typeof opts == "function") {
      cb = opts;
      opts = {};
    }
    cb = opts.cb || cb;
    var pre = typeof cb == "function" ? cb : cb.pre || function() {
    };
    var post = cb.post || function() {
    };
    _traverse(opts, pre, post, schema, "", schema);
  };
  traverse.keywords = {
    additionalItems: true,
    items: true,
    contains: true,
    additionalProperties: true,
    propertyNames: true,
    not: true
  };
  traverse.arrayKeywords = {
    items: true,
    allOf: true,
    anyOf: true,
    oneOf: true
  };
  traverse.propsKeywords = {
    definitions: true,
    properties: true,
    patternProperties: true,
    dependencies: true
  };
  traverse.skipKeywords = {
    default: true,
    enum: true,
    const: true,
    required: true,
    maximum: true,
    minimum: true,
    exclusiveMaximum: true,
    exclusiveMinimum: true,
    multipleOf: true,
    maxLength: true,
    minLength: true,
    pattern: true,
    format: true,
    maxItems: true,
    minItems: true,
    uniqueItems: true,
    maxProperties: true,
    minProperties: true
  };
  function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (schema && typeof schema == "object" && !Array.isArray(schema)) {
      pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      for (var key in schema) {
        var sch = schema[key];
        if (Array.isArray(sch)) {
          if (key in traverse.arrayKeywords) {
            for (var i = 0; i < sch.length; i++)
              _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
          }
        } else if (key in traverse.propsKeywords) {
          if (sch && typeof sch == "object") {
            for (var prop in sch)
              _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
          }
        } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
          _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
        }
      }
      post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    }
  }
  function escapeJsonPtr(str) {
    return str.replace(/~/g, "~0").replace(/\//g, "~1");
  }
});

// node_modules/ajv/lib/compile/resolve.js
var require_resolve = __commonJS((exports2, module2) => {
  "use strict";
  var URI = require_uri_all();
  var equal = require_fast_deep_equal();
  var util = require_util();
  var SchemaObject = require_schema_obj();
  var traverse = require_json_schema_traverse();
  module2.exports = resolve;
  resolve.normalizeId = normalizeId;
  resolve.fullPath = getFullPath;
  resolve.url = resolveUrl;
  resolve.ids = resolveIds;
  resolve.inlineRef = inlineRef;
  resolve.schema = resolveSchema;
  function resolve(compile, root, ref) {
    var refVal = this._refs[ref];
    if (typeof refVal == "string") {
      if (this._refs[refVal])
        refVal = this._refs[refVal];
      else
        return resolve.call(this, compile, root, refVal);
    }
    refVal = refVal || this._schemas[ref];
    if (refVal instanceof SchemaObject) {
      return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
    }
    var res = resolveSchema.call(this, root, ref);
    var schema, v, baseId;
    if (res) {
      schema = res.schema;
      root = res.root;
      baseId = res.baseId;
    }
    if (schema instanceof SchemaObject) {
      v = schema.validate || compile.call(this, schema.schema, root, void 0, baseId);
    } else if (schema !== void 0) {
      v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, void 0, baseId);
    }
    return v;
  }
  function resolveSchema(root, ref) {
    var p = URI.parse(ref), refPath = _getFullPath(p), baseId = getFullPath(this._getId(root.schema));
    if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
      var id = normalizeId(refPath);
      var refVal = this._refs[id];
      if (typeof refVal == "string") {
        return resolveRecursive.call(this, root, refVal, p);
      } else if (refVal instanceof SchemaObject) {
        if (!refVal.validate)
          this._compile(refVal);
        root = refVal;
      } else {
        refVal = this._schemas[id];
        if (refVal instanceof SchemaObject) {
          if (!refVal.validate)
            this._compile(refVal);
          if (id == normalizeId(ref))
            return {schema: refVal, root, baseId};
          root = refVal;
        } else {
          return;
        }
      }
      if (!root.schema)
        return;
      baseId = getFullPath(this._getId(root.schema));
    }
    return getJsonPointer.call(this, p, baseId, root.schema, root);
  }
  function resolveRecursive(root, ref, parsedRef) {
    var res = resolveSchema.call(this, root, ref);
    if (res) {
      var schema = res.schema;
      var baseId = res.baseId;
      root = res.root;
      var id = this._getId(schema);
      if (id)
        baseId = resolveUrl(baseId, id);
      return getJsonPointer.call(this, parsedRef, baseId, schema, root);
    }
  }
  var PREVENT_SCOPE_CHANGE = util.toHash(["properties", "patternProperties", "enum", "dependencies", "definitions"]);
  function getJsonPointer(parsedRef, baseId, schema, root) {
    parsedRef.fragment = parsedRef.fragment || "";
    if (parsedRef.fragment.slice(0, 1) != "/")
      return;
    var parts = parsedRef.fragment.split("/");
    for (var i = 1; i < parts.length; i++) {
      var part = parts[i];
      if (part) {
        part = util.unescapeFragment(part);
        schema = schema[part];
        if (schema === void 0)
          break;
        var id;
        if (!PREVENT_SCOPE_CHANGE[part]) {
          id = this._getId(schema);
          if (id)
            baseId = resolveUrl(baseId, id);
          if (schema.$ref) {
            var $ref = resolveUrl(baseId, schema.$ref);
            var res = resolveSchema.call(this, root, $ref);
            if (res) {
              schema = res.schema;
              root = res.root;
              baseId = res.baseId;
            }
          }
        }
      }
    }
    if (schema !== void 0 && schema !== root.schema)
      return {schema, root, baseId};
  }
  var SIMPLE_INLINED = util.toHash([
    "type",
    "format",
    "pattern",
    "maxLength",
    "minLength",
    "maxProperties",
    "minProperties",
    "maxItems",
    "minItems",
    "maximum",
    "minimum",
    "uniqueItems",
    "multipleOf",
    "required",
    "enum"
  ]);
  function inlineRef(schema, limit) {
    if (limit === false)
      return false;
    if (limit === void 0 || limit === true)
      return checkNoRef(schema);
    else if (limit)
      return countKeys(schema) <= limit;
  }
  function checkNoRef(schema) {
    var item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return false;
        item = schema[key];
        if (typeof item == "object" && !checkNoRef(item))
          return false;
      }
    }
    return true;
  }
  function countKeys(schema) {
    var count = 0, item;
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++) {
        item = schema[i];
        if (typeof item == "object")
          count += countKeys(item);
        if (count == Infinity)
          return Infinity;
      }
    } else {
      for (var key in schema) {
        if (key == "$ref")
          return Infinity;
        if (SIMPLE_INLINED[key]) {
          count++;
        } else {
          item = schema[key];
          if (typeof item == "object")
            count += countKeys(item) + 1;
          if (count == Infinity)
            return Infinity;
        }
      }
    }
    return count;
  }
  function getFullPath(id, normalize) {
    if (normalize !== false)
      id = normalizeId(id);
    var p = URI.parse(id);
    return _getFullPath(p);
  }
  function _getFullPath(p) {
    return URI.serialize(p).split("#")[0] + "#";
  }
  var TRAILING_SLASH_HASH = /#\/?$/;
  function normalizeId(id) {
    return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
  }
  function resolveUrl(baseId, id) {
    id = normalizeId(id);
    return URI.resolve(baseId, id);
  }
  function resolveIds(schema) {
    var schemaId = normalizeId(this._getId(schema));
    var baseIds = {"": schemaId};
    var fullPaths = {"": getFullPath(schemaId, false)};
    var localRefs = {};
    var self2 = this;
    traverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (jsonPtr === "")
        return;
      var id = self2._getId(sch);
      var baseId = baseIds[parentJsonPtr];
      var fullPath = fullPaths[parentJsonPtr] + "/" + parentKeyword;
      if (keyIndex !== void 0)
        fullPath += "/" + (typeof keyIndex == "number" ? keyIndex : util.escapeFragment(keyIndex));
      if (typeof id == "string") {
        id = baseId = normalizeId(baseId ? URI.resolve(baseId, id) : id);
        var refVal = self2._refs[id];
        if (typeof refVal == "string")
          refVal = self2._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(sch, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == "#") {
            if (localRefs[id] && !equal(sch, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = sch;
          } else {
            self2._refs[id] = fullPath;
          }
        }
      }
      baseIds[jsonPtr] = baseId;
      fullPaths[jsonPtr] = fullPath;
    });
    return localRefs;
  }
});

// node_modules/ajv/lib/compile/error_classes.js
var require_error_classes = __commonJS((exports2, module2) => {
  "use strict";
  var resolve = require_resolve();
  module2.exports = {
    Validation: errorSubclass(ValidationError),
    MissingRef: errorSubclass(MissingRefError)
  };
  function ValidationError(errors) {
    this.message = "validation failed";
    this.errors = errors;
    this.ajv = this.validation = true;
  }
  MissingRefError.message = function(baseId, ref) {
    return "can't resolve reference " + ref + " from id " + baseId;
  };
  function MissingRefError(baseId, ref, message) {
    this.message = message || MissingRefError.message(baseId, ref);
    this.missingRef = resolve.url(baseId, ref);
    this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
  }
  function errorSubclass(Subclass) {
    Subclass.prototype = Object.create(Error.prototype);
    Subclass.prototype.constructor = Subclass;
    return Subclass;
  }
});

// node_modules/fast-json-stable-stringify/index.js
var require_fast_json_stable_stringify = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function(data, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = {cmp: opts};
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = {key: a, value: node[a]};
          var bobj = {key: b, value: node[b]};
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(node) {
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      if (node === void 0)
        return;
      if (typeof node == "number")
        return isFinite(node) ? "" + node : "null";
      if (typeof node !== "object")
        return JSON.stringify(node);
      var i, out;
      if (Array.isArray(node)) {
        out = "[";
        for (i = 0; i < node.length; i++) {
          if (i)
            out += ",";
          out += stringify(node[i]) || "null";
        }
        return out + "]";
      }
      if (node === null)
        return "null";
      if (seen.indexOf(node) !== -1) {
        if (cycles)
          return JSON.stringify("__cycle__");
        throw new TypeError("Converting circular structure to JSON");
      }
      var seenIndex = seen.push(node) - 1;
      var keys = Object.keys(node).sort(cmp && cmp(node));
      out = "";
      for (i = 0; i < keys.length; i++) {
        var key = keys[i];
        var value = stringify(node[key]);
        if (!value)
          continue;
        if (out)
          out += ",";
        out += JSON.stringify(key) + ":" + value;
      }
      seen.splice(seenIndex, 1);
      return "{" + out + "}";
    }(data);
  };
});

// node_modules/ajv/lib/dotjs/validate.js
var require_validate = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_validate(it2, $keyword, $ruleType) {
    var out = "";
    var $async = it2.schema.$async === true, $refKeywords = it2.util.schemaHasRulesExcept(it2.schema, it2.RULES.all, "$ref"), $id = it2.self._getId(it2.schema);
    if (it2.opts.strictKeywords) {
      var $unknownKwd = it2.util.schemaUnknownRules(it2.schema, it2.RULES.keywords);
      if ($unknownKwd) {
        var $keywordsMsg = "unknown keyword: " + $unknownKwd;
        if (it2.opts.strictKeywords === "log")
          it2.logger.warn($keywordsMsg);
        else
          throw new Error($keywordsMsg);
      }
    }
    if (it2.isTop) {
      out += " var validate = ";
      if ($async) {
        it2.async = true;
        out += "async ";
      }
      out += "function(data, dataPath, parentData, parentDataProperty, rootData) { 'use strict'; ";
      if ($id && (it2.opts.sourceCode || it2.opts.processCode)) {
        out += " " + ("/*# sourceURL=" + $id + " */") + " ";
      }
    }
    if (typeof it2.schema == "boolean" || !($refKeywords || it2.schema.$ref)) {
      var $keyword = "false schema";
      var $lvl = it2.level;
      var $dataLvl = it2.dataLevel;
      var $schema = it2.schema[$keyword];
      var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
      var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
      var $breakOnError = !it2.opts.allErrors;
      var $errorKeyword;
      var $data = "data" + ($dataLvl || "");
      var $valid = "valid" + $lvl;
      if (it2.schema === false) {
        if (it2.isTop) {
          $breakOnError = true;
        } else {
          out += " var " + $valid + " = false; ";
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "false schema") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
          if (it2.opts.messages !== false) {
            out += " , message: 'boolean schema is false' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
      } else {
        if (it2.isTop) {
          if ($async) {
            out += " return data; ";
          } else {
            out += " validate.errors = null; return true; ";
          }
        } else {
          out += " var " + $valid + " = true; ";
        }
      }
      if (it2.isTop) {
        out += " }; return validate; ";
      }
      return out;
    }
    if (it2.isTop) {
      var $top = it2.isTop, $lvl = it2.level = 0, $dataLvl = it2.dataLevel = 0, $data = "data";
      it2.rootId = it2.resolve.fullPath(it2.self._getId(it2.root.schema));
      it2.baseId = it2.baseId || it2.rootId;
      delete it2.isTop;
      it2.dataPathArr = [""];
      if (it2.schema.default !== void 0 && it2.opts.useDefaults && it2.opts.strictDefaults) {
        var $defaultMsg = "default is ignored in the schema root";
        if (it2.opts.strictDefaults === "log")
          it2.logger.warn($defaultMsg);
        else
          throw new Error($defaultMsg);
      }
      out += " var vErrors = null; ";
      out += " var errors = 0;     ";
      out += " if (rootData === undefined) rootData = data; ";
    } else {
      var $lvl = it2.level, $dataLvl = it2.dataLevel, $data = "data" + ($dataLvl || "");
      if ($id)
        it2.baseId = it2.resolve.url(it2.baseId, $id);
      if ($async && !it2.async)
        throw new Error("async schema in sync schema");
      out += " var errs_" + $lvl + " = errors;";
    }
    var $valid = "valid" + $lvl, $breakOnError = !it2.opts.allErrors, $closingBraces1 = "", $closingBraces2 = "";
    var $errorKeyword;
    var $typeSchema = it2.schema.type, $typeIsArray = Array.isArray($typeSchema);
    if ($typeSchema && it2.opts.nullable && it2.schema.nullable === true) {
      if ($typeIsArray) {
        if ($typeSchema.indexOf("null") == -1)
          $typeSchema = $typeSchema.concat("null");
      } else if ($typeSchema != "null") {
        $typeSchema = [$typeSchema, "null"];
        $typeIsArray = true;
      }
    }
    if ($typeIsArray && $typeSchema.length == 1) {
      $typeSchema = $typeSchema[0];
      $typeIsArray = false;
    }
    if (it2.schema.$ref && $refKeywords) {
      if (it2.opts.extendRefs == "fail") {
        throw new Error('$ref: validation keywords used in schema at path "' + it2.errSchemaPath + '" (see option extendRefs)');
      } else if (it2.opts.extendRefs !== true) {
        $refKeywords = false;
        it2.logger.warn('$ref: keywords ignored in schema at path "' + it2.errSchemaPath + '"');
      }
    }
    if (it2.schema.$comment && it2.opts.$comment) {
      out += " " + it2.RULES.all.$comment.code(it2, "$comment");
    }
    if ($typeSchema) {
      if (it2.opts.coerceTypes) {
        var $coerceToTypes = it2.util.coerceToTypes(it2.opts.coerceTypes, $typeSchema);
      }
      var $rulesGroup = it2.RULES.types[$typeSchema];
      if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
        var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
        var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type", $method = $typeIsArray ? "checkDataTypes" : "checkDataType";
        out += " if (" + it2.util[$method]($typeSchema, $data, it2.opts.strictNumbers, true) + ") { ";
        if ($coerceToTypes) {
          var $dataType = "dataType" + $lvl, $coerced = "coerced" + $lvl;
          out += " var " + $dataType + " = typeof " + $data + "; var " + $coerced + " = undefined; ";
          if (it2.opts.coerceTypes == "array") {
            out += " if (" + $dataType + " == 'object' && Array.isArray(" + $data + ") && " + $data + ".length == 1) { " + $data + " = " + $data + "[0]; " + $dataType + " = typeof " + $data + "; if (" + it2.util.checkDataType(it2.schema.type, $data, it2.opts.strictNumbers) + ") " + $coerced + " = " + $data + "; } ";
          }
          out += " if (" + $coerced + " !== undefined) ; ";
          var arr1 = $coerceToTypes;
          if (arr1) {
            var $type, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $type = arr1[$i += 1];
              if ($type == "string") {
                out += " else if (" + $dataType + " == 'number' || " + $dataType + " == 'boolean') " + $coerced + " = '' + " + $data + "; else if (" + $data + " === null) " + $coerced + " = ''; ";
              } else if ($type == "number" || $type == "integer") {
                out += " else if (" + $dataType + " == 'boolean' || " + $data + " === null || (" + $dataType + " == 'string' && " + $data + " && " + $data + " == +" + $data + " ";
                if ($type == "integer") {
                  out += " && !(" + $data + " % 1)";
                }
                out += ")) " + $coerced + " = +" + $data + "; ";
              } else if ($type == "boolean") {
                out += " else if (" + $data + " === 'false' || " + $data + " === 0 || " + $data + " === null) " + $coerced + " = false; else if (" + $data + " === 'true' || " + $data + " === 1) " + $coerced + " = true; ";
              } else if ($type == "null") {
                out += " else if (" + $data + " === '' || " + $data + " === 0 || " + $data + " === false) " + $coerced + " = null; ";
              } else if (it2.opts.coerceTypes == "array" && $type == "array") {
                out += " else if (" + $dataType + " == 'string' || " + $dataType + " == 'number' || " + $dataType + " == 'boolean' || " + $data + " == null) " + $coerced + " = [" + $data + "]; ";
              }
            }
          }
          out += " else {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } if (" + $coerced + " !== undefined) {  ";
          var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
          out += " " + $data + " = " + $coerced + "; ";
          if (!$dataLvl) {
            out += "if (" + $parentData + " !== undefined)";
          }
          out += " " + $parentData + "[" + $parentDataProperty + "] = " + $coerced + "; } ";
        } else {
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
            if ($typeIsArray) {
              out += "" + $typeSchema.join(",");
            } else {
              out += "" + $typeSchema;
            }
            out += "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should be ";
              if ($typeIsArray) {
                out += "" + $typeSchema.join(",");
              } else {
                out += "" + $typeSchema;
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        }
        out += " } ";
      }
    }
    if (it2.schema.$ref && !$refKeywords) {
      out += " " + it2.RULES.all.$ref.code(it2, "$ref") + " ";
      if ($breakOnError) {
        out += " } if (errors === ";
        if ($top) {
          out += "0";
        } else {
          out += "errs_" + $lvl;
        }
        out += ") { ";
        $closingBraces2 += "}";
      }
    } else {
      var arr2 = it2.RULES;
      if (arr2) {
        var $rulesGroup, i2 = -1, l2 = arr2.length - 1;
        while (i2 < l2) {
          $rulesGroup = arr2[i2 += 1];
          if ($shouldUseGroup($rulesGroup)) {
            if ($rulesGroup.type) {
              out += " if (" + it2.util.checkDataType($rulesGroup.type, $data, it2.opts.strictNumbers) + ") { ";
            }
            if (it2.opts.useDefaults) {
              if ($rulesGroup.type == "object" && it2.schema.properties) {
                var $schema = it2.schema.properties, $schemaKeys = Object.keys($schema);
                var arr3 = $schemaKeys;
                if (arr3) {
                  var $propertyKey, i3 = -1, l3 = arr3.length - 1;
                  while (i3 < l3) {
                    $propertyKey = arr3[i3 += 1];
                    var $sch = $schema[$propertyKey];
                    if ($sch.default !== void 0) {
                      var $passData = $data + it2.util.getProperty($propertyKey);
                      if (it2.compositeRule) {
                        if (it2.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it2.opts.strictDefaults === "log")
                            it2.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it2.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it2.opts.useDefaults == "shared") {
                          out += " " + it2.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              } else if ($rulesGroup.type == "array" && Array.isArray(it2.schema.items)) {
                var arr4 = it2.schema.items;
                if (arr4) {
                  var $sch, $i = -1, l4 = arr4.length - 1;
                  while ($i < l4) {
                    $sch = arr4[$i += 1];
                    if ($sch.default !== void 0) {
                      var $passData = $data + "[" + $i + "]";
                      if (it2.compositeRule) {
                        if (it2.opts.strictDefaults) {
                          var $defaultMsg = "default is ignored for: " + $passData;
                          if (it2.opts.strictDefaults === "log")
                            it2.logger.warn($defaultMsg);
                          else
                            throw new Error($defaultMsg);
                        }
                      } else {
                        out += " if (" + $passData + " === undefined ";
                        if (it2.opts.useDefaults == "empty") {
                          out += " || " + $passData + " === null || " + $passData + " === '' ";
                        }
                        out += " ) " + $passData + " = ";
                        if (it2.opts.useDefaults == "shared") {
                          out += " " + it2.useDefault($sch.default) + " ";
                        } else {
                          out += " " + JSON.stringify($sch.default) + " ";
                        }
                        out += "; ";
                      }
                    }
                  }
                }
              }
            }
            var arr5 = $rulesGroup.rules;
            if (arr5) {
              var $rule, i5 = -1, l5 = arr5.length - 1;
              while (i5 < l5) {
                $rule = arr5[i5 += 1];
                if ($shouldUseRule($rule)) {
                  var $code = $rule.code(it2, $rule.keyword, $rulesGroup.type);
                  if ($code) {
                    out += " " + $code + " ";
                    if ($breakOnError) {
                      $closingBraces1 += "}";
                    }
                  }
                }
              }
            }
            if ($breakOnError) {
              out += " " + $closingBraces1 + " ";
              $closingBraces1 = "";
            }
            if ($rulesGroup.type) {
              out += " } ";
              if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                out += " else { ";
                var $schemaPath = it2.schemaPath + ".type", $errSchemaPath = it2.errSchemaPath + "/type";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it2.createErrors !== false) {
                  out += " { keyword: '" + ($errorKeyword || "type") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { type: '";
                  if ($typeIsArray) {
                    out += "" + $typeSchema.join(",");
                  } else {
                    out += "" + $typeSchema;
                  }
                  out += "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: 'should be ";
                    if ($typeIsArray) {
                      out += "" + $typeSchema.join(",");
                    } else {
                      out += "" + $typeSchema;
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it2.compositeRule && $breakOnError) {
                  if (it2.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                out += " } ";
              }
            }
            if ($breakOnError) {
              out += " if (errors === ";
              if ($top) {
                out += "0";
              } else {
                out += "errs_" + $lvl;
              }
              out += ") { ";
              $closingBraces2 += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces2 + " ";
    }
    if ($top) {
      if ($async) {
        out += " if (errors === 0) return data;           ";
        out += " else throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; ";
        out += " return errors === 0;       ";
      }
      out += " }; return validate;";
    } else {
      out += " var " + $valid + " = errors === errs_" + $lvl + ";";
    }
    function $shouldUseGroup($rulesGroup2) {
      var rules = $rulesGroup2.rules;
      for (var i = 0; i < rules.length; i++)
        if ($shouldUseRule(rules[i]))
          return true;
    }
    function $shouldUseRule($rule2) {
      return it2.schema[$rule2.keyword] !== void 0 || $rule2.implements && $ruleImplementsSomeKeyword($rule2);
    }
    function $ruleImplementsSomeKeyword($rule2) {
      var impl = $rule2.implements;
      for (var i = 0; i < impl.length; i++)
        if (it2.schema[impl[i]] !== void 0)
          return true;
    }
    return out;
  };
});

// node_modules/ajv/lib/compile/index.js
var require_compile2 = __commonJS((exports2, module2) => {
  "use strict";
  var resolve = require_resolve();
  var util = require_util();
  var errorClasses = require_error_classes();
  var stableStringify = require_fast_json_stable_stringify();
  var validateGenerator = require_validate();
  var ucs2length = util.ucs2length;
  var equal = require_fast_deep_equal();
  var ValidationError = errorClasses.Validation;
  module2.exports = compile;
  function compile(schema, root, localRefs, baseId) {
    var self2 = this, opts = this._opts, refVal = [void 0], refs = {}, patterns = [], patternsHash = {}, defaults = [], defaultsHash = {}, customRules = [];
    root = root || {schema, refVal, refs};
    var c = checkCompiling.call(this, schema, root, baseId);
    var compilation = this._compilations[c.index];
    if (c.compiling)
      return compilation.callValidate = callValidate;
    var formats = this._formats;
    var RULES = this.RULES;
    try {
      var v = localCompile(schema, root, localRefs, baseId);
      compilation.validate = v;
      var cv = compilation.callValidate;
      if (cv) {
        cv.schema = v.schema;
        cv.errors = null;
        cv.refs = v.refs;
        cv.refVal = v.refVal;
        cv.root = v.root;
        cv.$async = v.$async;
        if (opts.sourceCode)
          cv.source = v.source;
      }
      return v;
    } finally {
      endCompiling.call(this, schema, root, baseId);
    }
    function callValidate() {
      var validate = compilation.validate;
      var result = validate.apply(this, arguments);
      callValidate.errors = validate.errors;
      return result;
    }
    function localCompile(_schema, _root, localRefs2, baseId2) {
      var isRoot = !_root || _root && _root.schema == _schema;
      if (_root.schema != root.schema)
        return compile.call(self2, _schema, _root, localRefs2, baseId2);
      var $async = _schema.$async === true;
      var sourceCode = validateGenerator({
        isTop: true,
        schema: _schema,
        isRoot,
        baseId: baseId2,
        root: _root,
        schemaPath: "",
        errSchemaPath: "#",
        errorPath: '""',
        MissingRefError: errorClasses.MissingRef,
        RULES,
        validate: validateGenerator,
        util,
        resolve,
        resolveRef,
        usePattern,
        useDefault,
        useCustomRule,
        opts,
        formats,
        logger: self2.logger,
        self: self2
      });
      sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;
      if (opts.processCode)
        sourceCode = opts.processCode(sourceCode, _schema);
      var validate;
      try {
        var makeValidate = new Function("self", "RULES", "formats", "root", "refVal", "defaults", "customRules", "equal", "ucs2length", "ValidationError", sourceCode);
        validate = makeValidate(self2, RULES, formats, root, refVal, defaults, customRules, equal, ucs2length, ValidationError);
        refVal[0] = validate;
      } catch (e) {
        self2.logger.error("Error compiling schema, function code:", sourceCode);
        throw e;
      }
      validate.schema = _schema;
      validate.errors = null;
      validate.refs = refs;
      validate.refVal = refVal;
      validate.root = isRoot ? validate : _root;
      if ($async)
        validate.$async = true;
      if (opts.sourceCode === true) {
        validate.source = {
          code: sourceCode,
          patterns,
          defaults
        };
      }
      return validate;
    }
    function resolveRef(baseId2, ref, isRoot) {
      ref = resolve.url(baseId2, ref);
      var refIndex = refs[ref];
      var _refVal, refCode;
      if (refIndex !== void 0) {
        _refVal = refVal[refIndex];
        refCode = "refVal[" + refIndex + "]";
        return resolvedRef(_refVal, refCode);
      }
      if (!isRoot && root.refs) {
        var rootRefId = root.refs[ref];
        if (rootRefId !== void 0) {
          _refVal = root.refVal[rootRefId];
          refCode = addLocalRef(ref, _refVal);
          return resolvedRef(_refVal, refCode);
        }
      }
      refCode = addLocalRef(ref);
      var v2 = resolve.call(self2, localCompile, root, ref);
      if (v2 === void 0) {
        var localSchema = localRefs && localRefs[ref];
        if (localSchema) {
          v2 = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self2, localSchema, root, localRefs, baseId2);
        }
      }
      if (v2 === void 0) {
        removeLocalRef(ref);
      } else {
        replaceLocalRef(ref, v2);
        return resolvedRef(v2, refCode);
      }
    }
    function addLocalRef(ref, v2) {
      var refId = refVal.length;
      refVal[refId] = v2;
      refs[ref] = refId;
      return "refVal" + refId;
    }
    function removeLocalRef(ref) {
      delete refs[ref];
    }
    function replaceLocalRef(ref, v2) {
      var refId = refs[ref];
      refVal[refId] = v2;
    }
    function resolvedRef(refVal2, code) {
      return typeof refVal2 == "object" || typeof refVal2 == "boolean" ? {code, schema: refVal2, inline: true} : {code, $async: refVal2 && !!refVal2.$async};
    }
    function usePattern(regexStr) {
      var index = patternsHash[regexStr];
      if (index === void 0) {
        index = patternsHash[regexStr] = patterns.length;
        patterns[index] = regexStr;
      }
      return "pattern" + index;
    }
    function useDefault(value) {
      switch (typeof value) {
        case "boolean":
        case "number":
          return "" + value;
        case "string":
          return util.toQuotedString(value);
        case "object":
          if (value === null)
            return "null";
          var valueStr = stableStringify(value);
          var index = defaultsHash[valueStr];
          if (index === void 0) {
            index = defaultsHash[valueStr] = defaults.length;
            defaults[index] = value;
          }
          return "default" + index;
      }
    }
    function useCustomRule(rule, schema2, parentSchema, it2) {
      if (self2._opts.validateSchema !== false) {
        var deps = rule.definition.dependencies;
        if (deps && !deps.every(function(keyword) {
          return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
        }))
          throw new Error("parent schema must have all required keywords: " + deps.join(","));
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema) {
          var valid = validateSchema(schema2);
          if (!valid) {
            var message = "keyword schema is invalid: " + self2.errorsText(validateSchema.errors);
            if (self2._opts.validateSchema == "log")
              self2.logger.error(message);
            else
              throw new Error(message);
          }
        }
      }
      var compile2 = rule.definition.compile, inline = rule.definition.inline, macro = rule.definition.macro;
      var validate;
      if (compile2) {
        validate = compile2.call(self2, schema2, parentSchema, it2);
      } else if (macro) {
        validate = macro.call(self2, schema2, parentSchema, it2);
        if (opts.validateSchema !== false)
          self2.validateSchema(validate, true);
      } else if (inline) {
        validate = inline.call(self2, it2, rule.keyword, schema2, parentSchema);
      } else {
        validate = rule.definition.validate;
        if (!validate)
          return;
      }
      if (validate === void 0)
        throw new Error('custom keyword "' + rule.keyword + '"failed to compile');
      var index = customRules.length;
      customRules[index] = validate;
      return {
        code: "customRule" + index,
        validate
      };
    }
  }
  function checkCompiling(schema, root, baseId) {
    var index = compIndex.call(this, schema, root, baseId);
    if (index >= 0)
      return {index, compiling: true};
    index = this._compilations.length;
    this._compilations[index] = {
      schema,
      root,
      baseId
    };
    return {index, compiling: false};
  }
  function endCompiling(schema, root, baseId) {
    var i = compIndex.call(this, schema, root, baseId);
    if (i >= 0)
      this._compilations.splice(i, 1);
  }
  function compIndex(schema, root, baseId) {
    for (var i = 0; i < this._compilations.length; i++) {
      var c = this._compilations[i];
      if (c.schema == schema && c.root == root && c.baseId == baseId)
        return i;
    }
    return -1;
  }
  function patternCode(i, patterns) {
    return "var pattern" + i + " = new RegExp(" + util.toQuotedString(patterns[i]) + ");";
  }
  function defaultCode(i) {
    return "var default" + i + " = defaults[" + i + "];";
  }
  function refValCode(i, refVal) {
    return refVal[i] === void 0 ? "" : "var refVal" + i + " = refVal[" + i + "];";
  }
  function customRuleCode(i) {
    return "var customRule" + i + " = customRules[" + i + "];";
  }
  function vars(arr, statement) {
    if (!arr.length)
      return "";
    var code = "";
    for (var i = 0; i < arr.length; i++)
      code += statement(i, arr);
    return code;
  }
});

// node_modules/ajv/lib/cache.js
var require_cache = __commonJS((exports2, module2) => {
  "use strict";
  var Cache = module2.exports = function Cache2() {
    this._cache = {};
  };
  Cache.prototype.put = function Cache_put(key, value) {
    this._cache[key] = value;
  };
  Cache.prototype.get = function Cache_get(key) {
    return this._cache[key];
  };
  Cache.prototype.del = function Cache_del(key) {
    delete this._cache[key];
  };
  Cache.prototype.clear = function Cache_clear() {
    this._cache = {};
  };
});

// node_modules/ajv/lib/compile/formats.js
var require_formats = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_util();
  var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
  var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
  var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
  var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
  var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
  var URL2 = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
  var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
  var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
  var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
  var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;
  module2.exports = formats;
  function formats(mode) {
    mode = mode == "full" ? "full" : "fast";
    return util.copy(formats[mode]);
  }
  formats.fast = {
    date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
    time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
    "date-time": /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
    uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
    "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  formats.full = {
    date,
    time,
    "date-time": date_time,
    uri,
    "uri-reference": URIREF,
    "uri-template": URITEMPLATE,
    url: URL2,
    email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
    hostname: HOSTNAME,
    ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
    ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
    regex,
    uuid: UUID,
    "json-pointer": JSON_POINTER,
    "json-pointer-uri-fragment": JSON_POINTER_URI_FRAGMENT,
    "relative-json-pointer": RELATIVE_JSON_POINTER
  };
  function isLeapYear(year) {
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
  }
  function date(str) {
    var matches = str.match(DATE);
    if (!matches)
      return false;
    var year = +matches[1];
    var month = +matches[2];
    var day = +matches[3];
    return month >= 1 && month <= 12 && day >= 1 && day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
  }
  function time(str, full) {
    var matches = str.match(TIME);
    if (!matches)
      return false;
    var hour = matches[1];
    var minute = matches[2];
    var second = matches[3];
    var timeZone = matches[5];
    return (hour <= 23 && minute <= 59 && second <= 59 || hour == 23 && minute == 59 && second == 60) && (!full || timeZone);
  }
  var DATE_TIME_SEPARATOR = /t|\s/i;
  function date_time(str) {
    var dateTime = str.split(DATE_TIME_SEPARATOR);
    return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
  }
  var NOT_URI_FRAGMENT = /\/|:/;
  function uri(str) {
    return NOT_URI_FRAGMENT.test(str) && URI.test(str);
  }
  var Z_ANCHOR = /[^\\]\\Z/;
  function regex(str) {
    if (Z_ANCHOR.test(str))
      return false;
    try {
      new RegExp(str);
      return true;
    } catch (e) {
      return false;
    }
  }
});

// node_modules/ajv/lib/dotjs/ref.js
var require_ref = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_ref(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $async, $refCode;
    if ($schema == "#" || $schema == "#/") {
      if (it2.isRoot) {
        $async = it2.async;
        $refCode = "validate";
      } else {
        $async = it2.root.schema.$async === true;
        $refCode = "root.refVal[0]";
      }
    } else {
      var $refVal = it2.resolveRef(it2.baseId, $schema, it2.isRoot);
      if ($refVal === void 0) {
        var $message = it2.MissingRefError.message(it2.baseId, $schema);
        if (it2.opts.missingRefs == "fail") {
          it2.logger.error($message);
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: '$ref' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { ref: '" + it2.util.escapeQuotes($schema) + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'can\\'t resolve reference " + it2.util.escapeQuotes($schema) + "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: " + it2.util.toQuotedString($schema) + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          if ($breakOnError) {
            out += " if (false) { ";
          }
        } else if (it2.opts.missingRefs == "ignore") {
          it2.logger.warn($message);
          if ($breakOnError) {
            out += " if (true) { ";
          }
        } else {
          throw new it2.MissingRefError(it2.baseId, $schema, $message);
        }
      } else if ($refVal.inline) {
        var $it = it2.util.copy(it2);
        $it.level++;
        var $nextValid = "valid" + $it.level;
        $it.schema = $refVal.schema;
        $it.schemaPath = "";
        $it.errSchemaPath = $schema;
        var $code = it2.validate($it).replace(/validate\.schema/g, $refVal.code);
        out += " " + $code + " ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
        }
      } else {
        $async = $refVal.$async === true || it2.async && $refVal.$async !== false;
        $refCode = $refVal.code;
      }
    }
    if ($refCode) {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.opts.passContext) {
        out += " " + $refCode + ".call(this, ";
      } else {
        out += " " + $refCode + "( ";
      }
      out += " " + $data + ", (dataPath || '')";
      if (it2.errorPath != '""') {
        out += " + " + it2.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + ", rootData)  ";
      var __callValidate = out;
      out = $$outStack.pop();
      if ($async) {
        if (!it2.async)
          throw new Error("async schema referenced by sync schema");
        if ($breakOnError) {
          out += " var " + $valid + "; ";
        }
        out += " try { await " + __callValidate + "; ";
        if ($breakOnError) {
          out += " " + $valid + " = true; ";
        }
        out += " } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ";
        if ($breakOnError) {
          out += " " + $valid + " = false; ";
        }
        out += " } ";
        if ($breakOnError) {
          out += " if (" + $valid + ") { ";
        }
      } else {
        out += " if (!" + __callValidate + ") { if (vErrors === null) vErrors = " + $refCode + ".errors; else vErrors = vErrors.concat(" + $refCode + ".errors); errors = vErrors.length; } ";
        if ($breakOnError) {
          out += " else { ";
        }
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/allOf.js
var require_allOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_allOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $allSchemasEmpty = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
          $allSchemasEmpty = false;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($breakOnError) {
      if ($allSchemasEmpty) {
        out += " if (true) { ";
      } else {
        out += " " + $closingBraces.slice(0, -1) + " ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/anyOf.js
var require_anyOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_anyOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $noEmptySchema = $schema.every(function($sch2) {
      return it2.opts.strictKeywords ? typeof $sch2 == "object" && Object.keys($sch2).length > 0 || $sch2 === false : it2.util.schemaHasRules($sch2, it2.RULES.all);
    });
    if ($noEmptySchema) {
      var $currentBaseId = $it.baseId;
      out += " var " + $errs + " = errors; var " + $valid + " = false;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
          out += " " + $valid + " = " + $valid + " || " + $nextValid + "; if (!" + $valid + ") { ";
          $closingBraces += "}";
        }
      }
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $valid + ") {   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'anyOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should match some schema in anyOf' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it2.opts.allErrors) {
        out += " } ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/comment.js
var require_comment = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_comment(it2, $keyword, $ruleType) {
    var out = " ";
    var $schema = it2.schema[$keyword];
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $comment = it2.util.toQuotedString($schema);
    if (it2.opts.$comment === true) {
      out += " console.log(" + $comment + ");";
    } else if (typeof it2.opts.$comment == "function") {
      out += " self._opts.$comment(" + $comment + ", " + it2.util.toQuotedString($errSchemaPath) + ", validate.root.schema);";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/const.js
var require_const = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_const(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!$isData) {
      out += " var schema" + $lvl + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + " = equal(" + $data + ", schema" + $lvl + "); if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'const' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValue: schema" + $lvl + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be equal to constant' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/contains.js
var require_contains = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_contains(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId, $nonEmptySchema = it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all);
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($nonEmptySchema) {
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $nextValid + " = false; for (var " + $idx + " = 0; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      out += " if (" + $nextValid + ") break; }  ";
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $closingBraces + " if (!" + $nextValid + ") {";
    } else {
      out += " if (" + $data + ".length == 0) {";
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'contains' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should contain a valid item' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } else { ";
    if ($nonEmptySchema) {
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
    }
    if (it2.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/dependencies.js
var require_dependencies = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_dependencies(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $schemaDeps = {}, $propertyDeps = {}, $ownProperties = it2.opts.ownProperties;
    for ($property in $schema) {
      if ($property == "__proto__")
        continue;
      var $sch = $schema[$property];
      var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
      $deps[$property] = $sch;
    }
    out += "var " + $errs + " = errors;";
    var $currentErrorPath = it2.errorPath;
    out += "var missing" + $lvl + ";";
    for (var $property in $propertyDeps) {
      $deps = $propertyDeps[$property];
      if ($deps.length) {
        out += " if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
        }
        if ($breakOnError) {
          out += " && ( ";
          var arr1 = $deps;
          if (arr1) {
            var $propertyKey, $i = -1, l1 = arr1.length - 1;
            while ($i < l1) {
              $propertyKey = arr1[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ")) {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: 'should have ";
              if ($deps.length == 1) {
                out += "property " + it2.util.escapeQuotes($deps[0]);
              } else {
                out += "properties " + it2.util.escapeQuotes($deps.join(", "));
              }
              out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
        } else {
          out += " ) { ";
          var arr2 = $deps;
          if (arr2) {
            var $propertyKey, i2 = -1, l2 = arr2.length - 1;
            while (i2 < l2) {
              $propertyKey = arr2[i2 += 1];
              var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'dependencies' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { property: '" + it2.util.escapeQuotes($property) + "', missingProperty: '" + $missingProperty + "', depsCount: " + $deps.length + ", deps: '" + it2.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: 'should have ";
                  if ($deps.length == 1) {
                    out += "property " + it2.util.escapeQuotes($deps[0]);
                  } else {
                    out += "properties " + it2.util.escapeQuotes($deps.join(", "));
                  }
                  out += " when property " + it2.util.escapeQuotes($property) + " is present' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
        out += " }   ";
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
    }
    it2.errorPath = $currentErrorPath;
    var $currentBaseId = $it.baseId;
    for (var $property in $schemaDeps) {
      var $sch = $schemaDeps[$property];
      if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
        out += " " + $nextValid + " = true; if ( " + $data + it2.util.getProperty($property) + " !== undefined ";
        if ($ownProperties) {
          out += " && Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($property) + "') ";
        }
        out += ") { ";
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + it2.util.getProperty($property);
        $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($property);
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    }
    if ($breakOnError) {
      out += "   " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/enum.js
var require_enum = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_enum(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $i = "i" + $lvl, $vSchema = "schema" + $lvl;
    if (!$isData) {
      out += " var " + $vSchema + " = validate.schema" + $schemaPath + ";";
    }
    out += "var " + $valid + ";";
    if ($isData) {
      out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
    }
    out += "" + $valid + " = false;for (var " + $i + "=0; " + $i + "<" + $vSchema + ".length; " + $i + "++) if (equal(" + $data + ", " + $vSchema + "[" + $i + "])) { " + $valid + " = true; break; }";
    if ($isData) {
      out += "  }  ";
    }
    out += " if (!" + $valid + ") {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'enum' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { allowedValues: schema" + $lvl + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be equal to one of the allowed values' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " }";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/format.js
var require_format = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_format(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    if (it2.opts.format === false) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
      return out;
    }
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $unknownFormats = it2.opts.unknownFormats, $allowUnknown = Array.isArray($unknownFormats);
    if ($isData) {
      var $format = "format" + $lvl, $isObject = "isObject" + $lvl, $formatType = "formatType" + $lvl;
      out += " var " + $format + " = formats[" + $schemaValue + "]; var " + $isObject + " = typeof " + $format + " == 'object' && !(" + $format + " instanceof RegExp) && " + $format + ".validate; var " + $formatType + " = " + $isObject + " && " + $format + ".type || 'string'; if (" + $isObject + ") { ";
      if (it2.async) {
        out += " var async" + $lvl + " = " + $format + ".async; ";
      }
      out += " " + $format + " = " + $format + ".validate; } if (  ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
      }
      out += " (";
      if ($unknownFormats != "ignore") {
        out += " (" + $schemaValue + " && !" + $format + " ";
        if ($allowUnknown) {
          out += " && self._opts.unknownFormats.indexOf(" + $schemaValue + ") == -1 ";
        }
        out += ") || ";
      }
      out += " (" + $format + " && " + $formatType + " == '" + $ruleType + "' && !(typeof " + $format + " == 'function' ? ";
      if (it2.async) {
        out += " (async" + $lvl + " ? await " + $format + "(" + $data + ") : " + $format + "(" + $data + ")) ";
      } else {
        out += " " + $format + "(" + $data + ") ";
      }
      out += " : " + $format + ".test(" + $data + "))))) {";
    } else {
      var $format = it2.formats[$schema];
      if (!$format) {
        if ($unknownFormats == "ignore") {
          it2.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it2.errSchemaPath + '"');
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
          if ($breakOnError) {
            out += " if (true) { ";
          }
          return out;
        } else {
          throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it2.errSchemaPath + '"');
        }
      }
      var $isObject = typeof $format == "object" && !($format instanceof RegExp) && $format.validate;
      var $formatType = $isObject && $format.type || "string";
      if ($isObject) {
        var $async = $format.async === true;
        $format = $format.validate;
      }
      if ($formatType != $ruleType) {
        if ($breakOnError) {
          out += " if (true) { ";
        }
        return out;
      }
      if ($async) {
        if (!it2.async)
          throw new Error("async format in sync schema");
        var $formatRef = "formats" + it2.util.getProperty($schema) + ".validate";
        out += " if (!(await " + $formatRef + "(" + $data + "))) { ";
      } else {
        out += " if (! ";
        var $formatRef = "formats" + it2.util.getProperty($schema);
        if ($isObject)
          $formatRef += ".validate";
        if (typeof $format == "function") {
          out += " " + $formatRef + "(" + $data + ") ";
        } else {
          out += " " + $formatRef + ".test(" + $data + ") ";
        }
        out += ") { ";
      }
    }
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'format' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { format:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it2.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it2.opts.messages !== false) {
        out += ` , message: 'should match format "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it2.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it2.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/if.js
var require_if = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_if(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $thenSch = it2.schema["then"], $elseSch = it2.schema["else"], $thenPresent = $thenSch !== void 0 && (it2.opts.strictKeywords ? typeof $thenSch == "object" && Object.keys($thenSch).length > 0 || $thenSch === false : it2.util.schemaHasRules($thenSch, it2.RULES.all)), $elsePresent = $elseSch !== void 0 && (it2.opts.strictKeywords ? typeof $elseSch == "object" && Object.keys($elseSch).length > 0 || $elseSch === false : it2.util.schemaHasRules($elseSch, it2.RULES.all)), $currentBaseId = $it.baseId;
    if ($thenPresent || $elsePresent) {
      var $ifClause;
      $it.createErrors = false;
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors; var " + $valid + " = true;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      out += "  " + it2.validate($it) + " ";
      $it.baseId = $currentBaseId;
      $it.createErrors = true;
      out += "  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }  ";
      it2.compositeRule = $it.compositeRule = $wasComposite;
      if ($thenPresent) {
        out += " if (" + $nextValid + ") {  ";
        $it.schema = it2.schema["then"];
        $it.schemaPath = it2.schemaPath + ".then";
        $it.errSchemaPath = it2.errSchemaPath + "/then";
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'then'; ";
        } else {
          $ifClause = "'then'";
        }
        out += " } ";
        if ($elsePresent) {
          out += " else { ";
        }
      } else {
        out += " if (!" + $nextValid + ") { ";
      }
      if ($elsePresent) {
        $it.schema = it2.schema["else"];
        $it.schemaPath = it2.schemaPath + ".else";
        $it.errSchemaPath = it2.errSchemaPath + "/else";
        out += "  " + it2.validate($it) + " ";
        $it.baseId = $currentBaseId;
        out += " " + $valid + " = " + $nextValid + "; ";
        if ($thenPresent && $elsePresent) {
          $ifClause = "ifClause" + $lvl;
          out += " var " + $ifClause + " = 'else'; ";
        } else {
          $ifClause = "'else'";
        }
        out += " } ";
      }
      out += " if (!" + $valid + ") {   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'if' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { failingKeyword: " + $ifClause + " } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should match "' + ` + $ifClause + ` + '" schema' `;
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      out += " }   ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/items.js
var require_items = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_items(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $idx = "i" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $currentBaseId = it2.baseId;
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if (Array.isArray($schema)) {
      var $additionalItems = it2.schema.additionalItems;
      if ($additionalItems === false) {
        out += " " + $valid + " = " + $data + ".length <= " + $schema.length + "; ";
        var $currErrSchemaPath = $errSchemaPath;
        $errSchemaPath = it2.errSchemaPath + "/additionalItems";
        out += "  if (!" + $valid + ") {   ";
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = "";
        if (it2.createErrors !== false) {
          out += " { keyword: 'additionalItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schema.length + " } ";
          if (it2.opts.messages !== false) {
            out += " , message: 'should NOT have more than " + $schema.length + " items' ";
          }
          if (it2.opts.verbose) {
            out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError([" + __err + "]); ";
          } else {
            out += " validate.errors = [" + __err + "]; return false; ";
          }
        } else {
          out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        }
        out += " } ";
        $errSchemaPath = $currErrSchemaPath;
        if ($breakOnError) {
          $closingBraces += "}";
          out += " else { ";
        }
      }
      var arr1 = $schema;
      if (arr1) {
        var $sch, $i = -1, l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            out += " " + $nextValid + " = true; if (" + $data + ".length > " + $i + ") { ";
            var $passData = $data + "[" + $i + "]";
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + "[" + $i + "]";
            $it.errSchemaPath = $errSchemaPath + "/" + $i;
            $it.errorPath = it2.util.getPathExpr(it2.errorPath, $i, it2.opts.jsonPointers, true);
            $it.dataPathArr[$dataNxt] = $i;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
      if (typeof $additionalItems == "object" && (it2.opts.strictKeywords ? typeof $additionalItems == "object" && Object.keys($additionalItems).length > 0 || $additionalItems === false : it2.util.schemaHasRules($additionalItems, it2.RULES.all))) {
        $it.schema = $additionalItems;
        $it.schemaPath = it2.schemaPath + ".additionalItems";
        $it.errSchemaPath = it2.errSchemaPath + "/additionalItems";
        out += " " + $nextValid + " = true; if (" + $data + ".length > " + $schema.length + ") {  for (var " + $idx + " = " + $schema.length + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
        $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
        var $passData = $data + "[" + $idx + "]";
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it2.validate($it);
        $it.baseId = $currentBaseId;
        if (it2.util.varOccurences($code, $nextData) < 2) {
          out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
        } else {
          out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
        }
        if ($breakOnError) {
          out += " if (!" + $nextValid + ") break; ";
        }
        out += " } }  ";
        if ($breakOnError) {
          out += " if (" + $nextValid + ") { ";
          $closingBraces += "}";
        }
      }
    } else if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += "  for (var " + $idx + " = " + 0 + "; " + $idx + " < " + $data + ".length; " + $idx + "++) { ";
      $it.errorPath = it2.util.getPathExpr(it2.errorPath, $idx, it2.opts.jsonPointers, true);
      var $passData = $data + "[" + $idx + "]";
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      if ($breakOnError) {
        out += " if (!" + $nextValid + ") break; ";
      }
      out += " }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limit.js
var require_limit = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limit(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $isMax = $keyword == "maximum", $exclusiveKeyword = $isMax ? "exclusiveMaximum" : "exclusiveMinimum", $schemaExcl = it2.schema[$exclusiveKeyword], $isDataExcl = it2.opts.$data && $schemaExcl && $schemaExcl.$data, $op = $isMax ? "<" : ">", $notOp = $isMax ? ">" : "<", $errorKeyword = void 0;
    if (!($isData || typeof $schema == "number" || $schema === void 0)) {
      throw new Error($keyword + " must be number");
    }
    if (!($isDataExcl || $schemaExcl === void 0 || typeof $schemaExcl == "number" || typeof $schemaExcl == "boolean")) {
      throw new Error($exclusiveKeyword + " must be number or boolean");
    }
    if ($isDataExcl) {
      var $schemaValueExcl = it2.util.getData($schemaExcl.$data, $dataLvl, it2.dataPathArr), $exclusive = "exclusive" + $lvl, $exclType = "exclType" + $lvl, $exclIsNumber = "exclIsNumber" + $lvl, $opExpr = "op" + $lvl, $opStr = "' + " + $opExpr + " + '";
      out += " var schemaExcl" + $lvl + " = " + $schemaValueExcl + "; ";
      $schemaValueExcl = "schemaExcl" + $lvl;
      out += " var " + $exclusive + "; var " + $exclType + " = typeof " + $schemaValueExcl + "; if (" + $exclType + " != 'boolean' && " + $exclType + " != 'undefined' && " + $exclType + " != 'number') { ";
      var $errorKeyword = $exclusiveKeyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "_exclusiveLimit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: '" + $exclusiveKeyword + " should be boolean' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else if ( ";
      if ($isData) {
        out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
      }
      out += " " + $exclType + " == 'number' ? ( (" + $exclusive + " = " + $schemaValue + " === undefined || " + $schemaValueExcl + " " + $op + "= " + $schemaValue + ") ? " + $data + " " + $notOp + "= " + $schemaValueExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) : ( (" + $exclusive + " = " + $schemaValueExcl + " === true) ? " + $data + " " + $notOp + "= " + $schemaValue + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { var op" + $lvl + " = " + $exclusive + " ? '" + $op + "' : '" + $op + "='; ";
      if ($schema === void 0) {
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
        $schemaValue = $schemaValueExcl;
        $isData = $isDataExcl;
      }
    } else {
      var $exclIsNumber = typeof $schemaExcl == "number", $opStr = $op;
      if ($exclIsNumber && $isData) {
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " ( " + $schemaValue + " === undefined || " + $schemaExcl + " " + $op + "= " + $schemaValue + " ? " + $data + " " + $notOp + "= " + $schemaExcl + " : " + $data + " " + $notOp + " " + $schemaValue + " ) || " + $data + " !== " + $data + ") { ";
      } else {
        if ($exclIsNumber && $schema === void 0) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
          $schemaValue = $schemaExcl;
          $notOp += "=";
        } else {
          if ($exclIsNumber)
            $schemaValue = Math[$isMax ? "min" : "max"]($schemaExcl, $schema);
          if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it2.errSchemaPath + "/" + $exclusiveKeyword;
            $notOp += "=";
          } else {
            $exclusive = false;
            $opStr += "=";
          }
        }
        var $opExpr = "'" + $opStr + "'";
        out += " if ( ";
        if ($isData) {
          out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
        }
        out += " " + $data + " " + $notOp + " " + $schemaValue + " || " + $data + " !== " + $data + ") { ";
      }
    }
    $errorKeyword = $errorKeyword || $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limit") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { comparison: " + $opExpr + ", limit: " + $schemaValue + ", exclusive: " + $exclusive + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be " + $opStr + " ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += " } ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitItems.js
var require_limitItems = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitItems(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxItems" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " " + $data + ".length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitItems") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxItems") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " items' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitLength.js
var require_limitLength = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitLength(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxLength" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    if (it2.opts.unicode === false) {
      out += " " + $data + ".length ";
    } else {
      out += " ucs2length(" + $data + ") ";
    }
    out += " " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitLength") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT be ";
        if ($keyword == "maxLength") {
          out += "longer";
        } else {
          out += "shorter";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " characters' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/_limitProperties.js
var require_limitProperties = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate__limitProperties(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    var $op = $keyword == "maxProperties" ? ">" : "<";
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'number') || ";
    }
    out += " Object.keys(" + $data + ").length " + $op + " " + $schemaValue + ") { ";
    var $errorKeyword = $keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: '" + ($errorKeyword || "_limitProperties") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { limit: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should NOT have ";
        if ($keyword == "maxProperties") {
          out += "more";
        } else {
          out += "fewer";
        }
        out += " than ";
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + $schema;
        }
        out += " properties' ";
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/multipleOf.js
var require_multipleOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_multipleOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (!($isData || typeof $schema == "number")) {
      throw new Error($keyword + " must be number");
    }
    out += "var division" + $lvl + ";if (";
    if ($isData) {
      out += " " + $schemaValue + " !== undefined && ( typeof " + $schemaValue + " != 'number' || ";
    }
    out += " (division" + $lvl + " = " + $data + " / " + $schemaValue + ", ";
    if (it2.opts.multipleOfPrecision) {
      out += " Math.abs(Math.round(division" + $lvl + ") - division" + $lvl + ") > 1e-" + it2.opts.multipleOfPrecision + " ";
    } else {
      out += " division" + $lvl + " !== parseInt(division" + $lvl + ") ";
    }
    out += " ) ";
    if ($isData) {
      out += "  )  ";
    }
    out += " ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'multipleOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { multipleOf: " + $schemaValue + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should be multiple of ";
        if ($isData) {
          out += "' + " + $schemaValue;
        } else {
          out += "" + $schemaValue + "'";
        }
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + $schema;
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/not.js
var require_not = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_not(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    $it.level++;
    var $nextValid = "valid" + $it.level;
    if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      out += " var " + $errs + " = errors;  ";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      $it.createErrors = false;
      var $allErrorsOption;
      if ($it.opts.allErrors) {
        $allErrorsOption = $it.opts.allErrors;
        $it.opts.allErrors = false;
      }
      out += " " + it2.validate($it) + " ";
      $it.createErrors = true;
      if ($allErrorsOption)
        $it.opts.allErrors = $allErrorsOption;
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (" + $nextValid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; } ";
      if (it2.opts.allErrors) {
        out += " } ";
      }
    } else {
      out += "  var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'not' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: {} ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT be valid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if ($breakOnError) {
        out += " if (false) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/oneOf.js
var require_oneOf = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_oneOf(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $currentBaseId = $it.baseId, $prevValid = "prevValid" + $lvl, $passingSchemas = "passingSchemas" + $lvl;
    out += "var " + $errs + " = errors , " + $prevValid + " = false , " + $valid + " = false , " + $passingSchemas + " = null; ";
    var $wasComposite = it2.compositeRule;
    it2.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1, l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + "[" + $i + "]";
          $it.errSchemaPath = $errSchemaPath + "/" + $i;
          out += "  " + it2.validate($it) + " ";
          $it.baseId = $currentBaseId;
        } else {
          out += " var " + $nextValid + " = true; ";
        }
        if ($i) {
          out += " if (" + $nextValid + " && " + $prevValid + ") { " + $valid + " = false; " + $passingSchemas + " = [" + $passingSchemas + ", " + $i + "]; } else { ";
          $closingBraces += "}";
        }
        out += " if (" + $nextValid + ") { " + $valid + " = " + $prevValid + " = true; " + $passingSchemas + " = " + $i + "; }";
      }
    }
    it2.compositeRule = $it.compositeRule = $wasComposite;
    out += "" + $closingBraces + "if (!" + $valid + ") {   var err =   ";
    if (it2.createErrors !== false) {
      out += " { keyword: 'oneOf' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { passingSchemas: " + $passingSchemas + " } ";
      if (it2.opts.messages !== false) {
        out += " , message: 'should match exactly one schema in oneOf' ";
      }
      if (it2.opts.verbose) {
        out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError(vErrors); ";
      } else {
        out += " validate.errors = vErrors; return false; ";
      }
    }
    out += "} else {  errors = " + $errs + "; if (vErrors !== null) { if (" + $errs + ") vErrors.length = " + $errs + "; else vErrors = null; }";
    if (it2.opts.allErrors) {
      out += " } ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/pattern.js
var require_pattern = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_pattern(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $regexp = $isData ? "(new RegExp(" + $schemaValue + "))" : it2.usePattern($schema);
    out += "if ( ";
    if ($isData) {
      out += " (" + $schemaValue + " !== undefined && typeof " + $schemaValue + " != 'string') || ";
    }
    out += " !" + $regexp + ".test(" + $data + ") ) {   ";
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = "";
    if (it2.createErrors !== false) {
      out += " { keyword: 'pattern' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { pattern:  ";
      if ($isData) {
        out += "" + $schemaValue;
      } else {
        out += "" + it2.util.toQuotedString($schema);
      }
      out += "  } ";
      if (it2.opts.messages !== false) {
        out += ` , message: 'should match pattern "`;
        if ($isData) {
          out += "' + " + $schemaValue + " + '";
        } else {
          out += "" + it2.util.escapeQuotes($schema);
        }
        out += `"' `;
      }
      if (it2.opts.verbose) {
        out += " , schema:  ";
        if ($isData) {
          out += "validate.schema" + $schemaPath;
        } else {
          out += "" + it2.util.toQuotedString($schema);
        }
        out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
      }
      out += " } ";
    } else {
      out += " {} ";
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it2.compositeRule && $breakOnError) {
      if (it2.async) {
        out += " throw new ValidationError([" + __err + "]); ";
      } else {
        out += " validate.errors = [" + __err + "]; return false; ";
      }
    } else {
      out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
    }
    out += "} ";
    if ($breakOnError) {
      out += " else { ";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/properties.js
var require_properties = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_properties(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    var $key = "key" + $lvl, $idx = "idx" + $lvl, $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl;
    var $schemaKeys = Object.keys($schema || {}).filter(notProto), $pProperties = it2.schema.patternProperties || {}, $pPropertyKeys = Object.keys($pProperties).filter(notProto), $aProperties = it2.schema.additionalProperties, $someProperties = $schemaKeys.length || $pPropertyKeys.length, $noAdditional = $aProperties === false, $additionalIsSchema = typeof $aProperties == "object" && Object.keys($aProperties).length, $removeAdditional = it2.opts.removeAdditional, $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
    var $required = it2.schema.required;
    if ($required && !(it2.opts.$data && $required.$data) && $required.length < it2.opts.loopRequired) {
      var $requiredHash = it2.util.toHash($required);
    }
    function notProto(p) {
      return p !== "__proto__";
    }
    out += "var " + $errs + " = errors;var " + $nextValid + " = true;";
    if ($ownProperties) {
      out += " var " + $dataProperties + " = undefined;";
    }
    if ($checkAdditional) {
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      if ($someProperties) {
        out += " var isAdditional" + $lvl + " = !(false ";
        if ($schemaKeys.length) {
          if ($schemaKeys.length > 8) {
            out += " || validate.schema" + $schemaPath + ".hasOwnProperty(" + $key + ") ";
          } else {
            var arr1 = $schemaKeys;
            if (arr1) {
              var $propertyKey, i1 = -1, l1 = arr1.length - 1;
              while (i1 < l1) {
                $propertyKey = arr1[i1 += 1];
                out += " || " + $key + " == " + it2.util.toQuotedString($propertyKey) + " ";
              }
            }
          }
        }
        if ($pPropertyKeys.length) {
          var arr2 = $pPropertyKeys;
          if (arr2) {
            var $pProperty, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $pProperty = arr2[$i += 1];
              out += " || " + it2.usePattern($pProperty) + ".test(" + $key + ") ";
            }
          }
        }
        out += " ); if (isAdditional" + $lvl + ") { ";
      }
      if ($removeAdditional == "all") {
        out += " delete " + $data + "[" + $key + "]; ";
      } else {
        var $currentErrorPath = it2.errorPath;
        var $additionalProperty = "' + " + $key + " + '";
        if (it2.opts._errorDataPathProperty) {
          it2.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
        }
        if ($noAdditional) {
          if ($removeAdditional) {
            out += " delete " + $data + "[" + $key + "]; ";
          } else {
            out += " " + $nextValid + " = false; ";
            var $currErrSchemaPath = $errSchemaPath;
            $errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = "";
            if (it2.createErrors !== false) {
              out += " { keyword: 'additionalProperties' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { additionalProperty: '" + $additionalProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is an invalid additional property";
                } else {
                  out += "should NOT have additional properties";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: false , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it2.compositeRule && $breakOnError) {
              if (it2.async) {
                out += " throw new ValidationError([" + __err + "]); ";
              } else {
                out += " validate.errors = [" + __err + "]; return false; ";
              }
            } else {
              out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += " break; ";
            }
          }
        } else if ($additionalIsSchema) {
          if ($removeAdditional == "failing") {
            out += " var " + $errs + " = errors;  ";
            var $wasComposite = it2.compositeRule;
            it2.compositeRule = $it.compositeRule = true;
            $it.schema = $aProperties;
            $it.schemaPath = it2.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            out += " if (!" + $nextValid + ") { errors = " + $errs + "; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete " + $data + "[" + $key + "]; }  ";
            it2.compositeRule = $it.compositeRule = $wasComposite;
          } else {
            $it.schema = $aProperties;
            $it.schemaPath = it2.schemaPath + ".additionalProperties";
            $it.errSchemaPath = it2.errSchemaPath + "/additionalProperties";
            $it.errorPath = it2.opts._errorDataPathProperty ? it2.errorPath : it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
          }
        }
        it2.errorPath = $currentErrorPath;
      }
      if ($someProperties) {
        out += " } ";
      }
      out += " }  ";
      if ($breakOnError) {
        out += " if (" + $nextValid + ") { ";
        $closingBraces += "}";
      }
    }
    var $useDefaults = it2.opts.useDefaults && !it2.compositeRule;
    if ($schemaKeys.length) {
      var arr3 = $schemaKeys;
      if (arr3) {
        var $propertyKey, i3 = -1, l3 = arr3.length - 1;
        while (i3 < l3) {
          $propertyKey = arr3[i3 += 1];
          var $sch = $schema[$propertyKey];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            var $prop = it2.util.getProperty($propertyKey), $passData = $data + $prop, $hasDefault = $useDefaults && $sch.default !== void 0;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + $prop;
            $it.errSchemaPath = $errSchemaPath + "/" + it2.util.escapeFragment($propertyKey);
            $it.errorPath = it2.util.getPath(it2.errorPath, $propertyKey, it2.opts.jsonPointers);
            $it.dataPathArr[$dataNxt] = it2.util.toQuotedString($propertyKey);
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              $code = it2.util.varReplace($code, $nextData, $passData);
              var $useData = $passData;
            } else {
              var $useData = $nextData;
              out += " var " + $nextData + " = " + $passData + "; ";
            }
            if ($hasDefault) {
              out += " " + $code + " ";
            } else {
              if ($requiredHash && $requiredHash[$propertyKey]) {
                out += " if ( " + $useData + " === undefined ";
                if ($ownProperties) {
                  out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                }
                out += ") { " + $nextValid + " = false; ";
                var $currentErrorPath = it2.errorPath, $currErrSchemaPath = $errSchemaPath, $missingProperty = it2.util.escapeQuotes($propertyKey);
                if (it2.opts._errorDataPathProperty) {
                  it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
                }
                $errSchemaPath = it2.errSchemaPath + "/required";
                var $$outStack = $$outStack || [];
                $$outStack.push(out);
                out = "";
                if (it2.createErrors !== false) {
                  out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                  if (it2.opts.messages !== false) {
                    out += " , message: '";
                    if (it2.opts._errorDataPathProperty) {
                      out += "is a required property";
                    } else {
                      out += "should have required property \\'" + $missingProperty + "\\'";
                    }
                    out += "' ";
                  }
                  if (it2.opts.verbose) {
                    out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                  }
                  out += " } ";
                } else {
                  out += " {} ";
                }
                var __err = out;
                out = $$outStack.pop();
                if (!it2.compositeRule && $breakOnError) {
                  if (it2.async) {
                    out += " throw new ValidationError([" + __err + "]); ";
                  } else {
                    out += " validate.errors = [" + __err + "]; return false; ";
                  }
                } else {
                  out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
                }
                $errSchemaPath = $currErrSchemaPath;
                it2.errorPath = $currentErrorPath;
                out += " } else { ";
              } else {
                if ($breakOnError) {
                  out += " if ( " + $useData + " === undefined ";
                  if ($ownProperties) {
                    out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += ") { " + $nextValid + " = true; } else { ";
                } else {
                  out += " if (" + $useData + " !== undefined ";
                  if ($ownProperties) {
                    out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
                  }
                  out += " ) { ";
                }
              }
              out += " " + $code + " } ";
            }
          }
          if ($breakOnError) {
            out += " if (" + $nextValid + ") { ";
            $closingBraces += "}";
          }
        }
      }
    }
    if ($pPropertyKeys.length) {
      var arr4 = $pPropertyKeys;
      if (arr4) {
        var $pProperty, i4 = -1, l4 = arr4.length - 1;
        while (i4 < l4) {
          $pProperty = arr4[i4 += 1];
          var $sch = $pProperties[$pProperty];
          if (it2.opts.strictKeywords ? typeof $sch == "object" && Object.keys($sch).length > 0 || $sch === false : it2.util.schemaHasRules($sch, it2.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = it2.schemaPath + ".patternProperties" + it2.util.getProperty($pProperty);
            $it.errSchemaPath = it2.errSchemaPath + "/patternProperties/" + it2.util.escapeFragment($pProperty);
            if ($ownProperties) {
              out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
            } else {
              out += " for (var " + $key + " in " + $data + ") { ";
            }
            out += " if (" + it2.usePattern($pProperty) + ".test(" + $key + ")) { ";
            $it.errorPath = it2.util.getPathExpr(it2.errorPath, $key, it2.opts.jsonPointers);
            var $passData = $data + "[" + $key + "]";
            $it.dataPathArr[$dataNxt] = $key;
            var $code = it2.validate($it);
            $it.baseId = $currentBaseId;
            if (it2.util.varOccurences($code, $nextData) < 2) {
              out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
            } else {
              out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
            }
            if ($breakOnError) {
              out += " if (!" + $nextValid + ") break; ";
            }
            out += " } ";
            if ($breakOnError) {
              out += " else " + $nextValid + " = true; ";
            }
            out += " }  ";
            if ($breakOnError) {
              out += " if (" + $nextValid + ") { ";
              $closingBraces += "}";
            }
          }
        }
      }
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/propertyNames.js
var require_propertyNames = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_propertyNames(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $errs = "errs__" + $lvl;
    var $it = it2.util.copy(it2);
    var $closingBraces = "";
    $it.level++;
    var $nextValid = "valid" + $it.level;
    out += "var " + $errs + " = errors;";
    if (it2.opts.strictKeywords ? typeof $schema == "object" && Object.keys($schema).length > 0 || $schema === false : it2.util.schemaHasRules($schema, it2.RULES.all)) {
      $it.schema = $schema;
      $it.schemaPath = $schemaPath;
      $it.errSchemaPath = $errSchemaPath;
      var $key = "key" + $lvl, $idx = "idx" + $lvl, $i = "i" + $lvl, $invalidName = "' + " + $key + " + '", $dataNxt = $it.dataLevel = it2.dataLevel + 1, $nextData = "data" + $dataNxt, $dataProperties = "dataProperties" + $lvl, $ownProperties = it2.opts.ownProperties, $currentBaseId = it2.baseId;
      if ($ownProperties) {
        out += " var " + $dataProperties + " = undefined; ";
      }
      if ($ownProperties) {
        out += " " + $dataProperties + " = " + $dataProperties + " || Object.keys(" + $data + "); for (var " + $idx + "=0; " + $idx + "<" + $dataProperties + ".length; " + $idx + "++) { var " + $key + " = " + $dataProperties + "[" + $idx + "]; ";
      } else {
        out += " for (var " + $key + " in " + $data + ") { ";
      }
      out += " var startErrs" + $lvl + " = errors; ";
      var $passData = $key;
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var $code = it2.validate($it);
      $it.baseId = $currentBaseId;
      if (it2.util.varOccurences($code, $nextData) < 2) {
        out += " " + it2.util.varReplace($code, $nextData, $passData) + " ";
      } else {
        out += " var " + $nextData + " = " + $passData + "; " + $code + " ";
      }
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " if (!" + $nextValid + ") { for (var " + $i + "=startErrs" + $lvl + "; " + $i + "<errors; " + $i + "++) { vErrors[" + $i + "].propertyName = " + $key + "; }   var err =   ";
      if (it2.createErrors !== false) {
        out += " { keyword: 'propertyNames' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { propertyName: '" + $invalidName + "' } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'property name \\'" + $invalidName + "\\' is invalid' ";
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError(vErrors); ";
        } else {
          out += " validate.errors = vErrors; return false; ";
        }
      }
      if ($breakOnError) {
        out += " break; ";
      }
      out += " } }";
    }
    if ($breakOnError) {
      out += " " + $closingBraces + " if (" + $errs + " == errors) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/required.js
var require_required = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_required(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $vSchema = "schema" + $lvl;
    if (!$isData) {
      if ($schema.length < it2.opts.loopRequired && it2.schema.properties && Object.keys(it2.schema.properties).length) {
        var $required = [];
        var arr1 = $schema;
        if (arr1) {
          var $property, i1 = -1, l1 = arr1.length - 1;
          while (i1 < l1) {
            $property = arr1[i1 += 1];
            var $propertySch = it2.schema.properties[$property];
            if (!($propertySch && (it2.opts.strictKeywords ? typeof $propertySch == "object" && Object.keys($propertySch).length > 0 || $propertySch === false : it2.util.schemaHasRules($propertySch, it2.RULES.all)))) {
              $required[$required.length] = $property;
            }
          }
        }
      } else {
        var $required = $schema;
      }
    }
    if ($isData || $required.length) {
      var $currentErrorPath = it2.errorPath, $loopRequired = $isData || $required.length >= it2.opts.loopRequired, $ownProperties = it2.opts.ownProperties;
      if ($breakOnError) {
        out += " var missing" + $lvl + "; ";
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
          }
          out += " var " + $valid + " = true; ";
          if ($isData) {
            out += " if (schema" + $lvl + " === undefined) " + $valid + " = true; else if (!Array.isArray(schema" + $lvl + ")) " + $valid + " = false; else {";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { " + $valid + " = " + $data + "[" + $vSchema + "[" + $i + "]] !== undefined ";
          if ($ownProperties) {
            out += " &&   Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += "; if (!" + $valid + ") break; } ";
          if ($isData) {
            out += "  }  ";
          }
          out += "  if (!" + $valid + ") {   ";
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        } else {
          out += " if ( ";
          var arr2 = $required;
          if (arr2) {
            var $propertyKey, $i = -1, l2 = arr2.length - 1;
            while ($i < l2) {
              $propertyKey = arr2[$i += 1];
              if ($i) {
                out += " || ";
              }
              var $prop = it2.util.getProperty($propertyKey), $useData = $data + $prop;
              out += " ( ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") && (missing" + $lvl + " = " + it2.util.toQuotedString(it2.opts.jsonPointers ? $propertyKey : $prop) + ") ) ";
            }
          }
          out += ") {  ";
          var $propertyPath = "missing" + $lvl, $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.opts.jsonPointers ? it2.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + " + " + $propertyPath;
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = "";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it2.compositeRule && $breakOnError) {
            if (it2.async) {
              out += " throw new ValidationError([" + __err + "]); ";
            } else {
              out += " validate.errors = [" + __err + "]; return false; ";
            }
          } else {
            out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
          }
          out += " } else { ";
        }
      } else {
        if ($loopRequired) {
          if (!$isData) {
            out += " var " + $vSchema + " = validate.schema" + $schemaPath + "; ";
          }
          var $i = "i" + $lvl, $propertyPath = "schema" + $lvl + "[" + $i + "]", $missingProperty = "' + " + $propertyPath + " + '";
          if (it2.opts._errorDataPathProperty) {
            it2.errorPath = it2.util.getPathExpr($currentErrorPath, $propertyPath, it2.opts.jsonPointers);
          }
          if ($isData) {
            out += " if (" + $vSchema + " && !Array.isArray(" + $vSchema + ")) {  var err =   ";
            if (it2.createErrors !== false) {
              out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
              if (it2.opts.messages !== false) {
                out += " , message: '";
                if (it2.opts._errorDataPathProperty) {
                  out += "is a required property";
                } else {
                  out += "should have required property \\'" + $missingProperty + "\\'";
                }
                out += "' ";
              }
              if (it2.opts.verbose) {
                out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
              }
              out += " } ";
            } else {
              out += " {} ";
            }
            out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (" + $vSchema + " !== undefined) { ";
          }
          out += " for (var " + $i + " = 0; " + $i + " < " + $vSchema + ".length; " + $i + "++) { if (" + $data + "[" + $vSchema + "[" + $i + "]] === undefined ";
          if ($ownProperties) {
            out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", " + $vSchema + "[" + $i + "]) ";
          }
          out += ") {  var err =   ";
          if (it2.createErrors !== false) {
            out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
            if (it2.opts.messages !== false) {
              out += " , message: '";
              if (it2.opts._errorDataPathProperty) {
                out += "is a required property";
              } else {
                out += "should have required property \\'" + $missingProperty + "\\'";
              }
              out += "' ";
            }
            if (it2.opts.verbose) {
              out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
            }
            out += " } ";
          } else {
            out += " {} ";
          }
          out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ";
          if ($isData) {
            out += "  }  ";
          }
        } else {
          var arr3 = $required;
          if (arr3) {
            var $propertyKey, i3 = -1, l3 = arr3.length - 1;
            while (i3 < l3) {
              $propertyKey = arr3[i3 += 1];
              var $prop = it2.util.getProperty($propertyKey), $missingProperty = it2.util.escapeQuotes($propertyKey), $useData = $data + $prop;
              if (it2.opts._errorDataPathProperty) {
                it2.errorPath = it2.util.getPath($currentErrorPath, $propertyKey, it2.opts.jsonPointers);
              }
              out += " if ( " + $useData + " === undefined ";
              if ($ownProperties) {
                out += " || ! Object.prototype.hasOwnProperty.call(" + $data + ", '" + it2.util.escapeQuotes($propertyKey) + "') ";
              }
              out += ") {  var err =   ";
              if (it2.createErrors !== false) {
                out += " { keyword: 'required' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { missingProperty: '" + $missingProperty + "' } ";
                if (it2.opts.messages !== false) {
                  out += " , message: '";
                  if (it2.opts._errorDataPathProperty) {
                    out += "is a required property";
                  } else {
                    out += "should have required property \\'" + $missingProperty + "\\'";
                  }
                  out += "' ";
                }
                if (it2.opts.verbose) {
                  out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
                }
                out += " } ";
              } else {
                out += " {} ";
              }
              out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ";
            }
          }
        }
      }
      it2.errorPath = $currentErrorPath;
    } else if ($breakOnError) {
      out += " if (true) {";
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/uniqueItems.js
var require_uniqueItems = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_uniqueItems(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    if (($schema || $isData) && it2.opts.uniqueItems !== false) {
      if ($isData) {
        out += " var " + $valid + "; if (" + $schemaValue + " === false || " + $schemaValue + " === undefined) " + $valid + " = true; else if (typeof " + $schemaValue + " != 'boolean') " + $valid + " = false; else { ";
      }
      out += " var i = " + $data + ".length , " + $valid + " = true , j; if (i > 1) { ";
      var $itemType = it2.schema.items && it2.schema.items.type, $typeIsArray = Array.isArray($itemType);
      if (!$itemType || $itemType == "object" || $itemType == "array" || $typeIsArray && ($itemType.indexOf("object") >= 0 || $itemType.indexOf("array") >= 0)) {
        out += " outer: for (;i--;) { for (j = i; j--;) { if (equal(" + $data + "[i], " + $data + "[j])) { " + $valid + " = false; break outer; } } } ";
      } else {
        out += " var itemIndices = {}, item; for (;i--;) { var item = " + $data + "[i]; ";
        var $method = "checkDataType" + ($typeIsArray ? "s" : "");
        out += " if (" + it2.util[$method]($itemType, "item", it2.opts.strictNumbers, true) + ") continue; ";
        if ($typeIsArray) {
          out += ` if (typeof item == 'string') item = '"' + item; `;
        }
        out += " if (typeof itemIndices[item] == 'number') { " + $valid + " = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ";
      }
      out += " } ";
      if ($isData) {
        out += "  }  ";
      }
      out += " if (!" + $valid + ") {   ";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: 'uniqueItems' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { i: i, j: j } ";
        if (it2.opts.messages !== false) {
          out += " , message: 'should NOT have duplicate items (items ## ' + j + ' and ' + i + ' are identical)' ";
        }
        if (it2.opts.verbose) {
          out += " , schema:  ";
          if ($isData) {
            out += "validate.schema" + $schemaPath;
          } else {
            out += "" + $schema;
          }
          out += "         , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    } else {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/dotjs/index.js
var require_dotjs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    $ref: require_ref(),
    allOf: require_allOf(),
    anyOf: require_anyOf(),
    $comment: require_comment(),
    const: require_const(),
    contains: require_contains(),
    dependencies: require_dependencies(),
    enum: require_enum(),
    format: require_format(),
    if: require_if(),
    items: require_items(),
    maximum: require_limit(),
    minimum: require_limit(),
    maxItems: require_limitItems(),
    minItems: require_limitItems(),
    maxLength: require_limitLength(),
    minLength: require_limitLength(),
    maxProperties: require_limitProperties(),
    minProperties: require_limitProperties(),
    multipleOf: require_multipleOf(),
    not: require_not(),
    oneOf: require_oneOf(),
    pattern: require_pattern(),
    properties: require_properties(),
    propertyNames: require_propertyNames(),
    required: require_required(),
    uniqueItems: require_uniqueItems(),
    validate: require_validate()
  };
});

// node_modules/ajv/lib/compile/rules.js
var require_rules = __commonJS((exports2, module2) => {
  "use strict";
  var ruleModules = require_dotjs();
  var toHash = require_util().toHash;
  module2.exports = function rules() {
    var RULES = [
      {
        type: "number",
        rules: [
          {maximum: ["exclusiveMaximum"]},
          {minimum: ["exclusiveMinimum"]},
          "multipleOf",
          "format"
        ]
      },
      {
        type: "string",
        rules: ["maxLength", "minLength", "pattern", "format"]
      },
      {
        type: "array",
        rules: ["maxItems", "minItems", "items", "contains", "uniqueItems"]
      },
      {
        type: "object",
        rules: [
          "maxProperties",
          "minProperties",
          "required",
          "dependencies",
          "propertyNames",
          {properties: ["additionalProperties", "patternProperties"]}
        ]
      },
      {rules: ["$ref", "const", "enum", "not", "anyOf", "oneOf", "allOf", "if"]}
    ];
    var ALL = ["type", "$comment"];
    var KEYWORDS = [
      "$schema",
      "$id",
      "id",
      "$data",
      "$async",
      "title",
      "description",
      "default",
      "definitions",
      "examples",
      "readOnly",
      "writeOnly",
      "contentMediaType",
      "contentEncoding",
      "additionalItems",
      "then",
      "else"
    ];
    var TYPES = ["number", "integer", "string", "array", "object", "boolean", "null"];
    RULES.all = toHash(ALL);
    RULES.types = toHash(TYPES);
    RULES.forEach(function(group) {
      group.rules = group.rules.map(function(keyword) {
        var implKeywords;
        if (typeof keyword == "object") {
          var key = Object.keys(keyword)[0];
          implKeywords = keyword[key];
          keyword = key;
          implKeywords.forEach(function(k) {
            ALL.push(k);
            RULES.all[k] = true;
          });
        }
        ALL.push(keyword);
        var rule = RULES.all[keyword] = {
          keyword,
          code: ruleModules[keyword],
          implements: implKeywords
        };
        return rule;
      });
      RULES.all.$comment = {
        keyword: "$comment",
        code: ruleModules.$comment
      };
      if (group.type)
        RULES.types[group.type] = group;
    });
    RULES.keywords = toHash(ALL.concat(KEYWORDS));
    RULES.custom = {};
    return RULES;
  };
});

// node_modules/ajv/lib/data.js
var require_data = __commonJS((exports2, module2) => {
  "use strict";
  var KEYWORDS = [
    "multipleOf",
    "maximum",
    "exclusiveMaximum",
    "minimum",
    "exclusiveMinimum",
    "maxLength",
    "minLength",
    "pattern",
    "additionalItems",
    "maxItems",
    "minItems",
    "uniqueItems",
    "maxProperties",
    "minProperties",
    "required",
    "additionalProperties",
    "enum",
    "format",
    "const"
  ];
  module2.exports = function(metaSchema, keywordsJsonPointers) {
    for (var i = 0; i < keywordsJsonPointers.length; i++) {
      metaSchema = JSON.parse(JSON.stringify(metaSchema));
      var segments = keywordsJsonPointers[i].split("/");
      var keywords = metaSchema;
      var j;
      for (j = 1; j < segments.length; j++)
        keywords = keywords[segments[j]];
      for (j = 0; j < KEYWORDS.length; j++) {
        var key = KEYWORDS[j];
        var schema = keywords[key];
        if (schema) {
          keywords[key] = {
            anyOf: [
              schema,
              {$ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}
            ]
          };
        }
      }
    }
    return metaSchema;
  };
});

// node_modules/ajv/lib/compile/async.js
var require_async = __commonJS((exports2, module2) => {
  "use strict";
  var MissingRefError = require_error_classes().MissingRef;
  module2.exports = compileAsync;
  function compileAsync(schema, meta, callback) {
    var self2 = this;
    if (typeof this._opts.loadSchema != "function")
      throw new Error("options.loadSchema should be a function");
    if (typeof meta == "function") {
      callback = meta;
      meta = void 0;
    }
    var p = loadMetaSchemaOf(schema).then(function() {
      var schemaObj = self2._addSchema(schema, void 0, meta);
      return schemaObj.validate || _compileAsync(schemaObj);
    });
    if (callback) {
      p.then(function(v) {
        callback(null, v);
      }, callback);
    }
    return p;
    function loadMetaSchemaOf(sch) {
      var $schema = sch.$schema;
      return $schema && !self2.getSchema($schema) ? compileAsync.call(self2, {$ref: $schema}, true) : Promise.resolve();
    }
    function _compileAsync(schemaObj) {
      try {
        return self2._compile(schemaObj);
      } catch (e) {
        if (e instanceof MissingRefError)
          return loadMissingSchema(e);
        throw e;
      }
      function loadMissingSchema(e) {
        var ref = e.missingSchema;
        if (added(ref))
          throw new Error("Schema " + ref + " is loaded but " + e.missingRef + " cannot be resolved");
        var schemaPromise = self2._loadingSchemas[ref];
        if (!schemaPromise) {
          schemaPromise = self2._loadingSchemas[ref] = self2._opts.loadSchema(ref);
          schemaPromise.then(removePromise, removePromise);
        }
        return schemaPromise.then(function(sch) {
          if (!added(ref)) {
            return loadMetaSchemaOf(sch).then(function() {
              if (!added(ref))
                self2.addSchema(sch, ref, void 0, meta);
            });
          }
        }).then(function() {
          return _compileAsync(schemaObj);
        });
        function removePromise() {
          delete self2._loadingSchemas[ref];
        }
        function added(ref2) {
          return self2._refs[ref2] || self2._schemas[ref2];
        }
      }
    }
  }
});

// node_modules/ajv/lib/dotjs/custom.js
var require_custom = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function generate_custom(it2, $keyword, $ruleType) {
    var out = " ";
    var $lvl = it2.level;
    var $dataLvl = it2.dataLevel;
    var $schema = it2.schema[$keyword];
    var $schemaPath = it2.schemaPath + it2.util.getProperty($keyword);
    var $errSchemaPath = it2.errSchemaPath + "/" + $keyword;
    var $breakOnError = !it2.opts.allErrors;
    var $errorKeyword;
    var $data = "data" + ($dataLvl || "");
    var $valid = "valid" + $lvl;
    var $errs = "errs__" + $lvl;
    var $isData = it2.opts.$data && $schema && $schema.$data, $schemaValue;
    if ($isData) {
      out += " var schema" + $lvl + " = " + it2.util.getData($schema.$data, $dataLvl, it2.dataPathArr) + "; ";
      $schemaValue = "schema" + $lvl;
    } else {
      $schemaValue = $schema;
    }
    var $rule = this, $definition = "definition" + $lvl, $rDef = $rule.definition, $closingBraces = "";
    var $compile, $inline, $macro, $ruleValidate, $validateCode;
    if ($isData && $rDef.$data) {
      $validateCode = "keywordValidate" + $lvl;
      var $validateSchema = $rDef.validateSchema;
      out += " var " + $definition + " = RULES.custom['" + $keyword + "'].definition; var " + $validateCode + " = " + $definition + ".validate;";
    } else {
      $ruleValidate = it2.useCustomRule($rule, $schema, it2.schema, it2);
      if (!$ruleValidate)
        return;
      $schemaValue = "validate.schema" + $schemaPath;
      $validateCode = $ruleValidate.code;
      $compile = $rDef.compile;
      $inline = $rDef.inline;
      $macro = $rDef.macro;
    }
    var $ruleErrs = $validateCode + ".errors", $i = "i" + $lvl, $ruleErr = "ruleErr" + $lvl, $asyncKeyword = $rDef.async;
    if ($asyncKeyword && !it2.async)
      throw new Error("async keyword in sync schema");
    if (!($inline || $macro)) {
      out += "" + $ruleErrs + " = null;";
    }
    out += "var " + $errs + " = errors;var " + $valid + ";";
    if ($isData && $rDef.$data) {
      $closingBraces += "}";
      out += " if (" + $schemaValue + " === undefined) { " + $valid + " = true; } else { ";
      if ($validateSchema) {
        $closingBraces += "}";
        out += " " + $valid + " = " + $definition + ".validateSchema(" + $schemaValue + "); if (" + $valid + ") { ";
      }
    }
    if ($inline) {
      if ($rDef.statements) {
        out += " " + $ruleValidate.validate + " ";
      } else {
        out += " " + $valid + " = " + $ruleValidate.validate + "; ";
      }
    } else if ($macro) {
      var $it = it2.util.copy(it2);
      var $closingBraces = "";
      $it.level++;
      var $nextValid = "valid" + $it.level;
      $it.schema = $ruleValidate.validate;
      $it.schemaPath = "";
      var $wasComposite = it2.compositeRule;
      it2.compositeRule = $it.compositeRule = true;
      var $code = it2.validate($it).replace(/validate\.schema/g, $validateCode);
      it2.compositeRule = $it.compositeRule = $wasComposite;
      out += " " + $code;
    } else {
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      out += "  " + $validateCode + ".call( ";
      if (it2.opts.passContext) {
        out += "this";
      } else {
        out += "self";
      }
      if ($compile || $rDef.schema === false) {
        out += " , " + $data + " ";
      } else {
        out += " , " + $schemaValue + " , " + $data + " , validate.schema" + it2.schemaPath + " ";
      }
      out += " , (dataPath || '')";
      if (it2.errorPath != '""') {
        out += " + " + it2.errorPath;
      }
      var $parentData = $dataLvl ? "data" + ($dataLvl - 1 || "") : "parentData", $parentDataProperty = $dataLvl ? it2.dataPathArr[$dataLvl] : "parentDataProperty";
      out += " , " + $parentData + " , " + $parentDataProperty + " , rootData )  ";
      var def_callRuleValidate = out;
      out = $$outStack.pop();
      if ($rDef.errors === false) {
        out += " " + $valid + " = ";
        if ($asyncKeyword) {
          out += "await ";
        }
        out += "" + def_callRuleValidate + "; ";
      } else {
        if ($asyncKeyword) {
          $ruleErrs = "customErrors" + $lvl;
          out += " var " + $ruleErrs + " = null; try { " + $valid + " = await " + def_callRuleValidate + "; } catch (e) { " + $valid + " = false; if (e instanceof ValidationError) " + $ruleErrs + " = e.errors; else throw e; } ";
        } else {
          out += " " + $ruleErrs + " = null; " + $valid + " = " + def_callRuleValidate + "; ";
        }
      }
    }
    if ($rDef.modifying) {
      out += " if (" + $parentData + ") " + $data + " = " + $parentData + "[" + $parentDataProperty + "];";
    }
    out += "" + $closingBraces;
    if ($rDef.valid) {
      if ($breakOnError) {
        out += " if (true) { ";
      }
    } else {
      out += " if ( ";
      if ($rDef.valid === void 0) {
        out += " !";
        if ($macro) {
          out += "" + $nextValid;
        } else {
          out += "" + $valid;
        }
      } else {
        out += " " + !$rDef.valid + " ";
      }
      out += ") { ";
      $errorKeyword = $rule.keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = "";
      if (it2.createErrors !== false) {
        out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
        if (it2.opts.messages !== false) {
          out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
        }
        if (it2.opts.verbose) {
          out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
        }
        out += " } ";
      } else {
        out += " {} ";
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it2.compositeRule && $breakOnError) {
        if (it2.async) {
          out += " throw new ValidationError([" + __err + "]); ";
        } else {
          out += " validate.errors = [" + __err + "]; return false; ";
        }
      } else {
        out += " var err = " + __err + ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
      }
      var def_customError = out;
      out = $$outStack.pop();
      if ($inline) {
        if ($rDef.errors) {
          if ($rDef.errors != "full") {
            out += "  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it2.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } ";
          }
        } else {
          if ($rDef.errors === false) {
            out += " " + def_customError + " ";
          } else {
            out += " if (" + $errs + " == errors) { " + def_customError + " } else {  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + "; if (" + $ruleErr + ".schemaPath === undefined) { " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
            if (it2.opts.verbose) {
              out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
            }
            out += " } } ";
          }
        }
      } else if ($macro) {
        out += "   var err =   ";
        if (it2.createErrors !== false) {
          out += " { keyword: '" + ($errorKeyword || "custom") + "' , dataPath: (dataPath || '') + " + it2.errorPath + " , schemaPath: " + it2.util.toQuotedString($errSchemaPath) + " , params: { keyword: '" + $rule.keyword + "' } ";
          if (it2.opts.messages !== false) {
            out += ` , message: 'should pass "` + $rule.keyword + `" keyword validation' `;
          }
          if (it2.opts.verbose) {
            out += " , schema: validate.schema" + $schemaPath + " , parentSchema: validate.schema" + it2.schemaPath + " , data: " + $data + " ";
          }
          out += " } ";
        } else {
          out += " {} ";
        }
        out += ";  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ";
        if (!it2.compositeRule && $breakOnError) {
          if (it2.async) {
            out += " throw new ValidationError(vErrors); ";
          } else {
            out += " validate.errors = vErrors; return false; ";
          }
        }
      } else {
        if ($rDef.errors === false) {
          out += " " + def_customError + " ";
        } else {
          out += " if (Array.isArray(" + $ruleErrs + ")) { if (vErrors === null) vErrors = " + $ruleErrs + "; else vErrors = vErrors.concat(" + $ruleErrs + "); errors = vErrors.length;  for (var " + $i + "=" + $errs + "; " + $i + "<errors; " + $i + "++) { var " + $ruleErr + " = vErrors[" + $i + "]; if (" + $ruleErr + ".dataPath === undefined) " + $ruleErr + ".dataPath = (dataPath || '') + " + it2.errorPath + ";  " + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
          if (it2.opts.verbose) {
            out += " " + $ruleErr + ".schema = " + $schemaValue + "; " + $ruleErr + ".data = " + $data + "; ";
          }
          out += " } } else { " + def_customError + " } ";
        }
      }
      out += " } ";
      if ($breakOnError) {
        out += " else { ";
      }
    }
    return out;
  };
});

// node_modules/ajv/lib/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "http://json-schema.org/draft-07/schema#",
    title: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {$ref: "#"}
      },
      nonNegativeInteger: {
        type: "integer",
        minimum: 0
      },
      nonNegativeIntegerDefault0: {
        allOf: [
          {$ref: "#/definitions/nonNegativeInteger"},
          {default: 0}
        ]
      },
      simpleTypes: {
        enum: [
          "array",
          "boolean",
          "integer",
          "null",
          "number",
          "object",
          "string"
        ]
      },
      stringArray: {
        type: "array",
        items: {type: "string"},
        uniqueItems: true,
        default: []
      }
    },
    type: ["object", "boolean"],
    properties: {
      $id: {
        type: "string",
        format: "uri-reference"
      },
      $schema: {
        type: "string",
        format: "uri"
      },
      $ref: {
        type: "string",
        format: "uri-reference"
      },
      $comment: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: true,
      readOnly: {
        type: "boolean",
        default: false
      },
      examples: {
        type: "array",
        items: true
      },
      multipleOf: {
        type: "number",
        exclusiveMinimum: 0
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "number"
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "number"
      },
      maxLength: {$ref: "#/definitions/nonNegativeInteger"},
      minLength: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {$ref: "#"},
      items: {
        anyOf: [
          {$ref: "#"},
          {$ref: "#/definitions/schemaArray"}
        ],
        default: true
      },
      maxItems: {$ref: "#/definitions/nonNegativeInteger"},
      minItems: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      uniqueItems: {
        type: "boolean",
        default: false
      },
      contains: {$ref: "#"},
      maxProperties: {$ref: "#/definitions/nonNegativeInteger"},
      minProperties: {$ref: "#/definitions/nonNegativeIntegerDefault0"},
      required: {$ref: "#/definitions/stringArray"},
      additionalProperties: {$ref: "#"},
      definitions: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        propertyNames: {format: "regex"},
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {$ref: "#"},
            {$ref: "#/definitions/stringArray"}
          ]
        }
      },
      propertyNames: {$ref: "#"},
      const: true,
      enum: {
        type: "array",
        items: true,
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {$ref: "#/definitions/simpleTypes"},
          {
            type: "array",
            items: {$ref: "#/definitions/simpleTypes"},
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {type: "string"},
      contentMediaType: {type: "string"},
      contentEncoding: {type: "string"},
      if: {$ref: "#"},
      then: {$ref: "#"},
      else: {$ref: "#"},
      allOf: {$ref: "#/definitions/schemaArray"},
      anyOf: {$ref: "#/definitions/schemaArray"},
      oneOf: {$ref: "#/definitions/schemaArray"},
      not: {$ref: "#"}
    },
    default: true
  };
});

// node_modules/ajv/lib/definition_schema.js
var require_definition_schema = __commonJS((exports2, module2) => {
  "use strict";
  var metaSchema = require_json_schema_draft_07();
  module2.exports = {
    $id: "https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js",
    definitions: {
      simpleTypes: metaSchema.definitions.simpleTypes
    },
    type: "object",
    dependencies: {
      schema: ["validate"],
      $data: ["validate"],
      statements: ["inline"],
      valid: {not: {required: ["macro"]}}
    },
    properties: {
      type: metaSchema.properties.type,
      schema: {type: "boolean"},
      statements: {type: "boolean"},
      dependencies: {
        type: "array",
        items: {type: "string"}
      },
      metaSchema: {type: "object"},
      modifying: {type: "boolean"},
      valid: {type: "boolean"},
      $data: {type: "boolean"},
      async: {type: "boolean"},
      errors: {
        anyOf: [
          {type: "boolean"},
          {const: "full"}
        ]
      }
    }
  };
});

// node_modules/ajv/lib/keyword.js
var require_keyword = __commonJS((exports2, module2) => {
  "use strict";
  var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
  var customRuleCode = require_custom();
  var definitionSchema = require_definition_schema();
  module2.exports = {
    add: addKeyword,
    get: getKeyword,
    remove: removeKeyword,
    validate: validateKeyword
  };
  function addKeyword(keyword, definition) {
    var RULES = this.RULES;
    if (RULES.keywords[keyword])
      throw new Error("Keyword " + keyword + " is already defined");
    if (!IDENTIFIER.test(keyword))
      throw new Error("Keyword " + keyword + " is not a valid identifier");
    if (definition) {
      this.validateKeyword(definition, true);
      var dataType = definition.type;
      if (Array.isArray(dataType)) {
        for (var i = 0; i < dataType.length; i++)
          _addRule(keyword, dataType[i], definition);
      } else {
        _addRule(keyword, dataType, definition);
      }
      var metaSchema = definition.metaSchema;
      if (metaSchema) {
        if (definition.$data && this._opts.$data) {
          metaSchema = {
            anyOf: [
              metaSchema,
              {$ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"}
            ]
          };
        }
        definition.validateSchema = this.compile(metaSchema, true);
      }
    }
    RULES.keywords[keyword] = RULES.all[keyword] = true;
    function _addRule(keyword2, dataType2, definition2) {
      var ruleGroup;
      for (var i2 = 0; i2 < RULES.length; i2++) {
        var rg = RULES[i2];
        if (rg.type == dataType2) {
          ruleGroup = rg;
          break;
        }
      }
      if (!ruleGroup) {
        ruleGroup = {type: dataType2, rules: []};
        RULES.push(ruleGroup);
      }
      var rule = {
        keyword: keyword2,
        definition: definition2,
        custom: true,
        code: customRuleCode,
        implements: definition2.implements
      };
      ruleGroup.rules.push(rule);
      RULES.custom[keyword2] = rule;
    }
    return this;
  }
  function getKeyword(keyword) {
    var rule = this.RULES.custom[keyword];
    return rule ? rule.definition : this.RULES.keywords[keyword] || false;
  }
  function removeKeyword(keyword) {
    var RULES = this.RULES;
    delete RULES.keywords[keyword];
    delete RULES.all[keyword];
    delete RULES.custom[keyword];
    for (var i = 0; i < RULES.length; i++) {
      var rules = RULES[i].rules;
      for (var j = 0; j < rules.length; j++) {
        if (rules[j].keyword == keyword) {
          rules.splice(j, 1);
          break;
        }
      }
    }
    return this;
  }
  function validateKeyword(definition, throwError) {
    validateKeyword.errors = null;
    var v = this._validateKeyword = this._validateKeyword || this.compile(definitionSchema, true);
    if (v(definition))
      return true;
    validateKeyword.errors = v.errors;
    if (throwError)
      throw new Error("custom keyword definition is invalid: " + this.errorsText(v.errors));
    else
      return false;
  }
});

// node_modules/ajv/lib/refs/data.json
var require_data2 = __commonJS((exports2, module2) => {
  module2.exports = {
    $schema: "http://json-schema.org/draft-07/schema#",
    $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
    description: "Meta-schema for $data reference (JSON Schema extension proposal)",
    type: "object",
    required: ["$data"],
    properties: {
      $data: {
        type: "string",
        anyOf: [
          {format: "relative-json-pointer"},
          {format: "json-pointer"}
        ]
      }
    },
    additionalProperties: false
  };
});

// node_modules/ajv/lib/ajv.js
var require_ajv = __commonJS((exports2, module2) => {
  "use strict";
  var compileSchema = require_compile2();
  var resolve = require_resolve();
  var Cache = require_cache();
  var SchemaObject = require_schema_obj();
  var stableStringify = require_fast_json_stable_stringify();
  var formats = require_formats();
  var rules = require_rules();
  var $dataMetaSchema = require_data();
  var util = require_util();
  module2.exports = Ajv;
  Ajv.prototype.validate = validate;
  Ajv.prototype.compile = compile;
  Ajv.prototype.addSchema = addSchema;
  Ajv.prototype.addMetaSchema = addMetaSchema;
  Ajv.prototype.validateSchema = validateSchema;
  Ajv.prototype.getSchema = getSchema;
  Ajv.prototype.removeSchema = removeSchema;
  Ajv.prototype.addFormat = addFormat;
  Ajv.prototype.errorsText = errorsText;
  Ajv.prototype._addSchema = _addSchema;
  Ajv.prototype._compile = _compile;
  Ajv.prototype.compileAsync = require_async();
  var customKeyword = require_keyword();
  Ajv.prototype.addKeyword = customKeyword.add;
  Ajv.prototype.getKeyword = customKeyword.get;
  Ajv.prototype.removeKeyword = customKeyword.remove;
  Ajv.prototype.validateKeyword = customKeyword.validate;
  var errorClasses = require_error_classes();
  Ajv.ValidationError = errorClasses.Validation;
  Ajv.MissingRefError = errorClasses.MissingRef;
  Ajv.$dataMetaSchema = $dataMetaSchema;
  var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
  var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes", "strictDefaults"];
  var META_SUPPORT_DATA = ["/properties"];
  function Ajv(opts) {
    if (!(this instanceof Ajv))
      return new Ajv(opts);
    opts = this._opts = util.copy(opts) || {};
    setLogger(this);
    this._schemas = {};
    this._refs = {};
    this._fragments = {};
    this._formats = formats(opts.format);
    this._cache = opts.cache || new Cache();
    this._loadingSchemas = {};
    this._compilations = [];
    this.RULES = rules();
    this._getId = chooseGetId(opts);
    opts.loopRequired = opts.loopRequired || Infinity;
    if (opts.errorDataPath == "property")
      opts._errorDataPathProperty = true;
    if (opts.serialize === void 0)
      opts.serialize = stableStringify;
    this._metaOpts = getMetaSchemaOptions(this);
    if (opts.formats)
      addInitialFormats(this);
    if (opts.keywords)
      addInitialKeywords(this);
    addDefaultMetaSchema(this);
    if (typeof opts.meta == "object")
      this.addMetaSchema(opts.meta);
    if (opts.nullable)
      this.addKeyword("nullable", {metaSchema: {type: "boolean"}});
    addInitialSchemas(this);
  }
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == "string") {
      v = this.getSchema(schemaKeyRef);
      if (!v)
        throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = this._addSchema(schemaKeyRef);
      v = schemaObj.validate || this._compile(schemaObj);
    }
    var valid = v(data);
    if (v.$async !== true)
      this.errors = v.errors;
    return valid;
  }
  function compile(schema, _meta) {
    var schemaObj = this._addSchema(schema, void 0, _meta);
    return schemaObj.validate || this._compile(schemaObj);
  }
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)) {
      for (var i = 0; i < schema.length; i++)
        this.addSchema(schema[i], void 0, _skipValidation, _meta);
      return this;
    }
    var id = this._getId(schema);
    if (id !== void 0 && typeof id != "string")
      throw new Error("schema id must be string");
    key = resolve.normalizeId(key || id);
    checkUnique(this, key);
    this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
    return this;
  }
  function addMetaSchema(schema, key, skipValidation) {
    this.addSchema(schema, key, skipValidation, true);
    return this;
  }
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema;
    if ($schema !== void 0 && typeof $schema != "string")
      throw new Error("$schema must be a string");
    $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
    if (!$schema) {
      this.logger.warn("meta-schema not available");
      this.errors = null;
      return true;
    }
    var valid = this.validate($schema, schema);
    if (!valid && throwOrLogError) {
      var message = "schema is invalid: " + this.errorsText();
      if (this._opts.validateSchema == "log")
        this.logger.error(message);
      else
        throw new Error(message);
    }
    return valid;
  }
  function defaultMeta(self2) {
    var meta = self2._opts.meta;
    self2._opts.defaultMeta = typeof meta == "object" ? self2._getId(meta) || meta : self2.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0;
    return self2._opts.defaultMeta;
  }
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(this, keyRef);
    switch (typeof schemaObj) {
      case "object":
        return schemaObj.validate || this._compile(schemaObj);
      case "string":
        return this.getSchema(schemaObj);
      case "undefined":
        return _getSchemaFragment(this, keyRef);
    }
  }
  function _getSchemaFragment(self2, ref) {
    var res = resolve.schema.call(self2, {schema: {}}, ref);
    if (res) {
      var schema = res.schema, root = res.root, baseId = res.baseId;
      var v = compileSchema.call(self2, schema, root, void 0, baseId);
      self2._fragments[ref] = new SchemaObject({
        ref,
        fragment: true,
        schema,
        root,
        baseId,
        validate: v
      });
      return v;
    }
  }
  function _getSchemaObj(self2, keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self2._schemas[keyRef] || self2._refs[keyRef] || self2._fragments[keyRef];
  }
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(this, this._schemas, schemaKeyRef);
      _removeAllSchemas(this, this._refs, schemaKeyRef);
      return this;
    }
    switch (typeof schemaKeyRef) {
      case "undefined":
        _removeAllSchemas(this, this._schemas);
        _removeAllSchemas(this, this._refs);
        this._cache.clear();
        return this;
      case "string":
        var schemaObj = _getSchemaObj(this, schemaKeyRef);
        if (schemaObj)
          this._cache.del(schemaObj.cacheKey);
        delete this._schemas[schemaKeyRef];
        delete this._refs[schemaKeyRef];
        return this;
      case "object":
        var serialize = this._opts.serialize;
        var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
        this._cache.del(cacheKey);
        var id = this._getId(schemaKeyRef);
        if (id) {
          id = resolve.normalizeId(id);
          delete this._schemas[id];
          delete this._refs[id];
        }
    }
    return this;
  }
  function _removeAllSchemas(self2, schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self2._cache.del(schemaObj.cacheKey);
        delete schemas[keyRef];
      }
    }
  }
  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != "object" && typeof schema != "boolean")
      throw new Error("schema should be object or boolean");
    var serialize = this._opts.serialize;
    var cacheKey = serialize ? serialize(schema) : schema;
    var cached = this._cache.get(cacheKey);
    if (cached)
      return cached;
    shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;
    var id = resolve.normalizeId(this._getId(schema));
    if (id && shouldAddSchema)
      checkUnique(this, id);
    var willValidate = this._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema)))
      this.validateSchema(schema, true);
    var localRefs = resolve.ids.call(this, schema);
    var schemaObj = new SchemaObject({
      id,
      schema,
      localRefs,
      cacheKey,
      meta
    });
    if (id[0] != "#" && shouldAddSchema)
      this._refs[id] = schemaObj;
    this._cache.put(cacheKey, schemaObj);
    if (willValidate && recursiveMeta)
      this.validateSchema(schema, true);
    return schemaObj;
  }
  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;
    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = this._opts;
      this._opts = this._metaOpts;
    }
    var v;
    try {
      v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
    } catch (e) {
      delete schemaObj.validate;
      throw e;
    } finally {
      schemaObj.compiling = false;
      if (schemaObj.meta)
        this._opts = currentOpts;
    }
    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;
    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(this, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }
  function chooseGetId(opts) {
    switch (opts.schemaId) {
      case "auto":
        return _get$IdOrId;
      case "id":
        return _getId;
      default:
        return _get$Id;
    }
  }
  function _getId(schema) {
    if (schema.$id)
      this.logger.warn("schema $id ignored", schema.$id);
    return schema.id;
  }
  function _get$Id(schema) {
    if (schema.id)
      this.logger.warn("schema id ignored", schema.id);
    return schema.$id;
  }
  function _get$IdOrId(schema) {
    if (schema.$id && schema.id && schema.$id != schema.id)
      throw new Error("schema $id is different from id");
    return schema.$id || schema.id;
  }
  function errorsText(errors, options) {
    errors = errors || this.errors;
    if (!errors)
      return "No errors";
    options = options || {};
    var separator = options.separator === void 0 ? ", " : options.separator;
    var dataVar = options.dataVar === void 0 ? "data" : options.dataVar;
    var text = "";
    for (var i = 0; i < errors.length; i++) {
      var e = errors[i];
      if (e)
        text += dataVar + e.dataPath + " " + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }
  function addFormat(name, format) {
    if (typeof format == "string")
      format = new RegExp(format);
    this._formats[name] = format;
    return this;
  }
  function addDefaultMetaSchema(self2) {
    var $dataSchema;
    if (self2._opts.$data) {
      $dataSchema = require_data2();
      self2.addMetaSchema($dataSchema, $dataSchema.$id, true);
    }
    if (self2._opts.meta === false)
      return;
    var metaSchema = require_json_schema_draft_07();
    if (self2._opts.$data)
      metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
    self2.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
    self2._refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
  }
  function addInitialSchemas(self2) {
    var optsSchemas = self2._opts.schemas;
    if (!optsSchemas)
      return;
    if (Array.isArray(optsSchemas))
      self2.addSchema(optsSchemas);
    else
      for (var key in optsSchemas)
        self2.addSchema(optsSchemas[key], key);
  }
  function addInitialFormats(self2) {
    for (var name in self2._opts.formats) {
      var format = self2._opts.formats[name];
      self2.addFormat(name, format);
    }
  }
  function addInitialKeywords(self2) {
    for (var name in self2._opts.keywords) {
      var keyword = self2._opts.keywords[name];
      self2.addKeyword(name, keyword);
    }
  }
  function checkUnique(self2, id) {
    if (self2._schemas[id] || self2._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }
  function getMetaSchemaOptions(self2) {
    var metaOpts = util.copy(self2._opts);
    for (var i = 0; i < META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
  function setLogger(self2) {
    var logger = self2._opts.logger;
    if (logger === false) {
      self2.logger = {log: noop, warn: noop, error: noop};
    } else {
      if (logger === void 0)
        logger = console;
      if (!(typeof logger == "object" && logger.log && logger.warn && logger.error))
        throw new Error("logger must implement log, warn and error methods");
      self2.logger = logger;
    }
  }
  function noop() {
  }
});

// node_modules/ajv/lib/refs/json-schema-draft-04.json
var require_json_schema_draft_04 = __commonJS((exports2, module2) => {
  module2.exports = {
    id: "http://json-schema.org/draft-04/schema#",
    $schema: "http://json-schema.org/draft-04/schema#",
    description: "Core schema meta-schema",
    definitions: {
      schemaArray: {
        type: "array",
        minItems: 1,
        items: {$ref: "#"}
      },
      positiveInteger: {
        type: "integer",
        minimum: 0
      },
      positiveIntegerDefault0: {
        allOf: [{$ref: "#/definitions/positiveInteger"}, {default: 0}]
      },
      simpleTypes: {
        enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
      },
      stringArray: {
        type: "array",
        items: {type: "string"},
        minItems: 1,
        uniqueItems: true
      }
    },
    type: "object",
    properties: {
      id: {
        type: "string"
      },
      $schema: {
        type: "string"
      },
      title: {
        type: "string"
      },
      description: {
        type: "string"
      },
      default: {},
      multipleOf: {
        type: "number",
        minimum: 0,
        exclusiveMinimum: true
      },
      maximum: {
        type: "number"
      },
      exclusiveMaximum: {
        type: "boolean",
        default: false
      },
      minimum: {
        type: "number"
      },
      exclusiveMinimum: {
        type: "boolean",
        default: false
      },
      maxLength: {$ref: "#/definitions/positiveInteger"},
      minLength: {$ref: "#/definitions/positiveIntegerDefault0"},
      pattern: {
        type: "string",
        format: "regex"
      },
      additionalItems: {
        anyOf: [
          {type: "boolean"},
          {$ref: "#"}
        ],
        default: {}
      },
      items: {
        anyOf: [
          {$ref: "#"},
          {$ref: "#/definitions/schemaArray"}
        ],
        default: {}
      },
      maxItems: {$ref: "#/definitions/positiveInteger"},
      minItems: {$ref: "#/definitions/positiveIntegerDefault0"},
      uniqueItems: {
        type: "boolean",
        default: false
      },
      maxProperties: {$ref: "#/definitions/positiveInteger"},
      minProperties: {$ref: "#/definitions/positiveIntegerDefault0"},
      required: {$ref: "#/definitions/stringArray"},
      additionalProperties: {
        anyOf: [
          {type: "boolean"},
          {$ref: "#"}
        ],
        default: {}
      },
      definitions: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      properties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      patternProperties: {
        type: "object",
        additionalProperties: {$ref: "#"},
        default: {}
      },
      dependencies: {
        type: "object",
        additionalProperties: {
          anyOf: [
            {$ref: "#"},
            {$ref: "#/definitions/stringArray"}
          ]
        }
      },
      enum: {
        type: "array",
        minItems: 1,
        uniqueItems: true
      },
      type: {
        anyOf: [
          {$ref: "#/definitions/simpleTypes"},
          {
            type: "array",
            items: {$ref: "#/definitions/simpleTypes"},
            minItems: 1,
            uniqueItems: true
          }
        ]
      },
      format: {type: "string"},
      allOf: {$ref: "#/definitions/schemaArray"},
      anyOf: {$ref: "#/definitions/schemaArray"},
      oneOf: {$ref: "#/definitions/schemaArray"},
      not: {$ref: "#"}
    },
    dependencies: {
      exclusiveMaximum: ["maximum"],
      exclusiveMinimum: ["minimum"]
    },
    default: {}
  };
});

// node_modules/@eslint/eslintrc/lib/shared/ajv.js
var require_ajv2 = __commonJS((exports2, module2) => {
  "use strict";
  var Ajv = require_ajv();
  var metaSchema = require_json_schema_draft_04();
  module2.exports = (additionalOptions = {}) => {
    const ajv = new Ajv(__objSpread({
      meta: false,
      useDefaults: true,
      validateSchema: false,
      missingRefs: "ignore",
      verbose: true,
      schemaId: "auto"
    }, additionalOptions));
    ajv.addMetaSchema(metaSchema);
    ajv._opts.defaultMeta = metaSchema.id;
    return ajv;
  };
});

// node_modules/@eslint/eslintrc/lib/shared/config-validator.js
var require_config_validator = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var configSchema = require_config_schema();
  var BuiltInEnvironments = require_environments();
  var ConfigOps = require_config_ops();
  var {emitDeprecationWarning} = require_deprecation_warnings();
  var ajv = require_ajv2()();
  var ruleValidators = new WeakMap();
  var noop = Function.prototype;
  var validateSchema;
  var severityMap = {
    error: 2,
    warn: 1,
    off: 0
  };
  var validated = new WeakSet();
  module2.exports = class ConfigValidator {
    constructor({builtInRules = new Map()} = {}) {
      this.builtInRules = builtInRules;
    }
    getRuleOptionsSchema(rule) {
      if (!rule) {
        return null;
      }
      const schema = rule.schema || rule.meta && rule.meta.schema;
      if (Array.isArray(schema)) {
        if (schema.length) {
          return {
            type: "array",
            items: schema,
            minItems: 0,
            maxItems: schema.length
          };
        }
        return {
          type: "array",
          minItems: 0,
          maxItems: 0
        };
      }
      return schema || null;
    }
    validateRuleSeverity(options) {
      const severity = Array.isArray(options) ? options[0] : options;
      const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;
      if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
        return normSeverity;
      }
      throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
    }
    validateRuleSchema(rule, localOptions) {
      if (!ruleValidators.has(rule)) {
        const schema = this.getRuleOptionsSchema(rule);
        if (schema) {
          ruleValidators.set(rule, ajv.compile(schema));
        }
      }
      const validateRule = ruleValidators.get(rule);
      if (validateRule) {
        validateRule(localOptions);
        if (validateRule.errors) {
          throw new Error(validateRule.errors.map((error5) => `	Value ${JSON.stringify(error5.data)} ${error5.message}.
`).join(""));
        }
      }
    }
    validateRuleOptions(rule, ruleId, options, source = null) {
      try {
        const severity = this.validateRuleSeverity(options);
        if (severity !== 0) {
          this.validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
        }
      } catch (err) {
        const enhancedMessage = `Configuration for rule "${ruleId}" is invalid:
${err.message}`;
        if (typeof source === "string") {
          throw new Error(`${source}:
	${enhancedMessage}`);
        } else {
          throw new Error(enhancedMessage);
        }
      }
    }
    validateEnvironment(environment, source, getAdditionalEnv = noop) {
      if (!environment) {
        return;
      }
      Object.keys(environment).forEach((id) => {
        const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;
        if (!env) {
          const message = `${source}:
	Environment key "${id}" is unknown
`;
          throw new Error(message);
        }
      });
    }
    validateRules(rulesConfig, source, getAdditionalRule = noop) {
      if (!rulesConfig) {
        return;
      }
      Object.keys(rulesConfig).forEach((id) => {
        const rule = getAdditionalRule(id) || this.builtInRules.get(id) || null;
        this.validateRuleOptions(rule, id, rulesConfig[id], source);
      });
    }
    validateGlobals(globalsConfig, source = null) {
      if (!globalsConfig) {
        return;
      }
      Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {
        try {
          ConfigOps.normalizeConfigGlobal(configuredValue);
        } catch (err) {
          throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:
${err.message}`);
        }
      });
    }
    validateProcessor(processorName, source, getProcessor) {
      if (processorName && !getProcessor(processorName)) {
        throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);
      }
    }
    formatErrors(errors) {
      return errors.map((error5) => {
        if (error5.keyword === "additionalProperties") {
          const formattedPropertyPath = error5.dataPath.length ? `${error5.dataPath.slice(1)}.${error5.params.additionalProperty}` : error5.params.additionalProperty;
          return `Unexpected top-level property "${formattedPropertyPath}"`;
        }
        if (error5.keyword === "type") {
          const formattedField = error5.dataPath.slice(1);
          const formattedExpectedType = Array.isArray(error5.schema) ? error5.schema.join("/") : error5.schema;
          const formattedValue = JSON.stringify(error5.data);
          return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
        }
        const field = error5.dataPath[0] === "." ? error5.dataPath.slice(1) : error5.dataPath;
        return `"${field}" ${error5.message}. Value: ${JSON.stringify(error5.data)}`;
      }).map((message) => `	- ${message}.
`).join("");
    }
    validateConfigSchema(config, source = null) {
      validateSchema = validateSchema || ajv.compile(configSchema);
      if (!validateSchema(config)) {
        throw new Error(`ESLint configuration in ${source} is invalid:
${this.formatErrors(validateSchema.errors)}`);
      }
      if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
        emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
      }
    }
    validate(config, source, getAdditionalRule, getAdditionalEnv) {
      this.validateConfigSchema(config, source);
      this.validateRules(config.rules, source, getAdditionalRule);
      this.validateEnvironment(config.env, source, getAdditionalEnv);
      this.validateGlobals(config.globals, source);
      for (const override of config.overrides || []) {
        this.validateRules(override.rules, source, getAdditionalRule);
        this.validateEnvironment(override.env, source, getAdditionalEnv);
        this.validateGlobals(config.globals, source);
      }
    }
    validateConfigArray(configArray) {
      const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
      const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
      const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);
      for (const element of configArray) {
        if (validated.has(element)) {
          continue;
        }
        validated.add(element);
        this.validateEnvironment(element.env, element.name, getPluginEnv);
        this.validateGlobals(element.globals, element.name);
        this.validateProcessor(element.processor, element.name, getPluginProcessor);
        this.validateRules(element.rules, element.name, getPluginRule);
      }
    }
  };
});

// node_modules/@eslint/eslintrc/lib/shared/naming.js
var require_naming = __commonJS((exports2, module2) => {
  "use strict";
  var NAMESPACE_REGEX = /^@.*\//iu;
  function normalizePackageName(name, prefix) {
    let normalizedName = name;
    if (normalizedName.includes("\\")) {
      normalizedName = normalizedName.replace(/\\/gu, "/");
    }
    if (normalizedName.charAt(0) === "@") {
      const scopedPackageShortcutRegex = new RegExp(`^(@[^/]+)(?:/(?:${prefix})?)?$`, "u"), scopedPackageNameRegex = new RegExp(`^${prefix}(-|$)`, "u");
      if (scopedPackageShortcutRegex.test(normalizedName)) {
        normalizedName = normalizedName.replace(scopedPackageShortcutRegex, `$1/${prefix}`);
      } else if (!scopedPackageNameRegex.test(normalizedName.split("/")[1])) {
        normalizedName = normalizedName.replace(/^@([^/]+)\/(.*)$/u, `@$1/${prefix}-$2`);
      }
    } else if (!normalizedName.startsWith(`${prefix}-`)) {
      normalizedName = `${prefix}-${normalizedName}`;
    }
    return normalizedName;
  }
  function getShorthandName(fullname, prefix) {
    if (fullname[0] === "@") {
      let matchResult = new RegExp(`^(@[^/]+)/${prefix}$`, "u").exec(fullname);
      if (matchResult) {
        return matchResult[1];
      }
      matchResult = new RegExp(`^(@[^/]+)/${prefix}-(.+)$`, "u").exec(fullname);
      if (matchResult) {
        return `${matchResult[1]}/${matchResult[2]}`;
      }
    } else if (fullname.startsWith(`${prefix}-`)) {
      return fullname.slice(prefix.length + 1);
    }
    return fullname;
  }
  function getNamespaceFromTerm(term) {
    const match = term.match(NAMESPACE_REGEX);
    return match ? match[0] : "";
  }
  module2.exports = {
    normalizePackageName,
    getShorthandName,
    getNamespaceFromTerm
  };
});

// node_modules/@eslint/eslintrc/lib/shared/relative-module-resolver.js
var require_relative_module_resolver = __commonJS((exports2, module2) => {
  "use strict";
  var Module = require("module");
  var createRequire = Module.createRequire || Module.createRequireFromPath;
  module2.exports = {
    resolve(moduleName, relativeToPath) {
      try {
        return createRequire(relativeToPath).resolve(moduleName);
      } catch (error5) {
        if (typeof error5 === "object" && error5 !== null && error5.code === "MODULE_NOT_FOUND" && !error5.requireStack && error5.message.includes(moduleName)) {
          error5.message += `
Require stack:
- ${relativeToPath}`;
        }
        throw error5;
      }
    }
  };
});

// node_modules/ignore/index.js
var require_ignore = __commonJS((exports2, module2) => {
  function make_array(subject) {
    return Array.isArray(subject) ? subject : [subject];
  }
  var REGEX_BLANK_LINE = /^\s+$/;
  var REGEX_LEADING_EXCAPED_EXCLAMATION = /^\\!/;
  var REGEX_LEADING_EXCAPED_HASH = /^\\#/;
  var SLASH = "/";
  var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("node-ignore") : "node-ignore";
  var define2 = (object, key, value) => Object.defineProperty(object, key, {value});
  var REGEX_REGEXP_RANGE = /([0-z])-([0-z])/g;
  var sanitizeRange = (range) => range.replace(REGEX_REGEXP_RANGE, (match, from, to) => from.charCodeAt(0) <= to.charCodeAt(0) ? match : "");
  var DEFAULT_REPLACER_PREFIX = [
    [
      /\\?\s+$/,
      (match) => match.indexOf("\\") === 0 ? " " : ""
    ],
    [
      /\\\s/g,
      () => " "
    ],
    [
      /[\\^$.|*+(){]/g,
      (match) => `\\${match}`
    ],
    [
      /\[([^\]/]*)($|\])/g,
      (match, p1, p2) => p2 === "]" ? `[${sanitizeRange(p1)}]` : `\\${match}`
    ],
    [
      /(?!\\)\?/g,
      () => "[^/]"
    ],
    [
      /^\//,
      () => "^"
    ],
    [
      /\//g,
      () => "\\/"
    ],
    [
      /^\^*\\\*\\\*\\\//,
      () => "^(?:.*\\/)?"
    ]
  ];
  var DEFAULT_REPLACER_SUFFIX = [
    [
      /^(?=[^^])/,
      function startingReplacer() {
        return !/\/(?!$)/.test(this) ? "(?:^|\\/)" : "^";
      }
    ],
    [
      /\\\/\\\*\\\*(?=\\\/|$)/g,
      (match, index, str) => index + 6 < str.length ? "(?:\\/[^\\/]+)*" : "\\/.+"
    ],
    [
      /(^|[^\\]+)\\\*(?=.+)/g,
      (match, p1) => `${p1}[^\\/]*`
    ],
    [
      /(\^|\\\/)?\\\*$/,
      (match, p1) => {
        const prefix = p1 ? `${p1}[^/]+` : "[^/]*";
        return `${prefix}(?=$|\\/$)`;
      }
    ],
    [
      /\\\\\\/g,
      () => "\\"
    ]
  ];
  var POSITIVE_REPLACERS = [
    ...DEFAULT_REPLACER_PREFIX,
    [
      /(?:[^*/])$/,
      (match) => `${match}(?=$|\\/)`
    ],
    ...DEFAULT_REPLACER_SUFFIX
  ];
  var NEGATIVE_REPLACERS = [
    ...DEFAULT_REPLACER_PREFIX,
    [
      /(?:[^*])$/,
      (match) => `${match}(?=$|\\/$)`
    ],
    ...DEFAULT_REPLACER_SUFFIX
  ];
  var cache = Object.create(null);
  var make_regex = (pattern, negative, ignorecase) => {
    const r = cache[pattern];
    if (r) {
      return r;
    }
    const replacers = negative ? NEGATIVE_REPLACERS : POSITIVE_REPLACERS;
    const source = replacers.reduce((prev, current) => prev.replace(current[0], current[1].bind(pattern)), pattern);
    return cache[pattern] = ignorecase ? new RegExp(source, "i") : new RegExp(source);
  };
  var checkPattern = (pattern) => pattern && typeof pattern === "string" && !REGEX_BLANK_LINE.test(pattern) && pattern.indexOf("#") !== 0;
  var createRule = (pattern, ignorecase) => {
    const origin = pattern;
    let negative = false;
    if (pattern.indexOf("!") === 0) {
      negative = true;
      pattern = pattern.substr(1);
    }
    pattern = pattern.replace(REGEX_LEADING_EXCAPED_EXCLAMATION, "!").replace(REGEX_LEADING_EXCAPED_HASH, "#");
    const regex = make_regex(pattern, negative, ignorecase);
    return {
      origin,
      pattern,
      negative,
      regex
    };
  };
  var IgnoreBase = class {
    constructor({
      ignorecase = true
    } = {}) {
      this._rules = [];
      this._ignorecase = ignorecase;
      define2(this, KEY_IGNORE, true);
      this._initCache();
    }
    _initCache() {
      this._cache = Object.create(null);
    }
    add(pattern) {
      this._added = false;
      if (typeof pattern === "string") {
        pattern = pattern.split(/\r?\n/g);
      }
      make_array(pattern).forEach(this._addPattern, this);
      if (this._added) {
        this._initCache();
      }
      return this;
    }
    addPattern(pattern) {
      return this.add(pattern);
    }
    _addPattern(pattern) {
      if (pattern && pattern[KEY_IGNORE]) {
        this._rules = this._rules.concat(pattern._rules);
        this._added = true;
        return;
      }
      if (checkPattern(pattern)) {
        const rule = createRule(pattern, this._ignorecase);
        this._added = true;
        this._rules.push(rule);
      }
    }
    filter(paths) {
      return make_array(paths).filter((path3) => this._filter(path3));
    }
    createFilter() {
      return (path3) => this._filter(path3);
    }
    ignores(path3) {
      return !this._filter(path3);
    }
    _filter(path3, slices) {
      if (!path3) {
        return false;
      }
      if (path3 in this._cache) {
        return this._cache[path3];
      }
      if (!slices) {
        slices = path3.split(SLASH);
      }
      slices.pop();
      return this._cache[path3] = slices.length ? this._filter(slices.join(SLASH) + SLASH, slices) && this._test(path3) : this._test(path3);
    }
    _test(path3) {
      let matched = 0;
      this._rules.forEach((rule) => {
        if (!(matched ^ rule.negative)) {
          matched = rule.negative ^ rule.regex.test(path3);
        }
      });
      return !matched;
    }
  };
  if (typeof process !== "undefined" && (process.env && process.env.IGNORE_TEST_WIN32 || process.platform === "win32")) {
    const filter = IgnoreBase.prototype._filter;
    const make_posix = (str) => /^\\\\\?\\/.test(str) || /[^\x00-\x80]+/.test(str) ? str : str.replace(/\\/g, "/");
    IgnoreBase.prototype._filter = function filterWin32(path3, slices) {
      path3 = make_posix(path3);
      return filter.call(this, path3, slices);
    };
  }
  module2.exports = (options) => new IgnoreBase(options);
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.instances = [];
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      function debug5(...args) {
        if (!debug5.enabled) {
          return;
        }
        const self2 = debug5;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return match;
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug5.namespace = namespace;
      debug5.enabled = createDebug.enabled(namespace);
      debug5.useColors = createDebug.useColors();
      debug5.color = selectColor(namespace);
      debug5.destroy = destroy;
      debug5.extend = extend;
      if (typeof createDebug.init === "function") {
        createDebug.init(debug5);
      }
      createDebug.instances.push(debug5);
      return debug5;
    }
    function destroy() {
      const index = createDebug.instances.indexOf(this);
      if (index !== -1) {
        createDebug.instances.splice(index, 1);
        return true;
      }
      return false;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
      for (i = 0; i < createDebug.instances.length; i++) {
        const instance = createDebug.instances[i];
        instance.enabled = createDebug.enabled(instance.namespace);
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports2, module2) => {
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log(...args) {
    return typeof console === "object" && console.log && console.log(...args);
  }
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error5) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error5) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error5) {
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error5) {
      return "[UnexpectedJSONParseError]: " + error5.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (flag, argv) => {
    argv = argv || process.argv;
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const pos = argv.indexOf(prefix + flag);
    const terminatorPos = argv.indexOf("--");
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var hasFlag = require_has_flag();
  var env = process.env;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
    forceColor = false;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = true;
  }
  if ("FORCE_COLOR" in env) {
    forceColor = env.FORCE_COLOR.length === 0 || parseInt(env.FORCE_COLOR, 10) !== 0;
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }
    const min = forceColor ? 1 : 0;
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some((sign) => sign in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    if (env.TERM === "dumb") {
      return min;
    }
    return min;
  }
  function getSupportLevel(stream) {
    const level = supportsColor(stream);
    return translateLevel(level);
  }
  module2.exports = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports2, module2) => {
  var tty = require("tty");
  var util = require("util");
  exports2.init = init;
  exports2.log = log;
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports2.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error5) {
  }
  exports2.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  function useColors() {
    return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  }
  function formatArgs(args) {
    const {namespace: name, useColors: useColors2} = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} [0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  }
  function getDate() {
    if (exports2.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  }
  function log(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  }
  function save(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  }
  function load() {
    return process.env.DEBUG;
  }
  function init(debug5) {
    debug5.inspectOpts = {};
    const keys = Object.keys(exports2.inspectOpts);
    for (let i = 0; i < keys.length; i++) {
      debug5.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
    }
  }
  module2.exports = require_common()(exports2);
  var {formatters} = module2.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).replace(/\s*\n\s*/g, " ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports2, module2) => {
  if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
    module2.exports = require_browser();
  } else {
    module2.exports = require_node();
  }
});

// node_modules/@eslint/eslintrc/lib/config-array/ignore-pattern.js
var require_ignore_pattern = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var path3 = require("path");
  var ignore = require_ignore();
  var debug5 = require_src()("eslintrc:ignore-pattern");
  function getCommonAncestorPath(sourcePaths) {
    let result = sourcePaths[0];
    for (let i = 1; i < sourcePaths.length; ++i) {
      const a = result;
      const b = sourcePaths[i];
      result = a.length < b.length ? a : b;
      for (let j = 0, lastSepPos = 0; j < a.length && j < b.length; ++j) {
        if (a[j] !== b[j]) {
          result = a.slice(0, lastSepPos);
          break;
        }
        if (a[j] === path3.sep) {
          lastSepPos = j;
        }
      }
    }
    let resolvedResult = result || path3.sep;
    if (resolvedResult && resolvedResult.endsWith(":") && process.platform === "win32") {
      resolvedResult += path3.sep;
    }
    return resolvedResult;
  }
  function relative(from, to) {
    const relPath = path3.relative(from, to);
    if (path3.sep === "/") {
      return relPath;
    }
    return relPath.split(path3.sep).join("/");
  }
  function dirSuffix(filePath) {
    const isDir = filePath.endsWith(path3.sep) || process.platform === "win32" && filePath.endsWith("/");
    return isDir ? "/" : "";
  }
  var DefaultPatterns = Object.freeze(["/**/node_modules/*"]);
  var DotPatterns = Object.freeze([".*", "!.eslintrc.*", "!../"]);
  var IgnorePattern = class {
    static get DefaultPatterns() {
      return DefaultPatterns;
    }
    static createDefaultIgnore(cwd) {
      return this.createIgnore([new IgnorePattern(DefaultPatterns, cwd)]);
    }
    static createIgnore(ignorePatterns) {
      debug5("Create with: %o", ignorePatterns);
      const basePath = getCommonAncestorPath(ignorePatterns.map((p) => p.basePath));
      const patterns = [].concat(...ignorePatterns.map((p) => p.getPatternsRelativeTo(basePath)));
      const ig = ignore().add([...DotPatterns, ...patterns]);
      const dotIg = ignore().add(patterns);
      debug5("  processed: %o", {basePath, patterns});
      return Object.assign((filePath, dot = false) => {
        assert(path3.isAbsolute(filePath), "'filePath' should be an absolute path.");
        const relPathRaw = relative(basePath, filePath);
        const relPath = relPathRaw && relPathRaw + dirSuffix(filePath);
        const adoptedIg = dot ? dotIg : ig;
        const result = relPath !== "" && adoptedIg.ignores(relPath);
        debug5("Check", {filePath, dot, relativePath: relPath, result});
        return result;
      }, {basePath, patterns});
    }
    constructor(patterns, basePath) {
      assert(path3.isAbsolute(basePath), "'basePath' should be an absolute path.");
      this.patterns = patterns;
      this.basePath = basePath;
      this.loose = false;
    }
    getPatternsRelativeTo(newBasePath) {
      assert(path3.isAbsolute(newBasePath), "'newBasePath' should be an absolute path.");
      const {basePath, loose, patterns} = this;
      if (newBasePath === basePath) {
        return patterns;
      }
      const prefix = `/${relative(newBasePath, basePath)}`;
      return patterns.map((pattern) => {
        const negative = pattern.startsWith("!");
        const head = negative ? "!" : "";
        const body = negative ? pattern.slice(1) : pattern;
        if (body.startsWith("/") || body.startsWith("../")) {
          return `${head}${prefix}${body}`;
        }
        return loose ? pattern : `${head}${prefix}/**/${body}`;
      });
    }
  };
  module2.exports = {IgnorePattern};
});

// node_modules/@eslint/eslintrc/lib/config-array/extracted-config.js
var require_extracted_config = __commonJS((exports2, module2) => {
  "use strict";
  var {IgnorePattern} = require_ignore_pattern();
  function startsWith(xs, ys) {
    return xs.length >= ys.length && ys.every((y, i) => y === xs[i]);
  }
  var ExtractedConfig = class {
    constructor() {
      this.configNameOfNoInlineConfig = "";
      this.env = {};
      this.globals = {};
      this.ignores = void 0;
      this.noInlineConfig = void 0;
      this.parser = null;
      this.parserOptions = {};
      this.plugins = {};
      this.processor = null;
      this.reportUnusedDisableDirectives = void 0;
      this.rules = {};
      this.settings = {};
    }
    toCompatibleObjectAsConfigFileContent() {
      const _a = this, {
        configNameOfNoInlineConfig: _ignore1,
        processor: _ignore2,
        ignores
      } = _a, config = __objRest(_a, [
        "configNameOfNoInlineConfig",
        "processor",
        "ignores"
      ]);
      config.parser = config.parser && config.parser.filePath;
      config.plugins = Object.keys(config.plugins).filter(Boolean).reverse();
      config.ignorePatterns = ignores ? ignores.patterns : [];
      if (startsWith(config.ignorePatterns, IgnorePattern.DefaultPatterns)) {
        config.ignorePatterns = config.ignorePatterns.slice(IgnorePattern.DefaultPatterns.length);
      }
      return config;
    }
  };
  module2.exports = {ExtractedConfig};
});

// node_modules/@eslint/eslintrc/lib/config-array/config-array.js
var require_config_array = __commonJS((exports2, module2) => {
  "use strict";
  var {ExtractedConfig} = require_extracted_config();
  var {IgnorePattern} = require_ignore_pattern();
  var internalSlotsMap = new class extends WeakMap {
    get(key) {
      let value = super.get(key);
      if (!value) {
        value = {
          cache: new Map(),
          envMap: null,
          processorMap: null,
          ruleMap: null
        };
        super.set(key, value);
      }
      return value;
    }
  }();
  function getMatchedIndices(elements, filePath) {
    const indices = [];
    for (let i = elements.length - 1; i >= 0; --i) {
      const element = elements[i];
      if (!element.criteria || filePath && element.criteria.test(filePath)) {
        indices.push(i);
      }
    }
    return indices;
  }
  function isNonNullObject(x) {
    return typeof x === "object" && x !== null;
  }
  function mergeWithoutOverwrite(target, source) {
    if (!isNonNullObject(source)) {
      return;
    }
    for (const key of Object.keys(source)) {
      if (key === "__proto__") {
        continue;
      }
      if (isNonNullObject(target[key])) {
        mergeWithoutOverwrite(target[key], source[key]);
      } else if (target[key] === void 0) {
        if (isNonNullObject(source[key])) {
          target[key] = Array.isArray(source[key]) ? [] : {};
          mergeWithoutOverwrite(target[key], source[key]);
        } else if (source[key] !== void 0) {
          target[key] = source[key];
        }
      }
    }
  }
  var PluginConflictError = class extends Error {
    constructor(pluginId, plugins) {
      super(`Plugin "${pluginId}" was conflicted between ${plugins.map((p) => `"${p.importerName}"`).join(" and ")}.`);
      this.messageTemplate = "plugin-conflict";
      this.messageData = {pluginId, plugins};
    }
  };
  function mergePlugins(target, source) {
    if (!isNonNullObject(source)) {
      return;
    }
    for (const key of Object.keys(source)) {
      if (key === "__proto__") {
        continue;
      }
      const targetValue = target[key];
      const sourceValue = source[key];
      if (targetValue === void 0) {
        if (sourceValue.error) {
          throw sourceValue.error;
        }
        target[key] = sourceValue;
      } else if (sourceValue.filePath !== targetValue.filePath) {
        throw new PluginConflictError(key, [
          {
            filePath: targetValue.filePath,
            importerName: targetValue.importerName
          },
          {
            filePath: sourceValue.filePath,
            importerName: sourceValue.importerName
          }
        ]);
      }
    }
  }
  function mergeRuleConfigs(target, source) {
    if (!isNonNullObject(source)) {
      return;
    }
    for (const key of Object.keys(source)) {
      if (key === "__proto__") {
        continue;
      }
      const targetDef = target[key];
      const sourceDef = source[key];
      if (targetDef === void 0) {
        if (Array.isArray(sourceDef)) {
          target[key] = [...sourceDef];
        } else {
          target[key] = [sourceDef];
        }
      } else if (targetDef.length === 1 && Array.isArray(sourceDef) && sourceDef.length >= 2) {
        targetDef.push(...sourceDef.slice(1));
      }
    }
  }
  function createConfig(instance, indices) {
    const config = new ExtractedConfig();
    const ignorePatterns = [];
    for (const index of indices) {
      const element = instance[index];
      if (!config.parser && element.parser) {
        if (element.parser.error) {
          throw element.parser.error;
        }
        config.parser = element.parser;
      }
      if (!config.processor && element.processor) {
        config.processor = element.processor;
      }
      if (config.noInlineConfig === void 0 && element.noInlineConfig !== void 0) {
        config.noInlineConfig = element.noInlineConfig;
        config.configNameOfNoInlineConfig = element.name;
      }
      if (config.reportUnusedDisableDirectives === void 0 && element.reportUnusedDisableDirectives !== void 0) {
        config.reportUnusedDisableDirectives = element.reportUnusedDisableDirectives;
      }
      if (element.ignorePattern) {
        ignorePatterns.push(element.ignorePattern);
      }
      mergeWithoutOverwrite(config.env, element.env);
      mergeWithoutOverwrite(config.globals, element.globals);
      mergeWithoutOverwrite(config.parserOptions, element.parserOptions);
      mergeWithoutOverwrite(config.settings, element.settings);
      mergePlugins(config.plugins, element.plugins);
      mergeRuleConfigs(config.rules, element.rules);
    }
    if (ignorePatterns.length > 0) {
      config.ignores = IgnorePattern.createIgnore(ignorePatterns.reverse());
    }
    return config;
  }
  function collect(pluginId, defs, map, normalize) {
    if (defs) {
      const prefix = pluginId && `${pluginId}/`;
      for (const [key, value] of Object.entries(defs)) {
        map.set(`${prefix}${key}`, normalize ? normalize(value) : value);
      }
    }
  }
  function normalizePluginRule(rule) {
    return typeof rule === "function" ? {create: rule} : rule;
  }
  function deleteMutationMethods(map) {
    Object.defineProperties(map, {
      clear: {configurable: true, value: void 0},
      delete: {configurable: true, value: void 0},
      set: {configurable: true, value: void 0}
    });
  }
  function initPluginMemberMaps(elements, slots) {
    const processed = new Set();
    slots.envMap = new Map();
    slots.processorMap = new Map();
    slots.ruleMap = new Map();
    for (const element of elements) {
      if (!element.plugins) {
        continue;
      }
      for (const [pluginId, value] of Object.entries(element.plugins)) {
        const plugin = value.definition;
        if (!plugin || processed.has(pluginId)) {
          continue;
        }
        processed.add(pluginId);
        collect(pluginId, plugin.environments, slots.envMap);
        collect(pluginId, plugin.processors, slots.processorMap);
        collect(pluginId, plugin.rules, slots.ruleMap, normalizePluginRule);
      }
    }
    deleteMutationMethods(slots.envMap);
    deleteMutationMethods(slots.processorMap);
    deleteMutationMethods(slots.ruleMap);
  }
  function ensurePluginMemberMaps(instance) {
    const slots = internalSlotsMap.get(instance);
    if (!slots.ruleMap) {
      initPluginMemberMaps(instance, slots);
    }
    return slots;
  }
  var ConfigArray = class extends Array {
    get pluginEnvironments() {
      return ensurePluginMemberMaps(this).envMap;
    }
    get pluginProcessors() {
      return ensurePluginMemberMaps(this).processorMap;
    }
    get pluginRules() {
      return ensurePluginMemberMaps(this).ruleMap;
    }
    isRoot() {
      for (let i = this.length - 1; i >= 0; --i) {
        const root = this[i].root;
        if (typeof root === "boolean") {
          return root;
        }
      }
      return false;
    }
    extractConfig(filePath) {
      const {cache} = internalSlotsMap.get(this);
      const indices = getMatchedIndices(this, filePath);
      const cacheKey = indices.join(",");
      if (!cache.has(cacheKey)) {
        cache.set(cacheKey, createConfig(this, indices));
      }
      return cache.get(cacheKey);
    }
    isAdditionalTargetPath(filePath) {
      for (const {criteria, type} of this) {
        if (type === "config" && criteria && !criteria.endsWithWildcard && criteria.test(filePath)) {
          return true;
        }
      }
      return false;
    }
  };
  var exportObject = {
    ConfigArray,
    getUsedExtractedConfigs(instance) {
      const {cache} = internalSlotsMap.get(instance);
      return Array.from(cache.values());
    }
  };
  module2.exports = exportObject;
});

// node_modules/@eslint/eslintrc/lib/config-array/config-dependency.js
var require_config_dependency = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var ConfigDependency = class {
    constructor({
      definition = null,
      error: error5 = null,
      filePath = null,
      id,
      importerName,
      importerPath
    }) {
      this.definition = definition;
      this.error = error5;
      this.filePath = filePath;
      this.id = id;
      this.importerName = importerName;
      this.importerPath = importerPath;
    }
    toJSON() {
      const obj = this[util.inspect.custom]();
      if (obj.error instanceof Error) {
        obj.error = __objSpread(__objSpread({}, obj.error), {message: obj.error.message});
      }
      return obj;
    }
    [util.inspect.custom]() {
      const _a = this, {
        definition: _ignore
      } = _a, obj = __objRest(_a, [
        "definition"
      ]);
      return obj;
    }
  };
  module2.exports = {ConfigDependency};
});

// node_modules/concat-map/index.js
var require_concat_map = __commonJS((exports2, module2) => {
  module2.exports = function(xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
      var x = fn(xs[i], i);
      if (isArray(x))
        res.push.apply(res, x);
      else
        res.push(x);
    }
    return res;
  };
  var isArray = Array.isArray || function(xs) {
    return Object.prototype.toString.call(xs) === "[object Array]";
  };
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = balanced;
  function balanced(a, b, str) {
    if (a instanceof RegExp)
      a = maybeMatch(a, str);
    if (b instanceof RegExp)
      b = maybeMatch(b, str);
    var r = range(a, b, str);
    return r && {
      start: r[0],
      end: r[1],
      pre: str.slice(0, r[0]),
      body: str.slice(r[0] + a.length, r[1]),
      post: str.slice(r[1] + b.length)
    };
  }
  function maybeMatch(reg, str) {
    var m = str.match(reg);
    return m ? m[0] : null;
  }
  balanced.range = range;
  function range(a, b, str) {
    var begs, beg, left, right, result;
    var ai = str.indexOf(a);
    var bi = str.indexOf(b, ai + 1);
    var i = ai;
    if (ai >= 0 && bi > 0) {
      begs = [];
      left = str.length;
      while (i >= 0 && !result) {
        if (i == ai) {
          begs.push(i);
          ai = str.indexOf(a, i + 1);
        } else if (begs.length == 1) {
          result = [begs.pop(), bi];
        } else {
          beg = begs.pop();
          if (beg < left) {
            left = beg;
            right = bi;
          }
          bi = str.indexOf(b, i + 1);
        }
        i = ai < bi && ai >= 0 ? ai : bi;
      }
      if (begs.length) {
        result = [left, right];
      }
    }
    return result;
  }
});

// node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS((exports2, module2) => {
  var concatMap = require_concat_map();
  var balanced = require_balanced_match();
  module2.exports = expandTop;
  var escSlash = "\0SLASH" + Math.random() + "\0";
  var escOpen = "\0OPEN" + Math.random() + "\0";
  var escClose = "\0CLOSE" + Math.random() + "\0";
  var escComma = "\0COMMA" + Math.random() + "\0";
  var escPeriod = "\0PERIOD" + Math.random() + "\0";
  function numeric(str) {
    return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
  }
  function escapeBraces(str) {
    return str.split("\\\\").join(escSlash).split("\\{").join(escOpen).split("\\}").join(escClose).split("\\,").join(escComma).split("\\.").join(escPeriod);
  }
  function unescapeBraces(str) {
    return str.split(escSlash).join("\\").split(escOpen).join("{").split(escClose).join("}").split(escComma).join(",").split(escPeriod).join(".");
  }
  function parseCommaParts(str) {
    if (!str)
      return [""];
    var parts = [];
    var m = balanced("{", "}", str);
    if (!m)
      return str.split(",");
    var pre = m.pre;
    var body = m.body;
    var post = m.post;
    var p = pre.split(",");
    p[p.length - 1] += "{" + body + "}";
    var postParts = parseCommaParts(post);
    if (post.length) {
      p[p.length - 1] += postParts.shift();
      p.push.apply(p, postParts);
    }
    parts.push.apply(parts, p);
    return parts;
  }
  function expandTop(str) {
    if (!str)
      return [];
    if (str.substr(0, 2) === "{}") {
      str = "\\{\\}" + str.substr(2);
    }
    return expand(escapeBraces(str), true).map(unescapeBraces);
  }
  function embrace(str) {
    return "{" + str + "}";
  }
  function isPadded(el) {
    return /^-?0\d/.test(el);
  }
  function lte(i, y) {
    return i <= y;
  }
  function gte(i, y) {
    return i >= y;
  }
  function expand(str, isTop) {
    var expansions = [];
    var m = balanced("{", "}", str);
    if (!m || /\$$/.test(m.pre))
      return [str];
    var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
    var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
    var isSequence = isNumericSequence || isAlphaSequence;
    var isOptions = m.body.indexOf(",") >= 0;
    if (!isSequence && !isOptions) {
      if (m.post.match(/,.*\}/)) {
        str = m.pre + "{" + m.body + escClose + m.post;
        return expand(str);
      }
      return [str];
    }
    var n;
    if (isSequence) {
      n = m.body.split(/\.\./);
    } else {
      n = parseCommaParts(m.body);
      if (n.length === 1) {
        n = expand(n[0], false).map(embrace);
        if (n.length === 1) {
          var post = m.post.length ? expand(m.post, false) : [""];
          return post.map(function(p) {
            return m.pre + n[0] + p;
          });
        }
      }
    }
    var pre = m.pre;
    var post = m.post.length ? expand(m.post, false) : [""];
    var N;
    if (isSequence) {
      var x = numeric(n[0]);
      var y = numeric(n[1]);
      var width = Math.max(n[0].length, n[1].length);
      var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
      var test = lte;
      var reverse = y < x;
      if (reverse) {
        incr *= -1;
        test = gte;
      }
      var pad = n.some(isPadded);
      N = [];
      for (var i = x; test(i, y); i += incr) {
        var c;
        if (isAlphaSequence) {
          c = String.fromCharCode(i);
          if (c === "\\")
            c = "";
        } else {
          c = String(i);
          if (pad) {
            var need = width - c.length;
            if (need > 0) {
              var z = new Array(need + 1).join("0");
              if (i < 0)
                c = "-" + z + c.slice(1);
              else
                c = z + c;
            }
          }
        }
        N.push(c);
      }
    } else {
      N = concatMap(n, function(el) {
        return expand(el, false);
      });
    }
    for (var j = 0; j < N.length; j++) {
      for (var k = 0; k < post.length; k++) {
        var expansion = pre + N[j] + post[k];
        if (!isTop || isSequence || expansion)
          expansions.push(expansion);
      }
    }
    return expansions;
  }
});

// node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS((exports2, module2) => {
  module2.exports = minimatch;
  minimatch.Minimatch = Minimatch;
  var path3 = {sep: "/"};
  try {
    path3 = require("path");
  } catch (er) {
  }
  var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {};
  var expand = require_brace_expansion();
  var plTypes = {
    "!": {open: "(?:(?!(?:", close: "))[^/]*?)"},
    "?": {open: "(?:", close: ")?"},
    "+": {open: "(?:", close: ")+"},
    "*": {open: "(?:", close: ")*"},
    "@": {open: "(?:", close: ")"}
  };
  var qmark = "[^/]";
  var star = qmark + "*?";
  var twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
  var twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
  var reSpecials = charSet("().*{}+?[]^$\\!");
  function charSet(s) {
    return s.split("").reduce(function(set, c) {
      set[c] = true;
      return set;
    }, {});
  }
  var slashSplit = /\/+/;
  minimatch.filter = filter;
  function filter(pattern, options) {
    options = options || {};
    return function(p, i, list) {
      return minimatch(p, pattern, options);
    };
  }
  function ext(a, b) {
    a = a || {};
    b = b || {};
    var t = {};
    Object.keys(b).forEach(function(k) {
      t[k] = b[k];
    });
    Object.keys(a).forEach(function(k) {
      t[k] = a[k];
    });
    return t;
  }
  minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return minimatch;
    var orig = minimatch;
    var m = function minimatch2(p, pattern, options) {
      return orig.minimatch(p, pattern, ext(def, options));
    };
    m.Minimatch = function Minimatch2(pattern, options) {
      return new orig.Minimatch(pattern, ext(def, options));
    };
    return m;
  };
  Minimatch.defaults = function(def) {
    if (!def || !Object.keys(def).length)
      return Minimatch;
    return minimatch.defaults(def).Minimatch;
  };
  function minimatch(p, pattern, options) {
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    if (!options.nocomment && pattern.charAt(0) === "#") {
      return false;
    }
    if (pattern.trim() === "")
      return p === "";
    return new Minimatch(pattern, options).match(p);
  }
  function Minimatch(pattern, options) {
    if (!(this instanceof Minimatch)) {
      return new Minimatch(pattern, options);
    }
    if (typeof pattern !== "string") {
      throw new TypeError("glob pattern string required");
    }
    if (!options)
      options = {};
    pattern = pattern.trim();
    if (path3.sep !== "/") {
      pattern = pattern.split(path3.sep).join("/");
    }
    this.options = options;
    this.set = [];
    this.pattern = pattern;
    this.regexp = null;
    this.negate = false;
    this.comment = false;
    this.empty = false;
    this.make();
  }
  Minimatch.prototype.debug = function() {
  };
  Minimatch.prototype.make = make;
  function make() {
    if (this._made)
      return;
    var pattern = this.pattern;
    var options = this.options;
    if (!options.nocomment && pattern.charAt(0) === "#") {
      this.comment = true;
      return;
    }
    if (!pattern) {
      this.empty = true;
      return;
    }
    this.parseNegate();
    var set = this.globSet = this.braceExpand();
    if (options.debug)
      this.debug = console.error;
    this.debug(this.pattern, set);
    set = this.globParts = set.map(function(s) {
      return s.split(slashSplit);
    });
    this.debug(this.pattern, set);
    set = set.map(function(s, si, set2) {
      return s.map(this.parse, this);
    }, this);
    this.debug(this.pattern, set);
    set = set.filter(function(s) {
      return s.indexOf(false) === -1;
    });
    this.debug(this.pattern, set);
    this.set = set;
  }
  Minimatch.prototype.parseNegate = parseNegate;
  function parseNegate() {
    var pattern = this.pattern;
    var negate = false;
    var options = this.options;
    var negateOffset = 0;
    if (options.nonegate)
      return;
    for (var i = 0, l = pattern.length; i < l && pattern.charAt(i) === "!"; i++) {
      negate = !negate;
      negateOffset++;
    }
    if (negateOffset)
      this.pattern = pattern.substr(negateOffset);
    this.negate = negate;
  }
  minimatch.braceExpand = function(pattern, options) {
    return braceExpand(pattern, options);
  };
  Minimatch.prototype.braceExpand = braceExpand;
  function braceExpand(pattern, options) {
    if (!options) {
      if (this instanceof Minimatch) {
        options = this.options;
      } else {
        options = {};
      }
    }
    pattern = typeof pattern === "undefined" ? this.pattern : pattern;
    if (typeof pattern === "undefined") {
      throw new TypeError("undefined pattern");
    }
    if (options.nobrace || !pattern.match(/\{.*\}/)) {
      return [pattern];
    }
    return expand(pattern);
  }
  Minimatch.prototype.parse = parse;
  var SUBPARSE = {};
  function parse(pattern, isSub) {
    if (pattern.length > 1024 * 64) {
      throw new TypeError("pattern is too long");
    }
    var options = this.options;
    if (!options.noglobstar && pattern === "**")
      return GLOBSTAR;
    if (pattern === "")
      return "";
    var re = "";
    var hasMagic = !!options.nocase;
    var escaping = false;
    var patternListStack = [];
    var negativeLists = [];
    var stateChar;
    var inClass = false;
    var reClassStart = -1;
    var classStart = -1;
    var patternStart = pattern.charAt(0) === "." ? "" : options.dot ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))" : "(?!\\.)";
    var self2 = this;
    function clearStateChar() {
      if (stateChar) {
        switch (stateChar) {
          case "*":
            re += star;
            hasMagic = true;
            break;
          case "?":
            re += qmark;
            hasMagic = true;
            break;
          default:
            re += "\\" + stateChar;
            break;
        }
        self2.debug("clearStateChar %j %j", stateChar, re);
        stateChar = false;
      }
    }
    for (var i = 0, len = pattern.length, c; i < len && (c = pattern.charAt(i)); i++) {
      this.debug("%s	%s %s %j", pattern, i, re, c);
      if (escaping && reSpecials[c]) {
        re += "\\" + c;
        escaping = false;
        continue;
      }
      switch (c) {
        case "/":
          return false;
        case "\\":
          clearStateChar();
          escaping = true;
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          this.debug("%s	%s %s %j <-- stateChar", pattern, i, re, c);
          if (inClass) {
            this.debug("  in class");
            if (c === "!" && i === classStart + 1)
              c = "^";
            re += c;
            continue;
          }
          self2.debug("call clearStateChar %j", stateChar);
          clearStateChar();
          stateChar = c;
          if (options.noext)
            clearStateChar();
          continue;
        case "(":
          if (inClass) {
            re += "(";
            continue;
          }
          if (!stateChar) {
            re += "\\(";
            continue;
          }
          patternListStack.push({
            type: stateChar,
            start: i - 1,
            reStart: re.length,
            open: plTypes[stateChar].open,
            close: plTypes[stateChar].close
          });
          re += stateChar === "!" ? "(?:(?!(?:" : "(?:";
          this.debug("plType %j %j", stateChar, re);
          stateChar = false;
          continue;
        case ")":
          if (inClass || !patternListStack.length) {
            re += "\\)";
            continue;
          }
          clearStateChar();
          hasMagic = true;
          var pl = patternListStack.pop();
          re += pl.close;
          if (pl.type === "!") {
            negativeLists.push(pl);
          }
          pl.reEnd = re.length;
          continue;
        case "|":
          if (inClass || !patternListStack.length || escaping) {
            re += "\\|";
            escaping = false;
            continue;
          }
          clearStateChar();
          re += "|";
          continue;
        case "[":
          clearStateChar();
          if (inClass) {
            re += "\\" + c;
            continue;
          }
          inClass = true;
          classStart = i;
          reClassStart = re.length;
          re += c;
          continue;
        case "]":
          if (i === classStart + 1 || !inClass) {
            re += "\\" + c;
            escaping = false;
            continue;
          }
          if (inClass) {
            var cs = pattern.substring(classStart + 1, i);
            try {
              RegExp("[" + cs + "]");
            } catch (er) {
              var sp = this.parse(cs, SUBPARSE);
              re = re.substr(0, reClassStart) + "\\[" + sp[0] + "\\]";
              hasMagic = hasMagic || sp[1];
              inClass = false;
              continue;
            }
          }
          hasMagic = true;
          inClass = false;
          re += c;
          continue;
        default:
          clearStateChar();
          if (escaping) {
            escaping = false;
          } else if (reSpecials[c] && !(c === "^" && inClass)) {
            re += "\\";
          }
          re += c;
      }
    }
    if (inClass) {
      cs = pattern.substr(classStart + 1);
      sp = this.parse(cs, SUBPARSE);
      re = re.substr(0, reClassStart) + "\\[" + sp[0];
      hasMagic = hasMagic || sp[1];
    }
    for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
      var tail = re.slice(pl.reStart + pl.open.length);
      this.debug("setting tail", re, pl);
      tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function(_, $1, $2) {
        if (!$2) {
          $2 = "\\";
        }
        return $1 + $1 + $2 + "|";
      });
      this.debug("tail=%j\n   %s", tail, tail, pl, re);
      var t = pl.type === "*" ? star : pl.type === "?" ? qmark : "\\" + pl.type;
      hasMagic = true;
      re = re.slice(0, pl.reStart) + t + "\\(" + tail;
    }
    clearStateChar();
    if (escaping) {
      re += "\\\\";
    }
    var addPatternStart = false;
    switch (re.charAt(0)) {
      case ".":
      case "[":
      case "(":
        addPatternStart = true;
    }
    for (var n = negativeLists.length - 1; n > -1; n--) {
      var nl = negativeLists[n];
      var nlBefore = re.slice(0, nl.reStart);
      var nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
      var nlLast = re.slice(nl.reEnd - 8, nl.reEnd);
      var nlAfter = re.slice(nl.reEnd);
      nlLast += nlAfter;
      var openParensBefore = nlBefore.split("(").length - 1;
      var cleanAfter = nlAfter;
      for (i = 0; i < openParensBefore; i++) {
        cleanAfter = cleanAfter.replace(/\)[+*?]?/, "");
      }
      nlAfter = cleanAfter;
      var dollar = "";
      if (nlAfter === "" && isSub !== SUBPARSE) {
        dollar = "$";
      }
      var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast;
      re = newRe;
    }
    if (re !== "" && hasMagic) {
      re = "(?=.)" + re;
    }
    if (addPatternStart) {
      re = patternStart + re;
    }
    if (isSub === SUBPARSE) {
      return [re, hasMagic];
    }
    if (!hasMagic) {
      return globUnescape(pattern);
    }
    var flags = options.nocase ? "i" : "";
    try {
      var regExp = new RegExp("^" + re + "$", flags);
    } catch (er) {
      return new RegExp("$.");
    }
    regExp._glob = pattern;
    regExp._src = re;
    return regExp;
  }
  minimatch.makeRe = function(pattern, options) {
    return new Minimatch(pattern, options || {}).makeRe();
  };
  Minimatch.prototype.makeRe = makeRe;
  function makeRe() {
    if (this.regexp || this.regexp === false)
      return this.regexp;
    var set = this.set;
    if (!set.length) {
      this.regexp = false;
      return this.regexp;
    }
    var options = this.options;
    var twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
    var flags = options.nocase ? "i" : "";
    var re = set.map(function(pattern) {
      return pattern.map(function(p) {
        return p === GLOBSTAR ? twoStar : typeof p === "string" ? regExpEscape(p) : p._src;
      }).join("\\/");
    }).join("|");
    re = "^(?:" + re + ")$";
    if (this.negate)
      re = "^(?!" + re + ").*$";
    try {
      this.regexp = new RegExp(re, flags);
    } catch (ex) {
      this.regexp = false;
    }
    return this.regexp;
  }
  minimatch.match = function(list, pattern, options) {
    options = options || {};
    var mm = new Minimatch(pattern, options);
    list = list.filter(function(f) {
      return mm.match(f);
    });
    if (mm.options.nonull && !list.length) {
      list.push(pattern);
    }
    return list;
  };
  Minimatch.prototype.match = match;
  function match(f, partial) {
    this.debug("match", f, this.pattern);
    if (this.comment)
      return false;
    if (this.empty)
      return f === "";
    if (f === "/" && partial)
      return true;
    var options = this.options;
    if (path3.sep !== "/") {
      f = f.split(path3.sep).join("/");
    }
    f = f.split(slashSplit);
    this.debug(this.pattern, "split", f);
    var set = this.set;
    this.debug(this.pattern, "set", set);
    var filename;
    var i;
    for (i = f.length - 1; i >= 0; i--) {
      filename = f[i];
      if (filename)
        break;
    }
    for (i = 0; i < set.length; i++) {
      var pattern = set[i];
      var file = f;
      if (options.matchBase && pattern.length === 1) {
        file = [filename];
      }
      var hit = this.matchOne(file, pattern, partial);
      if (hit) {
        if (options.flipNegate)
          return true;
        return !this.negate;
      }
    }
    if (options.flipNegate)
      return false;
    return this.negate;
  }
  Minimatch.prototype.matchOne = function(file, pattern, partial) {
    var options = this.options;
    this.debug("matchOne", {this: this, file, pattern});
    this.debug("matchOne", file.length, pattern.length);
    for (var fi = 0, pi = 0, fl = file.length, pl = pattern.length; fi < fl && pi < pl; fi++, pi++) {
      this.debug("matchOne loop");
      var p = pattern[pi];
      var f = file[fi];
      this.debug(pattern, p, f);
      if (p === false)
        return false;
      if (p === GLOBSTAR) {
        this.debug("GLOBSTAR", [pattern, p, f]);
        var fr = fi;
        var pr = pi + 1;
        if (pr === pl) {
          this.debug("** at the end");
          for (; fi < fl; fi++) {
            if (file[fi] === "." || file[fi] === ".." || !options.dot && file[fi].charAt(0) === ".")
              return false;
          }
          return true;
        }
        while (fr < fl) {
          var swallowee = file[fr];
          this.debug("\nglobstar while", file, fr, pattern, pr, swallowee);
          if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
            this.debug("globstar found match!", fr, fl, swallowee);
            return true;
          } else {
            if (swallowee === "." || swallowee === ".." || !options.dot && swallowee.charAt(0) === ".") {
              this.debug("dot detected!", file, fr, pattern, pr);
              break;
            }
            this.debug("globstar swallow a segment, and continue");
            fr++;
          }
        }
        if (partial) {
          this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
          if (fr === fl)
            return true;
        }
        return false;
      }
      var hit;
      if (typeof p === "string") {
        if (options.nocase) {
          hit = f.toLowerCase() === p.toLowerCase();
        } else {
          hit = f === p;
        }
        this.debug("string match", p, f, hit);
      } else {
        hit = f.match(p);
        this.debug("pattern match", p, f, hit);
      }
      if (!hit)
        return false;
    }
    if (fi === fl && pi === pl) {
      return true;
    } else if (fi === fl) {
      return partial;
    } else if (pi === pl) {
      var emptyFileEnd = fi === fl - 1 && file[fi] === "";
      return emptyFileEnd;
    }
    throw new Error("wtf?");
  };
  function globUnescape(s) {
    return s.replace(/\\(.)/g, "$1");
  }
  function regExpEscape(s) {
    return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});

// node_modules/@eslint/eslintrc/lib/config-array/override-tester.js
var require_override_tester = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var path3 = require("path");
  var util = require("util");
  var {Minimatch} = require_minimatch();
  var minimatchOpts = {dot: true, matchBase: true};
  function normalizePatterns(patterns) {
    if (Array.isArray(patterns)) {
      return patterns.filter(Boolean);
    }
    if (typeof patterns === "string" && patterns) {
      return [patterns];
    }
    return [];
  }
  function toMatcher(patterns) {
    if (patterns.length === 0) {
      return null;
    }
    return patterns.map((pattern) => {
      if (/^\.[/\\]/u.test(pattern)) {
        return new Minimatch(pattern.slice(2), __objSpread(__objSpread({}, minimatchOpts), {matchBase: false}));
      }
      return new Minimatch(pattern, minimatchOpts);
    });
  }
  function patternToJson({includes, excludes}) {
    return {
      includes: includes && includes.map((m) => m.pattern),
      excludes: excludes && excludes.map((m) => m.pattern)
    };
  }
  var OverrideTester = class {
    static create(files, excludedFiles, basePath) {
      const includePatterns = normalizePatterns(files);
      const excludePatterns = normalizePatterns(excludedFiles);
      let endsWithWildcard = false;
      if (includePatterns.length === 0) {
        return null;
      }
      for (const pattern of includePatterns) {
        if (path3.isAbsolute(pattern) || pattern.includes("..")) {
          throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);
        }
        if (pattern.endsWith("*")) {
          endsWithWildcard = true;
        }
      }
      for (const pattern of excludePatterns) {
        if (path3.isAbsolute(pattern) || pattern.includes("..")) {
          throw new Error(`Invalid override pattern (expected relative path not containing '..'): ${pattern}`);
        }
      }
      const includes = toMatcher(includePatterns);
      const excludes = toMatcher(excludePatterns);
      return new OverrideTester([{includes, excludes}], basePath, endsWithWildcard);
    }
    static and(a, b) {
      if (!b) {
        return a && new OverrideTester(a.patterns, a.basePath, a.endsWithWildcard);
      }
      if (!a) {
        return new OverrideTester(b.patterns, b.basePath, b.endsWithWildcard);
      }
      assert.strictEqual(a.basePath, b.basePath);
      return new OverrideTester(a.patterns.concat(b.patterns), a.basePath, a.endsWithWildcard || b.endsWithWildcard);
    }
    constructor(patterns, basePath, endsWithWildcard = false) {
      this.patterns = patterns;
      this.basePath = basePath;
      this.endsWithWildcard = endsWithWildcard;
    }
    test(filePath) {
      if (typeof filePath !== "string" || !path3.isAbsolute(filePath)) {
        throw new Error(`'filePath' should be an absolute path, but got ${filePath}.`);
      }
      const relativePath = path3.relative(this.basePath, filePath);
      return this.patterns.every(({includes, excludes}) => (!includes || includes.some((m) => m.match(relativePath))) && (!excludes || !excludes.some((m) => m.match(relativePath))));
    }
    toJSON() {
      if (this.patterns.length === 1) {
        return __objSpread(__objSpread({}, patternToJson(this.patterns[0])), {
          basePath: this.basePath
        });
      }
      return {
        AND: this.patterns.map(patternToJson),
        basePath: this.basePath
      };
    }
    [util.inspect.custom]() {
      return this.toJSON();
    }
  };
  module2.exports = {OverrideTester};
});

// node_modules/@eslint/eslintrc/lib/config-array/index.js
var require_config_array2 = __commonJS((exports2, module2) => {
  "use strict";
  var {ConfigArray, getUsedExtractedConfigs} = require_config_array();
  var {ConfigDependency} = require_config_dependency();
  var {ExtractedConfig} = require_extracted_config();
  var {IgnorePattern} = require_ignore_pattern();
  var {OverrideTester} = require_override_tester();
  module2.exports = {
    ConfigArray,
    ConfigDependency,
    ExtractedConfig,
    IgnorePattern,
    OverrideTester,
    getUsedExtractedConfigs
  };
});

// node_modules/js-yaml/lib/js-yaml/common.js
var require_common2 = __commonJS((exports2, module2) => {
  "use strict";
  function isNothing(subject) {
    return typeof subject === "undefined" || subject === null;
  }
  function isObject(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function toArray(sequence) {
    if (Array.isArray(sequence))
      return sequence;
    else if (isNothing(sequence))
      return [];
    return [sequence];
  }
  function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
      sourceKeys = Object.keys(source);
      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }
    return target;
  }
  function repeat(string, count) {
    var result = "", cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }
    return result;
  }
  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }
  module2.exports.isNothing = isNothing;
  module2.exports.isObject = isObject;
  module2.exports.toArray = toArray;
  module2.exports.repeat = repeat;
  module2.exports.isNegativeZero = isNegativeZero;
  module2.exports.extend = extend;
});

// node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS((exports2, module2) => {
  "use strict";
  function YAMLException(reason, mark) {
    Error.call(this);
    this.name = "YAMLException";
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack || "";
    }
  }
  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;
  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ": ";
    result += this.reason || "(unknown reason)";
    if (!compact && this.mark) {
      result += " " + this.mark.toString();
    }
    return result;
  };
  module2.exports = YAMLException;
});

// node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }
  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer)
      return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = "";
    start = this.position;
    while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;
      if (this.position - start > maxLength / 2 - 1) {
        head = " ... ";
        start += 5;
        break;
      }
    }
    tail = "";
    end = this.position;
    while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;
      if (end - this.position > maxLength / 2 - 1) {
        tail = " ... ";
        end -= 5;
        break;
      }
    }
    snippet = this.buffer.slice(start, end);
    return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
  };
  Mark.prototype.toString = function toString(compact) {
    var snippet, where = "";
    if (this.name) {
      where += 'in "' + this.name + '" ';
    }
    where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
    if (!compact) {
      snippet = this.getSnippet();
      if (snippet) {
        where += ":\n" + snippet;
      }
    }
    return where;
  };
  module2.exports = Mark;
});

// node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS((exports2, module2) => {
  "use strict";
  var YAMLException = require_exception();
  var TYPE_CONSTRUCTOR_OPTIONS = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ];
  var YAML_NODE_KINDS = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function compileStyleAliases(map) {
    var result = {};
    if (map !== null) {
      Object.keys(map).forEach(function(style) {
        map[style].forEach(function(alias) {
          result[String(alias)] = style;
        });
      });
    }
    return result;
  }
  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function(name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    });
    this.tag = tag;
    this.kind = options["kind"] || null;
    this.resolve = options["resolve"] || function() {
      return true;
    };
    this.construct = options["construct"] || function(data) {
      return data;
    };
    this.instanceOf = options["instanceOf"] || null;
    this.predicate = options["predicate"] || null;
    this.represent = options["represent"] || null;
    this.defaultStyle = options["defaultStyle"] || null;
    this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }
  module2.exports = Type;
});

// node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  var YAMLException = require_exception();
  var Type = require_type();
  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function(includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function(currentType) {
      result.forEach(function(previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function(type, index) {
      return exclude.indexOf(index) === -1;
    });
  }
  function compileMap() {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, index, length;
    function collectType(type) {
      result[type.kind][type.tag] = result["fallback"][type.tag] = type;
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }
    return result;
  }
  function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function(type) {
      if (type.loadKind && type.loadKind !== "scalar") {
        throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
      }
    });
    this.compiledImplicit = compileList(this, "implicit", []);
    this.compiledExplicit = compileList(this, "explicit", []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }
  Schema.DEFAULT = null;
  Schema.create = function createSchema() {
    var schemas, types;
    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT;
        types = arguments[0];
        break;
      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;
      default:
        throw new YAMLException("Wrong number of arguments for Schema.create function");
    }
    schemas = common.toArray(schemas);
    types = common.toArray(types);
    if (!schemas.every(function(schema) {
      return schema instanceof Schema;
    })) {
      throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    }
    if (!types.every(function(type) {
      return type instanceof Type;
    })) {
      throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    }
    return new Schema({
      include: schemas,
      explicit: types
    });
  };
  module2.exports = Schema;
});

// node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(data) {
      return data !== null ? data : "";
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(data) {
      return data !== null ? data : [];
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  module2.exports = new Type("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(data) {
      return data !== null ? data : {};
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    explicit: [
      require_str(),
      require_seq(),
      require_map()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlNull(data) {
    if (data === null)
      return true;
    var max = data.length;
    return max === 1 && data === "~" || max === 4 && (data === "null" || data === "Null" || data === "NULL");
  }
  function constructYamlNull() {
    return null;
  }
  function isNull(object) {
    return object === null;
  }
  module2.exports = new Type("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlBoolean(data) {
    if (data === null)
      return false;
    var max = data.length;
    return max === 4 && (data === "true" || data === "True" || data === "TRUE") || max === 5 && (data === "false" || data === "False" || data === "FALSE");
  }
  function constructYamlBoolean(data) {
    return data === "true" || data === "True" || data === "TRUE";
  }
  function isBoolean(object) {
    return Object.prototype.toString.call(object) === "[object Boolean]";
  }
  module2.exports = new Type("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function(object) {
        return object ? "true" : "false";
      },
      uppercase: function(object) {
        return object ? "TRUE" : "FALSE";
      },
      camelcase: function(object) {
        return object ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  var Type = require_type();
  function isHexCode(c) {
    return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
  }
  function isOctCode(c) {
    return 48 <= c && c <= 55;
  }
  function isDecCode(c) {
    return 48 <= c && c <= 57;
  }
  function resolveYamlInteger(data) {
    if (data === null)
      return false;
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max)
      return false;
    ch = data[index];
    if (ch === "-" || ch === "+") {
      ch = data[++index];
    }
    if (ch === "0") {
      if (index + 1 === max)
        return true;
      ch = data[++index];
      if (ch === "b") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (ch !== "0" && ch !== "1")
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "x") {
        index++;
        for (; index < max; index++) {
          ch = data[index];
          if (ch === "_")
            continue;
          if (!isHexCode(data.charCodeAt(index)))
            return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      for (; index < max; index++) {
        ch = data[index];
        if (ch === "_")
          continue;
        if (!isOctCode(data.charCodeAt(index)))
          return false;
        hasDigits = true;
      }
      return hasDigits && ch !== "_";
    }
    if (ch === "_")
      return false;
    for (; index < max; index++) {
      ch = data[index];
      if (ch === "_")
        continue;
      if (ch === ":")
        break;
      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }
      hasDigits = true;
    }
    if (!hasDigits || ch === "_")
      return false;
    if (ch !== ":")
      return true;
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }
  function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf("_") !== -1) {
      value = value.replace(/_/g, "");
    }
    ch = value[0];
    if (ch === "-" || ch === "+") {
      if (ch === "-")
        sign = -1;
      value = value.slice(1);
      ch = value[0];
    }
    if (value === "0")
      return 0;
    if (ch === "0") {
      if (value[1] === "b")
        return sign * parseInt(value.slice(2), 2);
      if (value[1] === "x")
        return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }
    if (value.indexOf(":") !== -1) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseInt(value, 10);
  }
  function isInteger(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
  }
  module2.exports = new Type("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function(obj) {
        return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
      },
      octal: function(obj) {
        return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
      },
      decimal: function(obj) {
        return obj.toString(10);
      },
      hexadecimal: function(obj) {
        return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  });
});

// node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  var Type = require_type();
  var YAML_FLOAT_PATTERN = new RegExp("^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$");
  function resolveYamlFloat(data) {
    if (data === null)
      return false;
    if (!YAML_FLOAT_PATTERN.test(data) || data[data.length - 1] === "_") {
      return false;
    }
    return true;
  }
  function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, "").toLowerCase();
    sign = value[0] === "-" ? -1 : 1;
    digits = [];
    if ("+-".indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }
    if (value === ".inf") {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === ".nan") {
      return NaN;
    } else if (value.indexOf(":") >= 0) {
      value.split(":").forEach(function(v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function(d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }
    return sign * parseFloat(value, 10);
  }
  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
  function representYamlFloat(object, style) {
    var res;
    if (isNaN(object)) {
      switch (style) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    } else if (common.isNegativeZero(object)) {
      return "-0.0";
    }
    res = object.toString(10);
    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
  }
  function isFloat(object) {
    return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
  }
  module2.exports = new Type("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: "lowercase"
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_failsafe()
    ],
    implicit: [
      require_null(),
      require_bool(),
      require_int(),
      require_float()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core2 = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_json()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var YAML_DATE_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$");
  var YAML_TIMESTAMP_REGEXP = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$");
  function resolveYamlTimestamp(data) {
    if (data === null)
      return false;
    if (YAML_DATE_REGEXP.exec(data) !== null)
      return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null)
      return true;
    return false;
  }
  function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null)
      match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null)
      throw new Error("Date resolve error");
    year = +match[1];
    month = +match[2] - 1;
    day = +match[3];
    if (!match[4]) {
      return new Date(Date.UTC(year, month, day));
    }
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
      fraction = match[7].slice(0, 3);
      while (fraction.length < 3) {
        fraction += "0";
      }
      fraction = +fraction;
    }
    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 6e4;
      if (match[9] === "-")
        delta = -delta;
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta)
      date.setTime(date.getTime() - delta);
    return date;
  }
  function representYamlTimestamp(object) {
    return object.toISOString();
  }
  module2.exports = new Type("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveYamlMerge(data) {
    return data === "<<" || data === null;
  }
  module2.exports = new Type("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: resolveYamlMerge
  });
});

// node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS((exports2, module2) => {
  "use strict";
  var NodeBuffer;
  try {
    _require = require;
    NodeBuffer = _require("buffer").Buffer;
  } catch (__) {
  }
  var _require;
  var Type = require_type();
  var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
  function resolveYamlBinary(data) {
    if (data === null)
      return false;
    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx));
      if (code > 64)
        continue;
      if (code < 0)
        return false;
      bitlen += 6;
    }
    return bitlen % 8 === 0;
  }
  function constructYamlBinary(data) {
    var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max = input.length, map = BASE64_MAP, bits = 0, result = [];
    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      }
      bits = bits << 6 | map.indexOf(input.charAt(idx));
    }
    tailbits = max % 4 * 6;
    if (tailbits === 0) {
      result.push(bits >> 16 & 255);
      result.push(bits >> 8 & 255);
      result.push(bits & 255);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 255);
      result.push(bits >> 2 & 255);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 255);
    }
    if (NodeBuffer) {
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }
    return result;
  }
  function representYamlBinary(object) {
    var result = "", bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      }
      bits = (bits << 8) + object[idx];
    }
    tail = max % 3;
    if (tail === 0) {
      result += map[bits >> 18 & 63];
      result += map[bits >> 12 & 63];
      result += map[bits >> 6 & 63];
      result += map[bits & 63];
    } else if (tail === 2) {
      result += map[bits >> 10 & 63];
      result += map[bits >> 4 & 63];
      result += map[bits << 2 & 63];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 63];
      result += map[bits << 4 & 63];
      result += map[64];
      result += map[64];
    }
    return result;
  }
  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }
  module2.exports = new Type("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });
});

// node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;
  function resolveYamlOmap(data) {
    if (data === null)
      return true;
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== "[object Object]")
        return false;
      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey)
            pairHasKey = true;
          else
            return false;
        }
      }
      if (!pairHasKey)
        return false;
      if (objectKeys.indexOf(pairKey) === -1)
        objectKeys.push(pairKey);
      else
        return false;
    }
    return true;
  }
  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }
  module2.exports = new Type("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });
});

// node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _toString = Object.prototype.toString;
  function resolveYamlPairs(data) {
    if (data === null)
      return true;
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString.call(pair) !== "[object Object]")
        return false;
      keys = Object.keys(pair);
      if (keys.length !== 1)
        return false;
      result[index] = [keys[0], pair[keys[0]]];
    }
    return true;
  }
  function constructYamlPairs(data) {
    if (data === null)
      return [];
    var index, length, pair, keys, result, object = data;
    result = new Array(object.length);
    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }
    return result;
  }
  module2.exports = new Type("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });
});

// node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function resolveYamlSet(data) {
    if (data === null)
      return true;
    var key, object = data;
    for (key in object) {
      if (_hasOwnProperty.call(object, key)) {
        if (object[key] !== null)
          return false;
      }
    }
    return true;
  }
  function constructYamlSet(data) {
    return data !== null ? data : {};
  }
  module2.exports = new Type("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = new Schema({
    include: [
      require_core2()
    ],
    implicit: [
      require_timestamp(),
      require_merge()
    ],
    explicit: [
      require_binary(),
      require_omap(),
      require_pairs(),
      require_set()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveJavascriptUndefined() {
    return true;
  }
  function constructJavascriptUndefined() {
    return void 0;
  }
  function representJavascriptUndefined() {
    return "";
  }
  function isUndefined(object) {
    return typeof object === "undefined";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var Type = require_type();
  function resolveJavascriptRegExp(data) {
    if (data === null)
      return false;
    if (data.length === 0)
      return false;
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      if (modifiers.length > 3)
        return false;
      if (regexp[regexp.length - modifiers.length - 1] !== "/")
        return false;
    }
    return true;
  }
  function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
    if (regexp[0] === "/") {
      if (tail)
        modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
  }
  function representJavascriptRegExp(object) {
    var result = "/" + object.source + "/";
    if (object.global)
      result += "g";
    if (object.multiline)
      result += "m";
    if (object.ignoreCase)
      result += "i";
    return result;
  }
  function isRegExp(object) {
    return Object.prototype.toString.call(object) === "[object RegExp]";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });
});

// node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS((exports2, module2) => {
  "use strict";
  var esprima;
  try {
    _require = require;
    esprima = _require("esprima");
  } catch (_) {
    if (typeof window !== "undefined")
      esprima = window.esprima;
  }
  var _require;
  var Type = require_type();
  function resolveJavascriptFunction(data) {
    if (data === null)
      return false;
    try {
      var source = "(" + data + ")", ast = esprima.parse(source, {range: true});
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  function constructJavascriptFunction(data) {
    var source = "(" + data + ")", ast = esprima.parse(source, {range: true}), params = [], body;
    if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
      throw new Error("Failed to resolve function");
    }
    ast.body[0].expression.params.forEach(function(param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range;
    if (ast.body[0].expression.body.type === "BlockStatement") {
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    }
    return new Function(params, "return " + source.slice(body[0], body[1]));
  }
  function representJavascriptFunction(object) {
    return object.toString();
  }
  function isFunction(object) {
    return Object.prototype.toString.call(object) === "[object Function]";
  }
  module2.exports = new Type("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });
});

// node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS((exports2, module2) => {
  "use strict";
  var Schema = require_schema();
  module2.exports = Schema.DEFAULT = new Schema({
    include: [
      require_default_safe()
    ],
    explicit: [
      require_undefined(),
      require_regexp(),
      require_function()
    ]
  });
});

// node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  var YAMLException = require_exception();
  var Mark = require_mark();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }
  function is_EOL(c) {
    return c === 10 || c === 13;
  }
  function is_WHITE_SPACE(c) {
    return c === 9 || c === 32;
  }
  function is_WS_OR_EOL(c) {
    return c === 9 || c === 32 || c === 10 || c === 13;
  }
  function is_FLOW_INDICATOR(c) {
    return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
  }
  function fromHexCode(c) {
    var lc;
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    lc = c | 32;
    if (97 <= lc && lc <= 102) {
      return lc - 97 + 10;
    }
    return -1;
  }
  function escapedHexLen(c) {
    if (c === 120) {
      return 2;
    }
    if (c === 117) {
      return 4;
    }
    if (c === 85) {
      return 8;
    }
    return 0;
  }
  function fromDecimalCode(c) {
    if (48 <= c && c <= 57) {
      return c - 48;
    }
    return -1;
  }
  function simpleEscapeSequence(c) {
    return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
  }
  function charFromCodepoint(c) {
    if (c <= 65535) {
      return String.fromCharCode(c);
    }
    return String.fromCharCode((c - 65536 >> 10) + 55296, (c - 65536 & 1023) + 56320);
  }
  var simpleEscapeCheck = new Array(256);
  var simpleEscapeMap = new Array(256);
  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }
  function State(input, options) {
    this.input = input;
    this.filename = options["filename"] || null;
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.onWarning = options["onWarning"] || null;
    this.legacy = options["legacy"] || false;
    this.json = options["json"] || false;
    this.listener = options["listener"] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
  }
  function generateError(state, message) {
    return new YAMLException(message, new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
  }
  function throwError(state, message) {
    throw generateError(state, message);
  }
  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }
  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;
      if (state.version !== null) {
        throwError(state, "duplication of %YAML directive");
      }
      if (args.length !== 1) {
        throwError(state, "YAML directive accepts exactly one argument");
      }
      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
      if (match === null) {
        throwError(state, "ill-formed argument of the YAML directive");
      }
      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);
      if (major !== 1) {
        throwError(state, "unacceptable YAML version of the document");
      }
      state.version = args[0];
      state.checkLineBreaks = minor < 2;
      if (minor !== 1 && minor !== 2) {
        throwWarning(state, "unsupported YAML version of the document");
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;
      if (args.length !== 2) {
        throwError(state, "TAG directive accepts exactly two arguments");
      }
      handle = args[0];
      prefix = args[1];
      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
      }
      if (_hasOwnProperty.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }
      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
      }
      state.tagMap[handle] = prefix;
    }
  };
  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    if (start < end) {
      _result = state.input.slice(start, end);
      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);
          if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
            throwError(state, "expected valid JSON character");
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, "the stream contains non-printable characters");
      }
      state.result += _result;
    }
  }
  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;
    if (!common.isObject(source)) {
      throwError(state, "cannot merge mappings; the provided source object is unacceptable");
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];
      if (!_hasOwnProperty.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }
  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity;
    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);
      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, "nested arrays are not supported inside keys");
        }
        if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
          keyNode[index] = "[object Object]";
        }
      }
    }
    if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
      keyNode = "[object Object]";
    }
    keyNode = String(keyNode);
    if (_result === null) {
      _result = {};
    }
    if (keyTag === "tag:yaml.org,2002:merge") {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, "duplicated mapping key");
      }
      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }
    return _result;
  }
  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 10) {
      state.position++;
    } else if (ch === 13) {
      state.position++;
      if (state.input.charCodeAt(state.position) === 10) {
        state.position++;
      }
    } else {
      throwError(state, "a line break is expected");
    }
    state.line += 1;
    state.lineStart = state.position;
  }
  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (allowComments && ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 10 && ch !== 13 && ch !== 0);
      }
      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;
        while (ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }
    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, "deficient indentation");
    }
    return lineBreaks;
  }
  function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);
      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }
    return false;
  }
  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += " ";
    } else if (count > 1) {
      state.result += common.repeat("\n", count - 1);
    }
  }
  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
      return false;
    }
    if (ch === 63 || ch === 45) {
      following = state.input.charCodeAt(state.position + 1);
      if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
        return false;
      }
    }
    state.kind = "scalar";
    state.result = "";
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (ch !== 0) {
      if (ch === 58) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          break;
        }
      } else if (ch === 35) {
        preceding = state.input.charCodeAt(state.position - 1);
        if (is_WS_OR_EOL(preceding)) {
          break;
        }
      } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);
        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }
      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }
      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }
      ch = state.input.charCodeAt(++state.position);
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result) {
      return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
  }
  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 39) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 39) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (ch === 39) {
          captureStart = state.position;
          state.position++;
          captureEnd = state.position;
        } else {
          return true;
        }
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a single quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a single quoted scalar");
  }
  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 34) {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    state.position++;
    captureStart = captureEnd = state.position;
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 34) {
        captureSegment(state, captureStart, state.position, true);
        state.position++;
        return true;
      } else if (ch === 92) {
        captureSegment(state, captureStart, state.position, true);
        ch = state.input.charCodeAt(++state.position);
        if (is_EOL(ch)) {
          skipSeparationSpace(state, false, nodeIndent);
        } else if (ch < 256 && simpleEscapeCheck[ch]) {
          state.result += simpleEscapeMap[ch];
          state.position++;
        } else if ((tmp = escapedHexLen(ch)) > 0) {
          hexLength = tmp;
          hexResult = 0;
          for (; hexLength > 0; hexLength--) {
            ch = state.input.charCodeAt(++state.position);
            if ((tmp = fromHexCode(ch)) >= 0) {
              hexResult = (hexResult << 4) + tmp;
            } else {
              throwError(state, "expected hexadecimal character");
            }
          }
          state.result += charFromCodepoint(hexResult);
          state.position++;
        } else {
          throwError(state, "unknown escape sequence");
        }
        captureStart = captureEnd = state.position;
      } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, "unexpected end of the document within a double quoted scalar");
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }
    throwError(state, "unexpected end of the stream within a double quoted scalar");
  }
  function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 91) {
      terminator = 93;
      isMapping = false;
      _result = [];
    } else if (ch === 123) {
      terminator = 125;
      isMapping = true;
      _result = {};
    } else {
      return false;
    }
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? "mapping" : "sequence";
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, "missed comma between flow collection entries");
      }
      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;
      if (ch === 63) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following)) {
          isPair = isExplicitPair = true;
          state.position++;
          skipSeparationSpace(state, true, nodeIndent);
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if ((isExplicitPair || state.line === _line) && ch === 58) {
        isPair = true;
        ch = state.input.charCodeAt(++state.position);
        skipSeparationSpace(state, true, nodeIndent);
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        valueNode = state.result;
      }
      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);
      if (ch === 44) {
        readNext = true;
        ch = state.input.charCodeAt(++state.position);
      } else {
        readNext = false;
      }
    }
    throwError(state, "unexpected end of the stream within a flow collection");
  }
  function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 124) {
      folding = false;
    } else if (ch === 62) {
      folding = true;
    } else {
      return false;
    }
    state.kind = "scalar";
    state.result = "";
    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);
      if (ch === 43 || ch === 45) {
        if (CHOMPING_CLIP === chomping) {
          chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
        } else {
          throwError(state, "repeat of a chomping mode identifier");
        }
      } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, "repeat of an indentation width identifier");
        }
      } else {
        break;
      }
    }
    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));
      if (ch === 35) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (!is_EOL(ch) && ch !== 0);
      }
    }
    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);
      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }
      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      }
      if (state.lineIndent < textIndent) {
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            state.result += "\n";
          }
        }
        break;
      }
      if (folding) {
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true;
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat("\n", emptyLines + 1);
        } else if (emptyLines === 0) {
          if (didReadContent) {
            state.result += " ";
          }
        } else {
          state.result += common.repeat("\n", emptyLines);
        }
      } else {
        state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
      }
      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;
      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, state.position, false);
    }
    return true;
  }
  function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      if (ch !== 45) {
        break;
      }
      following = state.input.charCodeAt(state.position + 1);
      if (!is_WS_OR_EOL(following)) {
        break;
      }
      detected = true;
      state.position++;
      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);
          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }
      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
      _result.push(state.result);
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, "bad indentation of a sequence entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "sequence";
      state.result = _result;
      return true;
    }
    return false;
  }
  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line;
      _pos = state.position;
      if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
        if (ch === 63) {
          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }
          detected = true;
          atExplicitKey = true;
          allowCompact = true;
        } else if (atExplicitKey) {
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
        }
        state.position += 1;
        ch = following;
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 58) {
            ch = state.input.charCodeAt(++state.position);
            if (!is_WS_OR_EOL(ch)) {
              throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
            }
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = false;
            allowCompact = false;
            keyTag = state.tag;
            keyNode = state.result;
          } else if (detected) {
            throwError(state, "can not read an implicit mapping pair; a colon is missed");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else if (detected) {
          throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true;
        }
      } else {
        break;
      }
      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }
        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }
      if (state.lineIndent > nodeIndent && ch !== 0) {
        throwError(state, "bad indentation of a mapping entry");
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }
    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    }
    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = "mapping";
      state.result = _result;
    }
    return detected;
  }
  function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 33)
      return false;
    if (state.tag !== null) {
      throwError(state, "duplication of a tag property");
    }
    ch = state.input.charCodeAt(++state.position);
    if (ch === 60) {
      isVerbatim = true;
      ch = state.input.charCodeAt(++state.position);
    } else if (ch === 33) {
      isNamed = true;
      tagHandle = "!!";
      ch = state.input.charCodeAt(++state.position);
    } else {
      tagHandle = "!";
    }
    _position = state.position;
    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 62);
      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, "unexpected end of the stream within a verbatim tag");
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 33) {
          if (!isNamed) {
            tagHandle = state.input.slice(_position - 1, state.position + 1);
            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
              throwError(state, "named tag handle cannot contain such characters");
            }
            isNamed = true;
            _position = state.position + 1;
          } else {
            throwError(state, "tag suffix cannot contain exclamation marks");
          }
        }
        ch = state.input.charCodeAt(++state.position);
      }
      tagName = state.input.slice(_position, state.position);
      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, "tag suffix cannot contain flow indicator characters");
      }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, "tag name cannot contain such characters: " + tagName);
    }
    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === "!") {
      state.tag = "!" + tagName;
    } else if (tagHandle === "!!") {
      state.tag = "tag:yaml.org,2002:" + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
  }
  function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 38)
      return false;
    if (state.anchor !== null) {
      throwError(state, "duplication of an anchor property");
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an anchor node must contain at least one character");
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
  }
  function readAlias(state) {
    var _position, alias, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch !== 42)
      return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
      throwError(state, "name of an alias node must contain at least one character");
    }
    alias = state.input.slice(_position, state.position);
    if (!state.anchorMap.hasOwnProperty(alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }
    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }
  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
    if (state.listener !== null) {
      state.listener("open", state);
    }
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }
    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }
    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }
    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }
      blockIndent = state.position - state.lineStart;
      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;
            if (state.tag !== null || state.anchor !== null) {
              throwError(state, "alias node should not have any properties");
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;
            if (state.tag === null) {
              state.tag = "?";
            }
          }
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }
    if (state.tag !== null && state.tag !== "!") {
      if (state.tag === "?") {
        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];
          if (type.resolve(state.result)) {
            state.result = type.construct(state.result);
            state.tag = type.tag;
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
            break;
          }
        }
      } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
        type = state.typeMap[state.kind || "fallback"][state.tag];
        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }
        if (!type.resolve(state.result)) {
          throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
        } else {
          state.result = type.construct(state.result);
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, "unknown tag !<" + state.tag + ">");
      }
    }
    if (state.listener !== null) {
      state.listener("close", state);
    }
    return state.tag !== null || state.anchor !== null || hasContent;
  }
  function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
      if (state.lineIndent > 0 || ch !== 37) {
        break;
      }
      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];
      if (directiveName.length < 1) {
        throwError(state, "directive name must not be less than one character in length");
      }
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0 && !is_EOL(ch));
          break;
        }
        if (is_EOL(ch))
          break;
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveArgs.push(state.input.slice(_position, state.position));
      }
      if (ch !== 0)
        readLineBreak(state);
      if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }
    skipSeparationSpace(state, true, -1);
    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    } else if (hasDirectives) {
      throwError(state, "directives end mark is expected");
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, "non-ASCII line breaks are interpreted as content");
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 46) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      }
      return;
    }
    if (state.position < state.length - 1) {
      throwError(state, "end of the stream or a document separator is expected");
    } else {
      return;
    }
  }
  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};
    if (input.length !== 0) {
      if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
        input += "\n";
      }
      if (input.charCodeAt(0) === 65279) {
        input = input.slice(1);
      }
    }
    var state = new State(input, options);
    state.input += "\0";
    while (state.input.charCodeAt(state.position) === 32) {
      state.lineIndent += 1;
      state.position += 1;
    }
    while (state.position < state.length - 1) {
      readDocument(state);
    }
    return state.documents;
  }
  function loadAll(input, iterator, options) {
    var documents = loadDocuments(input, options), index, length;
    if (typeof iterator !== "function") {
      return documents;
    }
    for (index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }
  function load(input, options) {
    var documents = loadDocuments(input, options);
    if (documents.length === 0) {
      return void 0;
    } else if (documents.length === 1) {
      return documents[0];
    }
    throw new YAMLException("expected a single document in the stream, but found more");
  }
  function safeLoadAll(input, output, options) {
    if (typeof output === "function") {
      loadAll(input, output, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
    } else {
      return loadAll(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
    }
  }
  function safeLoad(input, options) {
    return load(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
  }
  module2.exports.loadAll = loadAll;
  module2.exports.load = load;
  module2.exports.safeLoadAll = safeLoadAll;
  module2.exports.safeLoad = safeLoad;
});

// node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS((exports2, module2) => {
  "use strict";
  var common = require_common2();
  var YAMLException = require_exception();
  var DEFAULT_FULL_SCHEMA = require_default_full();
  var DEFAULT_SAFE_SCHEMA = require_default_safe();
  var _toString = Object.prototype.toString;
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 9;
  var CHAR_LINE_FEED = 10;
  var CHAR_SPACE = 32;
  var CHAR_EXCLAMATION = 33;
  var CHAR_DOUBLE_QUOTE = 34;
  var CHAR_SHARP = 35;
  var CHAR_PERCENT = 37;
  var CHAR_AMPERSAND = 38;
  var CHAR_SINGLE_QUOTE = 39;
  var CHAR_ASTERISK = 42;
  var CHAR_COMMA = 44;
  var CHAR_MINUS = 45;
  var CHAR_COLON = 58;
  var CHAR_GREATER_THAN = 62;
  var CHAR_QUESTION = 63;
  var CHAR_COMMERCIAL_AT = 64;
  var CHAR_LEFT_SQUARE_BRACKET = 91;
  var CHAR_RIGHT_SQUARE_BRACKET = 93;
  var CHAR_GRAVE_ACCENT = 96;
  var CHAR_LEFT_CURLY_BRACKET = 123;
  var CHAR_VERTICAL_LINE = 124;
  var CHAR_RIGHT_CURLY_BRACKET = 125;
  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0] = "\\0";
  ESCAPE_SEQUENCES[7] = "\\a";
  ESCAPE_SEQUENCES[8] = "\\b";
  ESCAPE_SEQUENCES[9] = "\\t";
  ESCAPE_SEQUENCES[10] = "\\n";
  ESCAPE_SEQUENCES[11] = "\\v";
  ESCAPE_SEQUENCES[12] = "\\f";
  ESCAPE_SEQUENCES[13] = "\\r";
  ESCAPE_SEQUENCES[27] = "\\e";
  ESCAPE_SEQUENCES[34] = '\\"';
  ESCAPE_SEQUENCES[92] = "\\\\";
  ESCAPE_SEQUENCES[133] = "\\N";
  ESCAPE_SEQUENCES[160] = "\\_";
  ESCAPE_SEQUENCES[8232] = "\\L";
  ESCAPE_SEQUENCES[8233] = "\\P";
  var DEPRECATED_BOOLEANS_SYNTAX = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null)
      return {};
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);
      if (tag.slice(0, 2) === "!!") {
        tag = "tag:yaml.org,2002:" + tag.slice(2);
      }
      type = schema.compiledTypeMap["fallback"][tag];
      if (type && _hasOwnProperty.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }
      result[tag] = style;
    }
    return result;
  }
  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 255) {
      handle = "x";
      length = 2;
    } else if (character <= 65535) {
      handle = "u";
      length = 4;
    } else if (character <= 4294967295) {
      handle = "U";
      length = 8;
    } else {
      throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
    }
    return "\\" + handle + common.repeat("0", length - string.length) + string;
  }
  function State(options) {
    this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options["indent"] || 2);
    this.noArrayIndent = options["noArrayIndent"] || false;
    this.skipInvalid = options["skipInvalid"] || false;
    this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
    this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
    this.sortKeys = options["sortKeys"] || false;
    this.lineWidth = options["lineWidth"] || 80;
    this.noRefs = options["noRefs"] || false;
    this.noCompatMode = options["noCompatMode"] || false;
    this.condenseFlow = options["condenseFlow"] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = "";
    this.duplicates = [];
    this.usedDuplicates = null;
  }
  function indentString(string, spaces) {
    var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
    while (position < length) {
      next = string.indexOf("\n", position);
      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }
      if (line.length && line !== "\n")
        result += ind;
      result += line;
    }
    return result;
  }
  function generateNextLine(state, level) {
    return "\n" + common.repeat(" ", state.indent * level);
  }
  function testImplicitResolving(state, str) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];
      if (type.resolve(str)) {
        return true;
      }
    }
    return false;
  }
  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  }
  function isPrintable(c) {
    return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
  }
  function isPlainSafe(c) {
    return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && c !== CHAR_SHARP;
  }
  function isPlainSafeFirst(c) {
    return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  }
  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }
  var STYLE_PLAIN = 1;
  var STYLE_SINGLE = 2;
  var STYLE_LITERAL = 3;
  var STYLE_FOLDED = 4;
  var STYLE_DOUBLE = 5;
  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char;
    var hasLineBreak = false;
    var hasFoldableLine = false;
    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1;
    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
    if (singleLineOnly) {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
    } else {
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true;
          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }
        plain = plain && isPlainSafe(char);
      }
      hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
    }
    if (!hasLineBreak && !hasFoldableLine) {
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    }
    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    }
    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  }
  function writeScalar(state, string, level, iskey) {
    state.dump = function() {
      if (string.length === 0) {
        return "''";
      }
      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }
      var indent = state.indent * Math.max(1, level);
      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
      var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
      function testAmbiguity(string2) {
        return testImplicitResolving(state, string2);
      }
      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;
        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";
        case STYLE_LITERAL:
          return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
        case STYLE_FOLDED:
          return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
        case STYLE_DOUBLE:
          return '"' + escapeString(string, lineWidth) + '"';
        default:
          throw new YAMLException("impossible error: invalid scalar style");
      }
    }();
  }
  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
    var clip = string[string.length - 1] === "\n";
    var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
    var chomp = keep ? "+" : clip ? "" : "-";
    return indentIndicator + chomp + "\n";
  }
  function dropEndingNewline(string) {
    return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
  }
  function foldString(string, width) {
    var lineRe = /(\n+)([^\n]*)/g;
    var result = function() {
      var nextLF = string.indexOf("\n");
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }();
    var prevMoreIndented = string[0] === "\n" || string[0] === " ";
    var moreIndented;
    var match;
    while (match = lineRe.exec(string)) {
      var prefix = match[1], line = match[2];
      moreIndented = line[0] === " ";
      result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }
    return result;
  }
  function foldLine(line, width) {
    if (line === "" || line[0] === " ")
      return line;
    var breakRe = / [^ ]/g;
    var match;
    var start = 0, end, curr = 0, next = 0;
    var result = "";
    while (match = breakRe.exec(line)) {
      next = match.index;
      if (next - start > width) {
        end = curr > start ? curr : next;
        result += "\n" + line.slice(start, end);
        start = end + 1;
      }
      curr = next;
    }
    result += "\n";
    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }
    return result.slice(1);
  }
  function escapeString(string) {
    var result = "";
    var char, nextChar;
    var escapeSeq;
    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char >= 55296 && char <= 56319) {
        nextChar = string.charCodeAt(i + 1);
        if (nextChar >= 56320 && nextChar <= 57343) {
          result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
          i++;
          continue;
        }
      }
      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }
    return result;
  }
  function writeFlowSequence(state, level, object) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0)
          _result += "," + (!state.condenseFlow ? " " : "");
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = "[" + _result + "]";
  }
  function writeBlockSequence(state, level, object, compact) {
    var _result = "", _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += "-";
        } else {
          _result += "- ";
        }
        _result += state.dump;
      }
    }
    state.tag = _tag;
    state.dump = _result || "[]";
  }
  function writeFlowMapping(state, level, object) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = state.condenseFlow ? '"' : "";
      if (index !== 0)
        pairBuffer += ", ";
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level, objectKey, false, false)) {
        continue;
      }
      if (state.dump.length > 1024)
        pairBuffer += "? ";
      pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
      if (!writeNode(state, level, objectValue, false, false)) {
        continue;
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = "{" + _result + "}";
  }
  function writeBlockMapping(state, level, object, compact) {
    var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    if (state.sortKeys === true) {
      objectKeyList.sort();
    } else if (typeof state.sortKeys === "function") {
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      throw new YAMLException("sortKeys must be a boolean or a function");
    }
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = "";
      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];
      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue;
      }
      explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += "?";
        } else {
          pairBuffer += "? ";
        }
      }
      pairBuffer += state.dump;
      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }
      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue;
      }
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ":";
      } else {
        pairBuffer += ": ";
      }
      pairBuffer += state.dump;
      _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || "{}";
  }
  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];
      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        state.tag = explicit ? type.tag : "?";
        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;
          if (_toString.call(type.represent) === "[object Function]") {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
          }
          state.dump = _result;
        }
        return true;
      }
    }
    return false;
  }
  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }
    var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }
    if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = "*ref_" + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }
      if (type === "[object Object]") {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object Array]") {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
        if (block && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);
          if (duplicate) {
            state.dump = "&ref_" + duplicateIndex + " " + state.dump;
          }
        }
      } else if (type === "[object String]") {
        if (state.tag !== "?") {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid)
          return false;
        throw new YAMLException("unacceptable kind of an object to dump " + type);
      }
      if (state.tag !== null && state.tag !== "?") {
        state.dump = "!<" + state.tag + "> " + state.dump;
      }
    }
    return true;
  }
  function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
  }
  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;
    if (object !== null && typeof object === "object") {
      index = objects.indexOf(object);
      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);
        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);
          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }
  function dump(input, options) {
    options = options || {};
    var state = new State(options);
    if (!state.noRefs)
      getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true))
      return state.dump + "\n";
    return "";
  }
  function safeDump(input, options) {
    return dump(input, common.extend({schema: DEFAULT_SAFE_SCHEMA}, options));
  }
  module2.exports.dump = dump;
  module2.exports.safeDump = safeDump;
});

// node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS((exports2, module2) => {
  "use strict";
  var loader = require_loader();
  var dumper = require_dumper();
  function deprecated(name) {
    return function() {
      throw new Error("Function " + name + " is deprecated and cannot be used.");
    };
  }
  module2.exports.Type = require_type();
  module2.exports.Schema = require_schema();
  module2.exports.FAILSAFE_SCHEMA = require_failsafe();
  module2.exports.JSON_SCHEMA = require_json();
  module2.exports.CORE_SCHEMA = require_core2();
  module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
  module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
  module2.exports.load = loader.load;
  module2.exports.loadAll = loader.loadAll;
  module2.exports.safeLoad = loader.safeLoad;
  module2.exports.safeLoadAll = loader.safeLoadAll;
  module2.exports.dump = dumper.dump;
  module2.exports.safeDump = dumper.safeDump;
  module2.exports.YAMLException = require_exception();
  module2.exports.MINIMAL_SCHEMA = require_failsafe();
  module2.exports.SAFE_SCHEMA = require_default_safe();
  module2.exports.DEFAULT_SCHEMA = require_default_full();
  module2.exports.scan = deprecated("scan");
  module2.exports.parse = deprecated("parse");
  module2.exports.compose = deprecated("compose");
  module2.exports.addConstructor = deprecated("addConstructor");
});

// node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS((exports2, module2) => {
  "use strict";
  var yaml = require_js_yaml();
  module2.exports = yaml;
});

// node_modules/@eslint/eslintrc/lib/config-array-factory.js
var require_config_array_factory = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path3 = require("path");
  var importFresh = require_import_fresh();
  var stripComments = require_strip_json_comments();
  var ConfigValidator = require_config_validator();
  var naming = require_naming();
  var ModuleResolver = require_relative_module_resolver();
  var {
    ConfigArray,
    ConfigDependency,
    IgnorePattern,
    OverrideTester
  } = require_config_array2();
  var debug5 = require_src()("eslintrc:config-array-factory");
  var configFilenames = [
    ".eslintrc.js",
    ".eslintrc.cjs",
    ".eslintrc.yaml",
    ".eslintrc.yml",
    ".eslintrc.json",
    ".eslintrc",
    "package.json"
  ];
  var internalSlotsMap = new WeakMap();
  function isFilePath(nameOrPath) {
    return /^\.{1,2}[/\\]/u.test(nameOrPath) || path3.isAbsolute(nameOrPath);
  }
  function readFile(filePath) {
    return fs2.readFileSync(filePath, "utf8").replace(/^\ufeff/u, "");
  }
  function loadYAMLConfigFile(filePath) {
    debug5(`Loading YAML config file: ${filePath}`);
    const yaml = require_js_yaml2();
    try {
      return yaml.safeLoad(readFile(filePath)) || {};
    } catch (e) {
      debug5(`Error reading YAML file: ${filePath}`);
      e.message = `Cannot read config file: ${filePath}
Error: ${e.message}`;
      throw e;
    }
  }
  function loadJSONConfigFile(filePath) {
    debug5(`Loading JSON config file: ${filePath}`);
    try {
      return JSON.parse(stripComments(readFile(filePath)));
    } catch (e) {
      debug5(`Error reading JSON file: ${filePath}`);
      e.message = `Cannot read config file: ${filePath}
Error: ${e.message}`;
      e.messageTemplate = "failed-to-read-json";
      e.messageData = {
        path: filePath,
        message: e.message
      };
      throw e;
    }
  }
  function loadLegacyConfigFile(filePath) {
    debug5(`Loading legacy config file: ${filePath}`);
    const yaml = require_js_yaml2();
    try {
      return yaml.safeLoad(stripComments(readFile(filePath))) || {};
    } catch (e) {
      debug5("Error reading YAML file: %s\n%o", filePath, e);
      e.message = `Cannot read config file: ${filePath}
Error: ${e.message}`;
      throw e;
    }
  }
  function loadJSConfigFile(filePath) {
    debug5(`Loading JS config file: ${filePath}`);
    try {
      return importFresh(filePath);
    } catch (e) {
      debug5(`Error reading JavaScript file: ${filePath}`);
      e.message = `Cannot read config file: ${filePath}
Error: ${e.message}`;
      throw e;
    }
  }
  function loadPackageJSONConfigFile(filePath) {
    debug5(`Loading package.json config file: ${filePath}`);
    try {
      const packageData = loadJSONConfigFile(filePath);
      if (!Object.hasOwnProperty.call(packageData, "eslintConfig")) {
        throw Object.assign(new Error("package.json file doesn't have 'eslintConfig' field."), {code: "ESLINT_CONFIG_FIELD_NOT_FOUND"});
      }
      return packageData.eslintConfig;
    } catch (e) {
      debug5(`Error reading package.json file: ${filePath}`);
      e.message = `Cannot read config file: ${filePath}
Error: ${e.message}`;
      throw e;
    }
  }
  function loadESLintIgnoreFile(filePath) {
    debug5(`Loading .eslintignore file: ${filePath}`);
    try {
      return readFile(filePath).split(/\r?\n/gu).filter((line) => line.trim() !== "" && !line.startsWith("#"));
    } catch (e) {
      debug5(`Error reading .eslintignore file: ${filePath}`);
      e.message = `Cannot read .eslintignore file: ${filePath}
Error: ${e.message}`;
      throw e;
    }
  }
  function configInvalidError(configName, importerName, messageTemplate) {
    return Object.assign(new Error(`Failed to load config "${configName}" to extend from.`), {
      messageTemplate,
      messageData: {configName, importerName}
    });
  }
  function loadConfigFile(filePath) {
    switch (path3.extname(filePath)) {
      case ".js":
      case ".cjs":
        return loadJSConfigFile(filePath);
      case ".json":
        if (path3.basename(filePath) === "package.json") {
          return loadPackageJSONConfigFile(filePath);
        }
        return loadJSONConfigFile(filePath);
      case ".yaml":
      case ".yml":
        return loadYAMLConfigFile(filePath);
      default:
        return loadLegacyConfigFile(filePath);
    }
  }
  function writeDebugLogForLoading(request, relativeTo, filePath) {
    if (debug5.enabled) {
      let nameAndVersion = null;
      try {
        const packageJsonPath = ModuleResolver.resolve(`${request}/package.json`, relativeTo);
        const {version = "unknown"} = require(packageJsonPath);
        nameAndVersion = `${request}@${version}`;
      } catch (error5) {
        debug5("package.json was not found:", error5.message);
        nameAndVersion = request;
      }
      debug5("Loaded: %s (%s)", nameAndVersion, filePath);
    }
  }
  function createContext({cwd, resolvePluginsRelativeTo}, providedType, providedName, providedFilePath, providedMatchBasePath) {
    const filePath = providedFilePath ? path3.resolve(cwd, providedFilePath) : "";
    const matchBasePath = providedMatchBasePath && path3.resolve(cwd, providedMatchBasePath) || filePath && path3.dirname(filePath) || cwd;
    const name = providedName || filePath && path3.relative(cwd, filePath) || "";
    const pluginBasePath = resolvePluginsRelativeTo || filePath && path3.dirname(filePath) || cwd;
    const type = providedType || "config";
    return {filePath, matchBasePath, name, pluginBasePath, type};
  }
  function normalizePlugin(plugin) {
    return {
      configs: plugin.configs || {},
      environments: plugin.environments || {},
      processors: plugin.processors || {},
      rules: plugin.rules || {}
    };
  }
  var ConfigArrayFactory = class {
    constructor({
      additionalPluginPool = new Map(),
      cwd = process.cwd(),
      resolvePluginsRelativeTo,
      builtInRules,
      resolver = ModuleResolver,
      eslintAllPath,
      eslintRecommendedPath
    } = {}) {
      internalSlotsMap.set(this, {
        additionalPluginPool,
        cwd,
        resolvePluginsRelativeTo: resolvePluginsRelativeTo && path3.resolve(cwd, resolvePluginsRelativeTo),
        builtInRules,
        resolver,
        eslintAllPath,
        eslintRecommendedPath
      });
    }
    create(configData, {basePath, filePath, name} = {}) {
      if (!configData) {
        return new ConfigArray();
      }
      const slots = internalSlotsMap.get(this);
      const ctx = createContext(slots, "config", name, filePath, basePath);
      const elements = this._normalizeConfigData(configData, ctx);
      return new ConfigArray(...elements);
    }
    loadFile(filePath, {basePath, name} = {}) {
      const slots = internalSlotsMap.get(this);
      const ctx = createContext(slots, "config", name, filePath, basePath);
      return new ConfigArray(...this._loadConfigData(ctx));
    }
    loadInDirectory(directoryPath, {basePath, name} = {}) {
      const slots = internalSlotsMap.get(this);
      for (const filename of configFilenames) {
        const ctx = createContext(slots, "config", name, path3.join(directoryPath, filename), basePath);
        if (fs2.existsSync(ctx.filePath)) {
          let configData;
          try {
            configData = loadConfigFile(ctx.filePath);
          } catch (error5) {
            if (!error5 || error5.code !== "ESLINT_CONFIG_FIELD_NOT_FOUND") {
              throw error5;
            }
          }
          if (configData) {
            debug5(`Config file found: ${ctx.filePath}`);
            return new ConfigArray(...this._normalizeConfigData(configData, ctx));
          }
        }
      }
      debug5(`Config file not found on ${directoryPath}`);
      return new ConfigArray();
    }
    static getPathToConfigFileInDirectory(directoryPath) {
      for (const filename of configFilenames) {
        const filePath = path3.join(directoryPath, filename);
        if (fs2.existsSync(filePath)) {
          if (filename === "package.json") {
            try {
              loadPackageJSONConfigFile(filePath);
              return filePath;
            } catch (e) {
            }
          } else {
            return filePath;
          }
        }
      }
      return null;
    }
    loadESLintIgnore(filePath) {
      const slots = internalSlotsMap.get(this);
      const ctx = createContext(slots, "ignore", void 0, filePath, slots.cwd);
      const ignorePatterns = loadESLintIgnoreFile(ctx.filePath);
      return new ConfigArray(...this._normalizeESLintIgnoreData(ignorePatterns, ctx));
    }
    loadDefaultESLintIgnore() {
      const slots = internalSlotsMap.get(this);
      const eslintIgnorePath = path3.resolve(slots.cwd, ".eslintignore");
      const packageJsonPath = path3.resolve(slots.cwd, "package.json");
      if (fs2.existsSync(eslintIgnorePath)) {
        return this.loadESLintIgnore(eslintIgnorePath);
      }
      if (fs2.existsSync(packageJsonPath)) {
        const data = loadJSONConfigFile(packageJsonPath);
        if (Object.hasOwnProperty.call(data, "eslintIgnore")) {
          if (!Array.isArray(data.eslintIgnore)) {
            throw new Error("Package.json eslintIgnore property requires an array of paths");
          }
          const ctx = createContext(slots, "ignore", "eslintIgnore in package.json", packageJsonPath, slots.cwd);
          return new ConfigArray(...this._normalizeESLintIgnoreData(data.eslintIgnore, ctx));
        }
      }
      return new ConfigArray();
    }
    _loadConfigData(ctx) {
      return this._normalizeConfigData(loadConfigFile(ctx.filePath), ctx);
    }
    *_normalizeESLintIgnoreData(ignorePatterns, ctx) {
      const elements = this._normalizeObjectConfigData({ignorePatterns}, ctx);
      for (const element of elements) {
        if (element.ignorePattern) {
          element.ignorePattern.loose = true;
        }
        yield element;
      }
    }
    _normalizeConfigData(configData, ctx) {
      const validator = new ConfigValidator();
      validator.validateConfigSchema(configData, ctx.name || ctx.filePath);
      return this._normalizeObjectConfigData(configData, ctx);
    }
    *_normalizeObjectConfigData(configData, ctx) {
      const _a = configData, {files, excludedFiles} = _a, configBody = __objRest(_a, ["files", "excludedFiles"]);
      const criteria = OverrideTester.create(files, excludedFiles, ctx.matchBasePath);
      const elements = this._normalizeObjectConfigDataBody(configBody, ctx);
      for (const element of elements) {
        element.criteria = OverrideTester.and(criteria, element.criteria);
        if (element.criteria) {
          element.root = void 0;
        }
        yield element;
      }
    }
    *_normalizeObjectConfigDataBody({
      env,
      extends: extend,
      globals,
      ignorePatterns,
      noInlineConfig,
      parser: parserName,
      parserOptions,
      plugins: pluginList,
      processor,
      reportUnusedDisableDirectives,
      root,
      rules,
      settings,
      overrides: overrideList = []
    }, ctx) {
      const extendList = Array.isArray(extend) ? extend : [extend];
      const ignorePattern = ignorePatterns && new IgnorePattern(Array.isArray(ignorePatterns) ? ignorePatterns : [ignorePatterns], ctx.matchBasePath);
      for (const extendName of extendList.filter(Boolean)) {
        yield* this._loadExtends(extendName, ctx);
      }
      const parser = parserName && this._loadParser(parserName, ctx);
      const plugins = pluginList && this._loadPlugins(pluginList, ctx);
      if (plugins) {
        yield* this._takeFileExtensionProcessors(plugins, ctx);
      }
      yield {
        type: ctx.type,
        name: ctx.name,
        filePath: ctx.filePath,
        criteria: null,
        env,
        globals,
        ignorePattern,
        noInlineConfig,
        parser,
        parserOptions,
        plugins,
        processor,
        reportUnusedDisableDirectives,
        root,
        rules,
        settings
      };
      for (let i = 0; i < overrideList.length; ++i) {
        yield* this._normalizeObjectConfigData(overrideList[i], __objSpread(__objSpread({}, ctx), {name: `${ctx.name}#overrides[${i}]`}));
      }
    }
    _loadExtends(extendName, ctx) {
      debug5("Loading {extends:%j} relative to %s", extendName, ctx.filePath);
      try {
        if (extendName.startsWith("eslint:")) {
          return this._loadExtendedBuiltInConfig(extendName, ctx);
        }
        if (extendName.startsWith("plugin:")) {
          return this._loadExtendedPluginConfig(extendName, ctx);
        }
        return this._loadExtendedShareableConfig(extendName, ctx);
      } catch (error5) {
        error5.message += `
Referenced from: ${ctx.filePath || ctx.name}`;
        throw error5;
      }
    }
    _loadExtendedBuiltInConfig(extendName, ctx) {
      const {eslintAllPath, eslintRecommendedPath} = internalSlotsMap.get(this);
      if (extendName === "eslint:recommended") {
        return this._loadConfigData(__objSpread(__objSpread({}, ctx), {
          filePath: eslintRecommendedPath,
          name: `${ctx.name} \xBB ${extendName}`
        }));
      }
      if (extendName === "eslint:all") {
        return this._loadConfigData(__objSpread(__objSpread({}, ctx), {
          filePath: eslintAllPath,
          name: `${ctx.name} \xBB ${extendName}`
        }));
      }
      throw configInvalidError(extendName, ctx.name, "extend-config-missing");
    }
    _loadExtendedPluginConfig(extendName, ctx) {
      const slashIndex = extendName.lastIndexOf("/");
      if (slashIndex === -1) {
        throw configInvalidError(extendName, ctx.filePath, "plugin-invalid");
      }
      const pluginName = extendName.slice("plugin:".length, slashIndex);
      const configName = extendName.slice(slashIndex + 1);
      if (isFilePath(pluginName)) {
        throw new Error("'extends' cannot use a file path for plugins.");
      }
      const plugin = this._loadPlugin(pluginName, ctx);
      const configData = plugin.definition && plugin.definition.configs[configName];
      if (configData) {
        return this._normalizeConfigData(configData, __objSpread(__objSpread({}, ctx), {
          filePath: plugin.filePath || ctx.filePath,
          name: `${ctx.name} \xBB plugin:${plugin.id}/${configName}`
        }));
      }
      throw plugin.error || configInvalidError(extendName, ctx.filePath, "extend-config-missing");
    }
    _loadExtendedShareableConfig(extendName, ctx) {
      const {cwd, resolver} = internalSlotsMap.get(this);
      const relativeTo = ctx.filePath || path3.join(cwd, "__placeholder__.js");
      let request;
      if (isFilePath(extendName)) {
        request = extendName;
      } else if (extendName.startsWith(".")) {
        request = `./${extendName}`;
      } else {
        request = naming.normalizePackageName(extendName, "eslint-config");
      }
      let filePath;
      try {
        filePath = resolver.resolve(request, relativeTo);
      } catch (error5) {
        if (error5 && error5.code === "MODULE_NOT_FOUND") {
          throw configInvalidError(extendName, ctx.filePath, "extend-config-missing");
        }
        throw error5;
      }
      writeDebugLogForLoading(request, relativeTo, filePath);
      return this._loadConfigData(__objSpread(__objSpread({}, ctx), {
        filePath,
        name: `${ctx.name} \xBB ${request}`
      }));
    }
    _loadPlugins(names, ctx) {
      return names.reduce((map, name) => {
        if (isFilePath(name)) {
          throw new Error("Plugins array cannot includes file paths.");
        }
        const plugin = this._loadPlugin(name, ctx);
        map[plugin.id] = plugin;
        return map;
      }, {});
    }
    _loadParser(nameOrPath, ctx) {
      debug5("Loading parser %j from %s", nameOrPath, ctx.filePath);
      const {cwd} = internalSlotsMap.get(this);
      const relativeTo = ctx.filePath || path3.join(cwd, "__placeholder__.js");
      try {
        const filePath = ModuleResolver.resolve(nameOrPath, relativeTo);
        writeDebugLogForLoading(nameOrPath, relativeTo, filePath);
        return new ConfigDependency({
          definition: require(filePath),
          filePath,
          id: nameOrPath,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      } catch (error5) {
        if (nameOrPath === "espree") {
          debug5("Fallback espree.");
          return new ConfigDependency({
            definition: require("espree"),
            filePath: require.resolve("espree"),
            id: nameOrPath,
            importerName: ctx.name,
            importerPath: ctx.filePath
          });
        }
        debug5("Failed to load parser '%s' declared in '%s'.", nameOrPath, ctx.name);
        error5.message = `Failed to load parser '${nameOrPath}' declared in '${ctx.name}': ${error5.message}`;
        return new ConfigDependency({
          error: error5,
          id: nameOrPath,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      }
    }
    _loadPlugin(name, ctx) {
      debug5("Loading plugin %j from %s", name, ctx.filePath);
      const {additionalPluginPool} = internalSlotsMap.get(this);
      const request = naming.normalizePackageName(name, "eslint-plugin");
      const id = naming.getShorthandName(request, "eslint-plugin");
      const relativeTo = path3.join(ctx.pluginBasePath, "__placeholder__.js");
      if (name.match(/\s+/u)) {
        const error6 = Object.assign(new Error(`Whitespace found in plugin name '${name}'`), {
          messageTemplate: "whitespace-found",
          messageData: {pluginName: request}
        });
        return new ConfigDependency({
          error: error6,
          id,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      }
      const plugin = additionalPluginPool.get(request) || additionalPluginPool.get(id);
      if (plugin) {
        return new ConfigDependency({
          definition: normalizePlugin(plugin),
          filePath: "",
          id,
          importerName: ctx.name,
          importerPath: ctx.filePath
        });
      }
      let filePath;
      let error5;
      try {
        filePath = ModuleResolver.resolve(request, relativeTo);
      } catch (resolveError) {
        error5 = resolveError;
        if (error5 && error5.code === "MODULE_NOT_FOUND") {
          error5.messageTemplate = "plugin-missing";
          error5.messageData = {
            pluginName: request,
            resolvePluginsRelativeTo: ctx.pluginBasePath,
            importerName: ctx.name
          };
        }
      }
      if (filePath) {
        try {
          writeDebugLogForLoading(request, relativeTo, filePath);
          const startTime = Date.now();
          const pluginDefinition = require(filePath);
          debug5(`Plugin ${filePath} loaded in: ${Date.now() - startTime}ms`);
          return new ConfigDependency({
            definition: normalizePlugin(pluginDefinition),
            filePath,
            id,
            importerName: ctx.name,
            importerPath: ctx.filePath
          });
        } catch (loadError) {
          error5 = loadError;
        }
      }
      debug5("Failed to load plugin '%s' declared in '%s'.", name, ctx.name);
      error5.message = `Failed to load plugin '${name}' declared in '${ctx.name}': ${error5.message}`;
      return new ConfigDependency({
        error: error5,
        id,
        importerName: ctx.name,
        importerPath: ctx.filePath
      });
    }
    *_takeFileExtensionProcessors(plugins, ctx) {
      for (const pluginId of Object.keys(plugins)) {
        const processors = plugins[pluginId] && plugins[pluginId].definition && plugins[pluginId].definition.processors;
        if (!processors) {
          continue;
        }
        for (const processorId of Object.keys(processors)) {
          if (processorId.startsWith(".")) {
            yield* this._normalizeObjectConfigData({
              files: [`*${processorId}`],
              processor: `${pluginId}/${processorId}`
            }, __objSpread(__objSpread({}, ctx), {
              type: "implicit-processor",
              name: `${ctx.name}#processors["${pluginId}/${processorId}"]`
            }));
          }
        }
      }
    }
  };
  module2.exports = {ConfigArrayFactory, createContext};
});

// node_modules/@eslint/eslintrc/lib/cascading-config-array-factory.js
var require_cascading_config_array_factory = __commonJS((exports2, module2) => {
  "use strict";
  var os = require("os");
  var path3 = require("path");
  var ConfigValidator = require_config_validator();
  var {emitDeprecationWarning} = require_deprecation_warnings();
  var {ConfigArrayFactory} = require_config_array_factory();
  var {ConfigArray, ConfigDependency, IgnorePattern} = require_config_array2();
  var debug5 = require_src()("eslintrc:cascading-config-array-factory");
  var internalSlotsMap = new WeakMap();
  function createBaseConfigArray({
    configArrayFactory,
    baseConfigData,
    rulePaths,
    cwd,
    loadRules
  }) {
    const baseConfigArray = configArrayFactory.create(baseConfigData, {name: "BaseConfig"});
    baseConfigArray.unshift(configArrayFactory.create({ignorePatterns: IgnorePattern.DefaultPatterns}, {name: "DefaultIgnorePattern"})[0]);
    if (rulePaths && rulePaths.length > 0) {
      baseConfigArray.push({
        type: "config",
        name: "--rulesdir",
        filePath: "",
        plugins: {
          "": new ConfigDependency({
            definition: {
              rules: rulePaths.reduce((map, rulesPath) => Object.assign(map, loadRules(rulesPath, cwd)), {})
            },
            filePath: "",
            id: "",
            importerName: "--rulesdir",
            importerPath: ""
          })
        }
      });
    }
    return baseConfigArray;
  }
  function createCLIConfigArray({
    cliConfigData,
    configArrayFactory,
    cwd,
    ignorePath,
    specificConfigPath
  }) {
    const cliConfigArray = configArrayFactory.create(cliConfigData, {name: "CLIOptions"});
    cliConfigArray.unshift(...ignorePath ? configArrayFactory.loadESLintIgnore(ignorePath) : configArrayFactory.loadDefaultESLintIgnore());
    if (specificConfigPath) {
      cliConfigArray.unshift(...configArrayFactory.loadFile(specificConfigPath, {name: "--config", basePath: cwd}));
    }
    return cliConfigArray;
  }
  var ConfigurationNotFoundError = class extends Error {
    constructor(directoryPath) {
      super(`No ESLint configuration found in ${directoryPath}.`);
      this.messageTemplate = "no-config-found";
      this.messageData = {directoryPath};
    }
  };
  var CascadingConfigArrayFactory = class {
    constructor({
      additionalPluginPool = new Map(),
      baseConfig: baseConfigData = null,
      cliConfig: cliConfigData = null,
      cwd = process.cwd(),
      ignorePath,
      resolvePluginsRelativeTo,
      rulePaths = [],
      specificConfigPath = null,
      useEslintrc = true,
      builtInRules = new Map(),
      loadRules,
      resolver,
      eslintRecommendedPath,
      eslintAllPath
    } = {}) {
      const configArrayFactory = new ConfigArrayFactory({
        additionalPluginPool,
        cwd,
        resolvePluginsRelativeTo,
        builtInRules,
        resolver,
        eslintRecommendedPath,
        eslintAllPath
      });
      internalSlotsMap.set(this, {
        baseConfigArray: createBaseConfigArray({
          baseConfigData,
          configArrayFactory,
          cwd,
          rulePaths,
          loadRules,
          resolver
        }),
        baseConfigData,
        cliConfigArray: createCLIConfigArray({
          cliConfigData,
          configArrayFactory,
          cwd,
          ignorePath,
          specificConfigPath
        }),
        cliConfigData,
        configArrayFactory,
        configCache: new Map(),
        cwd,
        finalizeCache: new WeakMap(),
        ignorePath,
        rulePaths,
        specificConfigPath,
        useEslintrc,
        builtInRules,
        loadRules
      });
    }
    get cwd() {
      const {cwd} = internalSlotsMap.get(this);
      return cwd;
    }
    getConfigArrayForFile(filePath, {ignoreNotFoundError = false} = {}) {
      const {
        baseConfigArray,
        cliConfigArray,
        cwd
      } = internalSlotsMap.get(this);
      if (!filePath) {
        return new ConfigArray(...baseConfigArray, ...cliConfigArray);
      }
      const directoryPath = path3.dirname(path3.resolve(cwd, filePath));
      debug5(`Load config files for ${directoryPath}.`);
      return this._finalizeConfigArray(this._loadConfigInAncestors(directoryPath), directoryPath, ignoreNotFoundError);
    }
    setOverrideConfig(configData) {
      const slots = internalSlotsMap.get(this);
      slots.cliConfigData = configData;
    }
    clearCache() {
      const slots = internalSlotsMap.get(this);
      slots.baseConfigArray = createBaseConfigArray(slots);
      slots.cliConfigArray = createCLIConfigArray(slots);
      slots.configCache.clear();
    }
    _loadConfigInAncestors(directoryPath, configsExistInSubdirs = false) {
      const {
        baseConfigArray,
        configArrayFactory,
        configCache,
        cwd,
        useEslintrc
      } = internalSlotsMap.get(this);
      if (!useEslintrc) {
        return baseConfigArray;
      }
      let configArray = configCache.get(directoryPath);
      if (configArray) {
        debug5(`Cache hit: ${directoryPath}.`);
        return configArray;
      }
      debug5(`No cache found: ${directoryPath}.`);
      const homePath = os.homedir();
      if (directoryPath === homePath && cwd !== homePath) {
        debug5("Stop traversing because of considered root.");
        if (configsExistInSubdirs) {
          const filePath = ConfigArrayFactory.getPathToConfigFileInDirectory(directoryPath);
          if (filePath) {
            emitDeprecationWarning(filePath, "ESLINT_PERSONAL_CONFIG_SUPPRESS");
          }
        }
        return this._cacheConfig(directoryPath, baseConfigArray);
      }
      try {
        configArray = configArrayFactory.loadInDirectory(directoryPath);
      } catch (error5) {
        if (error5.code === "EACCES") {
          debug5("Stop traversing because of 'EACCES' error.");
          return this._cacheConfig(directoryPath, baseConfigArray);
        }
        throw error5;
      }
      if (configArray.length > 0 && configArray.isRoot()) {
        debug5("Stop traversing because of 'root:true'.");
        configArray.unshift(...baseConfigArray);
        return this._cacheConfig(directoryPath, configArray);
      }
      const parentPath = path3.dirname(directoryPath);
      const parentConfigArray = parentPath && parentPath !== directoryPath ? this._loadConfigInAncestors(parentPath, configsExistInSubdirs || configArray.length > 0) : baseConfigArray;
      if (configArray.length > 0) {
        configArray.unshift(...parentConfigArray);
      } else {
        configArray = parentConfigArray;
      }
      return this._cacheConfig(directoryPath, configArray);
    }
    _cacheConfig(directoryPath, configArray) {
      const {configCache} = internalSlotsMap.get(this);
      Object.freeze(configArray);
      configCache.set(directoryPath, configArray);
      return configArray;
    }
    _finalizeConfigArray(configArray, directoryPath, ignoreNotFoundError) {
      const {
        cliConfigArray,
        configArrayFactory,
        finalizeCache,
        useEslintrc,
        builtInRules
      } = internalSlotsMap.get(this);
      let finalConfigArray = finalizeCache.get(configArray);
      if (!finalConfigArray) {
        finalConfigArray = configArray;
        if (useEslintrc && configArray.every((c) => !c.filePath) && cliConfigArray.every((c) => !c.filePath)) {
          const homePath = os.homedir();
          debug5("Loading the config file of the home directory:", homePath);
          const personalConfigArray = configArrayFactory.loadInDirectory(homePath, {name: "PersonalConfig"});
          if (personalConfigArray.length > 0 && !directoryPath.startsWith(homePath)) {
            const lastElement = personalConfigArray[personalConfigArray.length - 1];
            emitDeprecationWarning(lastElement.filePath, "ESLINT_PERSONAL_CONFIG_LOAD");
          }
          finalConfigArray = finalConfigArray.concat(personalConfigArray);
        }
        if (cliConfigArray.length > 0) {
          finalConfigArray = finalConfigArray.concat(cliConfigArray);
        }
        const validator = new ConfigValidator({
          builtInRules
        });
        validator.validateConfigArray(finalConfigArray);
        Object.freeze(finalConfigArray);
        finalizeCache.set(configArray, finalConfigArray);
        debug5("Configuration was determined: %o on %s", finalConfigArray, directoryPath);
      }
      if (!ignoreNotFoundError && useEslintrc && finalConfigArray.length <= 1) {
        throw new ConfigurationNotFoundError(directoryPath);
      }
      return finalConfigArray;
    }
  };
  module2.exports = {CascadingConfigArrayFactory};
});

// node_modules/@eslint/eslintrc/lib/flat-compat.js
var require_flat_compat = __commonJS((exports2) => {
  "use strict";
  var path3 = require("path");
  var environments = require_environments();
  var createDebug = require_src();
  var {ConfigArrayFactory} = require_config_array_factory();
  var debug5 = createDebug("eslintrc:flat-compat");
  var cafactory = Symbol("cafactory");
  function translateESLintRC(eslintrcConfig, {
    resolveConfigRelativeTo,
    resolvePluginsRelativeTo,
    pluginEnvironments,
    pluginProcessors
  }) {
    const flatConfig = {};
    const configs = [];
    const languageOptions = {};
    const linterOptions = {};
    const keysToCopy = ["settings", "rules", "processor"];
    const languageOptionsKeysToCopy = ["globals", "parser", "parserOptions"];
    const linterOptionsKeysToCopy = ["noInlineConfig", "reportUnusedDisableDirectives"];
    if (eslintrcConfig.settings) {
      if (eslintrcConfig.settings["eslint:all"] === true) {
        return ["eslint:all"];
      }
      if (eslintrcConfig.settings["eslint:recommended"] === true) {
        return ["eslint:recommended"];
      }
    }
    for (const key of keysToCopy) {
      if (key in eslintrcConfig && typeof eslintrcConfig[key] !== "undefined") {
        flatConfig[key] = eslintrcConfig[key];
      }
    }
    for (const key of languageOptionsKeysToCopy) {
      if (key in eslintrcConfig && typeof eslintrcConfig[key] !== "undefined") {
        flatConfig.languageOptions = languageOptions;
        if (key === "parser") {
          debug5(`Resolving parser '${languageOptions[key]}' relative to ${resolveConfigRelativeTo}`);
          if (eslintrcConfig[key].error) {
            throw eslintrcConfig[key].error;
          }
          languageOptions[key] = eslintrcConfig[key].definition;
          continue;
        }
        if (eslintrcConfig[key] && typeof eslintrcConfig[key] === "object") {
          languageOptions[key] = __objSpread({}, eslintrcConfig[key]);
        } else {
          languageOptions[key] = eslintrcConfig[key];
        }
      }
    }
    for (const key of linterOptionsKeysToCopy) {
      if (key in eslintrcConfig && typeof eslintrcConfig[key] !== "undefined") {
        flatConfig.linterOptions = linterOptions;
        linterOptions[key] = eslintrcConfig[key];
      }
    }
    if (languageOptions.parserOptions) {
      if ("ecmaVersion" in languageOptions.parserOptions) {
        languageOptions.ecmaVersion = languageOptions.parserOptions.ecmaVersion;
        delete languageOptions.parserOptions.ecmaVersion;
      }
      if ("sourceType" in languageOptions.parserOptions) {
        languageOptions.sourceType = languageOptions.parserOptions.sourceType;
        delete languageOptions.parserOptions.sourceType;
      }
      if (Object.keys(languageOptions.parserOptions).length === 0) {
        delete languageOptions.parserOptions;
      }
    }
    if (eslintrcConfig.criteria) {
      flatConfig.files = [(absoluteFilePath) => eslintrcConfig.criteria.test(absoluteFilePath)];
    }
    if (eslintrcConfig.plugins && typeof eslintrcConfig.plugins === "object") {
      debug5(`Translating plugins: ${eslintrcConfig.plugins}`);
      flatConfig.plugins = {};
      for (const pluginName of Object.keys(eslintrcConfig.plugins)) {
        debug5(`Translating plugin: ${pluginName}`);
        debug5(`Resolving plugin '${pluginName} relative to ${resolvePluginsRelativeTo}`);
        const {definition: plugin, error: error5} = eslintrcConfig.plugins[pluginName];
        if (error5) {
          throw error5;
        }
        flatConfig.plugins[pluginName] = plugin;
        if (plugin.processors) {
          for (const processorName of Object.keys(plugin.processors)) {
            if (processorName.startsWith(".")) {
              debug5(`Assigning processor: ${pluginName}/${processorName}`);
              configs.unshift({
                files: [`**/*${processorName}`],
                processor: pluginProcessors.get(`${pluginName}/${processorName}`)
              });
            }
          }
        }
      }
    }
    if (eslintrcConfig.env && typeof eslintrcConfig.env === "object") {
      for (const envName of Object.keys(eslintrcConfig.env)) {
        if (eslintrcConfig.env[envName]) {
          debug5(`Translating environment: ${envName}`);
          if (environments.has(envName)) {
            configs.unshift(...translateESLintRC(environments.get(envName), {
              resolveConfigRelativeTo,
              resolvePluginsRelativeTo
            }));
          } else if (pluginEnvironments.has(envName)) {
            configs.push(...translateESLintRC(pluginEnvironments.get(envName), {
              resolveConfigRelativeTo,
              resolvePluginsRelativeTo
            }));
          }
        }
      }
    }
    if (Object.keys(flatConfig).length > 0) {
      configs.push(flatConfig);
    }
    return configs;
  }
  var FlatCompat = class {
    constructor({
      baseDirectory = process.cwd(),
      resolvePluginsRelativeTo = baseDirectory
    } = {}) {
      this.baseDirectory = baseDirectory;
      this.resolvePluginsRelativeTo = resolvePluginsRelativeTo;
      this[cafactory] = new ConfigArrayFactory({
        cwd: baseDirectory,
        resolvePluginsRelativeTo,
        eslintAllPath: path3.resolve(__dirname, "../conf/eslint-all.js"),
        eslintRecommendedPath: path3.resolve(__dirname, "../conf/eslint-recommended.js")
      });
    }
    config(eslintrcConfig) {
      const eslintrcArray = this[cafactory].create(eslintrcConfig, {
        basePath: this.baseDirectory
      });
      const flatArray = [];
      let hasIgnorePatterns = false;
      eslintrcArray.forEach((configData) => {
        if (configData.type === "config") {
          hasIgnorePatterns = hasIgnorePatterns || configData.ignorePattern;
          flatArray.push(...translateESLintRC(configData, {
            resolveConfigRelativeTo: path3.join(this.baseDirectory, "__placeholder.js"),
            resolvePluginsRelativeTo: path3.join(this.resolvePluginsRelativeTo, "__placeholder.js"),
            pluginEnvironments: eslintrcArray.pluginEnvironments,
            pluginProcessors: eslintrcArray.pluginProcessors
          }));
        }
      });
      if (hasIgnorePatterns) {
        flatArray.unshift({
          ignores: [(filePath) => {
            const finalConfig = eslintrcArray.extractConfig(filePath);
            return Boolean(finalConfig.ignores) && finalConfig.ignores(filePath);
          }]
        });
      }
      return flatArray;
    }
    env(envConfig) {
      return this.config({
        env: envConfig
      });
    }
    extends(...configsToExtend) {
      return this.config({
        extends: configsToExtend
      });
    }
    plugins(...plugins) {
      return this.config({
        plugins
      });
    }
  };
  exports2.FlatCompat = FlatCompat;
});

// node_modules/@eslint/eslintrc/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    ConfigArrayFactory,
    createContext: createConfigArrayFactoryContext
  } = require_config_array_factory();
  var {CascadingConfigArrayFactory} = require_cascading_config_array_factory();
  var {ModuleResolver} = require_relative_module_resolver();
  var {ConfigArray, getUsedExtractedConfigs} = require_config_array2();
  var {ConfigDependency} = require_config_dependency();
  var {ExtractedConfig} = require_extracted_config();
  var {IgnorePattern} = require_ignore_pattern();
  var {OverrideTester} = require_override_tester();
  var ConfigOps = require_config_ops();
  var ConfigValidator = require_config_validator();
  var naming = require_naming();
  var {FlatCompat} = require_flat_compat();
  module2.exports = {
    Legacy: {
      ConfigArray,
      createConfigArrayFactoryContext,
      CascadingConfigArrayFactory,
      ConfigArrayFactory,
      ConfigDependency,
      ExtractedConfig,
      IgnorePattern,
      OverrideTester,
      getUsedExtractedConfigs,
      ConfigOps,
      ConfigValidator,
      ModuleResolver,
      naming
    },
    FlatCompat
  };
});

// node_modules/is-extglob/index.js
var require_is_extglob = __commonJS((exports2, module2) => {
  /*!
   * is-extglob <https://github.com/jonschlinkert/is-extglob>
   *
   * Copyright (c) 2014-2016, Jon Schlinkert.
   * Licensed under the MIT License.
   */
  module2.exports = function isExtglob(str) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    var match;
    while (match = /(\\).|([@?!+*]\(.*\))/g.exec(str)) {
      if (match[2])
        return true;
      str = str.slice(match.index + match[0].length);
    }
    return false;
  };
});

// node_modules/is-glob/index.js
var require_is_glob = __commonJS((exports2, module2) => {
  /*!
   * is-glob <https://github.com/jonschlinkert/is-glob>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   */
  var isExtglob = require_is_extglob();
  var chars = {"{": "}", "(": ")", "[": "]"};
  var strictRegex = /\\(.)|(^!|\*|[\].+)]\?|\[[^\\\]]+\]|\{[^\\}]+\}|\(\?[:!=][^\\)]+\)|\([^|]+\|[^\\)]+\))/;
  var relaxedRegex = /\\(.)|(^!|[*?{}()[\]]|\(\?)/;
  module2.exports = function isGlob(str, options) {
    if (typeof str !== "string" || str === "") {
      return false;
    }
    if (isExtglob(str)) {
      return true;
    }
    var regex = strictRegex;
    var match;
    if (options && options.strict === false) {
      regex = relaxedRegex;
    }
    while (match = regex.exec(str)) {
      if (match[2])
        return true;
      var idx = match.index + match[0].length;
      var open = match[1];
      var close = open ? chars[open] : null;
      if (open && close) {
        var n = str.indexOf(close, idx);
        if (n !== -1) {
          idx = n + 1;
        }
      }
      str = str.slice(idx);
    }
    return false;
  };
});

// node_modules/glob-parent/index.js
var require_glob_parent = __commonJS((exports2, module2) => {
  "use strict";
  var isGlob = require_is_glob();
  var pathPosixDirname = require("path").posix.dirname;
  var isWin32 = require("os").platform() === "win32";
  var slash = "/";
  var backslash = /\\/g;
  var enclosure = /[\{\[].*[\/]*.*[\}\]]$/;
  var globby = /(^|[^\\])([\{\[]|\([^\)]+$)/;
  var escaped = /\\([\!\*\?\|\[\]\(\)\{\}])/g;
  module2.exports = function globParent(str, opts) {
    var options = Object.assign({flipBackslashes: true}, opts);
    if (options.flipBackslashes && isWin32 && str.indexOf(slash) < 0) {
      str = str.replace(backslash, slash);
    }
    if (enclosure.test(str)) {
      str += slash;
    }
    str += "a";
    do {
      str = pathPosixDirname(str);
    } while (isGlob(str) || globby.test(str));
    return str.replace(escaped, "$1");
  };
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS((exports2, module2) => {
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  (function() {
    var undefined2;
    var VERSION = "4.17.21";
    var LARGE_ARRAY_SIZE = 200;
    var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_MEMOIZE_SIZE = 500;
    var PLACEHOLDER = "__lodash_placeholder__";
    var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
    var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
    var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
    var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
    var HOT_COUNT = 800, HOT_SPAN = 16;
    var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
    var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
    var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
    var wrapFlags = [
      ["ary", WRAP_ARY_FLAG],
      ["bind", WRAP_BIND_FLAG],
      ["bindKey", WRAP_BIND_KEY_FLAG],
      ["curry", WRAP_CURRY_FLAG],
      ["curryRight", WRAP_CURRY_RIGHT_FLAG],
      ["flip", WRAP_FLIP_FLAG],
      ["partial", WRAP_PARTIAL_FLAG],
      ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
      ["rearg", WRAP_REARG_FLAG]
    ];
    var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
    var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
    var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
    var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
    var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
    var reTrimStart = /^\s+/;
    var reWhitespace = /\s/;
    var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
    var reEscapeChar = /\\(\\)?/g;
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    var reFlags = /\w*$/;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var reNoMatch = /($^)/;
    var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
    var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var contextProps = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ];
    var templateCounter = -1;
    var typedArrayTags = {};
    typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
    typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var deburredLetters = {
      \u00C0: "A",
      \u00C1: "A",
      \u00C2: "A",
      \u00C3: "A",
      \u00C4: "A",
      \u00C5: "A",
      \u00E0: "a",
      \u00E1: "a",
      \u00E2: "a",
      \u00E3: "a",
      \u00E4: "a",
      \u00E5: "a",
      \u00C7: "C",
      \u00E7: "c",
      \u00D0: "D",
      \u00F0: "d",
      \u00C8: "E",
      \u00C9: "E",
      \u00CA: "E",
      \u00CB: "E",
      \u00E8: "e",
      \u00E9: "e",
      \u00EA: "e",
      \u00EB: "e",
      \u00CC: "I",
      \u00CD: "I",
      \u00CE: "I",
      \u00CF: "I",
      \u00EC: "i",
      \u00ED: "i",
      \u00EE: "i",
      \u00EF: "i",
      \u00D1: "N",
      \u00F1: "n",
      \u00D2: "O",
      \u00D3: "O",
      \u00D4: "O",
      \u00D5: "O",
      \u00D6: "O",
      \u00D8: "O",
      \u00F2: "o",
      \u00F3: "o",
      \u00F4: "o",
      \u00F5: "o",
      \u00F6: "o",
      \u00F8: "o",
      \u00D9: "U",
      \u00DA: "U",
      \u00DB: "U",
      \u00DC: "U",
      \u00F9: "u",
      \u00FA: "u",
      \u00FB: "u",
      \u00FC: "u",
      \u00DD: "Y",
      \u00FD: "y",
      \u00FF: "y",
      \u00C6: "Ae",
      \u00E6: "ae",
      \u00DE: "Th",
      \u00FE: "th",
      \u00DF: "ss",
      \u0100: "A",
      \u0102: "A",
      \u0104: "A",
      \u0101: "a",
      \u0103: "a",
      \u0105: "a",
      \u0106: "C",
      \u0108: "C",
      \u010A: "C",
      \u010C: "C",
      \u0107: "c",
      \u0109: "c",
      \u010B: "c",
      \u010D: "c",
      \u010E: "D",
      \u0110: "D",
      \u010F: "d",
      \u0111: "d",
      \u0112: "E",
      \u0114: "E",
      \u0116: "E",
      \u0118: "E",
      \u011A: "E",
      \u0113: "e",
      \u0115: "e",
      \u0117: "e",
      \u0119: "e",
      \u011B: "e",
      \u011C: "G",
      \u011E: "G",
      \u0120: "G",
      \u0122: "G",
      \u011D: "g",
      \u011F: "g",
      \u0121: "g",
      \u0123: "g",
      \u0124: "H",
      \u0126: "H",
      \u0125: "h",
      \u0127: "h",
      \u0128: "I",
      \u012A: "I",
      \u012C: "I",
      \u012E: "I",
      \u0130: "I",
      \u0129: "i",
      \u012B: "i",
      \u012D: "i",
      \u012F: "i",
      \u0131: "i",
      \u0134: "J",
      \u0135: "j",
      \u0136: "K",
      \u0137: "k",
      \u0138: "k",
      \u0139: "L",
      \u013B: "L",
      \u013D: "L",
      \u013F: "L",
      \u0141: "L",
      \u013A: "l",
      \u013C: "l",
      \u013E: "l",
      \u0140: "l",
      \u0142: "l",
      \u0143: "N",
      \u0145: "N",
      \u0147: "N",
      \u014A: "N",
      \u0144: "n",
      \u0146: "n",
      \u0148: "n",
      \u014B: "n",
      \u014C: "O",
      \u014E: "O",
      \u0150: "O",
      \u014D: "o",
      \u014F: "o",
      \u0151: "o",
      \u0154: "R",
      \u0156: "R",
      \u0158: "R",
      \u0155: "r",
      \u0157: "r",
      \u0159: "r",
      \u015A: "S",
      \u015C: "S",
      \u015E: "S",
      \u0160: "S",
      \u015B: "s",
      \u015D: "s",
      \u015F: "s",
      \u0161: "s",
      \u0162: "T",
      \u0164: "T",
      \u0166: "T",
      \u0163: "t",
      \u0165: "t",
      \u0167: "t",
      \u0168: "U",
      \u016A: "U",
      \u016C: "U",
      \u016E: "U",
      \u0170: "U",
      \u0172: "U",
      \u0169: "u",
      \u016B: "u",
      \u016D: "u",
      \u016F: "u",
      \u0171: "u",
      \u0173: "u",
      \u0174: "W",
      \u0175: "w",
      \u0176: "Y",
      \u0177: "y",
      \u0178: "Y",
      \u0179: "Z",
      \u017B: "Z",
      \u017D: "Z",
      \u017A: "z",
      \u017C: "z",
      \u017E: "z",
      \u0132: "IJ",
      \u0133: "ij",
      \u0152: "Oe",
      \u0153: "oe",
      \u0149: "'n",
      \u017F: "s"
    };
    var htmlEscapes = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    var htmlUnescapes = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    };
    var stringEscapes = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    };
    var freeParseFloat = parseFloat, freeParseInt = parseInt;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    var freeProcess = moduleExports && freeGlobal.process;
    var nodeUtil = function() {
      try {
        var types = freeModule && freeModule.require && freeModule.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess && freeProcess.binding && freeProcess.binding("util");
      } catch (e) {
      }
    }();
    var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
    function apply(func, thisArg, args) {
      switch (args.length) {
        case 0:
          return func.call(thisArg);
        case 1:
          return func.call(thisArg, args[0]);
        case 2:
          return func.call(thisArg, args[0], args[1]);
        case 3:
          return func.call(thisArg, args[0], args[1], args[2]);
      }
      return func.apply(thisArg, args);
    }
    function arrayAggregator(array, setter, iteratee, accumulator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        var value = array[index];
        setter(accumulator, value, iteratee(value), array);
      }
      return accumulator;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEachRight(array, iteratee) {
      var length = array == null ? 0 : array.length;
      while (length--) {
        if (iteratee(array[length], length, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayEvery(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (!predicate(array[index], index, array)) {
          return false;
        }
      }
      return true;
    }
    function arrayFilter(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    function arrayIncludes(array, value) {
      var length = array == null ? 0 : array.length;
      return !!length && baseIndexOf(array, value, 0) > -1;
    }
    function arrayIncludesWith(array, value, comparator) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (comparator(value, array[index])) {
          return true;
        }
      }
      return false;
    }
    function arrayMap(array, iteratee) {
      var index = -1, length = array == null ? 0 : array.length, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function arrayReduceRight(array, iteratee, accumulator, initAccum) {
      var length = array == null ? 0 : array.length;
      if (initAccum && length) {
        accumulator = array[--length];
      }
      while (length--) {
        accumulator = iteratee(accumulator, array[length], length, array);
      }
      return accumulator;
    }
    function arraySome(array, predicate) {
      var index = -1, length = array == null ? 0 : array.length;
      while (++index < length) {
        if (predicate(array[index], index, array)) {
          return true;
        }
      }
      return false;
    }
    var asciiSize = baseProperty("length");
    function asciiToArray(string) {
      return string.split("");
    }
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    function baseFindKey(collection, predicate, eachFunc) {
      var result;
      eachFunc(collection, function(value, key, collection2) {
        if (predicate(value, key, collection2)) {
          result = key;
          return false;
        }
      });
      return result;
    }
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    function baseIndexOf(array, value, fromIndex) {
      return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
    }
    function baseIndexOfWith(array, value, fromIndex, comparator) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (comparator(array[index], value)) {
          return index;
        }
      }
      return -1;
    }
    function baseIsNaN(value) {
      return value !== value;
    }
    function baseMean(array, iteratee) {
      var length = array == null ? 0 : array.length;
      return length ? baseSum(array, iteratee) / length : NAN;
    }
    function baseProperty(key) {
      return function(object) {
        return object == null ? undefined2 : object[key];
      };
    }
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? undefined2 : object[key];
      };
    }
    function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
      eachFunc(collection, function(value, index, collection2) {
        accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
      });
      return accumulator;
    }
    function baseSortBy(array, comparer) {
      var length = array.length;
      array.sort(comparer);
      while (length--) {
        array[length] = array[length].value;
      }
      return array;
    }
    function baseSum(array, iteratee) {
      var result, index = -1, length = array.length;
      while (++index < length) {
        var current = iteratee(array[index]);
        if (current !== undefined2) {
          result = result === undefined2 ? current : result + current;
        }
      }
      return result;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function baseToPairs(object, props) {
      return arrayMap(props, function(key) {
        return [key, object[key]];
      });
    }
    function baseTrim(string) {
      return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
    }
    function baseUnary(func) {
      return function(value) {
        return func(value);
      };
    }
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    function cacheHas(cache, key) {
      return cache.has(key);
    }
    function charsStartIndex(strSymbols, chrSymbols) {
      var index = -1, length = strSymbols.length;
      while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function charsEndIndex(strSymbols, chrSymbols) {
      var index = strSymbols.length;
      while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
      }
      return index;
    }
    function countHolders(array, placeholder) {
      var length = array.length, result = 0;
      while (length--) {
        if (array[length] === placeholder) {
          ++result;
        }
      }
      return result;
    }
    var deburrLetter = basePropertyOf(deburredLetters);
    var escapeHtmlChar = basePropertyOf(htmlEscapes);
    function escapeStringChar(chr) {
      return "\\" + stringEscapes[chr];
    }
    function getValue(object, key) {
      return object == null ? undefined2 : object[key];
    }
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    function iteratorToArray(iterator) {
      var data, result = [];
      while (!(data = iterator.next()).done) {
        result.push(data.value);
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function replaceHolders(array, placeholder) {
      var index = -1, length = array.length, resIndex = 0, result = [];
      while (++index < length) {
        var value = array[index];
        if (value === placeholder || value === PLACEHOLDER) {
          array[index] = PLACEHOLDER;
          result[resIndex++] = index;
        }
      }
      return result;
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    function setToPairs(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = [value, value];
      });
      return result;
    }
    function strictIndexOf(array, value, fromIndex) {
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    function strictLastIndexOf(array, value, fromIndex) {
      var index = fromIndex + 1;
      while (index--) {
        if (array[index] === value) {
          return index;
        }
      }
      return index;
    }
    function stringSize(string) {
      return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
    }
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    function trimmedEndIndex(string) {
      var index = string.length;
      while (index-- && reWhitespace.test(string.charAt(index))) {
      }
      return index;
    }
    var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
    function unicodeSize(string) {
      var result = reUnicode.lastIndex = 0;
      while (reUnicode.test(string)) {
        ++result;
      }
      return result;
    }
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    var runInContext = function runInContext2(context4) {
      context4 = context4 == null ? root : _.defaults(root.Object(), context4, _.pick(root, contextProps));
      var Array2 = context4.Array, Date2 = context4.Date, Error2 = context4.Error, Function2 = context4.Function, Math2 = context4.Math, Object2 = context4.Object, RegExp2 = context4.RegExp, String2 = context4.String, TypeError2 = context4.TypeError;
      var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
      var coreJsData = context4["__core-js_shared__"];
      var funcToString = funcProto.toString;
      var hasOwnProperty = objectProto.hasOwnProperty;
      var idCounter = 0;
      var maskSrcKey = function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      }();
      var nativeObjectToString = objectProto.toString;
      var objectCtorString = funcToString.call(Object2);
      var oldDash = root._;
      var reIsNative = RegExp2("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
      var Buffer2 = moduleExports ? context4.Buffer : undefined2, Symbol2 = context4.Symbol, Uint8Array2 = context4.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined2, symIterator = Symbol2 ? Symbol2.iterator : undefined2, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined2;
      var defineProperty = function() {
        try {
          var func = getNative(Object2, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      }();
      var ctxClearTimeout = context4.clearTimeout !== root.clearTimeout && context4.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context4.setTimeout !== root.setTimeout && context4.setTimeout;
      var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context4.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context4.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
      var DataView = getNative(context4, "DataView"), Map2 = getNative(context4, "Map"), Promise2 = getNative(context4, "Promise"), Set2 = getNative(context4, "Set"), WeakMap2 = getNative(context4, "WeakMap"), nativeCreate = getNative(Object2, "create");
      var metaMap = WeakMap2 && new WeakMap2();
      var realNames = {};
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
      var symbolProto = Symbol2 ? Symbol2.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
      function lodash(value) {
        if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
          if (value instanceof LodashWrapper) {
            return value;
          }
          if (hasOwnProperty.call(value, "__wrapped__")) {
            return wrapperClone(value);
          }
        }
        return new LodashWrapper(value);
      }
      var baseCreate = function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result2 = new object();
          object.prototype = undefined2;
          return result2;
        };
      }();
      function baseLodash() {
      }
      function LodashWrapper(value, chainAll) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__chain__ = !!chainAll;
        this.__index__ = 0;
        this.__values__ = undefined2;
      }
      lodash.templateSettings = {
        escape: reEscape,
        evaluate: reEvaluate,
        interpolate: reInterpolate,
        variable: "",
        imports: {
          _: lodash
        }
      };
      lodash.prototype = baseLodash.prototype;
      lodash.prototype.constructor = lodash;
      LodashWrapper.prototype = baseCreate(baseLodash.prototype);
      LodashWrapper.prototype.constructor = LodashWrapper;
      function LazyWrapper(value) {
        this.__wrapped__ = value;
        this.__actions__ = [];
        this.__dir__ = 1;
        this.__filtered__ = false;
        this.__iteratees__ = [];
        this.__takeCount__ = MAX_ARRAY_LENGTH;
        this.__views__ = [];
      }
      function lazyClone() {
        var result2 = new LazyWrapper(this.__wrapped__);
        result2.__actions__ = copyArray(this.__actions__);
        result2.__dir__ = this.__dir__;
        result2.__filtered__ = this.__filtered__;
        result2.__iteratees__ = copyArray(this.__iteratees__);
        result2.__takeCount__ = this.__takeCount__;
        result2.__views__ = copyArray(this.__views__);
        return result2;
      }
      function lazyReverse() {
        if (this.__filtered__) {
          var result2 = new LazyWrapper(this);
          result2.__dir__ = -1;
          result2.__filtered__ = true;
        } else {
          result2 = this.clone();
          result2.__dir__ *= -1;
        }
        return result2;
      }
      function lazyValue() {
        var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
        if (!isArr || !isRight && arrLength == length && takeCount == length) {
          return baseWrapperValue(array, this.__actions__);
        }
        var result2 = [];
        outer:
          while (length-- && resIndex < takeCount) {
            index += dir;
            var iterIndex = -1, value = array[index];
            while (++iterIndex < iterLength) {
              var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
              if (type == LAZY_MAP_FLAG) {
                value = computed;
              } else if (!computed) {
                if (type == LAZY_FILTER_FLAG) {
                  continue outer;
                } else {
                  break outer;
                }
              }
            }
            result2[resIndex++] = value;
          }
        return result2;
      }
      LazyWrapper.prototype = baseCreate(baseLodash.prototype);
      LazyWrapper.prototype.constructor = LazyWrapper;
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result2 = this.has(key) && delete this.__data__[key];
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result2 = data[key];
          return result2 === HASH_UNDEFINED ? undefined2 : result2;
        }
        return hasOwnProperty.call(data, key) ? data[key] : undefined2;
      }
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
      }
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
        return this;
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? undefined2 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          hash: new Hash(),
          map: new (Map2 || ListCache)(),
          string: new Hash()
        };
      }
      function mapCacheDelete(key) {
        var result2 = getMapData(this, key)["delete"](key);
        this.size -= result2 ? 1 : 0;
        return result2;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      function SetCache(values2) {
        var index = -1, length = values2 == null ? 0 : values2.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values2[index]);
        }
      }
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result2 = data["delete"](key);
        this.size = data.size;
        return result2;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function arraySample(array) {
        var length = array.length;
        return length ? array[baseRandom(0, length - 1)] : undefined2;
      }
      function arraySampleSize(array, n) {
        return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
      }
      function arrayShuffle(array) {
        return shuffleSelf(copyArray(array));
      }
      function assignMergeValue(object, key, value) {
        if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      function baseAggregator(collection, setter, iteratee2, accumulator) {
        baseEach(collection, function(value, key, collection2) {
          setter(accumulator, value, iteratee2(value), collection2);
        });
        return accumulator;
      }
      function baseAssign(object, source) {
        return object && copyObject(source, keys(source), object);
      }
      function baseAssignIn(object, source) {
        return object && copyObject(source, keysIn(source), object);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            configurable: true,
            enumerable: true,
            value,
            writable: true
          });
        } else {
          object[key] = value;
        }
      }
      function baseAt(object, paths) {
        var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
        while (++index < length) {
          result2[index] = skip ? undefined2 : get(object, paths[index]);
        }
        return result2;
      }
      function baseClamp(number, lower, upper) {
        if (number === number) {
          if (upper !== undefined2) {
            number = number <= upper ? number : upper;
          }
          if (lower !== undefined2) {
            number = number >= lower ? number : lower;
          }
        }
        return number;
      }
      function baseClone(value, bitmask, customizer, key, object, stack) {
        var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
        if (customizer) {
          result2 = object ? customizer(value, key, object, stack) : customizer(value);
        }
        if (result2 !== undefined2) {
          return result2;
        }
        if (!isObject(value)) {
          return value;
        }
        var isArr = isArray(value);
        if (isArr) {
          result2 = initCloneArray(value);
          if (!isDeep) {
            return copyArray(value, result2);
          }
        } else {
          var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
          if (isBuffer(value)) {
            return cloneBuffer(value, isDeep);
          }
          if (tag == objectTag || tag == argsTag || isFunc && !object) {
            result2 = isFlat || isFunc ? {} : initCloneObject(value);
            if (!isDeep) {
              return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
            }
          } else {
            if (!cloneableTags[tag]) {
              return object ? value : {};
            }
            result2 = initCloneByTag(value, tag, isDeep);
          }
        }
        stack || (stack = new Stack());
        var stacked = stack.get(value);
        if (stacked) {
          return stacked;
        }
        stack.set(value, result2);
        if (isSet(value)) {
          value.forEach(function(subValue) {
            result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
          });
        } else if (isMap(value)) {
          value.forEach(function(subValue, key2) {
            result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
        }
        var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
        var props = isArr ? undefined2 : keysFunc(value);
        arrayEach(props || value, function(subValue, key2) {
          if (props) {
            key2 = subValue;
            subValue = value[key2];
          }
          assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
        });
        return result2;
      }
      function baseConforms(source) {
        var props = keys(source);
        return function(object) {
          return baseConformsTo(object, source, props);
        };
      }
      function baseConformsTo(object, source, props) {
        var length = props.length;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (length--) {
          var key = props[length], predicate = source[key], value = object[key];
          if (value === undefined2 && !(key in object) || !predicate(value)) {
            return false;
          }
        }
        return true;
      }
      function baseDelay(func, wait, args) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return setTimeout2(function() {
          func.apply(undefined2, args);
        }, wait);
      }
      function baseDifference(array, values2, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
        if (!length) {
          return result2;
        }
        if (iteratee2) {
          values2 = arrayMap(values2, baseUnary(iteratee2));
        }
        if (comparator) {
          includes2 = arrayIncludesWith;
          isCommon = false;
        } else if (values2.length >= LARGE_ARRAY_SIZE) {
          includes2 = cacheHas;
          isCommon = false;
          values2 = new SetCache(values2);
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var valuesIndex = valuesLength;
              while (valuesIndex--) {
                if (values2[valuesIndex] === computed) {
                  continue outer;
                }
              }
              result2.push(value);
            } else if (!includes2(values2, computed, comparator)) {
              result2.push(value);
            }
          }
        return result2;
      }
      var baseEach = createBaseEach(baseForOwn);
      var baseEachRight = createBaseEach(baseForOwnRight, true);
      function baseEvery(collection, predicate) {
        var result2 = true;
        baseEach(collection, function(value, index, collection2) {
          result2 = !!predicate(value, index, collection2);
          return result2;
        });
        return result2;
      }
      function baseExtremum(array, iteratee2, comparator) {
        var index = -1, length = array.length;
        while (++index < length) {
          var value = array[index], current = iteratee2(value);
          if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
            var computed = current, result2 = value;
          }
        }
        return result2;
      }
      function baseFill(array, value, start, end) {
        var length = array.length;
        start = toInteger(start);
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end === undefined2 || end > length ? length : toInteger(end);
        if (end < 0) {
          end += length;
        }
        end = start > end ? 0 : toLength(end);
        while (start < end) {
          array[start++] = value;
        }
        return array;
      }
      function baseFilter(collection, predicate) {
        var result2 = [];
        baseEach(collection, function(value, index, collection2) {
          if (predicate(value, index, collection2)) {
            result2.push(value);
          }
        });
        return result2;
      }
      function baseFlatten(array, depth, predicate, isStrict, result2) {
        var index = -1, length = array.length;
        predicate || (predicate = isFlattenable);
        result2 || (result2 = []);
        while (++index < length) {
          var value = array[index];
          if (depth > 0 && predicate(value)) {
            if (depth > 1) {
              baseFlatten(value, depth - 1, predicate, isStrict, result2);
            } else {
              arrayPush(result2, value);
            }
          } else if (!isStrict) {
            result2[result2.length] = value;
          }
        }
        return result2;
      }
      var baseFor = createBaseFor();
      var baseForRight = createBaseFor(true);
      function baseForOwn(object, iteratee2) {
        return object && baseFor(object, iteratee2, keys);
      }
      function baseForOwnRight(object, iteratee2) {
        return object && baseForRight(object, iteratee2, keys);
      }
      function baseFunctions(object, props) {
        return arrayFilter(props, function(key) {
          return isFunction(object[key]);
        });
      }
      function baseGet(object, path3) {
        path3 = castPath(path3, object);
        var index = 0, length = path3.length;
        while (object != null && index < length) {
          object = object[toKey(path3[index++])];
        }
        return index && index == length ? object : undefined2;
      }
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result2 = keysFunc(object);
        return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
      }
      function baseGetTag(value) {
        if (value == null) {
          return value === undefined2 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
      }
      function baseGt(value, other) {
        return value > other;
      }
      function baseHas(object, key) {
        return object != null && hasOwnProperty.call(object, key);
      }
      function baseHasIn(object, key) {
        return object != null && key in Object2(object);
      }
      function baseInRange(number, start, end) {
        return number >= nativeMin(start, end) && number < nativeMax(start, end);
      }
      function baseIntersection(arrays, iteratee2, comparator) {
        var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
        while (othIndex--) {
          var array = arrays[othIndex];
          if (othIndex && iteratee2) {
            array = arrayMap(array, baseUnary(iteratee2));
          }
          maxLength = nativeMin(array.length, maxLength);
          caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
        }
        array = arrays[0];
        var index = -1, seen = caches[0];
        outer:
          while (++index < length && result2.length < maxLength) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
              othIndex = othLength;
              while (--othIndex) {
                var cache = caches[othIndex];
                if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                  continue outer;
                }
              }
              if (seen) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseInverter(object, setter, iteratee2, accumulator) {
        baseForOwn(object, function(value, key, object2) {
          setter(accumulator, iteratee2(value), key, object2);
        });
        return accumulator;
      }
      function baseInvoke(object, path3, args) {
        path3 = castPath(path3, object);
        object = parent(object, path3);
        var func = object == null ? object : object[toKey(last(path3))];
        return func == null ? undefined2 : apply(func, object, args);
      }
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag;
      }
      function baseIsArrayBuffer(value) {
        return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
      }
      function baseIsDate(value) {
        return isObjectLike(value) && baseGetTag(value) == dateTag;
      }
      function baseIsEqual(value, other, bitmask, customizer, stack) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
      }
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack || (stack = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack || (stack = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack || (stack = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
      }
      function baseIsMap(value) {
        return isObjectLike(value) && getTag(value) == mapTag;
      }
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index, noCustomizer = !customizer;
        if (object == null) {
          return !length;
        }
        object = Object2(object);
        while (index--) {
          var data = matchData[index];
          if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (noCustomizer && data[2]) {
            if (objValue === undefined2 && !(key in object)) {
              return false;
            }
          } else {
            var stack = new Stack();
            if (customizer) {
              var result2 = customizer(objValue, srcValue, key, object, source, stack);
            }
            if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
              return false;
            }
          }
        }
        return true;
      }
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function baseIsRegExp(value) {
        return isObjectLike(value) && baseGetTag(value) == regexpTag;
      }
      function baseIsSet(value) {
        return isObjectLike(value) && getTag(value) == setTag;
      }
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result2 = [];
        for (var key in Object2(object)) {
          if (hasOwnProperty.call(object, key) && key != "constructor") {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result2 = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
            result2.push(key);
          }
        }
        return result2;
      }
      function baseLt(value, other) {
        return value < other;
      }
      function baseMap(collection, iteratee2) {
        var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result2[++index] = iteratee2(value, key, collection2);
        });
        return result2;
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseMatchesProperty(path3, srcValue) {
        if (isKey(path3) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path3), srcValue);
        }
        return function(object) {
          var objValue = get(object, path3);
          return objValue === undefined2 && objValue === srcValue ? hasIn(object, path3) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseMerge(object, source, srcIndex, customizer, stack) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack || (stack = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
            if (newValue === undefined2) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
        var isCommon = newValue === undefined2;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue, true);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue, true);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
          stack["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseNth(array, n) {
        var length = array.length;
        if (!length) {
          return;
        }
        n += n < 0 ? length : 0;
        return isIndex(n, length) ? array[n] : undefined2;
      }
      function baseOrderBy(collection, iteratees, orders) {
        if (iteratees.length) {
          iteratees = arrayMap(iteratees, function(iteratee2) {
            if (isArray(iteratee2)) {
              return function(value) {
                return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
              };
            }
            return iteratee2;
          });
        } else {
          iteratees = [identity];
        }
        var index = -1;
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        var result2 = baseMap(collection, function(value, key, collection2) {
          var criteria = arrayMap(iteratees, function(iteratee2) {
            return iteratee2(value);
          });
          return {criteria, index: ++index, value};
        });
        return baseSortBy(result2, function(object, other) {
          return compareMultiple(object, other, orders);
        });
      }
      function basePick(object, paths) {
        return basePickBy(object, paths, function(value, path3) {
          return hasIn(object, path3);
        });
      }
      function basePickBy(object, paths, predicate) {
        var index = -1, length = paths.length, result2 = {};
        while (++index < length) {
          var path3 = paths[index], value = baseGet(object, path3);
          if (predicate(value, path3)) {
            baseSet(result2, castPath(path3, object), value);
          }
        }
        return result2;
      }
      function basePropertyDeep(path3) {
        return function(object) {
          return baseGet(object, path3);
        };
      }
      function basePullAll(array, values2, iteratee2, comparator) {
        var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
        if (array === values2) {
          values2 = copyArray(values2);
        }
        if (iteratee2) {
          seen = arrayMap(array, baseUnary(iteratee2));
        }
        while (++index < length) {
          var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
          while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
            if (seen !== array) {
              splice.call(seen, fromIndex, 1);
            }
            splice.call(array, fromIndex, 1);
          }
        }
        return array;
      }
      function basePullAt(array, indexes) {
        var length = array ? indexes.length : 0, lastIndex = length - 1;
        while (length--) {
          var index = indexes[length];
          if (length == lastIndex || index !== previous) {
            var previous = index;
            if (isIndex(index)) {
              splice.call(array, index, 1);
            } else {
              baseUnset(array, index);
            }
          }
        }
        return array;
      }
      function baseRandom(lower, upper) {
        return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
      }
      function baseRange(start, end, step, fromRight) {
        var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
        while (length--) {
          result2[fromRight ? length : ++index] = start;
          start += step;
        }
        return result2;
      }
      function baseRepeat(string, n) {
        var result2 = "";
        if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
          return result2;
        }
        do {
          if (n % 2) {
            result2 += string;
          }
          n = nativeFloor(n / 2);
          if (n) {
            string += string;
          }
        } while (n);
        return result2;
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      function baseSample(collection) {
        return arraySample(values(collection));
      }
      function baseSampleSize(collection, n) {
        var array = values(collection);
        return shuffleSelf(array, baseClamp(n, 0, array.length));
      }
      function baseSet(object, path3, value, customizer) {
        if (!isObject(object)) {
          return object;
        }
        path3 = castPath(path3, object);
        var index = -1, length = path3.length, lastIndex = length - 1, nested = object;
        while (nested != null && ++index < length) {
          var key = toKey(path3[index]), newValue = value;
          if (key === "__proto__" || key === "constructor" || key === "prototype") {
            return object;
          }
          if (index != lastIndex) {
            var objValue = nested[key];
            newValue = customizer ? customizer(objValue, key, nested) : undefined2;
            if (newValue === undefined2) {
              newValue = isObject(objValue) ? objValue : isIndex(path3[index + 1]) ? [] : {};
            }
          }
          assignValue(nested, key, newValue);
          nested = nested[key];
        }
        return object;
      }
      var baseSetData = !metaMap ? identity : function(func, data) {
        metaMap.set(func, data);
        return func;
      };
      var baseSetToString = !defineProperty ? identity : function(func, string) {
        return defineProperty(func, "toString", {
          configurable: true,
          enumerable: false,
          value: constant(string),
          writable: true
        });
      };
      function baseShuffle(collection) {
        return shuffleSelf(values(collection));
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result2 = Array2(length);
        while (++index < length) {
          result2[index] = array[index + start];
        }
        return result2;
      }
      function baseSome(collection, predicate) {
        var result2;
        baseEach(collection, function(value, index, collection2) {
          result2 = predicate(value, index, collection2);
          return !result2;
        });
        return !!result2;
      }
      function baseSortedIndex(array, value, retHighest) {
        var low = 0, high = array == null ? low : array.length;
        if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
          while (low < high) {
            var mid = low + high >>> 1, computed = array[mid];
            if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return high;
        }
        return baseSortedIndexBy(array, value, identity, retHighest);
      }
      function baseSortedIndexBy(array, value, iteratee2, retHighest) {
        var low = 0, high = array == null ? 0 : array.length;
        if (high === 0) {
          return 0;
        }
        value = iteratee2(value);
        var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
        while (low < high) {
          var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
          if (valIsNaN) {
            var setLow = retHighest || othIsReflexive;
          } else if (valIsUndefined) {
            setLow = othIsReflexive && (retHighest || othIsDefined);
          } else if (valIsNull) {
            setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
          } else if (valIsSymbol) {
            setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
          } else if (othIsNull || othIsSymbol) {
            setLow = false;
          } else {
            setLow = retHighest ? computed <= value : computed < value;
          }
          if (setLow) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return nativeMin(high, MAX_ARRAY_INDEX);
      }
      function baseSortedUniq(array, iteratee2) {
        var index = -1, length = array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
          if (!index || !eq(computed, seen)) {
            var seen = computed;
            result2[resIndex++] = value === 0 ? 0 : value;
          }
        }
        return result2;
      }
      function baseToNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        return +value;
      }
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function baseUniq(array, iteratee2, comparator) {
        var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
        if (comparator) {
          isCommon = false;
          includes2 = arrayIncludesWith;
        } else if (length >= LARGE_ARRAY_SIZE) {
          var set2 = iteratee2 ? null : createSet(array);
          if (set2) {
            return setToArray(set2);
          }
          isCommon = false;
          includes2 = cacheHas;
          seen = new SetCache();
        } else {
          seen = iteratee2 ? [] : result2;
        }
        outer:
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            value = comparator || value !== 0 ? value : 0;
            if (isCommon && computed === computed) {
              var seenIndex = seen.length;
              while (seenIndex--) {
                if (seen[seenIndex] === computed) {
                  continue outer;
                }
              }
              if (iteratee2) {
                seen.push(computed);
              }
              result2.push(value);
            } else if (!includes2(seen, computed, comparator)) {
              if (seen !== result2) {
                seen.push(computed);
              }
              result2.push(value);
            }
          }
        return result2;
      }
      function baseUnset(object, path3) {
        path3 = castPath(path3, object);
        object = parent(object, path3);
        return object == null || delete object[toKey(last(path3))];
      }
      function baseUpdate(object, path3, updater, customizer) {
        return baseSet(object, path3, updater(baseGet(object, path3)), customizer);
      }
      function baseWhile(array, predicate, isDrop, fromRight) {
        var length = array.length, index = fromRight ? length : -1;
        while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
        }
        return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
      }
      function baseWrapperValue(value, actions) {
        var result2 = value;
        if (result2 instanceof LazyWrapper) {
          result2 = result2.value();
        }
        return arrayReduce(actions, function(result3, action) {
          return action.func.apply(action.thisArg, arrayPush([result3], action.args));
        }, result2);
      }
      function baseXor(arrays, iteratee2, comparator) {
        var length = arrays.length;
        if (length < 2) {
          return length ? baseUniq(arrays[0]) : [];
        }
        var index = -1, result2 = Array2(length);
        while (++index < length) {
          var array = arrays[index], othIndex = -1;
          while (++othIndex < length) {
            if (othIndex != index) {
              result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
            }
          }
        }
        return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
      }
      function baseZipObject(props, values2, assignFunc) {
        var index = -1, length = props.length, valsLength = values2.length, result2 = {};
        while (++index < length) {
          var value = index < valsLength ? values2[index] : undefined2;
          assignFunc(result2, props[index], value);
        }
        return result2;
      }
      function castArrayLikeObject(value) {
        return isArrayLikeObject(value) ? value : [];
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      var castRest = baseRest;
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === undefined2 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var clearTimeout2 = ctxClearTimeout || function(id) {
        return root.clearTimeout(id);
      };
      function cloneBuffer(buffer, isDeep) {
        if (isDeep) {
          return buffer.slice();
        }
        var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
        buffer.copy(result2);
        return result2;
      }
      function cloneArrayBuffer(arrayBuffer) {
        var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
        return result2;
      }
      function cloneDataView(dataView, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
        return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
      }
      function cloneRegExp(regexp) {
        var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
        result2.lastIndex = regexp.lastIndex;
        return result2;
      }
      function cloneSymbol(symbol) {
        return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function compareAscending(value, other) {
        if (value !== other) {
          var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
          var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
          if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
            return 1;
          }
          if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
            return -1;
          }
        }
        return 0;
      }
      function compareMultiple(object, other, orders) {
        var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
        while (++index < length) {
          var result2 = compareAscending(objCriteria[index], othCriteria[index]);
          if (result2) {
            if (index >= ordersLength) {
              return result2;
            }
            var order = orders[index];
            return result2 * (order == "desc" ? -1 : 1);
          }
        }
        return object.index - other.index;
      }
      function composeArgs(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
        while (++leftIndex < leftLength) {
          result2[leftIndex] = partials[leftIndex];
        }
        while (++argsIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[holders[argsIndex]] = args[argsIndex];
          }
        }
        while (rangeLength--) {
          result2[leftIndex++] = args[argsIndex++];
        }
        return result2;
      }
      function composeArgsRight(args, partials, holders, isCurried) {
        var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
        while (++argsIndex < rangeLength) {
          result2[argsIndex] = args[argsIndex];
        }
        var offset = argsIndex;
        while (++rightIndex < rightLength) {
          result2[offset + rightIndex] = partials[rightIndex];
        }
        while (++holdersIndex < holdersLength) {
          if (isUncurried || argsIndex < argsLength) {
            result2[offset + holders[holdersIndex]] = args[argsIndex++];
          }
        }
        return result2;
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array2(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
          if (newValue === undefined2) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      function copySymbols(source, object) {
        return copyObject(source, getSymbols(source), object);
      }
      function copySymbolsIn(source, object) {
        return copyObject(source, getSymbolsIn(source), object);
      }
      function createAggregator(setter, initializer) {
        return function(collection, iteratee2) {
          var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
          return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
        };
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? undefined2 : customizer;
            length = 1;
          }
          object = Object2(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee2) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee2);
          }
          var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
          while (fromRight ? index-- : ++index < length) {
            if (iteratee2(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee2, keysFunc) {
          var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[fromRight ? length : ++index];
            if (iteratee2(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      function createBind(func, bitmask, thisArg) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return fn.apply(isBind ? thisArg : this, arguments);
        }
        return wrapper;
      }
      function createCaseFirst(methodName) {
        return function(string) {
          string = toString(string);
          var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
          var chr = strSymbols ? strSymbols[0] : string.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      function createCompounder(callback) {
        return function(string) {
          return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
        };
      }
      function createCtor(Ctor) {
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return new Ctor();
            case 1:
              return new Ctor(args[0]);
            case 2:
              return new Ctor(args[0], args[1]);
            case 3:
              return new Ctor(args[0], args[1], args[2]);
            case 4:
              return new Ctor(args[0], args[1], args[2], args[3]);
            case 5:
              return new Ctor(args[0], args[1], args[2], args[3], args[4]);
            case 6:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
            case 7:
              return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
          }
          var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
          return isObject(result2) ? result2 : thisBinding;
        };
      }
      function createCurry(func, bitmask, arity) {
        var Ctor = createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
          while (index--) {
            args[index] = arguments[index];
          }
          var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
          length -= holders.length;
          if (length < arity) {
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined2, args, holders, undefined2, undefined2, arity - length);
          }
          var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          return apply(fn, this, args);
        }
        return wrapper;
      }
      function createFind(findIndexFunc) {
        return function(collection, predicate, fromIndex) {
          var iterable = Object2(collection);
          if (!isArrayLike(collection)) {
            var iteratee2 = getIteratee(predicate, 3);
            collection = keys(collection);
            predicate = function(key) {
              return iteratee2(iterable[key], key, iterable);
            };
          }
          var index = findIndexFunc(collection, predicate, fromIndex);
          return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
        };
      }
      function createFlow(fromRight) {
        return flatRest(function(funcs) {
          var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
          if (fromRight) {
            funcs.reverse();
          }
          while (index--) {
            var func = funcs[index];
            if (typeof func != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            if (prereq && !wrapper && getFuncName(func) == "wrapper") {
              var wrapper = new LodashWrapper([], true);
            }
          }
          index = wrapper ? index : length;
          while (++index < length) {
            func = funcs[index];
            var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
            if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
              wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
            } else {
              wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
            }
          }
          return function() {
            var args = arguments, value = args[0];
            if (wrapper && args.length == 1 && isArray(value)) {
              return wrapper.plant(value).value();
            }
            var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
            while (++index2 < length) {
              result2 = funcs[index2].call(this, result2);
            }
            return result2;
          };
        });
      }
      function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
        var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
        function wrapper() {
          var length = arguments.length, args = Array2(length), index = length;
          while (index--) {
            args[index] = arguments[index];
          }
          if (isCurried) {
            var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
          }
          if (partials) {
            args = composeArgs(args, partials, holders, isCurried);
          }
          if (partialsRight) {
            args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
          }
          length -= holdersCount;
          if (isCurried && length < arity) {
            var newHolders = replaceHolders(args, placeholder);
            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary2, arity - length);
          }
          var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
          length = args.length;
          if (argPos) {
            args = reorder(args, argPos);
          } else if (isFlip && length > 1) {
            args.reverse();
          }
          if (isAry && ary2 < length) {
            args.length = ary2;
          }
          if (this && this !== root && this instanceof wrapper) {
            fn = Ctor || createCtor(fn);
          }
          return fn.apply(thisBinding, args);
        }
        return wrapper;
      }
      function createInverter(setter, toIteratee) {
        return function(object, iteratee2) {
          return baseInverter(object, setter, toIteratee(iteratee2), {});
        };
      }
      function createMathOperation(operator, defaultValue) {
        return function(value, other) {
          var result2;
          if (value === undefined2 && other === undefined2) {
            return defaultValue;
          }
          if (value !== undefined2) {
            result2 = value;
          }
          if (other !== undefined2) {
            if (result2 === undefined2) {
              return other;
            }
            if (typeof value == "string" || typeof other == "string") {
              value = baseToString(value);
              other = baseToString(other);
            } else {
              value = baseToNumber(value);
              other = baseToNumber(other);
            }
            result2 = operator(value, other);
          }
          return result2;
        };
      }
      function createOver(arrayFunc) {
        return flatRest(function(iteratees) {
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          return baseRest(function(args) {
            var thisArg = this;
            return arrayFunc(iteratees, function(iteratee2) {
              return apply(iteratee2, thisArg, args);
            });
          });
        });
      }
      function createPadding(length, chars) {
        chars = chars === undefined2 ? " " : baseToString(chars);
        var charsLength = chars.length;
        if (charsLength < 2) {
          return charsLength ? baseRepeat(chars, length) : chars;
        }
        var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
        return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
      }
      function createPartial(func, bitmask, thisArg, partials) {
        var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
        function wrapper() {
          var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
          while (++leftIndex < leftLength) {
            args[leftIndex] = partials[leftIndex];
          }
          while (argsLength--) {
            args[leftIndex++] = arguments[++argsIndex];
          }
          return apply(fn, isBind ? thisArg : this, args);
        }
        return wrapper;
      }
      function createRange(fromRight) {
        return function(start, end, step) {
          if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
            end = step = undefined2;
          }
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
          return baseRange(start, end, step, fromRight);
        };
      }
      function createRelationalOperation(operator) {
        return function(value, other) {
          if (!(typeof value == "string" && typeof other == "string")) {
            value = toNumber(value);
            other = toNumber(other);
          }
          return operator(value, other);
        };
      }
      function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
        var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
        bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
        bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
        if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
          bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
        }
        var newData = [
          func,
          bitmask,
          thisArg,
          newPartials,
          newHolders,
          newPartialsRight,
          newHoldersRight,
          argPos,
          ary2,
          arity
        ];
        var result2 = wrapFunc.apply(undefined2, newData);
        if (isLaziable(func)) {
          setData(result2, newData);
        }
        result2.placeholder = placeholder;
        return setWrapToString(result2, func, bitmask);
      }
      function createRound(methodName) {
        var func = Math2[methodName];
        return function(number, precision) {
          number = toNumber(number);
          precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
          if (precision && nativeIsFinite(number)) {
            var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
            pair = (toString(value) + "e").split("e");
            return +(pair[0] + "e" + (+pair[1] - precision));
          }
          return func(number);
        };
      }
      var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
        return new Set2(values2);
      };
      function createToPairs(keysFunc) {
        return function(object) {
          var tag = getTag(object);
          if (tag == mapTag) {
            return mapToArray(object);
          }
          if (tag == setTag) {
            return setToPairs(object);
          }
          return baseToPairs(object, keysFunc(object));
        };
      }
      function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
        var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
        if (!isBindKey && typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var length = partials ? partials.length : 0;
        if (!length) {
          bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
          partials = holders = undefined2;
        }
        ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
        arity = arity === undefined2 ? arity : toInteger(arity);
        length -= holders ? holders.length : 0;
        if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
          var partialsRight = partials, holdersRight = holders;
          partials = holders = undefined2;
        }
        var data = isBindKey ? undefined2 : getData(func);
        var newData = [
          func,
          bitmask,
          thisArg,
          partials,
          holders,
          partialsRight,
          holdersRight,
          argPos,
          ary2,
          arity
        ];
        if (data) {
          mergeData(newData, data);
        }
        func = newData[0];
        bitmask = newData[1];
        thisArg = newData[2];
        partials = newData[3];
        holders = newData[4];
        arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
        if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
          bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
        }
        if (!bitmask || bitmask == WRAP_BIND_FLAG) {
          var result2 = createBind(func, bitmask, thisArg);
        } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
          result2 = createCurry(func, bitmask, arity);
        } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
          result2 = createPartial(func, bitmask, thisArg, partials);
        } else {
          result2 = createHybrid.apply(undefined2, newData);
        }
        var setter = data ? baseSetData : setData;
        return setWrapToString(setter(result2, newData), func, bitmask);
      }
      function customDefaultsAssignIn(objValue, srcValue, key, object) {
        if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
          return srcValue;
        }
        return objValue;
      }
      function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
        if (isObject(objValue) && isObject(srcValue)) {
          stack.set(srcValue, objValue);
          baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
          stack["delete"](srcValue);
        }
        return objValue;
      }
      function customOmitClone(value) {
        return isPlainObject(value) ? undefined2 : value;
      }
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack.get(array);
        var othStacked = stack.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
        stack.set(array, other);
        stack.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
          }
          if (compared !== undefined2) {
            if (compared) {
              continue;
            }
            result2 = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                return seen.push(othIndex);
              }
            })) {
              result2 = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            result2 = false;
            break;
          }
        }
        stack["delete"](array);
        stack["delete"](other);
        return result2;
      }
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG;
            stack.set(object, other);
            var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
            stack["delete"](object);
            return result2;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack.get(object);
        var othStacked = stack.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result2 = true;
        stack.set(object, other);
        stack.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
          }
          if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
            result2 = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result2 && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result2 = false;
          }
        }
        stack["delete"](object);
        stack["delete"](other);
        return result2;
      }
      function flatRest(func) {
        return setToString(overRest(func, undefined2, flatten), func + "");
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      function getAllKeysIn(object) {
        return baseGetAllKeys(object, keysIn, getSymbolsIn);
      }
      var getData = !metaMap ? noop : function(func) {
        return metaMap.get(func);
      };
      function getFuncName(func) {
        var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
        while (length--) {
          var data = array[length], otherFunc = data.func;
          if (otherFunc == null || otherFunc == func) {
            return data.name;
          }
        }
        return result2;
      }
      function getHolder(func) {
        var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
        return object.placeholder;
      }
      function getIteratee() {
        var result2 = lodash.iteratee || iteratee;
        result2 = result2 === iteratee ? baseIteratee : result2;
        return arguments.length ? result2(arguments[0], arguments[1]) : result2;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function getMatchData(object) {
        var result2 = keys(object), length = result2.length;
        while (length--) {
          var key = result2[length], value = object[key];
          result2[length] = [key, value, isStrictComparable(value)];
        }
        return result2;
      }
      function getNative(object, key) {
        var value = getValue(object, key);
        return baseIsNative(value) ? value : undefined2;
      }
      function getRawTag(value) {
        var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
        try {
          value[symToStringTag] = undefined2;
          var unmasked = true;
        } catch (e) {
        }
        var result2 = nativeObjectToString.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag] = tag;
          } else {
            delete value[symToStringTag];
          }
        }
        return result2;
      }
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object2(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
        var result2 = [];
        while (object) {
          arrayPush(result2, getSymbols(object));
          object = getPrototype(object);
        }
        return result2;
      };
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
        getTag = function(value) {
          var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag;
              case mapCtorString:
                return mapTag;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result2;
        };
      }
      function getView(start, end, transforms) {
        var index = -1, length = transforms.length;
        while (++index < length) {
          var data = transforms[index], size2 = data.size;
          switch (data.type) {
            case "drop":
              start += size2;
              break;
            case "dropRight":
              end -= size2;
              break;
            case "take":
              end = nativeMin(end, start + size2);
              break;
            case "takeRight":
              start = nativeMax(start, end - size2);
              break;
          }
        }
        return {start, end};
      }
      function getWrapDetails(source) {
        var match = source.match(reWrapDetails);
        return match ? match[1].split(reSplitDetails) : [];
      }
      function hasPath(object, path3, hasFunc) {
        path3 = castPath(path3, object);
        var index = -1, length = path3.length, result2 = false;
        while (++index < length) {
          var key = toKey(path3[index]);
          if (!(result2 = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result2 || ++index != length) {
          return result2;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function initCloneArray(array) {
        var length = array.length, result2 = new array.constructor(length);
        if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
          result2.index = array.index;
          result2.input = array.input;
        }
        return result2;
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      function initCloneByTag(object, tag, isDeep) {
        var Ctor = object.constructor;
        switch (tag) {
          case arrayBufferTag:
            return cloneArrayBuffer(object);
          case boolTag:
          case dateTag:
            return new Ctor(+object);
          case dataViewTag:
            return cloneDataView(object, isDeep);
          case float32Tag:
          case float64Tag:
          case int8Tag:
          case int16Tag:
          case int32Tag:
          case uint8Tag:
          case uint8ClampedTag:
          case uint16Tag:
          case uint32Tag:
            return cloneTypedArray(object, isDeep);
          case mapTag:
            return new Ctor();
          case numberTag:
          case stringTag:
            return new Ctor(object);
          case regexpTag:
            return cloneRegExp(object);
          case setTag:
            return new Ctor();
          case symbolTag:
            return cloneSymbol(object);
        }
      }
      function insertWrapDetails(source, details) {
        var length = details.length;
        if (!length) {
          return source;
        }
        var lastIndex = length - 1;
        details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
        details = details.join(length > 2 ? ", " : " ");
        return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
      }
      function isFlattenable(value) {
        return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
      }
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function isLaziable(func) {
        var funcName = getFuncName(func), other = lodash[funcName];
        if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
          return false;
        }
        if (func === other) {
          return true;
        }
        var data = getData(other);
        return !!data && func === data[0];
      }
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var isMaskable = coreJsData ? isFunction : stubFalse;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
        return value === proto;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
        };
      }
      function memoizeCapped(func) {
        var result2 = memoize(func, function(key) {
          if (cache.size === MAX_MEMOIZE_SIZE) {
            cache.clear();
          }
          return key;
        });
        var cache = result2.cache;
        return result2;
      }
      function mergeData(data, source) {
        var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
        var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
        if (!(isCommon || isCombo)) {
          return data;
        }
        if (srcBitmask & WRAP_BIND_FLAG) {
          data[2] = source[2];
          newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
        }
        var value = source[3];
        if (value) {
          var partials = data[3];
          data[3] = partials ? composeArgs(partials, value, source[4]) : value;
          data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
        }
        value = source[5];
        if (value) {
          partials = data[5];
          data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
          data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
        }
        value = source[7];
        if (value) {
          data[7] = value;
        }
        if (srcBitmask & WRAP_ARY_FLAG) {
          data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
        }
        if (data[9] == null) {
          data[9] = source[9];
        }
        data[0] = source[0];
        data[1] = newBitmask;
        return data;
      }
      function nativeKeysIn(object) {
        var result2 = [];
        if (object != null) {
          for (var key in Object2(object)) {
            result2.push(key);
          }
        }
        return result2;
      }
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      function overRest(func, start, transform2) {
        start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array2(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform2(array);
          return apply(func, this, otherArgs);
        };
      }
      function parent(object, path3) {
        return path3.length < 2 ? object : baseGet(object, baseSlice(path3, 0, -1));
      }
      function reorder(array, indexes) {
        var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
        while (length--) {
          var index = indexes[length];
          array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
        }
        return array;
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      var setData = shortOut(baseSetData);
      var setTimeout2 = ctxSetTimeout || function(func, wait) {
        return root.setTimeout(func, wait);
      };
      var setToString = shortOut(baseSetToString);
      function setWrapToString(wrapper, reference, bitmask) {
        var source = reference + "";
        return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
      }
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(undefined2, arguments);
        };
      }
      function shuffleSelf(array, size2) {
        var index = -1, length = array.length, lastIndex = length - 1;
        size2 = size2 === undefined2 ? length : size2;
        while (++index < size2) {
          var rand = baseRandom(index, lastIndex), value = array[rand];
          array[rand] = array[index];
          array[index] = value;
        }
        array.length = size2;
        return array;
      }
      var stringToPath = memoizeCapped(function(string) {
        var result2 = [];
        if (string.charCodeAt(0) === 46) {
          result2.push("");
        }
        string.replace(rePropName, function(match, number, quote, subString) {
          result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
        });
        return result2;
      });
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result2 = value + "";
        return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
      }
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      function updateWrapDetails(details, bitmask) {
        arrayEach(wrapFlags, function(pair) {
          var value = "_." + pair[0];
          if (bitmask & pair[1] && !arrayIncludes(details, value)) {
            details.push(value);
          }
        });
        return details.sort();
      }
      function wrapperClone(wrapper) {
        if (wrapper instanceof LazyWrapper) {
          return wrapper.clone();
        }
        var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
        result2.__actions__ = copyArray(wrapper.__actions__);
        result2.__index__ = wrapper.__index__;
        result2.__values__ = wrapper.__values__;
        return result2;
      }
      function chunk(array, size2, guard) {
        if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
          size2 = 1;
        } else {
          size2 = nativeMax(toInteger(size2), 0);
        }
        var length = array == null ? 0 : array.length;
        if (!length || size2 < 1) {
          return [];
        }
        var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
        while (index < length) {
          result2[resIndex++] = baseSlice(array, index, index += size2);
        }
        return result2;
      }
      function compact(array) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
        while (++index < length) {
          var value = array[index];
          if (value) {
            result2[resIndex++] = value;
          }
        }
        return result2;
      }
      function concat() {
        var length = arguments.length;
        if (!length) {
          return [];
        }
        var args = Array2(length - 1), array = arguments[0], index = length;
        while (index--) {
          args[index - 1] = arguments[index];
        }
        return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
      }
      var difference = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
      });
      var differenceBy = baseRest(function(array, values2) {
        var iteratee2 = last(values2);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
      });
      var differenceWith = baseRest(function(array, values2) {
        var comparator = last(values2);
        if (isArrayLikeObject(comparator)) {
          comparator = undefined2;
        }
        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
      });
      function drop(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function dropRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function dropRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
      }
      function dropWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
      }
      function fill(array, value, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
          start = 0;
          end = length;
        }
        return baseFill(array, value, start, end);
      }
      function findIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index);
      }
      function findLastIndex(array, predicate, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length - 1;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return baseFindIndex(array, getIteratee(predicate, 3), index, true);
      }
      function flatten(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, 1) : [];
      }
      function flattenDeep(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseFlatten(array, INFINITY) : [];
      }
      function flattenDepth(array, depth) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(array, depth);
      }
      function fromPairs(pairs) {
        var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
        while (++index < length) {
          var pair = pairs[index];
          result2[pair[0]] = pair[1];
        }
        return result2;
      }
      function head(array) {
        return array && array.length ? array[0] : undefined2;
      }
      function indexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = fromIndex == null ? 0 : toInteger(fromIndex);
        if (index < 0) {
          index = nativeMax(length + index, 0);
        }
        return baseIndexOf(array, value, index);
      }
      function initial(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 0, -1) : [];
      }
      var intersection = baseRest(function(arrays) {
        var mapped = arrayMap(arrays, castArrayLikeObject);
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
      });
      var intersectionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        if (iteratee2 === last(mapped)) {
          iteratee2 = undefined2;
        } else {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
      });
      var intersectionWith = baseRest(function(arrays) {
        var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        if (comparator) {
          mapped.pop();
        }
        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
      });
      function join(array, separator) {
        return array == null ? "" : nativeJoin.call(array, separator);
      }
      function last(array) {
        var length = array == null ? 0 : array.length;
        return length ? array[length - 1] : undefined2;
      }
      function lastIndexOf(array, value, fromIndex) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return -1;
        }
        var index = length;
        if (fromIndex !== undefined2) {
          index = toInteger(fromIndex);
          index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
        }
        return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
      }
      function nth(array, n) {
        return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
      }
      var pull = baseRest(pullAll);
      function pullAll(array, values2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
      }
      function pullAllBy(array, values2, iteratee2) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
      }
      function pullAllWith(array, values2, comparator) {
        return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
      }
      var pullAt = flatRest(function(array, indexes) {
        var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
        basePullAt(array, arrayMap(indexes, function(index) {
          return isIndex(index, length) ? +index : index;
        }).sort(compareAscending));
        return result2;
      });
      function remove(array, predicate) {
        var result2 = [];
        if (!(array && array.length)) {
          return result2;
        }
        var index = -1, indexes = [], length = array.length;
        predicate = getIteratee(predicate, 3);
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result2.push(value);
            indexes.push(index);
          }
        }
        basePullAt(array, indexes);
        return result2;
      }
      function reverse(array) {
        return array == null ? array : nativeReverse.call(array);
      }
      function slice(array, start, end) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
          start = 0;
          end = length;
        } else {
          start = start == null ? 0 : toInteger(start);
          end = end === undefined2 ? length : toInteger(end);
        }
        return baseSlice(array, start, end);
      }
      function sortedIndex(array, value) {
        return baseSortedIndex(array, value);
      }
      function sortedIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
      }
      function sortedIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value);
          if (index < length && eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedLastIndex(array, value) {
        return baseSortedIndex(array, value, true);
      }
      function sortedLastIndexBy(array, value, iteratee2) {
        return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
      }
      function sortedLastIndexOf(array, value) {
        var length = array == null ? 0 : array.length;
        if (length) {
          var index = baseSortedIndex(array, value, true) - 1;
          if (eq(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function sortedUniq(array) {
        return array && array.length ? baseSortedUniq(array) : [];
      }
      function sortedUniqBy(array, iteratee2) {
        return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function tail(array) {
        var length = array == null ? 0 : array.length;
        return length ? baseSlice(array, 1, length) : [];
      }
      function take(array, n, guard) {
        if (!(array && array.length)) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        return baseSlice(array, 0, n < 0 ? 0 : n);
      }
      function takeRight(array, n, guard) {
        var length = array == null ? 0 : array.length;
        if (!length) {
          return [];
        }
        n = guard || n === undefined2 ? 1 : toInteger(n);
        n = length - n;
        return baseSlice(array, n < 0 ? 0 : n, length);
      }
      function takeRightWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
      }
      function takeWhile(array, predicate) {
        return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
      }
      var union = baseRest(function(arrays) {
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
      });
      var unionBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
      });
      var unionWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
      });
      function uniq(array) {
        return array && array.length ? baseUniq(array) : [];
      }
      function uniqBy(array, iteratee2) {
        return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
      }
      function uniqWith(array, comparator) {
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return array && array.length ? baseUniq(array, undefined2, comparator) : [];
      }
      function unzip(array) {
        if (!(array && array.length)) {
          return [];
        }
        var length = 0;
        array = arrayFilter(array, function(group) {
          if (isArrayLikeObject(group)) {
            length = nativeMax(group.length, length);
            return true;
          }
        });
        return baseTimes(length, function(index) {
          return arrayMap(array, baseProperty(index));
        });
      }
      function unzipWith(array, iteratee2) {
        if (!(array && array.length)) {
          return [];
        }
        var result2 = unzip(array);
        if (iteratee2 == null) {
          return result2;
        }
        return arrayMap(result2, function(group) {
          return apply(iteratee2, undefined2, group);
        });
      }
      var without = baseRest(function(array, values2) {
        return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
      });
      var xor = baseRest(function(arrays) {
        return baseXor(arrayFilter(arrays, isArrayLikeObject));
      });
      var xorBy = baseRest(function(arrays) {
        var iteratee2 = last(arrays);
        if (isArrayLikeObject(iteratee2)) {
          iteratee2 = undefined2;
        }
        return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
      });
      var xorWith = baseRest(function(arrays) {
        var comparator = last(arrays);
        comparator = typeof comparator == "function" ? comparator : undefined2;
        return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
      });
      var zip = baseRest(unzip);
      function zipObject(props, values2) {
        return baseZipObject(props || [], values2 || [], assignValue);
      }
      function zipObjectDeep(props, values2) {
        return baseZipObject(props || [], values2 || [], baseSet);
      }
      var zipWith = baseRest(function(arrays) {
        var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
        iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
        return unzipWith(arrays, iteratee2);
      });
      function chain(value) {
        var result2 = lodash(value);
        result2.__chain__ = true;
        return result2;
      }
      function tap(value, interceptor) {
        interceptor(value);
        return value;
      }
      function thru(value, interceptor) {
        return interceptor(value);
      }
      var wrapperAt = flatRest(function(paths) {
        var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
          return baseAt(object, paths);
        };
        if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
          return this.thru(interceptor);
        }
        value = value.slice(start, +start + (length ? 1 : 0));
        value.__actions__.push({
          func: thru,
          args: [interceptor],
          thisArg: undefined2
        });
        return new LodashWrapper(value, this.__chain__).thru(function(array) {
          if (length && !array.length) {
            array.push(undefined2);
          }
          return array;
        });
      });
      function wrapperChain() {
        return chain(this);
      }
      function wrapperCommit() {
        return new LodashWrapper(this.value(), this.__chain__);
      }
      function wrapperNext() {
        if (this.__values__ === undefined2) {
          this.__values__ = toArray(this.value());
        }
        var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
        return {done, value};
      }
      function wrapperToIterator() {
        return this;
      }
      function wrapperPlant(value) {
        var result2, parent2 = this;
        while (parent2 instanceof baseLodash) {
          var clone2 = wrapperClone(parent2);
          clone2.__index__ = 0;
          clone2.__values__ = undefined2;
          if (result2) {
            previous.__wrapped__ = clone2;
          } else {
            result2 = clone2;
          }
          var previous = clone2;
          parent2 = parent2.__wrapped__;
        }
        previous.__wrapped__ = value;
        return result2;
      }
      function wrapperReverse() {
        var value = this.__wrapped__;
        if (value instanceof LazyWrapper) {
          var wrapped = value;
          if (this.__actions__.length) {
            wrapped = new LazyWrapper(this);
          }
          wrapped = wrapped.reverse();
          wrapped.__actions__.push({
            func: thru,
            args: [reverse],
            thisArg: undefined2
          });
          return new LodashWrapper(wrapped, this.__chain__);
        }
        return this.thru(reverse);
      }
      function wrapperValue() {
        return baseWrapperValue(this.__wrapped__, this.__actions__);
      }
      var countBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          ++result2[key];
        } else {
          baseAssignValue(result2, key, 1);
        }
      });
      function every(collection, predicate, guard) {
        var func = isArray(collection) ? arrayEvery : baseEvery;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      function filter(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, getIteratee(predicate, 3));
      }
      var find = createFind(findIndex);
      var findLast = createFind(findLastIndex);
      function flatMap(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), 1);
      }
      function flatMapDeep(collection, iteratee2) {
        return baseFlatten(map(collection, iteratee2), INFINITY);
      }
      function flatMapDepth(collection, iteratee2, depth) {
        depth = depth === undefined2 ? 1 : toInteger(depth);
        return baseFlatten(map(collection, iteratee2), depth);
      }
      function forEach(collection, iteratee2) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function forEachRight(collection, iteratee2) {
        var func = isArray(collection) ? arrayEachRight : baseEachRight;
        return func(collection, getIteratee(iteratee2, 3));
      }
      var groupBy = createAggregator(function(result2, value, key) {
        if (hasOwnProperty.call(result2, key)) {
          result2[key].push(value);
        } else {
          baseAssignValue(result2, key, [value]);
        }
      });
      function includes(collection, value, fromIndex, guard) {
        collection = isArrayLike(collection) ? collection : values(collection);
        fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
        var length = collection.length;
        if (fromIndex < 0) {
          fromIndex = nativeMax(length + fromIndex, 0);
        }
        return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
      }
      var invokeMap = baseRest(function(collection, path3, args) {
        var index = -1, isFunc = typeof path3 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
        baseEach(collection, function(value) {
          result2[++index] = isFunc ? apply(path3, value, args) : baseInvoke(value, path3, args);
        });
        return result2;
      });
      var keyBy = createAggregator(function(result2, value, key) {
        baseAssignValue(result2, key, value);
      });
      function map(collection, iteratee2) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, getIteratee(iteratee2, 3));
      }
      function orderBy(collection, iteratees, orders, guard) {
        if (collection == null) {
          return [];
        }
        if (!isArray(iteratees)) {
          iteratees = iteratees == null ? [] : [iteratees];
        }
        orders = guard ? undefined2 : orders;
        if (!isArray(orders)) {
          orders = orders == null ? [] : [orders];
        }
        return baseOrderBy(collection, iteratees, orders);
      }
      var partition = createAggregator(function(result2, value, key) {
        result2[key ? 0 : 1].push(value);
      }, function() {
        return [[], []];
      });
      function reduce(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
      }
      function reduceRight(collection, iteratee2, accumulator) {
        var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
        return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
      }
      function reject(collection, predicate) {
        var func = isArray(collection) ? arrayFilter : baseFilter;
        return func(collection, negate(getIteratee(predicate, 3)));
      }
      function sample(collection) {
        var func = isArray(collection) ? arraySample : baseSample;
        return func(collection);
      }
      function sampleSize(collection, n, guard) {
        if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        var func = isArray(collection) ? arraySampleSize : baseSampleSize;
        return func(collection, n);
      }
      function shuffle(collection) {
        var func = isArray(collection) ? arrayShuffle : baseShuffle;
        return func(collection);
      }
      function size(collection) {
        if (collection == null) {
          return 0;
        }
        if (isArrayLike(collection)) {
          return isString(collection) ? stringSize(collection) : collection.length;
        }
        var tag = getTag(collection);
        if (tag == mapTag || tag == setTag) {
          return collection.size;
        }
        return baseKeys(collection).length;
      }
      function some(collection, predicate, guard) {
        var func = isArray(collection) ? arraySome : baseSome;
        if (guard && isIterateeCall(collection, predicate, guard)) {
          predicate = undefined2;
        }
        return func(collection, getIteratee(predicate, 3));
      }
      var sortBy = baseRest(function(collection, iteratees) {
        if (collection == null) {
          return [];
        }
        var length = iteratees.length;
        if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
          iteratees = [];
        } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
          iteratees = [iteratees[0]];
        }
        return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
      });
      var now = ctxNow || function() {
        return root.Date.now();
      };
      function after(n, func) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n < 1) {
            return func.apply(this, arguments);
          }
        };
      }
      function ary(func, n, guard) {
        n = guard ? undefined2 : n;
        n = func && n == null ? func.length : n;
        return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
      }
      function before(n, func) {
        var result2;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        n = toInteger(n);
        return function() {
          if (--n > 0) {
            result2 = func.apply(this, arguments);
          }
          if (n <= 1) {
            func = undefined2;
          }
          return result2;
        };
      }
      var bind = baseRest(function(func, thisArg, partials) {
        var bitmask = WRAP_BIND_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bind));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(func, bitmask, thisArg, partials, holders);
      });
      var bindKey = baseRest(function(object, key, partials) {
        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
        if (partials.length) {
          var holders = replaceHolders(partials, getHolder(bindKey));
          bitmask |= WRAP_PARTIAL_FLAG;
        }
        return createWrap(key, bitmask, object, partials, holders);
      });
      function curry(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curry.placeholder;
        return result2;
      }
      function curryRight(func, arity, guard) {
        arity = guard ? undefined2 : arity;
        var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
        result2.placeholder = curryRight.placeholder;
        return result2;
      }
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = undefined2;
          lastInvokeTime = time;
          result2 = func.apply(thisArg, args);
          return result2;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout2(timerExpired, wait);
          return leading ? invokeFunc(time) : result2;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout2(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = undefined2;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = undefined2;
          return result2;
        }
        function cancel() {
          if (timerId !== undefined2) {
            clearTimeout2(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = undefined2;
        }
        function flush() {
          return timerId === undefined2 ? result2 : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === undefined2) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout2(timerId);
              timerId = setTimeout2(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === undefined2) {
            timerId = setTimeout2(timerExpired, wait);
          }
          return result2;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      var defer = baseRest(function(func, args) {
        return baseDelay(func, 1, args);
      });
      var delay = baseRest(function(func, wait, args) {
        return baseDelay(func, toNumber(wait) || 0, args);
      });
      function flip(func) {
        return createWrap(func, WRAP_FLIP_FLAG);
      }
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
          if (cache.has(key)) {
            return cache.get(key);
          }
          var result2 = func.apply(this, args);
          memoized.cache = cache.set(key, result2) || cache;
          return result2;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      function negate(predicate) {
        if (typeof predicate != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        return function() {
          var args = arguments;
          switch (args.length) {
            case 0:
              return !predicate.call(this);
            case 1:
              return !predicate.call(this, args[0]);
            case 2:
              return !predicate.call(this, args[0], args[1]);
            case 3:
              return !predicate.call(this, args[0], args[1], args[2]);
          }
          return !predicate.apply(this, args);
        };
      }
      function once(func) {
        return before(2, func);
      }
      var overArgs = castRest(function(func, transforms) {
        transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
        var funcsLength = transforms.length;
        return baseRest(function(args) {
          var index = -1, length = nativeMin(args.length, funcsLength);
          while (++index < length) {
            args[index] = transforms[index].call(this, args[index]);
          }
          return apply(func, this, args);
        });
      });
      var partial = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partial));
        return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
      });
      var partialRight = baseRest(function(func, partials) {
        var holders = replaceHolders(partials, getHolder(partialRight));
        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
      });
      var rearg = flatRest(function(func, indexes) {
        return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
      });
      function rest(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start === undefined2 ? start : toInteger(start);
        return baseRest(func, start);
      }
      function spread(func, start) {
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        start = start == null ? 0 : nativeMax(toInteger(start), 0);
        return baseRest(function(args) {
          var array = args[start], otherArgs = castSlice(args, 0, start);
          if (array) {
            arrayPush(otherArgs, array);
          }
          return apply(func, this, otherArgs);
        });
      }
      function throttle(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError2(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          leading,
          maxWait: wait,
          trailing
        });
      }
      function unary(func) {
        return ary(func, 1);
      }
      function wrap(value, wrapper) {
        return partial(castFunction(wrapper), value);
      }
      function castArray() {
        if (!arguments.length) {
          return [];
        }
        var value = arguments[0];
        return isArray(value) ? value : [value];
      }
      function clone(value) {
        return baseClone(value, CLONE_SYMBOLS_FLAG);
      }
      function cloneWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
      }
      function cloneDeep(value) {
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
      }
      function cloneDeepWith(value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
      }
      function conformsTo(object, source) {
        return source == null || baseConformsTo(object, source, keys(source));
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var gt = createRelationalOperation(baseGt);
      var gte = createRelationalOperation(function(value, other) {
        return value >= other;
      });
      var isArguments = baseIsArguments(function() {
        return arguments;
      }()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
      };
      var isArray = Array2.isArray;
      var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function isBoolean(value) {
        return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
      }
      var isBuffer = nativeIsBuffer || stubFalse;
      var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
      function isElement(value) {
        return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
      }
      function isEmpty(value) {
        if (value == null) {
          return true;
        }
        if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
          return !value.length;
        }
        var tag = getTag(value);
        if (tag == mapTag || tag == setTag) {
          return !value.size;
        }
        if (isPrototype(value)) {
          return !baseKeys(value).length;
        }
        for (var key in value) {
          if (hasOwnProperty.call(value, key)) {
            return false;
          }
        }
        return true;
      }
      function isEqual(value, other) {
        return baseIsEqual(value, other);
      }
      function isEqualWith(value, other, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        var result2 = customizer ? customizer(value, other) : undefined2;
        return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
      }
      function isError(value) {
        if (!isObjectLike(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
      }
      function isFinite2(value) {
        return typeof value == "number" && nativeIsFinite(value);
      }
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      function isInteger(value) {
        return typeof value == "number" && value == toInteger(value);
      }
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
      function isMatch(object, source) {
        return object === source || baseIsMatch(object, source, getMatchData(source));
      }
      function isMatchWith(object, source, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return baseIsMatch(object, source, getMatchData(source), customizer);
      }
      function isNaN2(value) {
        return isNumber(value) && value != +value;
      }
      function isNative(value) {
        if (isMaskable(value)) {
          throw new Error2(CORE_ERROR_TEXT);
        }
        return baseIsNative(value);
      }
      function isNull(value) {
        return value === null;
      }
      function isNil(value) {
        return value == null;
      }
      function isNumber(value) {
        return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
      }
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
      function isSafeInteger(value) {
        return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
      }
      var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
      function isString(value) {
        return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
      }
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      function isUndefined(value) {
        return value === undefined2;
      }
      function isWeakMap(value) {
        return isObjectLike(value) && getTag(value) == weakMapTag;
      }
      function isWeakSet(value) {
        return isObjectLike(value) && baseGetTag(value) == weakSetTag;
      }
      var lt = createRelationalOperation(baseLt);
      var lte = createRelationalOperation(function(value, other) {
        return value <= other;
      });
      function toArray(value) {
        if (!value) {
          return [];
        }
        if (isArrayLike(value)) {
          return isString(value) ? stringToArray(value) : copyArray(value);
        }
        if (symIterator && value[symIterator]) {
          return iteratorToArray(value[symIterator]());
        }
        var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
        return func(value);
      }
      function toFinite(value) {
        if (!value) {
          return value === 0 ? value : 0;
        }
        value = toNumber(value);
        if (value === INFINITY || value === -INFINITY) {
          var sign = value < 0 ? -1 : 1;
          return sign * MAX_INTEGER;
        }
        return value === value ? value : 0;
      }
      function toInteger(value) {
        var result2 = toFinite(value), remainder = result2 % 1;
        return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
      }
      function toLength(value) {
        return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function toSafeInteger(value) {
        return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
      }
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      var assign = createAssigner(function(object, source) {
        if (isPrototype(source) || isArrayLike(source)) {
          copyObject(source, keys(source), object);
          return;
        }
        for (var key in source) {
          if (hasOwnProperty.call(source, key)) {
            assignValue(object, key, source[key]);
          }
        }
      });
      var assignIn = createAssigner(function(object, source) {
        copyObject(source, keysIn(source), object);
      });
      var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keysIn(source), object, customizer);
      });
      var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
        copyObject(source, keys(source), object, customizer);
      });
      var at = flatRest(baseAt);
      function create(prototype, properties) {
        var result2 = baseCreate(prototype);
        return properties == null ? result2 : baseAssign(result2, properties);
      }
      var defaults = baseRest(function(object, sources) {
        object = Object2(object);
        var index = -1;
        var length = sources.length;
        var guard = length > 2 ? sources[2] : undefined2;
        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          length = 1;
        }
        while (++index < length) {
          var source = sources[index];
          var props = keysIn(source);
          var propsIndex = -1;
          var propsLength = props.length;
          while (++propsIndex < propsLength) {
            var key = props[propsIndex];
            var value = object[key];
            if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              object[key] = source[key];
            }
          }
        }
        return object;
      });
      var defaultsDeep = baseRest(function(args) {
        args.push(undefined2, customDefaultsMerge);
        return apply(mergeWith, undefined2, args);
      });
      function findKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
      }
      function findLastKey(object, predicate) {
        return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
      }
      function forIn(object, iteratee2) {
        return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forInRight(object, iteratee2) {
        return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
      }
      function forOwn(object, iteratee2) {
        return object && baseForOwn(object, getIteratee(iteratee2, 3));
      }
      function forOwnRight(object, iteratee2) {
        return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
      }
      function functions(object) {
        return object == null ? [] : baseFunctions(object, keys(object));
      }
      function functionsIn(object) {
        return object == null ? [] : baseFunctions(object, keysIn(object));
      }
      function get(object, path3, defaultValue) {
        var result2 = object == null ? undefined2 : baseGet(object, path3);
        return result2 === undefined2 ? defaultValue : result2;
      }
      function has(object, path3) {
        return object != null && hasPath(object, path3, baseHas);
      }
      function hasIn(object, path3) {
        return object != null && hasPath(object, path3, baseHasIn);
      }
      var invert = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        result2[value] = key;
      }, constant(identity));
      var invertBy = createInverter(function(result2, value, key) {
        if (value != null && typeof value.toString != "function") {
          value = nativeObjectToString.call(value);
        }
        if (hasOwnProperty.call(result2, value)) {
          result2[value].push(key);
        } else {
          result2[value] = [key];
        }
      }, getIteratee);
      var invoke = baseRest(baseInvoke);
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      function mapKeys(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, iteratee2(value, key, object2), value);
        });
        return result2;
      }
      function mapValues(object, iteratee2) {
        var result2 = {};
        iteratee2 = getIteratee(iteratee2, 3);
        baseForOwn(object, function(value, key, object2) {
          baseAssignValue(result2, key, iteratee2(value, key, object2));
        });
        return result2;
      }
      var merge = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
        baseMerge(object, source, srcIndex, customizer);
      });
      var omit = flatRest(function(object, paths) {
        var result2 = {};
        if (object == null) {
          return result2;
        }
        var isDeep = false;
        paths = arrayMap(paths, function(path3) {
          path3 = castPath(path3, object);
          isDeep || (isDeep = path3.length > 1);
          return path3;
        });
        copyObject(object, getAllKeysIn(object), result2);
        if (isDeep) {
          result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
        }
        var length = paths.length;
        while (length--) {
          baseUnset(result2, paths[length]);
        }
        return result2;
      });
      function omitBy(object, predicate) {
        return pickBy(object, negate(getIteratee(predicate)));
      }
      var pick = flatRest(function(object, paths) {
        return object == null ? {} : basePick(object, paths);
      });
      function pickBy(object, predicate) {
        if (object == null) {
          return {};
        }
        var props = arrayMap(getAllKeysIn(object), function(prop) {
          return [prop];
        });
        predicate = getIteratee(predicate);
        return basePickBy(object, props, function(value, path3) {
          return predicate(value, path3[0]);
        });
      }
      function result(object, path3, defaultValue) {
        path3 = castPath(path3, object);
        var index = -1, length = path3.length;
        if (!length) {
          length = 1;
          object = undefined2;
        }
        while (++index < length) {
          var value = object == null ? undefined2 : object[toKey(path3[index])];
          if (value === undefined2) {
            index = length;
            value = defaultValue;
          }
          object = isFunction(value) ? value.call(object) : value;
        }
        return object;
      }
      function set(object, path3, value) {
        return object == null ? object : baseSet(object, path3, value);
      }
      function setWith(object, path3, value, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseSet(object, path3, value, customizer);
      }
      var toPairs = createToPairs(keys);
      var toPairsIn = createToPairs(keysIn);
      function transform(object, iteratee2, accumulator) {
        var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
        iteratee2 = getIteratee(iteratee2, 4);
        if (accumulator == null) {
          var Ctor = object && object.constructor;
          if (isArrLike) {
            accumulator = isArr ? new Ctor() : [];
          } else if (isObject(object)) {
            accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
          } else {
            accumulator = {};
          }
        }
        (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
          return iteratee2(accumulator, value, index, object2);
        });
        return accumulator;
      }
      function unset(object, path3) {
        return object == null ? true : baseUnset(object, path3);
      }
      function update(object, path3, updater) {
        return object == null ? object : baseUpdate(object, path3, castFunction(updater));
      }
      function updateWith(object, path3, updater, customizer) {
        customizer = typeof customizer == "function" ? customizer : undefined2;
        return object == null ? object : baseUpdate(object, path3, castFunction(updater), customizer);
      }
      function values(object) {
        return object == null ? [] : baseValues(object, keys(object));
      }
      function valuesIn(object) {
        return object == null ? [] : baseValues(object, keysIn(object));
      }
      function clamp(number, lower, upper) {
        if (upper === undefined2) {
          upper = lower;
          lower = undefined2;
        }
        if (upper !== undefined2) {
          upper = toNumber(upper);
          upper = upper === upper ? upper : 0;
        }
        if (lower !== undefined2) {
          lower = toNumber(lower);
          lower = lower === lower ? lower : 0;
        }
        return baseClamp(toNumber(number), lower, upper);
      }
      function inRange(number, start, end) {
        start = toFinite(start);
        if (end === undefined2) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        number = toNumber(number);
        return baseInRange(number, start, end);
      }
      function random(lower, upper, floating) {
        if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
          upper = floating = undefined2;
        }
        if (floating === undefined2) {
          if (typeof upper == "boolean") {
            floating = upper;
            upper = undefined2;
          } else if (typeof lower == "boolean") {
            floating = lower;
            lower = undefined2;
          }
        }
        if (lower === undefined2 && upper === undefined2) {
          lower = 0;
          upper = 1;
        } else {
          lower = toFinite(lower);
          if (upper === undefined2) {
            upper = lower;
            lower = 0;
          } else {
            upper = toFinite(upper);
          }
        }
        if (lower > upper) {
          var temp = lower;
          lower = upper;
          upper = temp;
        }
        if (floating || lower % 1 || upper % 1) {
          var rand = nativeRandom();
          return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
        }
        return baseRandom(lower, upper);
      }
      var camelCase = createCompounder(function(result2, word, index) {
        word = word.toLowerCase();
        return result2 + (index ? capitalize(word) : word);
      });
      function capitalize(string) {
        return upperFirst(toString(string).toLowerCase());
      }
      function deburr(string) {
        string = toString(string);
        return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
      }
      function endsWith(string, target, position) {
        string = toString(string);
        target = baseToString(target);
        var length = string.length;
        position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
        var end = position;
        position -= target.length;
        return position >= 0 && string.slice(position, end) == target;
      }
      function escape2(string) {
        string = toString(string);
        return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
      }
      function escapeRegExp(string) {
        string = toString(string);
        return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
      }
      var kebabCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "-" : "") + word.toLowerCase();
      });
      var lowerCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toLowerCase();
      });
      var lowerFirst = createCaseFirst("toLowerCase");
      function pad(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        if (!length || strLength >= length) {
          return string;
        }
        var mid = (length - strLength) / 2;
        return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
      }
      function padEnd(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
      }
      function padStart(string, length, chars) {
        string = toString(string);
        length = toInteger(length);
        var strLength = length ? stringSize(string) : 0;
        return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
      }
      function parseInt2(string, radix, guard) {
        if (guard || radix == null) {
          radix = 0;
        } else if (radix) {
          radix = +radix;
        }
        return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
      }
      function repeat(string, n, guard) {
        if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
          n = 1;
        } else {
          n = toInteger(n);
        }
        return baseRepeat(toString(string), n);
      }
      function replace() {
        var args = arguments, string = toString(args[0]);
        return args.length < 3 ? string : string.replace(args[1], args[2]);
      }
      var snakeCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? "_" : "") + word.toLowerCase();
      });
      function split(string, separator, limit) {
        if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
          separator = limit = undefined2;
        }
        limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
        if (!limit) {
          return [];
        }
        string = toString(string);
        if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
          separator = baseToString(separator);
          if (!separator && hasUnicode(string)) {
            return castSlice(stringToArray(string), 0, limit);
          }
        }
        return string.split(separator, limit);
      }
      var startCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + upperFirst(word);
      });
      function startsWith(string, target, position) {
        string = toString(string);
        position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
        target = baseToString(target);
        return string.slice(position, position + target.length) == target;
      }
      function template(string, options, guard) {
        var settings = lodash.templateSettings;
        if (guard && isIterateeCall(string, options, guard)) {
          options = undefined2;
        }
        string = toString(string);
        options = assignInWith({}, options, settings, customDefaultsAssignIn);
        var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
        var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
        var reDelimiters = RegExp2((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g");
        var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
        string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
          interpolateValue || (interpolateValue = esTemplateValue);
          source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
          if (escapeValue) {
            isEscaping = true;
            source += "' +\n__e(" + escapeValue + ") +\n'";
          }
          if (evaluateValue) {
            isEvaluating = true;
            source += "';\n" + evaluateValue + ";\n__p += '";
          }
          if (interpolateValue) {
            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
          }
          index = offset + match.length;
          return match;
        });
        source += "';\n";
        var variable = hasOwnProperty.call(options, "variable") && options.variable;
        if (!variable) {
          source = "with (obj) {\n" + source + "\n}\n";
        } else if (reForbiddenIdentifierChars.test(variable)) {
          throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
        }
        source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
        source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
        var result2 = attempt(function() {
          return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
        });
        result2.source = source;
        if (isError(result2)) {
          throw result2;
        }
        return result2;
      }
      function toLower(value) {
        return toString(value).toLowerCase();
      }
      function toUpper(value) {
        return toString(value).toUpperCase();
      }
      function trim(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return baseTrim(string);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
        return castSlice(strSymbols, start, end).join("");
      }
      function trimEnd(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.slice(0, trimmedEndIndex(string) + 1);
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
        return castSlice(strSymbols, 0, end).join("");
      }
      function trimStart(string, chars, guard) {
        string = toString(string);
        if (string && (guard || chars === undefined2)) {
          return string.replace(reTrimStart, "");
        }
        if (!string || !(chars = baseToString(chars))) {
          return string;
        }
        var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
        return castSlice(strSymbols, start).join("");
      }
      function truncate(string, options) {
        var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
        if (isObject(options)) {
          var separator = "separator" in options ? options.separator : separator;
          length = "length" in options ? toInteger(options.length) : length;
          omission = "omission" in options ? baseToString(options.omission) : omission;
        }
        string = toString(string);
        var strLength = string.length;
        if (hasUnicode(string)) {
          var strSymbols = stringToArray(string);
          strLength = strSymbols.length;
        }
        if (length >= strLength) {
          return string;
        }
        var end = length - stringSize(omission);
        if (end < 1) {
          return omission;
        }
        var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
        if (separator === undefined2) {
          return result2 + omission;
        }
        if (strSymbols) {
          end += result2.length - end;
        }
        if (isRegExp(separator)) {
          if (string.slice(end).search(separator)) {
            var match, substring = result2;
            if (!separator.global) {
              separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
            }
            separator.lastIndex = 0;
            while (match = separator.exec(substring)) {
              var newEnd = match.index;
            }
            result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
          }
        } else if (string.indexOf(baseToString(separator), end) != end) {
          var index = result2.lastIndexOf(separator);
          if (index > -1) {
            result2 = result2.slice(0, index);
          }
        }
        return result2 + omission;
      }
      function unescape2(string) {
        string = toString(string);
        return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
      }
      var upperCase = createCompounder(function(result2, word, index) {
        return result2 + (index ? " " : "") + word.toUpperCase();
      });
      var upperFirst = createCaseFirst("toUpperCase");
      function words(string, pattern, guard) {
        string = toString(string);
        pattern = guard ? undefined2 : pattern;
        if (pattern === undefined2) {
          return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
        }
        return string.match(pattern) || [];
      }
      var attempt = baseRest(function(func, args) {
        try {
          return apply(func, undefined2, args);
        } catch (e) {
          return isError(e) ? e : new Error2(e);
        }
      });
      var bindAll = flatRest(function(object, methodNames) {
        arrayEach(methodNames, function(key) {
          key = toKey(key);
          baseAssignValue(object, key, bind(object[key], object));
        });
        return object;
      });
      function cond(pairs) {
        var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
        pairs = !length ? [] : arrayMap(pairs, function(pair) {
          if (typeof pair[1] != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return [toIteratee(pair[0]), pair[1]];
        });
        return baseRest(function(args) {
          var index = -1;
          while (++index < length) {
            var pair = pairs[index];
            if (apply(pair[0], this, args)) {
              return apply(pair[1], this, args);
            }
          }
        });
      }
      function conforms(source) {
        return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      function defaultTo(value, defaultValue) {
        return value == null || value !== value ? defaultValue : value;
      }
      var flow = createFlow();
      var flowRight = createFlow(true);
      function identity(value) {
        return value;
      }
      function iteratee(func) {
        return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
      }
      function matches(source) {
        return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
      }
      function matchesProperty(path3, srcValue) {
        return baseMatchesProperty(path3, baseClone(srcValue, CLONE_DEEP_FLAG));
      }
      var method = baseRest(function(path3, args) {
        return function(object) {
          return baseInvoke(object, path3, args);
        };
      });
      var methodOf = baseRest(function(object, args) {
        return function(path3) {
          return baseInvoke(object, path3, args);
        };
      });
      function mixin(object, source, options) {
        var props = keys(source), methodNames = baseFunctions(source, props);
        if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
          options = source;
          source = object;
          object = this;
          methodNames = baseFunctions(source, keys(source));
        }
        var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
        arrayEach(methodNames, function(methodName) {
          var func = source[methodName];
          object[methodName] = func;
          if (isFunc) {
            object.prototype[methodName] = function() {
              var chainAll = this.__chain__;
              if (chain2 || chainAll) {
                var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                actions.push({func, args: arguments, thisArg: object});
                result2.__chain__ = chainAll;
                return result2;
              }
              return func.apply(object, arrayPush([this.value()], arguments));
            };
          }
        });
        return object;
      }
      function noConflict() {
        if (root._ === this) {
          root._ = oldDash;
        }
        return this;
      }
      function noop() {
      }
      function nthArg(n) {
        n = toInteger(n);
        return baseRest(function(args) {
          return baseNth(args, n);
        });
      }
      var over = createOver(arrayMap);
      var overEvery = createOver(arrayEvery);
      var overSome = createOver(arraySome);
      function property(path3) {
        return isKey(path3) ? baseProperty(toKey(path3)) : basePropertyDeep(path3);
      }
      function propertyOf(object) {
        return function(path3) {
          return object == null ? undefined2 : baseGet(object, path3);
        };
      }
      var range = createRange();
      var rangeRight = createRange(true);
      function stubArray() {
        return [];
      }
      function stubFalse() {
        return false;
      }
      function stubObject() {
        return {};
      }
      function stubString() {
        return "";
      }
      function stubTrue() {
        return true;
      }
      function times(n, iteratee2) {
        n = toInteger(n);
        if (n < 1 || n > MAX_SAFE_INTEGER) {
          return [];
        }
        var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
        iteratee2 = getIteratee(iteratee2);
        n -= MAX_ARRAY_LENGTH;
        var result2 = baseTimes(length, iteratee2);
        while (++index < n) {
          iteratee2(index);
        }
        return result2;
      }
      function toPath(value) {
        if (isArray(value)) {
          return arrayMap(value, toKey);
        }
        return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
      }
      function uniqueId(prefix) {
        var id = ++idCounter;
        return toString(prefix) + id;
      }
      var add = createMathOperation(function(augend, addend) {
        return augend + addend;
      }, 0);
      var ceil = createRound("ceil");
      var divide = createMathOperation(function(dividend, divisor) {
        return dividend / divisor;
      }, 1);
      var floor = createRound("floor");
      function max(array) {
        return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
      }
      function maxBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
      }
      function mean(array) {
        return baseMean(array, identity);
      }
      function meanBy(array, iteratee2) {
        return baseMean(array, getIteratee(iteratee2, 2));
      }
      function min(array) {
        return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
      }
      function minBy(array, iteratee2) {
        return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
      }
      var multiply = createMathOperation(function(multiplier, multiplicand) {
        return multiplier * multiplicand;
      }, 1);
      var round = createRound("round");
      var subtract = createMathOperation(function(minuend, subtrahend) {
        return minuend - subtrahend;
      }, 0);
      function sum(array) {
        return array && array.length ? baseSum(array, identity) : 0;
      }
      function sumBy(array, iteratee2) {
        return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
      }
      lodash.after = after;
      lodash.ary = ary;
      lodash.assign = assign;
      lodash.assignIn = assignIn;
      lodash.assignInWith = assignInWith;
      lodash.assignWith = assignWith;
      lodash.at = at;
      lodash.before = before;
      lodash.bind = bind;
      lodash.bindAll = bindAll;
      lodash.bindKey = bindKey;
      lodash.castArray = castArray;
      lodash.chain = chain;
      lodash.chunk = chunk;
      lodash.compact = compact;
      lodash.concat = concat;
      lodash.cond = cond;
      lodash.conforms = conforms;
      lodash.constant = constant;
      lodash.countBy = countBy;
      lodash.create = create;
      lodash.curry = curry;
      lodash.curryRight = curryRight;
      lodash.debounce = debounce;
      lodash.defaults = defaults;
      lodash.defaultsDeep = defaultsDeep;
      lodash.defer = defer;
      lodash.delay = delay;
      lodash.difference = difference;
      lodash.differenceBy = differenceBy;
      lodash.differenceWith = differenceWith;
      lodash.drop = drop;
      lodash.dropRight = dropRight;
      lodash.dropRightWhile = dropRightWhile;
      lodash.dropWhile = dropWhile;
      lodash.fill = fill;
      lodash.filter = filter;
      lodash.flatMap = flatMap;
      lodash.flatMapDeep = flatMapDeep;
      lodash.flatMapDepth = flatMapDepth;
      lodash.flatten = flatten;
      lodash.flattenDeep = flattenDeep;
      lodash.flattenDepth = flattenDepth;
      lodash.flip = flip;
      lodash.flow = flow;
      lodash.flowRight = flowRight;
      lodash.fromPairs = fromPairs;
      lodash.functions = functions;
      lodash.functionsIn = functionsIn;
      lodash.groupBy = groupBy;
      lodash.initial = initial;
      lodash.intersection = intersection;
      lodash.intersectionBy = intersectionBy;
      lodash.intersectionWith = intersectionWith;
      lodash.invert = invert;
      lodash.invertBy = invertBy;
      lodash.invokeMap = invokeMap;
      lodash.iteratee = iteratee;
      lodash.keyBy = keyBy;
      lodash.keys = keys;
      lodash.keysIn = keysIn;
      lodash.map = map;
      lodash.mapKeys = mapKeys;
      lodash.mapValues = mapValues;
      lodash.matches = matches;
      lodash.matchesProperty = matchesProperty;
      lodash.memoize = memoize;
      lodash.merge = merge;
      lodash.mergeWith = mergeWith;
      lodash.method = method;
      lodash.methodOf = methodOf;
      lodash.mixin = mixin;
      lodash.negate = negate;
      lodash.nthArg = nthArg;
      lodash.omit = omit;
      lodash.omitBy = omitBy;
      lodash.once = once;
      lodash.orderBy = orderBy;
      lodash.over = over;
      lodash.overArgs = overArgs;
      lodash.overEvery = overEvery;
      lodash.overSome = overSome;
      lodash.partial = partial;
      lodash.partialRight = partialRight;
      lodash.partition = partition;
      lodash.pick = pick;
      lodash.pickBy = pickBy;
      lodash.property = property;
      lodash.propertyOf = propertyOf;
      lodash.pull = pull;
      lodash.pullAll = pullAll;
      lodash.pullAllBy = pullAllBy;
      lodash.pullAllWith = pullAllWith;
      lodash.pullAt = pullAt;
      lodash.range = range;
      lodash.rangeRight = rangeRight;
      lodash.rearg = rearg;
      lodash.reject = reject;
      lodash.remove = remove;
      lodash.rest = rest;
      lodash.reverse = reverse;
      lodash.sampleSize = sampleSize;
      lodash.set = set;
      lodash.setWith = setWith;
      lodash.shuffle = shuffle;
      lodash.slice = slice;
      lodash.sortBy = sortBy;
      lodash.sortedUniq = sortedUniq;
      lodash.sortedUniqBy = sortedUniqBy;
      lodash.split = split;
      lodash.spread = spread;
      lodash.tail = tail;
      lodash.take = take;
      lodash.takeRight = takeRight;
      lodash.takeRightWhile = takeRightWhile;
      lodash.takeWhile = takeWhile;
      lodash.tap = tap;
      lodash.throttle = throttle;
      lodash.thru = thru;
      lodash.toArray = toArray;
      lodash.toPairs = toPairs;
      lodash.toPairsIn = toPairsIn;
      lodash.toPath = toPath;
      lodash.toPlainObject = toPlainObject;
      lodash.transform = transform;
      lodash.unary = unary;
      lodash.union = union;
      lodash.unionBy = unionBy;
      lodash.unionWith = unionWith;
      lodash.uniq = uniq;
      lodash.uniqBy = uniqBy;
      lodash.uniqWith = uniqWith;
      lodash.unset = unset;
      lodash.unzip = unzip;
      lodash.unzipWith = unzipWith;
      lodash.update = update;
      lodash.updateWith = updateWith;
      lodash.values = values;
      lodash.valuesIn = valuesIn;
      lodash.without = without;
      lodash.words = words;
      lodash.wrap = wrap;
      lodash.xor = xor;
      lodash.xorBy = xorBy;
      lodash.xorWith = xorWith;
      lodash.zip = zip;
      lodash.zipObject = zipObject;
      lodash.zipObjectDeep = zipObjectDeep;
      lodash.zipWith = zipWith;
      lodash.entries = toPairs;
      lodash.entriesIn = toPairsIn;
      lodash.extend = assignIn;
      lodash.extendWith = assignInWith;
      mixin(lodash, lodash);
      lodash.add = add;
      lodash.attempt = attempt;
      lodash.camelCase = camelCase;
      lodash.capitalize = capitalize;
      lodash.ceil = ceil;
      lodash.clamp = clamp;
      lodash.clone = clone;
      lodash.cloneDeep = cloneDeep;
      lodash.cloneDeepWith = cloneDeepWith;
      lodash.cloneWith = cloneWith;
      lodash.conformsTo = conformsTo;
      lodash.deburr = deburr;
      lodash.defaultTo = defaultTo;
      lodash.divide = divide;
      lodash.endsWith = endsWith;
      lodash.eq = eq;
      lodash.escape = escape2;
      lodash.escapeRegExp = escapeRegExp;
      lodash.every = every;
      lodash.find = find;
      lodash.findIndex = findIndex;
      lodash.findKey = findKey;
      lodash.findLast = findLast;
      lodash.findLastIndex = findLastIndex;
      lodash.findLastKey = findLastKey;
      lodash.floor = floor;
      lodash.forEach = forEach;
      lodash.forEachRight = forEachRight;
      lodash.forIn = forIn;
      lodash.forInRight = forInRight;
      lodash.forOwn = forOwn;
      lodash.forOwnRight = forOwnRight;
      lodash.get = get;
      lodash.gt = gt;
      lodash.gte = gte;
      lodash.has = has;
      lodash.hasIn = hasIn;
      lodash.head = head;
      lodash.identity = identity;
      lodash.includes = includes;
      lodash.indexOf = indexOf;
      lodash.inRange = inRange;
      lodash.invoke = invoke;
      lodash.isArguments = isArguments;
      lodash.isArray = isArray;
      lodash.isArrayBuffer = isArrayBuffer;
      lodash.isArrayLike = isArrayLike;
      lodash.isArrayLikeObject = isArrayLikeObject;
      lodash.isBoolean = isBoolean;
      lodash.isBuffer = isBuffer;
      lodash.isDate = isDate;
      lodash.isElement = isElement;
      lodash.isEmpty = isEmpty;
      lodash.isEqual = isEqual;
      lodash.isEqualWith = isEqualWith;
      lodash.isError = isError;
      lodash.isFinite = isFinite2;
      lodash.isFunction = isFunction;
      lodash.isInteger = isInteger;
      lodash.isLength = isLength;
      lodash.isMap = isMap;
      lodash.isMatch = isMatch;
      lodash.isMatchWith = isMatchWith;
      lodash.isNaN = isNaN2;
      lodash.isNative = isNative;
      lodash.isNil = isNil;
      lodash.isNull = isNull;
      lodash.isNumber = isNumber;
      lodash.isObject = isObject;
      lodash.isObjectLike = isObjectLike;
      lodash.isPlainObject = isPlainObject;
      lodash.isRegExp = isRegExp;
      lodash.isSafeInteger = isSafeInteger;
      lodash.isSet = isSet;
      lodash.isString = isString;
      lodash.isSymbol = isSymbol;
      lodash.isTypedArray = isTypedArray;
      lodash.isUndefined = isUndefined;
      lodash.isWeakMap = isWeakMap;
      lodash.isWeakSet = isWeakSet;
      lodash.join = join;
      lodash.kebabCase = kebabCase;
      lodash.last = last;
      lodash.lastIndexOf = lastIndexOf;
      lodash.lowerCase = lowerCase;
      lodash.lowerFirst = lowerFirst;
      lodash.lt = lt;
      lodash.lte = lte;
      lodash.max = max;
      lodash.maxBy = maxBy;
      lodash.mean = mean;
      lodash.meanBy = meanBy;
      lodash.min = min;
      lodash.minBy = minBy;
      lodash.stubArray = stubArray;
      lodash.stubFalse = stubFalse;
      lodash.stubObject = stubObject;
      lodash.stubString = stubString;
      lodash.stubTrue = stubTrue;
      lodash.multiply = multiply;
      lodash.nth = nth;
      lodash.noConflict = noConflict;
      lodash.noop = noop;
      lodash.now = now;
      lodash.pad = pad;
      lodash.padEnd = padEnd;
      lodash.padStart = padStart;
      lodash.parseInt = parseInt2;
      lodash.random = random;
      lodash.reduce = reduce;
      lodash.reduceRight = reduceRight;
      lodash.repeat = repeat;
      lodash.replace = replace;
      lodash.result = result;
      lodash.round = round;
      lodash.runInContext = runInContext2;
      lodash.sample = sample;
      lodash.size = size;
      lodash.snakeCase = snakeCase;
      lodash.some = some;
      lodash.sortedIndex = sortedIndex;
      lodash.sortedIndexBy = sortedIndexBy;
      lodash.sortedIndexOf = sortedIndexOf;
      lodash.sortedLastIndex = sortedLastIndex;
      lodash.sortedLastIndexBy = sortedLastIndexBy;
      lodash.sortedLastIndexOf = sortedLastIndexOf;
      lodash.startCase = startCase;
      lodash.startsWith = startsWith;
      lodash.subtract = subtract;
      lodash.sum = sum;
      lodash.sumBy = sumBy;
      lodash.template = template;
      lodash.times = times;
      lodash.toFinite = toFinite;
      lodash.toInteger = toInteger;
      lodash.toLength = toLength;
      lodash.toLower = toLower;
      lodash.toNumber = toNumber;
      lodash.toSafeInteger = toSafeInteger;
      lodash.toString = toString;
      lodash.toUpper = toUpper;
      lodash.trim = trim;
      lodash.trimEnd = trimEnd;
      lodash.trimStart = trimStart;
      lodash.truncate = truncate;
      lodash.unescape = unescape2;
      lodash.uniqueId = uniqueId;
      lodash.upperCase = upperCase;
      lodash.upperFirst = upperFirst;
      lodash.each = forEach;
      lodash.eachRight = forEachRight;
      lodash.first = head;
      mixin(lodash, function() {
        var source = {};
        baseForOwn(lodash, function(func, methodName) {
          if (!hasOwnProperty.call(lodash.prototype, methodName)) {
            source[methodName] = func;
          }
        });
        return source;
      }(), {chain: false});
      lodash.VERSION = VERSION;
      arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
        lodash[methodName].placeholder = lodash;
      });
      arrayEach(["drop", "take"], function(methodName, index) {
        LazyWrapper.prototype[methodName] = function(n) {
          n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
          var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
          if (result2.__filtered__) {
            result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
          } else {
            result2.__views__.push({
              size: nativeMin(n, MAX_ARRAY_LENGTH),
              type: methodName + (result2.__dir__ < 0 ? "Right" : "")
            });
          }
          return result2;
        };
        LazyWrapper.prototype[methodName + "Right"] = function(n) {
          return this.reverse()[methodName](n).reverse();
        };
      });
      arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
        var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
        LazyWrapper.prototype[methodName] = function(iteratee2) {
          var result2 = this.clone();
          result2.__iteratees__.push({
            iteratee: getIteratee(iteratee2, 3),
            type
          });
          result2.__filtered__ = result2.__filtered__ || isFilter;
          return result2;
        };
      });
      arrayEach(["head", "last"], function(methodName, index) {
        var takeName = "take" + (index ? "Right" : "");
        LazyWrapper.prototype[methodName] = function() {
          return this[takeName](1).value()[0];
        };
      });
      arrayEach(["initial", "tail"], function(methodName, index) {
        var dropName = "drop" + (index ? "" : "Right");
        LazyWrapper.prototype[methodName] = function() {
          return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
        };
      });
      LazyWrapper.prototype.compact = function() {
        return this.filter(identity);
      };
      LazyWrapper.prototype.find = function(predicate) {
        return this.filter(predicate).head();
      };
      LazyWrapper.prototype.findLast = function(predicate) {
        return this.reverse().find(predicate);
      };
      LazyWrapper.prototype.invokeMap = baseRest(function(path3, args) {
        if (typeof path3 == "function") {
          return new LazyWrapper(this);
        }
        return this.map(function(value) {
          return baseInvoke(value, path3, args);
        });
      });
      LazyWrapper.prototype.reject = function(predicate) {
        return this.filter(negate(getIteratee(predicate)));
      };
      LazyWrapper.prototype.slice = function(start, end) {
        start = toInteger(start);
        var result2 = this;
        if (result2.__filtered__ && (start > 0 || end < 0)) {
          return new LazyWrapper(result2);
        }
        if (start < 0) {
          result2 = result2.takeRight(-start);
        } else if (start) {
          result2 = result2.drop(start);
        }
        if (end !== undefined2) {
          end = toInteger(end);
          result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
        }
        return result2;
      };
      LazyWrapper.prototype.takeRightWhile = function(predicate) {
        return this.reverse().takeWhile(predicate).reverse();
      };
      LazyWrapper.prototype.toArray = function() {
        return this.take(MAX_ARRAY_LENGTH);
      };
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
        if (!lodashFunc) {
          return;
        }
        lodash.prototype[methodName] = function() {
          var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
          var interceptor = function(value2) {
            var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
            return isTaker && chainAll ? result3[0] : result3;
          };
          if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
            isLazy = useLazy = false;
          }
          var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
          if (!retUnwrapped && useLazy) {
            value = onlyLazy ? value : new LazyWrapper(this);
            var result2 = func.apply(value, args);
            result2.__actions__.push({func: thru, args: [interceptor], thisArg: undefined2});
            return new LodashWrapper(result2, chainAll);
          }
          if (isUnwrapped && onlyLazy) {
            return func.apply(this, args);
          }
          result2 = this.thru(interceptor);
          return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
        };
      });
      arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
        var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
        lodash.prototype[methodName] = function() {
          var args = arguments;
          if (retUnwrapped && !this.__chain__) {
            var value = this.value();
            return func.apply(isArray(value) ? value : [], args);
          }
          return this[chainName](function(value2) {
            return func.apply(isArray(value2) ? value2 : [], args);
          });
        };
      });
      baseForOwn(LazyWrapper.prototype, function(func, methodName) {
        var lodashFunc = lodash[methodName];
        if (lodashFunc) {
          var key = lodashFunc.name + "";
          if (!hasOwnProperty.call(realNames, key)) {
            realNames[key] = [];
          }
          realNames[key].push({name: methodName, func: lodashFunc});
        }
      });
      realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
        name: "wrapper",
        func: undefined2
      }];
      LazyWrapper.prototype.clone = lazyClone;
      LazyWrapper.prototype.reverse = lazyReverse;
      LazyWrapper.prototype.value = lazyValue;
      lodash.prototype.at = wrapperAt;
      lodash.prototype.chain = wrapperChain;
      lodash.prototype.commit = wrapperCommit;
      lodash.prototype.next = wrapperNext;
      lodash.prototype.plant = wrapperPlant;
      lodash.prototype.reverse = wrapperReverse;
      lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
      lodash.prototype.first = lodash.prototype.head;
      if (symIterator) {
        lodash.prototype[symIterator] = wrapperToIterator;
      }
      return lodash;
    };
    var _ = runInContext();
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      root._ = _;
      define(function() {
        return _;
      });
    } else if (freeModule) {
      (freeModule.exports = _)._ = _;
      freeExports._ = _;
    } else {
      root._ = _;
    }
  }).call(exports2);
});

// node_modules/eslint/lib/cli-engine/file-enumerator.js
var require_file_enumerator = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path3 = require("path");
  var getGlobParent = require_glob_parent();
  var isGlob = require_is_glob();
  var {escapeRegExp} = require_lodash();
  var {Minimatch} = require_minimatch();
  var {
    Legacy: {
      IgnorePattern,
      CascadingConfigArrayFactory
    }
  } = require_lib2();
  var debug5 = require_src()("eslint:file-enumerator");
  var minimatchOpts = {dot: true, matchBase: true};
  var dotfilesPattern = /(?:(?:^\.)|(?:[/\\]\.))[^/\\.].*/u;
  var NONE = 0;
  var IGNORED_SILENTLY = 1;
  var IGNORED = 2;
  var internalSlotsMap = new WeakMap();
  function isGlobPattern(pattern) {
    return isGlob(path3.sep === "\\" ? pattern.replace(/\\/gu, "/") : pattern);
  }
  function statSafeSync(filePath) {
    try {
      return fs2.statSync(filePath);
    } catch (error5) {
      if (error5.code !== "ENOENT") {
        throw error5;
      }
      return null;
    }
  }
  function readdirSafeSync(directoryPath) {
    try {
      return fs2.readdirSync(directoryPath, {withFileTypes: true});
    } catch (error5) {
      if (error5.code !== "ENOENT") {
        throw error5;
      }
      return [];
    }
  }
  function createExtensionRegExp(extensions) {
    if (extensions) {
      const normalizedExts = extensions.map((ext) => escapeRegExp(ext.startsWith(".") ? ext.slice(1) : ext));
      return new RegExp(`.\\.(?:${normalizedExts.join("|")})$`, "u");
    }
    return null;
  }
  var NoFilesFoundError = class extends Error {
    constructor(pattern, globDisabled) {
      super(`No files matching '${pattern}' were found${globDisabled ? " (glob was disabled)" : ""}.`);
      this.messageTemplate = "file-not-found";
      this.messageData = {pattern, globDisabled};
    }
  };
  var AllFilesIgnoredError = class extends Error {
    constructor(pattern) {
      super(`All files matched by '${pattern}' are ignored.`);
      this.messageTemplate = "all-files-ignored";
      this.messageData = {pattern};
    }
  };
  var FileEnumerator = class {
    constructor({
      cwd = process.cwd(),
      configArrayFactory = new CascadingConfigArrayFactory({
        cwd,
        eslintRecommendedPath: path3.resolve(__dirname, "../../conf/eslint-recommended.js"),
        eslintAllPath: path3.resolve(__dirname, "../../conf/eslint-all.js")
      }),
      extensions = null,
      globInputPaths = true,
      errorOnUnmatchedPattern = true,
      ignore = true
    } = {}) {
      internalSlotsMap.set(this, {
        configArrayFactory,
        cwd,
        defaultIgnores: IgnorePattern.createDefaultIgnore(cwd),
        extensionRegExp: createExtensionRegExp(extensions),
        globInputPaths,
        errorOnUnmatchedPattern,
        ignoreFlag: ignore
      });
    }
    isTargetPath(filePath, providedConfig) {
      const {
        configArrayFactory,
        extensionRegExp
      } = internalSlotsMap.get(this);
      if (extensionRegExp) {
        return extensionRegExp.test(filePath);
      }
      if (filePath.endsWith(".js")) {
        return true;
      }
      const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {ignoreNotFoundError: true});
      return config.isAdditionalTargetPath(filePath);
    }
    *iterateFiles(patternOrPatterns) {
      const {globInputPaths, errorOnUnmatchedPattern} = internalSlotsMap.get(this);
      const patterns = Array.isArray(patternOrPatterns) ? patternOrPatterns : [patternOrPatterns];
      debug5("Start to iterate files: %o", patterns);
      const set = new Set();
      for (const pattern of patterns) {
        let foundRegardlessOfIgnored = false;
        let found = false;
        if (!pattern) {
          continue;
        }
        for (const {config, filePath, flag} of this._iterateFiles(pattern)) {
          foundRegardlessOfIgnored = true;
          if (flag === IGNORED_SILENTLY) {
            continue;
          }
          found = true;
          if (!set.has(filePath)) {
            set.add(filePath);
            yield {
              config,
              filePath,
              ignored: flag === IGNORED
            };
          }
        }
        if (errorOnUnmatchedPattern) {
          if (!foundRegardlessOfIgnored) {
            throw new NoFilesFoundError(pattern, !globInputPaths && isGlob(pattern));
          }
          if (!found) {
            throw new AllFilesIgnoredError(pattern);
          }
        }
      }
      debug5(`Complete iterating files: ${JSON.stringify(patterns)}`);
    }
    _iterateFiles(pattern) {
      const {cwd, globInputPaths} = internalSlotsMap.get(this);
      const absolutePath = path3.resolve(cwd, pattern);
      const isDot = dotfilesPattern.test(pattern);
      const stat = statSafeSync(absolutePath);
      if (stat && stat.isDirectory()) {
        return this._iterateFilesWithDirectory(absolutePath, isDot);
      }
      if (stat && stat.isFile()) {
        return this._iterateFilesWithFile(absolutePath);
      }
      if (globInputPaths && isGlobPattern(pattern)) {
        return this._iterateFilesWithGlob(absolutePath, isDot);
      }
      return [];
    }
    _iterateFilesWithFile(filePath) {
      debug5(`File: ${filePath}`);
      const {configArrayFactory} = internalSlotsMap.get(this);
      const config = configArrayFactory.getConfigArrayForFile(filePath);
      const ignored = this._isIgnoredFile(filePath, {config, direct: true});
      const flag = ignored ? IGNORED : NONE;
      return [{config, filePath, flag}];
    }
    _iterateFilesWithDirectory(directoryPath, dotfiles) {
      debug5(`Directory: ${directoryPath}`);
      return this._iterateFilesRecursive(directoryPath, {dotfiles, recursive: true, selector: null});
    }
    _iterateFilesWithGlob(pattern, dotfiles) {
      debug5(`Glob: ${pattern}`);
      const directoryPath = path3.resolve(getGlobParent(pattern));
      const globPart = pattern.slice(directoryPath.length + 1);
      const recursive = /\*\*|\/|\\/u.test(globPart);
      const selector = new Minimatch(pattern, minimatchOpts);
      debug5(`recursive? ${recursive}`);
      return this._iterateFilesRecursive(directoryPath, {dotfiles, recursive, selector});
    }
    *_iterateFilesRecursive(directoryPath, options) {
      debug5(`Enter the directory: ${directoryPath}`);
      const {configArrayFactory} = internalSlotsMap.get(this);
      let config = null;
      for (const entry of readdirSafeSync(directoryPath)) {
        const filePath = path3.join(directoryPath, entry.name);
        const fileInfo = entry.isSymbolicLink() ? statSafeSync(filePath) : entry;
        if (!fileInfo) {
          continue;
        }
        if (fileInfo.isFile()) {
          if (!config) {
            config = configArrayFactory.getConfigArrayForFile(filePath, {ignoreNotFoundError: true});
          }
          const matched = options.selector ? options.selector.match(filePath) : this.isTargetPath(filePath, config);
          if (matched) {
            const ignored = this._isIgnoredFile(filePath, __objSpread(__objSpread({}, options), {config}));
            const flag = ignored ? IGNORED_SILENTLY : NONE;
            debug5(`Yield: ${entry.name}${ignored ? " but ignored" : ""}`);
            yield {
              config: configArrayFactory.getConfigArrayForFile(filePath),
              filePath,
              flag
            };
          } else {
            debug5(`Didn't match: ${entry.name}`);
          }
        } else if (options.recursive && fileInfo.isDirectory()) {
          if (!config) {
            config = configArrayFactory.getConfigArrayForFile(filePath, {ignoreNotFoundError: true});
          }
          const ignored = this._isIgnoredFile(filePath + path3.sep, __objSpread(__objSpread({}, options), {config}));
          if (!ignored) {
            yield* this._iterateFilesRecursive(filePath, options);
          }
        }
      }
      debug5(`Leave the directory: ${directoryPath}`);
    }
    _isIgnoredFile(filePath, {
      config: providedConfig,
      dotfiles = false,
      direct = false
    }) {
      const {
        configArrayFactory,
        defaultIgnores,
        ignoreFlag
      } = internalSlotsMap.get(this);
      if (ignoreFlag) {
        const config = providedConfig || configArrayFactory.getConfigArrayForFile(filePath, {ignoreNotFoundError: true});
        const ignores = config.extractConfig(filePath).ignores || defaultIgnores;
        return ignores(filePath, dotfiles);
      }
      return !direct && defaultIgnores(filePath, dotfiles);
    }
  };
  module2.exports = {FileEnumerator};
});

// node_modules/estraverse/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "estraverse@4.3.0",
        "/Users/abrown/code/eslint-action"
      ]
    ],
    _from: "estraverse@4.3.0",
    _id: "estraverse@4.3.0",
    _inBundle: false,
    _integrity: "sha512-39nnKffWz8xN1BU/2c79n9nB9HDzo0niYUqx6xyqUnyoAnQyyWpOTdZEeiCch8BBu515t4wp9ZmgVfVhn9EBpw==",
    _location: "/estraverse",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "estraverse@4.3.0",
      name: "estraverse",
      escapedName: "estraverse",
      rawSpec: "4.3.0",
      saveSpec: null,
      fetchSpec: "4.3.0"
    },
    _requiredBy: [
      "/escodegen",
      "/eslint-scope",
      "/eslint/eslint-scope",
      "/esrecurse"
    ],
    _resolved: "https://registry.npmjs.org/estraverse/-/estraverse-4.3.0.tgz",
    _spec: "4.3.0",
    _where: "/Users/abrown/code/eslint-action",
    bugs: {
      url: "https://github.com/estools/estraverse/issues"
    },
    description: "ECMAScript JS AST traversal functions",
    devDependencies: {
      "babel-preset-env": "^1.6.1",
      "babel-register": "^6.3.13",
      chai: "^2.1.1",
      espree: "^1.11.0",
      gulp: "^3.8.10",
      "gulp-bump": "^0.2.2",
      "gulp-filter": "^2.0.0",
      "gulp-git": "^1.0.1",
      "gulp-tag-version": "^1.3.0",
      jshint: "^2.5.6",
      mocha: "^2.1.0"
    },
    engines: {
      node: ">=4.0"
    },
    homepage: "https://github.com/estools/estraverse",
    license: "BSD-2-Clause",
    main: "estraverse.js",
    maintainers: [
      {
        name: "Yusuke Suzuki",
        email: "utatane.tea@gmail.com",
        url: "http://github.com/Constellation"
      }
    ],
    name: "estraverse",
    repository: {
      type: "git",
      url: "git+ssh://git@github.com/estools/estraverse.git"
    },
    scripts: {
      lint: "jshint estraverse.js",
      test: "npm run-script lint && npm run-script unit-test",
      "unit-test": "mocha --compilers js:babel-register"
    },
    version: "4.3.0"
  };
});

// node_modules/estraverse/estraverse.js
var require_estraverse = __commonJS((exports2) => {
  (function clone(exports3) {
    "use strict";
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array, func) {
      var diff, len, i, current;
      len = array.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }
      return i;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace2(node) {
      this.parent[this.key] = node;
    };
    Reference.prototype.remove = function remove() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element(node, path3, wrap, ref) {
      this.node = node;
      this.path = path3;
      this.wrap = wrap;
      this.ref = ref;
    }
    function Controller() {
    }
    Controller.prototype.path = function path3() {
      var i, iz, j, jz, result, element;
      function addToPath(result2, path4) {
        if (Array.isArray(path4)) {
          for (j = 0, jz = path4.length; j < jz; ++j) {
            result2.push(path4[j]);
          }
        } else {
          result2.push(path4);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node = this.current();
      return node.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i, iz, result;
      result = [];
      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = void 0;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === "object" && typeof node.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && key === "properties";
    }
    Controller.prototype.traverse = function traverse2(root, visitor) {
      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element(root, null, null, null));
      leavelist.push(new Element(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node = element.node;
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace2(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element2) {
        var i, key2, nextElem, parent;
        if (element2.ref.remove()) {
          key2 = element2.ref.key;
          parent = element2.ref.parent;
          i = worklist.length;
          while (i--) {
            nextElem = worklist[i];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key2) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {
        root
      };
      element = new Element(root, null, null, new Reference(outer, "root"));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node = element.node;
        if (!node) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (comment2.extendedRange[1] > node.range[0]) {
              break;
            }
            if (comment2.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }
              node.leadingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (node.range[1] < comment2.extendedRange[0]) {
              break;
            }
            if (node.range[1] === comment2.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }
              node.trailingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports3.version = require_package2().version;
    exports3.Syntax = Syntax;
    exports3.traverse = traverse;
    exports3.replace = replace;
    exports3.attachComments = attachComments;
    exports3.VisitorKeys = VisitorKeys;
    exports3.VisitorOption = VisitorOption;
    exports3.Controller = Controller;
    exports3.cloneEnvironment = function() {
      return clone({});
    };
    return exports3;
  })(exports2);
});

// node_modules/eslint/node_modules/eslint-scope/lib/reference.js
var require_reference = __commonJS((exports2, module2) => {
  "use strict";
  var READ = 1;
  var WRITE = 2;
  var RW = READ | WRITE;
  var Reference = class {
    constructor(ident, scope, flag, writeExpr, maybeImplicitGlobal, partial, init) {
      this.identifier = ident;
      this.from = scope;
      this.tainted = false;
      this.resolved = null;
      this.flag = flag;
      if (this.isWrite()) {
        this.writeExpr = writeExpr;
        this.partial = partial;
        this.init = init;
      }
      this.__maybeImplicitGlobal = maybeImplicitGlobal;
    }
    isStatic() {
      return !this.tainted && this.resolved && this.resolved.scope.isStatic();
    }
    isWrite() {
      return !!(this.flag & Reference.WRITE);
    }
    isRead() {
      return !!(this.flag & Reference.READ);
    }
    isReadOnly() {
      return this.flag === Reference.READ;
    }
    isWriteOnly() {
      return this.flag === Reference.WRITE;
    }
    isReadWrite() {
      return this.flag === Reference.RW;
    }
  };
  Reference.READ = READ;
  Reference.WRITE = WRITE;
  Reference.RW = RW;
  module2.exports = Reference;
});

// node_modules/eslint/node_modules/eslint-scope/lib/variable.js
var require_variable = __commonJS((exports2, module2) => {
  "use strict";
  var Variable = class {
    constructor(name, scope) {
      this.name = name;
      this.identifiers = [];
      this.references = [];
      this.defs = [];
      this.tainted = false;
      this.stack = true;
      this.scope = scope;
    }
  };
  Variable.CatchClause = "CatchClause";
  Variable.Parameter = "Parameter";
  Variable.FunctionName = "FunctionName";
  Variable.ClassName = "ClassName";
  Variable.Variable = "Variable";
  Variable.ImportBinding = "ImportBinding";
  Variable.ImplicitGlobalVariable = "ImplicitGlobalVariable";
  module2.exports = Variable;
});

// node_modules/eslint/node_modules/eslint-scope/lib/definition.js
var require_definition = __commonJS((exports2, module2) => {
  "use strict";
  var Variable = require_variable();
  var Definition = class {
    constructor(type, name, node, parent, index, kind) {
      this.type = type;
      this.name = name;
      this.node = node;
      this.parent = parent;
      this.index = index;
      this.kind = kind;
    }
  };
  var ParameterDefinition = class extends Definition {
    constructor(name, node, index, rest) {
      super(Variable.Parameter, name, node, null, index, null);
      this.rest = rest;
    }
  };
  module2.exports = {
    ParameterDefinition,
    Definition
  };
});

// node_modules/eslint/node_modules/eslint-scope/lib/scope.js
var require_scope = __commonJS((exports2, module2) => {
  "use strict";
  var Syntax = require_estraverse().Syntax;
  var Reference = require_reference();
  var Variable = require_variable();
  var Definition = require_definition().Definition;
  var assert = require("assert");
  function isStrictScope(scope, block, isMethodDefinition, useDirective) {
    let body;
    if (scope.upper && scope.upper.isStrict) {
      return true;
    }
    if (isMethodDefinition) {
      return true;
    }
    if (scope.type === "class" || scope.type === "module") {
      return true;
    }
    if (scope.type === "block" || scope.type === "switch") {
      return false;
    }
    if (scope.type === "function") {
      if (block.type === Syntax.ArrowFunctionExpression && block.body.type !== Syntax.BlockStatement) {
        return false;
      }
      if (block.type === Syntax.Program) {
        body = block;
      } else {
        body = block.body;
      }
      if (!body) {
        return false;
      }
    } else if (scope.type === "global") {
      body = block;
    } else {
      return false;
    }
    if (useDirective) {
      for (let i = 0, iz = body.body.length; i < iz; ++i) {
        const stmt = body.body[i];
        if (stmt.type !== Syntax.DirectiveStatement) {
          break;
        }
        if (stmt.raw === '"use strict"' || stmt.raw === "'use strict'") {
          return true;
        }
      }
    } else {
      for (let i = 0, iz = body.body.length; i < iz; ++i) {
        const stmt = body.body[i];
        if (stmt.type !== Syntax.ExpressionStatement) {
          break;
        }
        const expr = stmt.expression;
        if (expr.type !== Syntax.Literal || typeof expr.value !== "string") {
          break;
        }
        if (expr.raw !== null && expr.raw !== void 0) {
          if (expr.raw === '"use strict"' || expr.raw === "'use strict'") {
            return true;
          }
        } else {
          if (expr.value === "use strict") {
            return true;
          }
        }
      }
    }
    return false;
  }
  function registerScope(scopeManager, scope) {
    scopeManager.scopes.push(scope);
    const scopes = scopeManager.__nodeToScope.get(scope.block);
    if (scopes) {
      scopes.push(scope);
    } else {
      scopeManager.__nodeToScope.set(scope.block, [scope]);
    }
  }
  function shouldBeStatically(def) {
    return def.type === Variable.ClassName || def.type === Variable.Variable && def.parent.kind !== "var";
  }
  var Scope = class {
    constructor(scopeManager, type, upperScope, block, isMethodDefinition) {
      this.type = type;
      this.set = new Map();
      this.taints = new Map();
      this.dynamic = this.type === "global" || this.type === "with";
      this.block = block;
      this.through = [];
      this.variables = [];
      this.references = [];
      this.variableScope = this.type === "global" || this.type === "function" || this.type === "module" ? this : upperScope.variableScope;
      this.functionExpressionScope = false;
      this.directCallToEvalScope = false;
      this.thisFound = false;
      this.__left = [];
      this.upper = upperScope;
      this.isStrict = isStrictScope(this, block, isMethodDefinition, scopeManager.__useDirective());
      this.childScopes = [];
      if (this.upper) {
        this.upper.childScopes.push(this);
      }
      this.__declaredVariables = scopeManager.__declaredVariables;
      registerScope(scopeManager, this);
    }
    __shouldStaticallyClose(scopeManager) {
      return !this.dynamic || scopeManager.__isOptimistic();
    }
    __shouldStaticallyCloseForGlobal(ref) {
      const name = ref.identifier.name;
      if (!this.set.has(name)) {
        return false;
      }
      const variable = this.set.get(name);
      const defs = variable.defs;
      return defs.length > 0 && defs.every(shouldBeStatically);
    }
    __staticCloseRef(ref) {
      if (!this.__resolve(ref)) {
        this.__delegateToUpperScope(ref);
      }
    }
    __dynamicCloseRef(ref) {
      let current = this;
      do {
        current.through.push(ref);
        current = current.upper;
      } while (current);
    }
    __globalCloseRef(ref) {
      if (this.__shouldStaticallyCloseForGlobal(ref)) {
        this.__staticCloseRef(ref);
      } else {
        this.__dynamicCloseRef(ref);
      }
    }
    __close(scopeManager) {
      let closeRef;
      if (this.__shouldStaticallyClose(scopeManager)) {
        closeRef = this.__staticCloseRef;
      } else if (this.type !== "global") {
        closeRef = this.__dynamicCloseRef;
      } else {
        closeRef = this.__globalCloseRef;
      }
      for (let i = 0, iz = this.__left.length; i < iz; ++i) {
        const ref = this.__left[i];
        closeRef.call(this, ref);
      }
      this.__left = null;
      return this.upper;
    }
    __isValidResolution(ref, variable) {
      return true;
    }
    __resolve(ref) {
      const name = ref.identifier.name;
      if (!this.set.has(name)) {
        return false;
      }
      const variable = this.set.get(name);
      if (!this.__isValidResolution(ref, variable)) {
        return false;
      }
      variable.references.push(ref);
      variable.stack = variable.stack && ref.from.variableScope === this.variableScope;
      if (ref.tainted) {
        variable.tainted = true;
        this.taints.set(variable.name, true);
      }
      ref.resolved = variable;
      return true;
    }
    __delegateToUpperScope(ref) {
      if (this.upper) {
        this.upper.__left.push(ref);
      }
      this.through.push(ref);
    }
    __addDeclaredVariablesOfNode(variable, node) {
      if (node === null || node === void 0) {
        return;
      }
      let variables = this.__declaredVariables.get(node);
      if (variables === null || variables === void 0) {
        variables = [];
        this.__declaredVariables.set(node, variables);
      }
      if (variables.indexOf(variable) === -1) {
        variables.push(variable);
      }
    }
    __defineGeneric(name, set, variables, node, def) {
      let variable;
      variable = set.get(name);
      if (!variable) {
        variable = new Variable(name, this);
        set.set(name, variable);
        variables.push(variable);
      }
      if (def) {
        variable.defs.push(def);
        this.__addDeclaredVariablesOfNode(variable, def.node);
        this.__addDeclaredVariablesOfNode(variable, def.parent);
      }
      if (node) {
        variable.identifiers.push(node);
      }
    }
    __define(node, def) {
      if (node && node.type === Syntax.Identifier) {
        this.__defineGeneric(node.name, this.set, this.variables, node, def);
      }
    }
    __referencing(node, assign, writeExpr, maybeImplicitGlobal, partial, init) {
      if (!node || node.type !== Syntax.Identifier) {
        return;
      }
      if (node.name === "super") {
        return;
      }
      const ref = new Reference(node, this, assign || Reference.READ, writeExpr, maybeImplicitGlobal, !!partial, !!init);
      this.references.push(ref);
      this.__left.push(ref);
    }
    __detectEval() {
      let current = this;
      this.directCallToEvalScope = true;
      do {
        current.dynamic = true;
        current = current.upper;
      } while (current);
    }
    __detectThis() {
      this.thisFound = true;
    }
    __isClosed() {
      return this.__left === null;
    }
    resolve(ident) {
      let ref, i, iz;
      assert(this.__isClosed(), "Scope should be closed.");
      assert(ident.type === Syntax.Identifier, "Target should be identifier.");
      for (i = 0, iz = this.references.length; i < iz; ++i) {
        ref = this.references[i];
        if (ref.identifier === ident) {
          return ref;
        }
      }
      return null;
    }
    isStatic() {
      return !this.dynamic;
    }
    isArgumentsMaterialized() {
      return true;
    }
    isThisMaterialized() {
      return true;
    }
    isUsedName(name) {
      if (this.set.has(name)) {
        return true;
      }
      for (let i = 0, iz = this.through.length; i < iz; ++i) {
        if (this.through[i].identifier.name === name) {
          return true;
        }
      }
      return false;
    }
  };
  var GlobalScope = class extends Scope {
    constructor(scopeManager, block) {
      super(scopeManager, "global", null, block, false);
      this.implicit = {
        set: new Map(),
        variables: [],
        left: []
      };
    }
    __close(scopeManager) {
      const implicit = [];
      for (let i = 0, iz = this.__left.length; i < iz; ++i) {
        const ref = this.__left[i];
        if (ref.__maybeImplicitGlobal && !this.set.has(ref.identifier.name)) {
          implicit.push(ref.__maybeImplicitGlobal);
        }
      }
      for (let i = 0, iz = implicit.length; i < iz; ++i) {
        const info3 = implicit[i];
        this.__defineImplicit(info3.pattern, new Definition(Variable.ImplicitGlobalVariable, info3.pattern, info3.node, null, null, null));
      }
      this.implicit.left = this.__left;
      return super.__close(scopeManager);
    }
    __defineImplicit(node, def) {
      if (node && node.type === Syntax.Identifier) {
        this.__defineGeneric(node.name, this.implicit.set, this.implicit.variables, node, def);
      }
    }
  };
  var ModuleScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "module", upperScope, block, false);
    }
  };
  var FunctionExpressionNameScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "function-expression-name", upperScope, block, false);
      this.__define(block.id, new Definition(Variable.FunctionName, block.id, block, null, null, null));
      this.functionExpressionScope = true;
    }
  };
  var CatchScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "catch", upperScope, block, false);
    }
  };
  var WithScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "with", upperScope, block, false);
    }
    __close(scopeManager) {
      if (this.__shouldStaticallyClose(scopeManager)) {
        return super.__close(scopeManager);
      }
      for (let i = 0, iz = this.__left.length; i < iz; ++i) {
        const ref = this.__left[i];
        ref.tainted = true;
        this.__delegateToUpperScope(ref);
      }
      this.__left = null;
      return this.upper;
    }
  };
  var BlockScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "block", upperScope, block, false);
    }
  };
  var SwitchScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "switch", upperScope, block, false);
    }
  };
  var FunctionScope = class extends Scope {
    constructor(scopeManager, upperScope, block, isMethodDefinition) {
      super(scopeManager, "function", upperScope, block, isMethodDefinition);
      if (this.block.type !== Syntax.ArrowFunctionExpression) {
        this.__defineArguments();
      }
    }
    isArgumentsMaterialized() {
      if (this.block.type === Syntax.ArrowFunctionExpression) {
        return false;
      }
      if (!this.isStatic()) {
        return true;
      }
      const variable = this.set.get("arguments");
      assert(variable, "Always have arguments variable.");
      return variable.tainted || variable.references.length !== 0;
    }
    isThisMaterialized() {
      if (!this.isStatic()) {
        return true;
      }
      return this.thisFound;
    }
    __defineArguments() {
      this.__defineGeneric("arguments", this.set, this.variables, null, null);
      this.taints.set("arguments", true);
    }
    __isValidResolution(ref, variable) {
      if (this.block.type === "Program") {
        return true;
      }
      const bodyStart = this.block.body.range[0];
      return !(variable.scope === this && ref.identifier.range[0] < bodyStart && variable.defs.every((d) => d.name.range[0] >= bodyStart));
    }
  };
  var ForScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "for", upperScope, block, false);
    }
  };
  var ClassScope = class extends Scope {
    constructor(scopeManager, upperScope, block) {
      super(scopeManager, "class", upperScope, block, false);
    }
  };
  module2.exports = {
    Scope,
    GlobalScope,
    ModuleScope,
    FunctionExpressionNameScope,
    CatchScope,
    WithScope,
    BlockScope,
    SwitchScope,
    FunctionScope,
    ForScope,
    ClassScope
  };
});

// node_modules/eslint/node_modules/eslint-scope/lib/scope-manager.js
var require_scope_manager = __commonJS((exports2, module2) => {
  "use strict";
  var Scope = require_scope();
  var assert = require("assert");
  var GlobalScope = Scope.GlobalScope;
  var CatchScope = Scope.CatchScope;
  var WithScope = Scope.WithScope;
  var ModuleScope = Scope.ModuleScope;
  var ClassScope = Scope.ClassScope;
  var SwitchScope = Scope.SwitchScope;
  var FunctionScope = Scope.FunctionScope;
  var ForScope = Scope.ForScope;
  var FunctionExpressionNameScope = Scope.FunctionExpressionNameScope;
  var BlockScope = Scope.BlockScope;
  var ScopeManager = class {
    constructor(options) {
      this.scopes = [];
      this.globalScope = null;
      this.__nodeToScope = new WeakMap();
      this.__currentScope = null;
      this.__options = options;
      this.__declaredVariables = new WeakMap();
    }
    __useDirective() {
      return this.__options.directive;
    }
    __isOptimistic() {
      return this.__options.optimistic;
    }
    __ignoreEval() {
      return this.__options.ignoreEval;
    }
    __isNodejsScope() {
      return this.__options.nodejsScope;
    }
    isModule() {
      return this.__options.sourceType === "module";
    }
    isImpliedStrict() {
      return this.__options.impliedStrict;
    }
    isStrictModeSupported() {
      return this.__options.ecmaVersion >= 5;
    }
    __get(node) {
      return this.__nodeToScope.get(node);
    }
    getDeclaredVariables(node) {
      return this.__declaredVariables.get(node) || [];
    }
    acquire(node, inner) {
      function predicate(testScope) {
        if (testScope.type === "function" && testScope.functionExpressionScope) {
          return false;
        }
        return true;
      }
      const scopes = this.__get(node);
      if (!scopes || scopes.length === 0) {
        return null;
      }
      if (scopes.length === 1) {
        return scopes[0];
      }
      if (inner) {
        for (let i = scopes.length - 1; i >= 0; --i) {
          const scope = scopes[i];
          if (predicate(scope)) {
            return scope;
          }
        }
      } else {
        for (let i = 0, iz = scopes.length; i < iz; ++i) {
          const scope = scopes[i];
          if (predicate(scope)) {
            return scope;
          }
        }
      }
      return null;
    }
    acquireAll(node) {
      return this.__get(node);
    }
    release(node, inner) {
      const scopes = this.__get(node);
      if (scopes && scopes.length) {
        const scope = scopes[0].upper;
        if (!scope) {
          return null;
        }
        return this.acquire(scope.block, inner);
      }
      return null;
    }
    attach() {
    }
    detach() {
    }
    __nestScope(scope) {
      if (scope instanceof GlobalScope) {
        assert(this.__currentScope === null);
        this.globalScope = scope;
      }
      this.__currentScope = scope;
      return scope;
    }
    __nestGlobalScope(node) {
      return this.__nestScope(new GlobalScope(this, node));
    }
    __nestBlockScope(node) {
      return this.__nestScope(new BlockScope(this, this.__currentScope, node));
    }
    __nestFunctionScope(node, isMethodDefinition) {
      return this.__nestScope(new FunctionScope(this, this.__currentScope, node, isMethodDefinition));
    }
    __nestForScope(node) {
      return this.__nestScope(new ForScope(this, this.__currentScope, node));
    }
    __nestCatchScope(node) {
      return this.__nestScope(new CatchScope(this, this.__currentScope, node));
    }
    __nestWithScope(node) {
      return this.__nestScope(new WithScope(this, this.__currentScope, node));
    }
    __nestClassScope(node) {
      return this.__nestScope(new ClassScope(this, this.__currentScope, node));
    }
    __nestSwitchScope(node) {
      return this.__nestScope(new SwitchScope(this, this.__currentScope, node));
    }
    __nestModuleScope(node) {
      return this.__nestScope(new ModuleScope(this, this.__currentScope, node));
    }
    __nestFunctionExpressionNameScope(node) {
      return this.__nestScope(new FunctionExpressionNameScope(this, this.__currentScope, node));
    }
    __isES6() {
      return this.__options.ecmaVersion >= 6;
    }
  };
  module2.exports = ScopeManager;
});

// node_modules/eslint/node_modules/esrecurse/node_modules/estraverse/estraverse.js
var require_estraverse2 = __commonJS((exports2) => {
  (function clone(exports3) {
    "use strict";
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array, func) {
      var diff, len, i, current;
      len = array.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }
      return i;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      ComprehensionExpression: "ComprehensionExpression",
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      Program: "Program",
      Property: "Property",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      ComprehensionExpression: ["blocks", "filter", "body"],
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      Program: ["body"],
      Property: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace2(node) {
      this.parent[this.key] = node;
    };
    Reference.prototype.remove = function remove() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element(node, path3, wrap, ref) {
      this.node = node;
      this.path = path3;
      this.wrap = wrap;
      this.ref = ref;
    }
    function Controller() {
    }
    Controller.prototype.path = function path3() {
      var i, iz, j, jz, result, element;
      function addToPath(result2, path4) {
        if (Array.isArray(path4)) {
          for (j = 0, jz = path4.length; j < jz; ++j) {
            result2.push(path4[j]);
          }
        } else {
          result2.push(path4);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node = this.current();
      return node.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i, iz, result;
      result = [];
      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = void 0;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function(root, visitor) {
      this.visitor = visitor;
      this.root = root;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === "object" && typeof node.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && key === "properties";
    }
    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i = leavelist.length - 1; i >= 0; --i) {
        if (leavelist[i].node === candidate) {
          return true;
        }
      }
      return false;
    }
    Controller.prototype.traverse = function traverse2(root, visitor) {
      var worklist, leavelist, element, node, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element(root, null, null, null));
      leavelist.push(new Element(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node = element.node;
          nodeType = node.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }
              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace2(root, visitor) {
      var worklist, leavelist, node, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element2) {
        var i, key2, nextElem, parent;
        if (element2.ref.remove()) {
          key2 = element2.ref.key;
          parent = element2.ref.parent;
          i = worklist.length;
          while (i--) {
            nextElem = worklist[i];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key2) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {
        root
      };
      element = new Element(root, null, null, new Reference(outer, "root"));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node = element.node;
        if (!node) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root, visitor) {
      var controller = new Controller();
      return controller.traverse(root, visitor);
    }
    function replace(root, visitor) {
      var controller = new Controller();
      return controller.replace(root, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (comment2.extendedRange[1] > node.range[0]) {
              break;
            }
            if (comment2.extendedRange[1] === node.range[0]) {
              if (!node.leadingComments) {
                node.leadingComments = [];
              }
              node.leadingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function(node) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (node.range[1] < comment2.extendedRange[0]) {
              break;
            }
            if (node.range[1] === comment2.extendedRange[0]) {
              if (!node.trailingComments) {
                node.trailingComments = [];
              }
              node.trailingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports3.Syntax = Syntax;
    exports3.traverse = traverse;
    exports3.replace = replace;
    exports3.attachComments = attachComments;
    exports3.VisitorKeys = VisitorKeys;
    exports3.VisitorOption = VisitorOption;
    exports3.Controller = Controller;
    exports3.cloneEnvironment = function() {
      return clone({});
    };
    return exports3;
  })(exports2);
});

// node_modules/eslint/node_modules/esrecurse/package.json
var require_package3 = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "esrecurse@4.3.0",
        "/Users/abrown/code/eslint-action"
      ]
    ],
    _from: "esrecurse@4.3.0",
    _id: "esrecurse@4.3.0",
    _inBundle: false,
    _integrity: "sha512-KmfKL3b6G+RXvP8N1vr3Tq1kL/oCFgn2NYXEtqP8/L3pKapUA4G8cFVaoF3SU323CD4XypR/ffioHmkti6/Tag==",
    _location: "/eslint/esrecurse",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "esrecurse@4.3.0",
      name: "esrecurse",
      escapedName: "esrecurse",
      rawSpec: "4.3.0",
      saveSpec: null,
      fetchSpec: "4.3.0"
    },
    _requiredBy: [
      "/eslint/eslint-scope"
    ],
    _resolved: "https://registry.npmjs.org/esrecurse/-/esrecurse-4.3.0.tgz",
    _spec: "4.3.0",
    _where: "/Users/abrown/code/eslint-action",
    babel: {
      presets: [
        "es2015"
      ]
    },
    bugs: {
      url: "https://github.com/estools/esrecurse/issues"
    },
    dependencies: {
      estraverse: "^5.2.0"
    },
    description: "ECMAScript AST recursive visitor",
    devDependencies: {
      "babel-cli": "^6.24.1",
      "babel-eslint": "^7.2.3",
      "babel-preset-es2015": "^6.24.1",
      "babel-register": "^6.24.1",
      chai: "^4.0.2",
      esprima: "^4.0.0",
      gulp: "^3.9.0",
      "gulp-bump": "^2.7.0",
      "gulp-eslint": "^4.0.0",
      "gulp-filter": "^5.0.0",
      "gulp-git": "^2.4.1",
      "gulp-mocha": "^4.3.1",
      "gulp-tag-version": "^1.2.1",
      jsdoc: "^3.3.0-alpha10",
      minimist: "^1.1.0"
    },
    engines: {
      node: ">=4.0"
    },
    homepage: "https://github.com/estools/esrecurse",
    license: "BSD-2-Clause",
    main: "esrecurse.js",
    maintainers: [
      {
        name: "Yusuke Suzuki",
        email: "utatane.tea@gmail.com",
        url: "https://github.com/Constellation"
      }
    ],
    name: "esrecurse",
    repository: {
      type: "git",
      url: "git+https://github.com/estools/esrecurse.git"
    },
    scripts: {
      lint: "gulp lint",
      test: "gulp travis",
      "unit-test": "gulp test"
    },
    version: "4.3.0"
  };
});

// node_modules/eslint/node_modules/esrecurse/esrecurse.js
var require_esrecurse = __commonJS((exports2) => {
  (function() {
    "use strict";
    var estraverse = require_estraverse2();
    function isNode(node) {
      if (node == null) {
        return false;
      }
      return typeof node === "object" && typeof node.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === estraverse.Syntax.ObjectExpression || nodeType === estraverse.Syntax.ObjectPattern) && key === "properties";
    }
    function Visitor(visitor, options) {
      options = options || {};
      this.__visitor = visitor || this;
      this.__childVisitorKeys = options.childVisitorKeys ? Object.assign({}, estraverse.VisitorKeys, options.childVisitorKeys) : estraverse.VisitorKeys;
      if (options.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof options.fallback === "function") {
        this.__fallback = options.fallback;
      }
    }
    Visitor.prototype.visitChildren = function(node) {
      var type, children, i, iz, j, jz, child;
      if (node == null) {
        return;
      }
      type = node.type || estraverse.Syntax.Property;
      children = this.__childVisitorKeys[type];
      if (!children) {
        if (this.__fallback) {
          children = this.__fallback(node);
        } else {
          throw new Error("Unknown node type " + type + ".");
        }
      }
      for (i = 0, iz = children.length; i < iz; ++i) {
        child = node[children[i]];
        if (child) {
          if (Array.isArray(child)) {
            for (j = 0, jz = child.length; j < jz; ++j) {
              if (child[j]) {
                if (isNode(child[j]) || isProperty(type, children[i])) {
                  this.visit(child[j]);
                }
              }
            }
          } else if (isNode(child)) {
            this.visit(child);
          }
        }
      }
    };
    Visitor.prototype.visit = function(node) {
      var type;
      if (node == null) {
        return;
      }
      type = node.type || estraverse.Syntax.Property;
      if (this.__visitor[type]) {
        this.__visitor[type].call(this, node);
        return;
      }
      this.visitChildren(node);
    };
    exports2.version = require_package3().version;
    exports2.Visitor = Visitor;
    exports2.visit = function(node, visitor, options) {
      var v = new Visitor(visitor, options);
      v.visit(node);
    };
  })();
});

// node_modules/eslint/node_modules/eslint-scope/lib/pattern-visitor.js
var require_pattern_visitor = __commonJS((exports2, module2) => {
  "use strict";
  var Syntax = require_estraverse().Syntax;
  var esrecurse = require_esrecurse();
  function getLast(xs) {
    return xs[xs.length - 1] || null;
  }
  var PatternVisitor = class extends esrecurse.Visitor {
    static isPattern(node) {
      const nodeType = node.type;
      return nodeType === Syntax.Identifier || nodeType === Syntax.ObjectPattern || nodeType === Syntax.ArrayPattern || nodeType === Syntax.SpreadElement || nodeType === Syntax.RestElement || nodeType === Syntax.AssignmentPattern;
    }
    constructor(options, rootPattern, callback) {
      super(null, options);
      this.rootPattern = rootPattern;
      this.callback = callback;
      this.assignments = [];
      this.rightHandNodes = [];
      this.restElements = [];
    }
    Identifier(pattern) {
      const lastRestElement = getLast(this.restElements);
      this.callback(pattern, {
        topLevel: pattern === this.rootPattern,
        rest: lastRestElement !== null && lastRestElement !== void 0 && lastRestElement.argument === pattern,
        assignments: this.assignments
      });
    }
    Property(property) {
      if (property.computed) {
        this.rightHandNodes.push(property.key);
      }
      this.visit(property.value);
    }
    ArrayPattern(pattern) {
      for (let i = 0, iz = pattern.elements.length; i < iz; ++i) {
        const element = pattern.elements[i];
        this.visit(element);
      }
    }
    AssignmentPattern(pattern) {
      this.assignments.push(pattern);
      this.visit(pattern.left);
      this.rightHandNodes.push(pattern.right);
      this.assignments.pop();
    }
    RestElement(pattern) {
      this.restElements.push(pattern);
      this.visit(pattern.argument);
      this.restElements.pop();
    }
    MemberExpression(node) {
      if (node.computed) {
        this.rightHandNodes.push(node.property);
      }
      this.rightHandNodes.push(node.object);
    }
    SpreadElement(node) {
      this.visit(node.argument);
    }
    ArrayExpression(node) {
      node.elements.forEach(this.visit, this);
    }
    AssignmentExpression(node) {
      this.assignments.push(node);
      this.visit(node.left);
      this.rightHandNodes.push(node.right);
      this.assignments.pop();
    }
    CallExpression(node) {
      node.arguments.forEach((a) => {
        this.rightHandNodes.push(a);
      });
      this.visit(node.callee);
    }
  };
  module2.exports = PatternVisitor;
});

// node_modules/eslint/node_modules/eslint-scope/lib/referencer.js
var require_referencer = __commonJS((exports2, module2) => {
  "use strict";
  var Syntax = require_estraverse().Syntax;
  var esrecurse = require_esrecurse();
  var Reference = require_reference();
  var Variable = require_variable();
  var PatternVisitor = require_pattern_visitor();
  var definition = require_definition();
  var assert = require("assert");
  var ParameterDefinition = definition.ParameterDefinition;
  var Definition = definition.Definition;
  function traverseIdentifierInPattern(options, rootPattern, referencer, callback) {
    const visitor = new PatternVisitor(options, rootPattern, callback);
    visitor.visit(rootPattern);
    if (referencer !== null && referencer !== void 0) {
      visitor.rightHandNodes.forEach(referencer.visit, referencer);
    }
  }
  var Importer = class extends esrecurse.Visitor {
    constructor(declaration, referencer) {
      super(null, referencer.options);
      this.declaration = declaration;
      this.referencer = referencer;
    }
    visitImport(id, specifier) {
      this.referencer.visitPattern(id, (pattern) => {
        this.referencer.currentScope().__define(pattern, new Definition(Variable.ImportBinding, pattern, specifier, this.declaration, null, null));
      });
    }
    ImportNamespaceSpecifier(node) {
      const local = node.local || node.id;
      if (local) {
        this.visitImport(local, node);
      }
    }
    ImportDefaultSpecifier(node) {
      const local = node.local || node.id;
      this.visitImport(local, node);
    }
    ImportSpecifier(node) {
      const local = node.local || node.id;
      if (node.name) {
        this.visitImport(node.name, node);
      } else {
        this.visitImport(local, node);
      }
    }
  };
  var Referencer = class extends esrecurse.Visitor {
    constructor(options, scopeManager) {
      super(null, options);
      this.options = options;
      this.scopeManager = scopeManager;
      this.parent = null;
      this.isInnerMethodDefinition = false;
    }
    currentScope() {
      return this.scopeManager.__currentScope;
    }
    close(node) {
      while (this.currentScope() && node === this.currentScope().block) {
        this.scopeManager.__currentScope = this.currentScope().__close(this.scopeManager);
      }
    }
    pushInnerMethodDefinition(isInnerMethodDefinition) {
      const previous = this.isInnerMethodDefinition;
      this.isInnerMethodDefinition = isInnerMethodDefinition;
      return previous;
    }
    popInnerMethodDefinition(isInnerMethodDefinition) {
      this.isInnerMethodDefinition = isInnerMethodDefinition;
    }
    referencingDefaultValue(pattern, assignments, maybeImplicitGlobal, init) {
      const scope = this.currentScope();
      assignments.forEach((assignment) => {
        scope.__referencing(pattern, Reference.WRITE, assignment.right, maybeImplicitGlobal, pattern !== assignment.left, init);
      });
    }
    visitPattern(node, options, callback) {
      let visitPatternOptions = options;
      let visitPatternCallback = callback;
      if (typeof options === "function") {
        visitPatternCallback = options;
        visitPatternOptions = {processRightHandNodes: false};
      }
      traverseIdentifierInPattern(this.options, node, visitPatternOptions.processRightHandNodes ? this : null, visitPatternCallback);
    }
    visitFunction(node) {
      let i, iz;
      if (node.type === Syntax.FunctionDeclaration) {
        this.currentScope().__define(node.id, new Definition(Variable.FunctionName, node.id, node, null, null, null));
      }
      if (node.type === Syntax.FunctionExpression && node.id) {
        this.scopeManager.__nestFunctionExpressionNameScope(node);
      }
      this.scopeManager.__nestFunctionScope(node, this.isInnerMethodDefinition);
      const that = this;
      function visitPatternCallback(pattern, info3) {
        that.currentScope().__define(pattern, new ParameterDefinition(pattern, node, i, info3.rest));
        that.referencingDefaultValue(pattern, info3.assignments, null, true);
      }
      for (i = 0, iz = node.params.length; i < iz; ++i) {
        this.visitPattern(node.params[i], {processRightHandNodes: true}, visitPatternCallback);
      }
      if (node.rest) {
        this.visitPattern({
          type: "RestElement",
          argument: node.rest
        }, (pattern) => {
          this.currentScope().__define(pattern, new ParameterDefinition(pattern, node, node.params.length, true));
        });
      }
      if (node.body) {
        if (node.body.type === Syntax.BlockStatement) {
          this.visitChildren(node.body);
        } else {
          this.visit(node.body);
        }
      }
      this.close(node);
    }
    visitClass(node) {
      if (node.type === Syntax.ClassDeclaration) {
        this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node, null, null, null));
      }
      this.visit(node.superClass);
      this.scopeManager.__nestClassScope(node);
      if (node.id) {
        this.currentScope().__define(node.id, new Definition(Variable.ClassName, node.id, node));
      }
      this.visit(node.body);
      this.close(node);
    }
    visitProperty(node) {
      let previous;
      if (node.computed) {
        this.visit(node.key);
      }
      const isMethodDefinition = node.type === Syntax.MethodDefinition;
      if (isMethodDefinition) {
        previous = this.pushInnerMethodDefinition(true);
      }
      this.visit(node.value);
      if (isMethodDefinition) {
        this.popInnerMethodDefinition(previous);
      }
    }
    visitForIn(node) {
      if (node.left.type === Syntax.VariableDeclaration && node.left.kind !== "var") {
        this.scopeManager.__nestForScope(node);
      }
      if (node.left.type === Syntax.VariableDeclaration) {
        this.visit(node.left);
        this.visitPattern(node.left.declarations[0].id, (pattern) => {
          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, null, true, true);
        });
      } else {
        this.visitPattern(node.left, {processRightHandNodes: true}, (pattern, info3) => {
          let maybeImplicitGlobal = null;
          if (!this.currentScope().isStrict) {
            maybeImplicitGlobal = {
              pattern,
              node
            };
          }
          this.referencingDefaultValue(pattern, info3.assignments, maybeImplicitGlobal, false);
          this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, true, false);
        });
      }
      this.visit(node.right);
      this.visit(node.body);
      this.close(node);
    }
    visitVariableDeclaration(variableTargetScope, type, node, index) {
      const decl = node.declarations[index];
      const init = decl.init;
      this.visitPattern(decl.id, {processRightHandNodes: true}, (pattern, info3) => {
        variableTargetScope.__define(pattern, new Definition(type, pattern, decl, node, index, node.kind));
        this.referencingDefaultValue(pattern, info3.assignments, null, true);
        if (init) {
          this.currentScope().__referencing(pattern, Reference.WRITE, init, null, !info3.topLevel, true);
        }
      });
    }
    AssignmentExpression(node) {
      if (PatternVisitor.isPattern(node.left)) {
        if (node.operator === "=") {
          this.visitPattern(node.left, {processRightHandNodes: true}, (pattern, info3) => {
            let maybeImplicitGlobal = null;
            if (!this.currentScope().isStrict) {
              maybeImplicitGlobal = {
                pattern,
                node
              };
            }
            this.referencingDefaultValue(pattern, info3.assignments, maybeImplicitGlobal, false);
            this.currentScope().__referencing(pattern, Reference.WRITE, node.right, maybeImplicitGlobal, !info3.topLevel, false);
          });
        } else {
          this.currentScope().__referencing(node.left, Reference.RW, node.right);
        }
      } else {
        this.visit(node.left);
      }
      this.visit(node.right);
    }
    CatchClause(node) {
      this.scopeManager.__nestCatchScope(node);
      this.visitPattern(node.param, {processRightHandNodes: true}, (pattern, info3) => {
        this.currentScope().__define(pattern, new Definition(Variable.CatchClause, node.param, node, null, null, null));
        this.referencingDefaultValue(pattern, info3.assignments, null, true);
      });
      this.visit(node.body);
      this.close(node);
    }
    Program(node) {
      this.scopeManager.__nestGlobalScope(node);
      if (this.scopeManager.__isNodejsScope()) {
        this.currentScope().isStrict = false;
        this.scopeManager.__nestFunctionScope(node, false);
      }
      if (this.scopeManager.__isES6() && this.scopeManager.isModule()) {
        this.scopeManager.__nestModuleScope(node);
      }
      if (this.scopeManager.isStrictModeSupported() && this.scopeManager.isImpliedStrict()) {
        this.currentScope().isStrict = true;
      }
      this.visitChildren(node);
      this.close(node);
    }
    Identifier(node) {
      this.currentScope().__referencing(node);
    }
    UpdateExpression(node) {
      if (PatternVisitor.isPattern(node.argument)) {
        this.currentScope().__referencing(node.argument, Reference.RW, null);
      } else {
        this.visitChildren(node);
      }
    }
    MemberExpression(node) {
      this.visit(node.object);
      if (node.computed) {
        this.visit(node.property);
      }
    }
    Property(node) {
      this.visitProperty(node);
    }
    MethodDefinition(node) {
      this.visitProperty(node);
    }
    BreakStatement() {
    }
    ContinueStatement() {
    }
    LabeledStatement(node) {
      this.visit(node.body);
    }
    ForStatement(node) {
      if (node.init && node.init.type === Syntax.VariableDeclaration && node.init.kind !== "var") {
        this.scopeManager.__nestForScope(node);
      }
      this.visitChildren(node);
      this.close(node);
    }
    ClassExpression(node) {
      this.visitClass(node);
    }
    ClassDeclaration(node) {
      this.visitClass(node);
    }
    CallExpression(node) {
      if (!this.scopeManager.__ignoreEval() && node.callee.type === Syntax.Identifier && node.callee.name === "eval") {
        this.currentScope().variableScope.__detectEval();
      }
      this.visitChildren(node);
    }
    BlockStatement(node) {
      if (this.scopeManager.__isES6()) {
        this.scopeManager.__nestBlockScope(node);
      }
      this.visitChildren(node);
      this.close(node);
    }
    ThisExpression() {
      this.currentScope().variableScope.__detectThis();
    }
    WithStatement(node) {
      this.visit(node.object);
      this.scopeManager.__nestWithScope(node);
      this.visit(node.body);
      this.close(node);
    }
    VariableDeclaration(node) {
      const variableTargetScope = node.kind === "var" ? this.currentScope().variableScope : this.currentScope();
      for (let i = 0, iz = node.declarations.length; i < iz; ++i) {
        const decl = node.declarations[i];
        this.visitVariableDeclaration(variableTargetScope, Variable.Variable, node, i);
        if (decl.init) {
          this.visit(decl.init);
        }
      }
    }
    SwitchStatement(node) {
      this.visit(node.discriminant);
      if (this.scopeManager.__isES6()) {
        this.scopeManager.__nestSwitchScope(node);
      }
      for (let i = 0, iz = node.cases.length; i < iz; ++i) {
        this.visit(node.cases[i]);
      }
      this.close(node);
    }
    FunctionDeclaration(node) {
      this.visitFunction(node);
    }
    FunctionExpression(node) {
      this.visitFunction(node);
    }
    ForOfStatement(node) {
      this.visitForIn(node);
    }
    ForInStatement(node) {
      this.visitForIn(node);
    }
    ArrowFunctionExpression(node) {
      this.visitFunction(node);
    }
    ImportDeclaration(node) {
      assert(this.scopeManager.__isES6() && this.scopeManager.isModule(), "ImportDeclaration should appear when the mode is ES6 and in the module context.");
      const importer = new Importer(node, this);
      importer.visit(node);
    }
    visitExportDeclaration(node) {
      if (node.source) {
        return;
      }
      if (node.declaration) {
        this.visit(node.declaration);
        return;
      }
      this.visitChildren(node);
    }
    ExportDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportAllDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportDefaultDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportNamedDeclaration(node) {
      this.visitExportDeclaration(node);
    }
    ExportSpecifier(node) {
      const local = node.id || node.local;
      this.visit(local);
    }
    MetaProperty() {
    }
  };
  module2.exports = Referencer;
});

// node_modules/eslint/node_modules/eslint-scope/package.json
var require_package4 = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "eslint-scope@5.1.1",
        "/Users/abrown/code/eslint-action"
      ]
    ],
    _from: "eslint-scope@5.1.1",
    _id: "eslint-scope@5.1.1",
    _inBundle: false,
    _integrity: "sha512-2NxwbF/hZ0KpepYN0cNbo+FN6XoK7GaHlQhgx/hIZl6Va0bF45RQOOwhLIy8lQDbuCiadSLCBnH2CFYquit5bw==",
    _location: "/eslint/eslint-scope",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "eslint-scope@5.1.1",
      name: "eslint-scope",
      escapedName: "eslint-scope",
      rawSpec: "5.1.1",
      saveSpec: null,
      fetchSpec: "5.1.1"
    },
    _requiredBy: [
      "/eslint"
    ],
    _resolved: "https://registry.npmjs.org/eslint-scope/-/eslint-scope-5.1.1.tgz",
    _spec: "5.1.1",
    _where: "/Users/abrown/code/eslint-action",
    bugs: {
      url: "https://github.com/eslint/eslint-scope/issues"
    },
    dependencies: {
      esrecurse: "^4.3.0",
      estraverse: "^4.1.1"
    },
    description: "ECMAScript scope analyzer for ESLint",
    devDependencies: {
      "@typescript-eslint/parser": "^1.11.0",
      chai: "^4.2.0",
      eslint: "^6.0.1",
      "eslint-config-eslint": "^5.0.1",
      "eslint-plugin-node": "^9.1.0",
      "eslint-release": "^1.0.0",
      "eslint-visitor-keys": "^1.2.0",
      espree: "^7.1.0",
      istanbul: "^0.4.5",
      mocha: "^6.1.4",
      "npm-license": "^0.3.3",
      shelljs: "^0.8.3",
      typescript: "^3.5.2"
    },
    engines: {
      node: ">=8.0.0"
    },
    files: [
      "LICENSE",
      "README.md",
      "lib"
    ],
    homepage: "http://github.com/eslint/eslint-scope",
    license: "BSD-2-Clause",
    main: "lib/index.js",
    name: "eslint-scope",
    repository: {
      type: "git",
      url: "git+https://github.com/eslint/eslint-scope.git"
    },
    scripts: {
      "generate-alpharelease": "eslint-generate-prerelease alpha",
      "generate-betarelease": "eslint-generate-prerelease beta",
      "generate-rcrelease": "eslint-generate-prerelease rc",
      "generate-release": "eslint-generate-release",
      lint: "node Makefile.js lint",
      "publish-release": "eslint-publish-release",
      test: "node Makefile.js test"
    },
    version: "5.1.1"
  };
});

// node_modules/eslint/node_modules/eslint-scope/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var ScopeManager = require_scope_manager();
  var Referencer = require_referencer();
  var Reference = require_reference();
  var Variable = require_variable();
  var Scope = require_scope().Scope;
  var version = require_package4().version;
  function defaultOptions() {
    return {
      optimistic: false,
      directive: false,
      nodejsScope: false,
      impliedStrict: false,
      sourceType: "script",
      ecmaVersion: 5,
      childVisitorKeys: null,
      fallback: "iteration"
    };
  }
  function updateDeeply(target, override) {
    function isHashObject(value) {
      return typeof value === "object" && value instanceof Object && !(value instanceof Array) && !(value instanceof RegExp);
    }
    for (const key in override) {
      if (Object.prototype.hasOwnProperty.call(override, key)) {
        const val = override[key];
        if (isHashObject(val)) {
          if (isHashObject(target[key])) {
            updateDeeply(target[key], val);
          } else {
            target[key] = updateDeeply({}, val);
          }
        } else {
          target[key] = val;
        }
      }
    }
    return target;
  }
  function analyze(tree, providedOptions) {
    const options = updateDeeply(defaultOptions(), providedOptions);
    const scopeManager = new ScopeManager(options);
    const referencer = new Referencer(options, scopeManager);
    referencer.visit(tree);
    assert(scopeManager.__currentScope === null, "currentScope should be null.");
    return scopeManager;
  }
  module2.exports = {
    version,
    Reference,
    Variable,
    Scope,
    ScopeManager,
    analyze
  };
});

// node_modules/eslint/node_modules/eslint-visitor-keys/lib/visitor-keys.json
var require_visitor_keys = __commonJS((exports2, module2) => {
  module2.exports = {
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AwaitExpression: [
      "argument"
    ],
    BlockStatement: [
      "body"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExportAllDeclaration: [
      "exported",
      "source"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source"
    ],
    ExportSpecifier: [
      "exported",
      "local"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportDeclaration: [
      "specifiers",
      "source"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXText: [],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    Literal: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    Super: [],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    SwitchCase: [
      "test",
      "consequent"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  };
});

// node_modules/eslint/node_modules/eslint-visitor-keys/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  "use strict";
  var KEYS = require_visitor_keys();
  var NODE_TYPES = Object.freeze(Object.keys(KEYS));
  for (const type of NODE_TYPES) {
    Object.freeze(KEYS[type]);
  }
  Object.freeze(KEYS);
  var KEY_BLACKLIST = new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
  }
  module2.exports = Object.freeze({
    KEYS,
    getKeys(node) {
      return Object.keys(node).filter(filterKey);
    },
    unionWith(additionalKeys) {
      const retv = Object.assign({}, KEYS);
      for (const type of Object.keys(additionalKeys)) {
        if (retv.hasOwnProperty(type)) {
          const keys = new Set(additionalKeys[type]);
          for (const key of retv[type]) {
            keys.add(key);
          }
          retv[type] = Object.freeze(Array.from(keys));
        } else {
          retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        }
      }
      return Object.freeze(retv);
    }
  });
});

// node_modules/eslint/lib/shared/ast-utils.js
var require_ast_utils = __commonJS((exports2, module2) => {
  "use strict";
  var breakableTypePattern = /^(?:(?:Do)?While|For(?:In|Of)?|Switch)Statement$/u;
  var lineBreakPattern = /\r\n|[\r\n\u2028\u2029]/u;
  var shebangPattern = /^#!([^\r\n]+)/u;
  function createGlobalLinebreakMatcher() {
    return new RegExp(lineBreakPattern.source, "gu");
  }
  module2.exports = {
    breakableTypePattern,
    lineBreakPattern,
    createGlobalLinebreakMatcher,
    shebangPattern
  };
});

// node_modules/eslint/lib/shared/traverser.js
var require_traverser = __commonJS((exports2, module2) => {
  "use strict";
  var vk = require_lib4();
  var debug5 = require_src()("eslint:traverser");
  function noop() {
  }
  function isNode(x) {
    return x !== null && typeof x === "object" && typeof x.type === "string";
  }
  function getVisitorKeys(visitorKeys, node) {
    let keys = visitorKeys[node.type];
    if (!keys) {
      keys = vk.getKeys(node);
      debug5('Unknown node type "%s": Estimated visitor keys %j', node.type, keys);
    }
    return keys;
  }
  var Traverser = class {
    constructor() {
      this._current = null;
      this._parents = [];
      this._skipped = false;
      this._broken = false;
      this._visitorKeys = null;
      this._enter = null;
      this._leave = null;
    }
    current() {
      return this._current;
    }
    parents() {
      return this._parents.slice(0);
    }
    break() {
      this._broken = true;
    }
    skip() {
      this._skipped = true;
    }
    traverse(node, options) {
      this._current = null;
      this._parents = [];
      this._skipped = false;
      this._broken = false;
      this._visitorKeys = options.visitorKeys || vk.KEYS;
      this._enter = options.enter || noop;
      this._leave = options.leave || noop;
      this._traverse(node, null);
    }
    _traverse(node, parent) {
      if (!isNode(node)) {
        return;
      }
      this._current = node;
      this._skipped = false;
      this._enter(node, parent);
      if (!this._skipped && !this._broken) {
        const keys = getVisitorKeys(this._visitorKeys, node);
        if (keys.length >= 1) {
          this._parents.push(node);
          for (let i = 0; i < keys.length && !this._broken; ++i) {
            const child = node[keys[i]];
            if (Array.isArray(child)) {
              for (let j = 0; j < child.length && !this._broken; ++j) {
                this._traverse(child[j], node);
              }
            } else {
              this._traverse(child, node);
            }
          }
          this._parents.pop();
        }
      }
      if (!this._broken) {
        this._leave(node, parent);
      }
      this._current = parent;
    }
    static getKeys(node) {
      return vk.getKeys(node);
    }
    static traverse(node, options) {
      new Traverser().traverse(node, options);
    }
    static get DEFAULT_VISITOR_KEYS() {
      return vk.KEYS;
    }
  };
  module2.exports = Traverser;
});

// node_modules/eslint/node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/visitor-keys.json
var require_visitor_keys2 = __commonJS((exports2, module2) => {
  module2.exports = {
    AssignmentExpression: [
      "left",
      "right"
    ],
    AssignmentPattern: [
      "left",
      "right"
    ],
    ArrayExpression: [
      "elements"
    ],
    ArrayPattern: [
      "elements"
    ],
    ArrowFunctionExpression: [
      "params",
      "body"
    ],
    AwaitExpression: [
      "argument"
    ],
    BlockStatement: [
      "body"
    ],
    BinaryExpression: [
      "left",
      "right"
    ],
    BreakStatement: [
      "label"
    ],
    CallExpression: [
      "callee",
      "arguments"
    ],
    CatchClause: [
      "param",
      "body"
    ],
    ChainExpression: [
      "expression"
    ],
    ClassBody: [
      "body"
    ],
    ClassDeclaration: [
      "id",
      "superClass",
      "body"
    ],
    ClassExpression: [
      "id",
      "superClass",
      "body"
    ],
    ConditionalExpression: [
      "test",
      "consequent",
      "alternate"
    ],
    ContinueStatement: [
      "label"
    ],
    DebuggerStatement: [],
    DoWhileStatement: [
      "body",
      "test"
    ],
    EmptyStatement: [],
    ExportAllDeclaration: [
      "exported",
      "source"
    ],
    ExportDefaultDeclaration: [
      "declaration"
    ],
    ExportNamedDeclaration: [
      "declaration",
      "specifiers",
      "source"
    ],
    ExportSpecifier: [
      "exported",
      "local"
    ],
    ExpressionStatement: [
      "expression"
    ],
    ExperimentalRestProperty: [
      "argument"
    ],
    ExperimentalSpreadProperty: [
      "argument"
    ],
    ForStatement: [
      "init",
      "test",
      "update",
      "body"
    ],
    ForInStatement: [
      "left",
      "right",
      "body"
    ],
    ForOfStatement: [
      "left",
      "right",
      "body"
    ],
    FunctionDeclaration: [
      "id",
      "params",
      "body"
    ],
    FunctionExpression: [
      "id",
      "params",
      "body"
    ],
    Identifier: [],
    IfStatement: [
      "test",
      "consequent",
      "alternate"
    ],
    ImportDeclaration: [
      "specifiers",
      "source"
    ],
    ImportDefaultSpecifier: [
      "local"
    ],
    ImportExpression: [
      "source"
    ],
    ImportNamespaceSpecifier: [
      "local"
    ],
    ImportSpecifier: [
      "imported",
      "local"
    ],
    JSXAttribute: [
      "name",
      "value"
    ],
    JSXClosingElement: [
      "name"
    ],
    JSXElement: [
      "openingElement",
      "children",
      "closingElement"
    ],
    JSXEmptyExpression: [],
    JSXExpressionContainer: [
      "expression"
    ],
    JSXIdentifier: [],
    JSXMemberExpression: [
      "object",
      "property"
    ],
    JSXNamespacedName: [
      "namespace",
      "name"
    ],
    JSXOpeningElement: [
      "name",
      "attributes"
    ],
    JSXSpreadAttribute: [
      "argument"
    ],
    JSXText: [],
    JSXFragment: [
      "openingFragment",
      "children",
      "closingFragment"
    ],
    Literal: [],
    LabeledStatement: [
      "label",
      "body"
    ],
    LogicalExpression: [
      "left",
      "right"
    ],
    MemberExpression: [
      "object",
      "property"
    ],
    MetaProperty: [
      "meta",
      "property"
    ],
    MethodDefinition: [
      "key",
      "value"
    ],
    NewExpression: [
      "callee",
      "arguments"
    ],
    ObjectExpression: [
      "properties"
    ],
    ObjectPattern: [
      "properties"
    ],
    Program: [
      "body"
    ],
    Property: [
      "key",
      "value"
    ],
    RestElement: [
      "argument"
    ],
    ReturnStatement: [
      "argument"
    ],
    SequenceExpression: [
      "expressions"
    ],
    SpreadElement: [
      "argument"
    ],
    Super: [],
    SwitchStatement: [
      "discriminant",
      "cases"
    ],
    SwitchCase: [
      "test",
      "consequent"
    ],
    TaggedTemplateExpression: [
      "tag",
      "quasi"
    ],
    TemplateElement: [],
    TemplateLiteral: [
      "quasis",
      "expressions"
    ],
    ThisExpression: [],
    ThrowStatement: [
      "argument"
    ],
    TryStatement: [
      "block",
      "handler",
      "finalizer"
    ],
    UnaryExpression: [
      "argument"
    ],
    UpdateExpression: [
      "argument"
    ],
    VariableDeclaration: [
      "declarations"
    ],
    VariableDeclarator: [
      "id",
      "init"
    ],
    WhileStatement: [
      "test",
      "body"
    ],
    WithStatement: [
      "object",
      "body"
    ],
    YieldExpression: [
      "argument"
    ]
  };
});

// node_modules/eslint/node_modules/eslint-utils/node_modules/eslint-visitor-keys/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  "use strict";
  var KEYS = require_visitor_keys2();
  var NODE_TYPES = Object.freeze(Object.keys(KEYS));
  for (const type of NODE_TYPES) {
    Object.freeze(KEYS[type]);
  }
  Object.freeze(KEYS);
  var KEY_BLACKLIST = new Set([
    "parent",
    "leadingComments",
    "trailingComments"
  ]);
  function filterKey(key) {
    return !KEY_BLACKLIST.has(key) && key[0] !== "_";
  }
  module2.exports = Object.freeze({
    KEYS,
    getKeys(node) {
      return Object.keys(node).filter(filterKey);
    },
    unionWith(additionalKeys) {
      const retv = Object.assign({}, KEYS);
      for (const type of Object.keys(additionalKeys)) {
        if (retv.hasOwnProperty(type)) {
          const keys = new Set(additionalKeys[type]);
          for (const key of retv[type]) {
            keys.add(key);
          }
          retv[type] = Object.freeze(Array.from(keys));
        } else {
          retv[type] = Object.freeze(Array.from(additionalKeys[type]));
        }
      }
      return Object.freeze(retv);
    }
  });
});

// node_modules/eslint/node_modules/eslint-utils/index.js
var require_eslint_utils = __commonJS((exports2) => {
  /*! @author Toru Nagashima <https://github.com/mysticatea> */
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function _interopDefault(ex) {
    return ex && typeof ex === "object" && "default" in ex ? ex["default"] : ex;
  }
  var evk = _interopDefault(require_lib5());
  function getInnermostScope(initialScope, node) {
    const location = node.range[0];
    let scope = initialScope;
    let found = false;
    do {
      found = false;
      for (const childScope of scope.childScopes) {
        const range = childScope.block.range;
        if (range[0] <= location && location < range[1]) {
          scope = childScope;
          found = true;
          break;
        }
      }
    } while (found);
    return scope;
  }
  function findVariable(initialScope, nameOrNode) {
    let name = "";
    let scope = initialScope;
    if (typeof nameOrNode === "string") {
      name = nameOrNode;
    } else {
      name = nameOrNode.name;
      scope = getInnermostScope(scope, nameOrNode);
    }
    while (scope != null) {
      const variable = scope.set.get(name);
      if (variable != null) {
        return variable;
      }
      scope = scope.upper;
    }
    return null;
  }
  function negate0(token) {
    return !this(token);
  }
  function negate(f) {
    return negate0.bind(f);
  }
  function isArrowToken(token) {
    return token.value === "=>" && token.type === "Punctuator";
  }
  function isCommaToken(token) {
    return token.value === "," && token.type === "Punctuator";
  }
  function isSemicolonToken(token) {
    return token.value === ";" && token.type === "Punctuator";
  }
  function isColonToken(token) {
    return token.value === ":" && token.type === "Punctuator";
  }
  function isOpeningParenToken(token) {
    return token.value === "(" && token.type === "Punctuator";
  }
  function isClosingParenToken(token) {
    return token.value === ")" && token.type === "Punctuator";
  }
  function isOpeningBracketToken(token) {
    return token.value === "[" && token.type === "Punctuator";
  }
  function isClosingBracketToken(token) {
    return token.value === "]" && token.type === "Punctuator";
  }
  function isOpeningBraceToken(token) {
    return token.value === "{" && token.type === "Punctuator";
  }
  function isClosingBraceToken(token) {
    return token.value === "}" && token.type === "Punctuator";
  }
  function isCommentToken(token) {
    return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
  }
  var isNotArrowToken = negate(isArrowToken);
  var isNotCommaToken = negate(isCommaToken);
  var isNotSemicolonToken = negate(isSemicolonToken);
  var isNotColonToken = negate(isColonToken);
  var isNotOpeningParenToken = negate(isOpeningParenToken);
  var isNotClosingParenToken = negate(isClosingParenToken);
  var isNotOpeningBracketToken = negate(isOpeningBracketToken);
  var isNotClosingBracketToken = negate(isClosingBracketToken);
  var isNotOpeningBraceToken = negate(isOpeningBraceToken);
  var isNotClosingBraceToken = negate(isClosingBraceToken);
  var isNotCommentToken = negate(isCommentToken);
  function getOpeningParenOfParams(node, sourceCode) {
    return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
  }
  function getFunctionHeadLocation(node, sourceCode) {
    const parent = node.parent;
    let start = null;
    let end = null;
    if (node.type === "ArrowFunctionExpression") {
      const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
      start = arrowToken.loc.start;
      end = arrowToken.loc.end;
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
      start = parent.loc.start;
      end = getOpeningParenOfParams(node, sourceCode).loc.start;
    } else {
      start = node.loc.start;
      end = getOpeningParenOfParams(node, sourceCode).loc.start;
    }
    return {
      start: Object.assign({}, start),
      end: Object.assign({}, end)
    };
  }
  var globalObject = typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : {};
  var builtinNames = Object.freeze(new Set([
    "Array",
    "ArrayBuffer",
    "BigInt",
    "BigInt64Array",
    "BigUint64Array",
    "Boolean",
    "DataView",
    "Date",
    "decodeURI",
    "decodeURIComponent",
    "encodeURI",
    "encodeURIComponent",
    "escape",
    "Float32Array",
    "Float64Array",
    "Function",
    "Infinity",
    "Int16Array",
    "Int32Array",
    "Int8Array",
    "isFinite",
    "isNaN",
    "isPrototypeOf",
    "JSON",
    "Map",
    "Math",
    "NaN",
    "Number",
    "Object",
    "parseFloat",
    "parseInt",
    "Promise",
    "Proxy",
    "Reflect",
    "RegExp",
    "Set",
    "String",
    "Symbol",
    "Uint16Array",
    "Uint32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "undefined",
    "unescape",
    "WeakMap",
    "WeakSet"
  ]));
  var callAllowed = new Set([
    Array.isArray,
    typeof BigInt === "function" ? BigInt : void 0,
    Boolean,
    Date,
    Date.parse,
    decodeURI,
    decodeURIComponent,
    encodeURI,
    encodeURIComponent,
    escape,
    isFinite,
    isNaN,
    isPrototypeOf,
    ...Object.getOwnPropertyNames(Math).map((k) => Math[k]).filter((f) => typeof f === "function"),
    Number,
    Number.isFinite,
    Number.isNaN,
    Number.parseFloat,
    Number.parseInt,
    Object,
    Object.entries,
    Object.is,
    Object.isExtensible,
    Object.isFrozen,
    Object.isSealed,
    Object.keys,
    Object.values,
    parseFloat,
    parseInt,
    RegExp,
    String,
    String.fromCharCode,
    String.fromCodePoint,
    String.raw,
    Symbol,
    Symbol.for,
    Symbol.keyFor,
    unescape
  ].filter((f) => typeof f === "function"));
  var callPassThrough = new Set([
    Object.freeze,
    Object.preventExtensions,
    Object.seal
  ]);
  function getPropertyDescriptor(object, name) {
    let x = object;
    while ((typeof x === "object" || typeof x === "function") && x !== null) {
      const d = Object.getOwnPropertyDescriptor(x, name);
      if (d) {
        return d;
      }
      x = Object.getPrototypeOf(x);
    }
    return null;
  }
  function isGetter(object, name) {
    const d = getPropertyDescriptor(object, name);
    return d != null && d.get != null;
  }
  function getElementValues(nodeList, initialScope) {
    const valueList = [];
    for (let i = 0; i < nodeList.length; ++i) {
      const elementNode = nodeList[i];
      if (elementNode == null) {
        valueList.length = i + 1;
      } else if (elementNode.type === "SpreadElement") {
        const argument = getStaticValueR(elementNode.argument, initialScope);
        if (argument == null) {
          return null;
        }
        valueList.push(...argument.value);
      } else {
        const element = getStaticValueR(elementNode, initialScope);
        if (element == null) {
          return null;
        }
        valueList.push(element.value);
      }
    }
    return valueList;
  }
  var operations = Object.freeze({
    ArrayExpression(node, initialScope) {
      const elements = getElementValues(node.elements, initialScope);
      return elements != null ? {value: elements} : null;
    },
    AssignmentExpression(node, initialScope) {
      if (node.operator === "=") {
        return getStaticValueR(node.right, initialScope);
      }
      return null;
    },
    BinaryExpression(node, initialScope) {
      if (node.operator === "in" || node.operator === "instanceof") {
        return null;
      }
      const left = getStaticValueR(node.left, initialScope);
      const right = getStaticValueR(node.right, initialScope);
      if (left != null && right != null) {
        switch (node.operator) {
          case "==":
            return {value: left.value == right.value};
          case "!=":
            return {value: left.value != right.value};
          case "===":
            return {value: left.value === right.value};
          case "!==":
            return {value: left.value !== right.value};
          case "<":
            return {value: left.value < right.value};
          case "<=":
            return {value: left.value <= right.value};
          case ">":
            return {value: left.value > right.value};
          case ">=":
            return {value: left.value >= right.value};
          case "<<":
            return {value: left.value << right.value};
          case ">>":
            return {value: left.value >> right.value};
          case ">>>":
            return {value: left.value >>> right.value};
          case "+":
            return {value: left.value + right.value};
          case "-":
            return {value: left.value - right.value};
          case "*":
            return {value: left.value * right.value};
          case "/":
            return {value: left.value / right.value};
          case "%":
            return {value: left.value % right.value};
          case "**":
            return {value: Math.pow(left.value, right.value)};
          case "|":
            return {value: left.value | right.value};
          case "^":
            return {value: left.value ^ right.value};
          case "&":
            return {value: left.value & right.value};
        }
      }
      return null;
    },
    CallExpression(node, initialScope) {
      const calleeNode = node.callee;
      const args = getElementValues(node.arguments, initialScope);
      if (args != null) {
        if (calleeNode.type === "MemberExpression") {
          const object = getStaticValueR(calleeNode.object, initialScope);
          if (object != null) {
            if (object.value == null && (object.optional || node.optional)) {
              return {value: void 0, optional: true};
            }
            const property = calleeNode.computed ? getStaticValueR(calleeNode.property, initialScope) : {value: calleeNode.property.name};
            if (property != null) {
              const receiver = object.value;
              const methodName = property.value;
              if (callAllowed.has(receiver[methodName])) {
                return {value: receiver[methodName](...args)};
              }
              if (callPassThrough.has(receiver[methodName])) {
                return {value: args[0]};
              }
            }
          }
        } else {
          const callee = getStaticValueR(calleeNode, initialScope);
          if (callee != null) {
            if (callee.value == null && node.optional) {
              return {value: void 0, optional: true};
            }
            const func = callee.value;
            if (callAllowed.has(func)) {
              return {value: func(...args)};
            }
            if (callPassThrough.has(func)) {
              return {value: args[0]};
            }
          }
        }
      }
      return null;
    },
    ConditionalExpression(node, initialScope) {
      const test = getStaticValueR(node.test, initialScope);
      if (test != null) {
        return test.value ? getStaticValueR(node.consequent, initialScope) : getStaticValueR(node.alternate, initialScope);
      }
      return null;
    },
    ExpressionStatement(node, initialScope) {
      return getStaticValueR(node.expression, initialScope);
    },
    Identifier(node, initialScope) {
      if (initialScope != null) {
        const variable = findVariable(initialScope, node);
        if (variable != null && variable.defs.length === 0 && builtinNames.has(variable.name) && variable.name in globalObject) {
          return {value: globalObject[variable.name]};
        }
        if (variable != null && variable.defs.length === 1) {
          const def = variable.defs[0];
          if (def.parent && def.parent.kind === "const" && def.node.id.type === "Identifier") {
            return getStaticValueR(def.node.init, initialScope);
          }
        }
      }
      return null;
    },
    Literal(node) {
      if ((node.regex != null || node.bigint != null) && node.value == null) {
        return null;
      }
      return {value: node.value};
    },
    LogicalExpression(node, initialScope) {
      const left = getStaticValueR(node.left, initialScope);
      if (left != null) {
        if (node.operator === "||" && Boolean(left.value) === true || node.operator === "&&" && Boolean(left.value) === false || node.operator === "??" && left.value != null) {
          return left;
        }
        const right = getStaticValueR(node.right, initialScope);
        if (right != null) {
          return right;
        }
      }
      return null;
    },
    MemberExpression(node, initialScope) {
      const object = getStaticValueR(node.object, initialScope);
      if (object != null) {
        if (object.value == null && (object.optional || node.optional)) {
          return {value: void 0, optional: true};
        }
        const property = node.computed ? getStaticValueR(node.property, initialScope) : {value: node.property.name};
        if (property != null && !isGetter(object.value, property.value)) {
          return {value: object.value[property.value]};
        }
      }
      return null;
    },
    ChainExpression(node, initialScope) {
      const expression = getStaticValueR(node.expression, initialScope);
      if (expression != null) {
        return {value: expression.value};
      }
      return null;
    },
    NewExpression(node, initialScope) {
      const callee = getStaticValueR(node.callee, initialScope);
      const args = getElementValues(node.arguments, initialScope);
      if (callee != null && args != null) {
        const Func = callee.value;
        if (callAllowed.has(Func)) {
          return {value: new Func(...args)};
        }
      }
      return null;
    },
    ObjectExpression(node, initialScope) {
      const object = {};
      for (const propertyNode of node.properties) {
        if (propertyNode.type === "Property") {
          if (propertyNode.kind !== "init") {
            return null;
          }
          const key = propertyNode.computed ? getStaticValueR(propertyNode.key, initialScope) : {value: propertyNode.key.name};
          const value = getStaticValueR(propertyNode.value, initialScope);
          if (key == null || value == null) {
            return null;
          }
          object[key.value] = value.value;
        } else if (propertyNode.type === "SpreadElement" || propertyNode.type === "ExperimentalSpreadProperty") {
          const argument = getStaticValueR(propertyNode.argument, initialScope);
          if (argument == null) {
            return null;
          }
          Object.assign(object, argument.value);
        } else {
          return null;
        }
      }
      return {value: object};
    },
    SequenceExpression(node, initialScope) {
      const last = node.expressions[node.expressions.length - 1];
      return getStaticValueR(last, initialScope);
    },
    TaggedTemplateExpression(node, initialScope) {
      const tag = getStaticValueR(node.tag, initialScope);
      const expressions = getElementValues(node.quasi.expressions, initialScope);
      if (tag != null && expressions != null) {
        const func = tag.value;
        const strings = node.quasi.quasis.map((q) => q.value.cooked);
        strings.raw = node.quasi.quasis.map((q) => q.value.raw);
        if (func === String.raw) {
          return {value: func(strings, ...expressions)};
        }
      }
      return null;
    },
    TemplateLiteral(node, initialScope) {
      const expressions = getElementValues(node.expressions, initialScope);
      if (expressions != null) {
        let value = node.quasis[0].value.cooked;
        for (let i = 0; i < expressions.length; ++i) {
          value += expressions[i];
          value += node.quasis[i + 1].value.cooked;
        }
        return {value};
      }
      return null;
    },
    UnaryExpression(node, initialScope) {
      if (node.operator === "delete") {
        return null;
      }
      if (node.operator === "void") {
        return {value: void 0};
      }
      const arg = getStaticValueR(node.argument, initialScope);
      if (arg != null) {
        switch (node.operator) {
          case "-":
            return {value: -arg.value};
          case "+":
            return {value: +arg.value};
          case "!":
            return {value: !arg.value};
          case "~":
            return {value: ~arg.value};
          case "typeof":
            return {value: typeof arg.value};
        }
      }
      return null;
    }
  });
  function getStaticValueR(node, initialScope) {
    if (node != null && Object.hasOwnProperty.call(operations, node.type)) {
      return operations[node.type](node, initialScope);
    }
    return null;
  }
  function getStaticValue(node, initialScope = null) {
    try {
      return getStaticValueR(node, initialScope);
    } catch (_error) {
      return null;
    }
  }
  function getStringIfConstant(node, initialScope = null) {
    if (node && node.type === "Literal" && node.value === null) {
      if (node.regex) {
        return `/${node.regex.pattern}/${node.regex.flags}`;
      }
      if (node.bigint) {
        return node.bigint;
      }
    }
    const evaluated = getStaticValue(node, initialScope);
    return evaluated && String(evaluated.value);
  }
  function getPropertyName(node, initialScope) {
    switch (node.type) {
      case "MemberExpression":
        if (node.computed) {
          return getStringIfConstant(node.property, initialScope);
        }
        return node.property.name;
      case "Property":
      case "MethodDefinition":
        if (node.computed) {
          return getStringIfConstant(node.key, initialScope);
        }
        if (node.key.type === "Literal") {
          return String(node.key.value);
        }
        return node.key.name;
    }
    return null;
  }
  function getFunctionNameWithKind(node) {
    const parent = node.parent;
    const tokens = [];
    if (parent.type === "MethodDefinition" && parent.static) {
      tokens.push("static");
    }
    if (node.async) {
      tokens.push("async");
    }
    if (node.generator) {
      tokens.push("generator");
    }
    if (node.type === "ArrowFunctionExpression") {
      tokens.push("arrow", "function");
    } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
      if (parent.kind === "constructor") {
        return "constructor";
      }
      if (parent.kind === "get") {
        tokens.push("getter");
      } else if (parent.kind === "set") {
        tokens.push("setter");
      } else {
        tokens.push("method");
      }
    } else {
      tokens.push("function");
    }
    if (node.id) {
      tokens.push(`'${node.id.name}'`);
    } else {
      const name = getPropertyName(parent);
      if (name) {
        tokens.push(`'${name}'`);
      }
    }
    if (node.type === "ArrowFunctionExpression") {
      if (parent.type === "VariableDeclarator" && parent.id && parent.id.type === "Identifier") {
        tokens.push(`'${parent.id.name}'`);
      }
      if (parent.type === "AssignmentExpression" && parent.left && parent.left.type === "Identifier") {
        tokens.push(`'${parent.left.name}'`);
      }
    }
    return tokens.join(" ");
  }
  var typeConversionBinaryOps = Object.freeze(new Set([
    "==",
    "!=",
    "<",
    "<=",
    ">",
    ">=",
    "<<",
    ">>",
    ">>>",
    "+",
    "-",
    "*",
    "/",
    "%",
    "|",
    "^",
    "&",
    "in"
  ]));
  var typeConversionUnaryOps = Object.freeze(new Set(["-", "+", "!", "~"]));
  function isNode(x) {
    return x !== null && typeof x === "object" && typeof x.type === "string";
  }
  var visitor = Object.freeze(Object.assign(Object.create(null), {
    $visit(node, options, visitorKeys) {
      const {type} = node;
      if (typeof this[type] === "function") {
        return this[type](node, options, visitorKeys);
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    $visitChildren(node, options, visitorKeys) {
      const {type} = node;
      for (const key of visitorKeys[type] || evk.getKeys(node)) {
        const value = node[key];
        if (Array.isArray(value)) {
          for (const element of value) {
            if (isNode(element) && this.$visit(element, options, visitorKeys)) {
              return true;
            }
          }
        } else if (isNode(value) && this.$visit(value, options, visitorKeys)) {
          return true;
        }
      }
      return false;
    },
    ArrowFunctionExpression() {
      return false;
    },
    AssignmentExpression() {
      return true;
    },
    AwaitExpression() {
      return true;
    },
    BinaryExpression(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && typeConversionBinaryOps.has(node.operator) && (node.left.type !== "Literal" || node.right.type !== "Literal")) {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    CallExpression() {
      return true;
    },
    FunctionExpression() {
      return false;
    },
    ImportExpression() {
      return true;
    },
    MemberExpression(node, options, visitorKeys) {
      if (options.considerGetters) {
        return true;
      }
      if (options.considerImplicitTypeConversion && node.computed && node.property.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    MethodDefinition(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    NewExpression() {
      return true;
    },
    Property(node, options, visitorKeys) {
      if (options.considerImplicitTypeConversion && node.computed && node.key.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    UnaryExpression(node, options, visitorKeys) {
      if (node.operator === "delete") {
        return true;
      }
      if (options.considerImplicitTypeConversion && typeConversionUnaryOps.has(node.operator) && node.argument.type !== "Literal") {
        return true;
      }
      return this.$visitChildren(node, options, visitorKeys);
    },
    UpdateExpression() {
      return true;
    },
    YieldExpression() {
      return true;
    }
  }));
  function hasSideEffect(node, sourceCode, {considerGetters = false, considerImplicitTypeConversion = false} = {}) {
    return visitor.$visit(node, {considerGetters, considerImplicitTypeConversion}, sourceCode.visitorKeys || evk.KEYS);
  }
  function getParentSyntaxParen(node, sourceCode) {
    const parent = node.parent;
    switch (parent.type) {
      case "CallExpression":
      case "NewExpression":
        if (parent.arguments.length === 1 && parent.arguments[0] === node) {
          return sourceCode.getTokenAfter(parent.callee, isOpeningParenToken);
        }
        return null;
      case "DoWhileStatement":
        if (parent.test === node) {
          return sourceCode.getTokenAfter(parent.body, isOpeningParenToken);
        }
        return null;
      case "IfStatement":
      case "WhileStatement":
        if (parent.test === node) {
          return sourceCode.getFirstToken(parent, 1);
        }
        return null;
      case "ImportExpression":
        if (parent.source === node) {
          return sourceCode.getFirstToken(parent, 1);
        }
        return null;
      case "SwitchStatement":
        if (parent.discriminant === node) {
          return sourceCode.getFirstToken(parent, 1);
        }
        return null;
      case "WithStatement":
        if (parent.object === node) {
          return sourceCode.getFirstToken(parent, 1);
        }
        return null;
      default:
        return null;
    }
  }
  function isParenthesized(timesOrNode, nodeOrSourceCode, optionalSourceCode) {
    let times, node, sourceCode, maybeLeftParen, maybeRightParen;
    if (typeof timesOrNode === "number") {
      times = timesOrNode | 0;
      node = nodeOrSourceCode;
      sourceCode = optionalSourceCode;
      if (!(times >= 1)) {
        throw new TypeError("'times' should be a positive integer.");
      }
    } else {
      times = 1;
      node = timesOrNode;
      sourceCode = nodeOrSourceCode;
    }
    if (node == null) {
      return false;
    }
    maybeLeftParen = maybeRightParen = node;
    do {
      maybeLeftParen = sourceCode.getTokenBefore(maybeLeftParen);
      maybeRightParen = sourceCode.getTokenAfter(maybeRightParen);
    } while (maybeLeftParen != null && maybeRightParen != null && isOpeningParenToken(maybeLeftParen) && isClosingParenToken(maybeRightParen) && maybeLeftParen !== getParentSyntaxParen(node, sourceCode) && --times > 0);
    return times === 0;
  }
  var placeholder = /\$(?:[$&`']|[1-9][0-9]?)/gu;
  var internal = new WeakMap();
  function isEscaped(str, index2) {
    let escaped = false;
    for (let i = index2 - 1; i >= 0 && str.charCodeAt(i) === 92; --i) {
      escaped = !escaped;
    }
    return escaped;
  }
  function replaceS(matcher, str, replacement) {
    const chunks = [];
    let index2 = 0;
    let match = null;
    function replacer(key) {
      switch (key) {
        case "$$":
          return "$";
        case "$&":
          return match[0];
        case "$`":
          return str.slice(0, match.index);
        case "$'":
          return str.slice(match.index + match[0].length);
        default: {
          const i = key.slice(1);
          if (i in match) {
            return match[i];
          }
          return key;
        }
      }
    }
    for (match of matcher.execAll(str)) {
      chunks.push(str.slice(index2, match.index));
      chunks.push(replacement.replace(placeholder, replacer));
      index2 = match.index + match[0].length;
    }
    chunks.push(str.slice(index2));
    return chunks.join("");
  }
  function replaceF(matcher, str, replace) {
    const chunks = [];
    let index2 = 0;
    for (const match of matcher.execAll(str)) {
      chunks.push(str.slice(index2, match.index));
      chunks.push(String(replace(...match, match.index, match.input)));
      index2 = match.index + match[0].length;
    }
    chunks.push(str.slice(index2));
    return chunks.join("");
  }
  var PatternMatcher = class {
    constructor(pattern, {escaped = false} = {}) {
      if (!(pattern instanceof RegExp)) {
        throw new TypeError("'pattern' should be a RegExp instance.");
      }
      if (!pattern.flags.includes("g")) {
        throw new Error("'pattern' should contains 'g' flag.");
      }
      internal.set(this, {
        pattern: new RegExp(pattern.source, pattern.flags),
        escaped: Boolean(escaped)
      });
    }
    *execAll(str) {
      const {pattern, escaped} = internal.get(this);
      let match = null;
      let lastIndex = 0;
      pattern.lastIndex = 0;
      while ((match = pattern.exec(str)) != null) {
        if (escaped || !isEscaped(str, match.index)) {
          lastIndex = pattern.lastIndex;
          yield match;
          pattern.lastIndex = lastIndex;
        }
      }
    }
    test(str) {
      const it2 = this.execAll(str);
      const ret = it2.next();
      return !ret.done;
    }
    [Symbol.replace](str, replacer) {
      return typeof replacer === "function" ? replaceF(this, String(str), replacer) : replaceS(this, String(str), String(replacer));
    }
  };
  var IMPORT_TYPE = /^(?:Import|Export(?:All|Default|Named))Declaration$/u;
  var has = Function.call.bind(Object.hasOwnProperty);
  var READ = Symbol("read");
  var CALL = Symbol("call");
  var CONSTRUCT = Symbol("construct");
  var ESM = Symbol("esm");
  var requireCall = {require: {[CALL]: true}};
  function isModifiedGlobal(variable) {
    return variable == null || variable.defs.length !== 0 || variable.references.some((r) => r.isWrite());
  }
  function isPassThrough(node) {
    const parent = node.parent;
    switch (parent && parent.type) {
      case "ConditionalExpression":
        return parent.consequent === node || parent.alternate === node;
      case "LogicalExpression":
        return true;
      case "SequenceExpression":
        return parent.expressions[parent.expressions.length - 1] === node;
      case "ChainExpression":
        return true;
      default:
        return false;
    }
  }
  var ReferenceTracker = class {
    constructor(globalScope, {
      mode = "strict",
      globalObjectNames = ["global", "globalThis", "self", "window"]
    } = {}) {
      this.variableStack = [];
      this.globalScope = globalScope;
      this.mode = mode;
      this.globalObjectNames = globalObjectNames.slice(0);
    }
    *iterateGlobalReferences(traceMap) {
      for (const key of Object.keys(traceMap)) {
        const nextTraceMap = traceMap[key];
        const path3 = [key];
        const variable = this.globalScope.set.get(key);
        if (isModifiedGlobal(variable)) {
          continue;
        }
        yield* this._iterateVariableReferences(variable, path3, nextTraceMap, true);
      }
      for (const key of this.globalObjectNames) {
        const path3 = [];
        const variable = this.globalScope.set.get(key);
        if (isModifiedGlobal(variable)) {
          continue;
        }
        yield* this._iterateVariableReferences(variable, path3, traceMap, false);
      }
    }
    *iterateCjsReferences(traceMap) {
      for (const {node} of this.iterateGlobalReferences(requireCall)) {
        const key = getStringIfConstant(node.arguments[0]);
        if (key == null || !has(traceMap, key)) {
          continue;
        }
        const nextTraceMap = traceMap[key];
        const path3 = [key];
        if (nextTraceMap[READ]) {
          yield {
            node,
            path: path3,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iteratePropertyReferences(node, path3, nextTraceMap);
      }
    }
    *iterateEsmReferences(traceMap) {
      const programNode = this.globalScope.block;
      for (const node of programNode.body) {
        if (!IMPORT_TYPE.test(node.type) || node.source == null) {
          continue;
        }
        const moduleId = node.source.value;
        if (!has(traceMap, moduleId)) {
          continue;
        }
        const nextTraceMap = traceMap[moduleId];
        const path3 = [moduleId];
        if (nextTraceMap[READ]) {
          yield {node, path: path3, type: READ, info: nextTraceMap[READ]};
        }
        if (node.type === "ExportAllDeclaration") {
          for (const key of Object.keys(nextTraceMap)) {
            const exportTraceMap = nextTraceMap[key];
            if (exportTraceMap[READ]) {
              yield {
                node,
                path: path3.concat(key),
                type: READ,
                info: exportTraceMap[READ]
              };
            }
          }
        } else {
          for (const specifier of node.specifiers) {
            const esm = has(nextTraceMap, ESM);
            const it2 = this._iterateImportReferences(specifier, path3, esm ? nextTraceMap : this.mode === "legacy" ? Object.assign({default: nextTraceMap}, nextTraceMap) : {default: nextTraceMap});
            if (esm) {
              yield* it2;
            } else {
              for (const report of it2) {
                report.path = report.path.filter(exceptDefault);
                if (report.path.length >= 2 || report.type !== READ) {
                  yield report;
                }
              }
            }
          }
        }
      }
    }
    *_iterateVariableReferences(variable, path3, traceMap, shouldReport) {
      if (this.variableStack.includes(variable)) {
        return;
      }
      this.variableStack.push(variable);
      try {
        for (const reference of variable.references) {
          if (!reference.isRead()) {
            continue;
          }
          const node = reference.identifier;
          if (shouldReport && traceMap[READ]) {
            yield {node, path: path3, type: READ, info: traceMap[READ]};
          }
          yield* this._iteratePropertyReferences(node, path3, traceMap);
        }
      } finally {
        this.variableStack.pop();
      }
    }
    *_iteratePropertyReferences(rootNode, path3, traceMap) {
      let node = rootNode;
      while (isPassThrough(node)) {
        node = node.parent;
      }
      const parent = node.parent;
      if (parent.type === "MemberExpression") {
        if (parent.object === node) {
          const key = getPropertyName(parent);
          if (key == null || !has(traceMap, key)) {
            return;
          }
          path3 = path3.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: parent,
              path: path3,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iteratePropertyReferences(parent, path3, nextTraceMap);
        }
        return;
      }
      if (parent.type === "CallExpression") {
        if (parent.callee === node && traceMap[CALL]) {
          yield {node: parent, path: path3, type: CALL, info: traceMap[CALL]};
        }
        return;
      }
      if (parent.type === "NewExpression") {
        if (parent.callee === node && traceMap[CONSTRUCT]) {
          yield {
            node: parent,
            path: path3,
            type: CONSTRUCT,
            info: traceMap[CONSTRUCT]
          };
        }
        return;
      }
      if (parent.type === "AssignmentExpression") {
        if (parent.right === node) {
          yield* this._iterateLhsReferences(parent.left, path3, traceMap);
          yield* this._iteratePropertyReferences(parent, path3, traceMap);
        }
        return;
      }
      if (parent.type === "AssignmentPattern") {
        if (parent.right === node) {
          yield* this._iterateLhsReferences(parent.left, path3, traceMap);
        }
        return;
      }
      if (parent.type === "VariableDeclarator") {
        if (parent.init === node) {
          yield* this._iterateLhsReferences(parent.id, path3, traceMap);
        }
      }
    }
    *_iterateLhsReferences(patternNode, path3, traceMap) {
      if (patternNode.type === "Identifier") {
        const variable = findVariable(this.globalScope, patternNode);
        if (variable != null) {
          yield* this._iterateVariableReferences(variable, path3, traceMap, false);
        }
        return;
      }
      if (patternNode.type === "ObjectPattern") {
        for (const property of patternNode.properties) {
          const key = getPropertyName(property);
          if (key == null || !has(traceMap, key)) {
            continue;
          }
          const nextPath = path3.concat(key);
          const nextTraceMap = traceMap[key];
          if (nextTraceMap[READ]) {
            yield {
              node: property,
              path: nextPath,
              type: READ,
              info: nextTraceMap[READ]
            };
          }
          yield* this._iterateLhsReferences(property.value, nextPath, nextTraceMap);
        }
        return;
      }
      if (patternNode.type === "AssignmentPattern") {
        yield* this._iterateLhsReferences(patternNode.left, path3, traceMap);
      }
    }
    *_iterateImportReferences(specifierNode, path3, traceMap) {
      const type = specifierNode.type;
      if (type === "ImportSpecifier" || type === "ImportDefaultSpecifier") {
        const key = type === "ImportDefaultSpecifier" ? "default" : specifierNode.imported.name;
        if (!has(traceMap, key)) {
          return;
        }
        path3 = path3.concat(key);
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: specifierNode,
            path: path3,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
        yield* this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path3, nextTraceMap, false);
        return;
      }
      if (type === "ImportNamespaceSpecifier") {
        yield* this._iterateVariableReferences(findVariable(this.globalScope, specifierNode.local), path3, traceMap, false);
        return;
      }
      if (type === "ExportSpecifier") {
        const key = specifierNode.local.name;
        if (!has(traceMap, key)) {
          return;
        }
        path3 = path3.concat(key);
        const nextTraceMap = traceMap[key];
        if (nextTraceMap[READ]) {
          yield {
            node: specifierNode,
            path: path3,
            type: READ,
            info: nextTraceMap[READ]
          };
        }
      }
    }
  };
  ReferenceTracker.READ = READ;
  ReferenceTracker.CALL = CALL;
  ReferenceTracker.CONSTRUCT = CONSTRUCT;
  ReferenceTracker.ESM = ESM;
  function exceptDefault(name, index2) {
    return !(index2 === 1 && name === "default");
  }
  var index = {
    CALL,
    CONSTRUCT,
    ESM,
    findVariable,
    getFunctionHeadLocation,
    getFunctionNameWithKind,
    getInnermostScope,
    getPropertyName,
    getStaticValue,
    getStringIfConstant,
    hasSideEffect,
    isArrowToken,
    isClosingBraceToken,
    isClosingBracketToken,
    isClosingParenToken,
    isColonToken,
    isCommaToken,
    isCommentToken,
    isNotArrowToken,
    isNotClosingBraceToken,
    isNotClosingBracketToken,
    isNotClosingParenToken,
    isNotColonToken,
    isNotCommaToken,
    isNotCommentToken,
    isNotOpeningBraceToken,
    isNotOpeningBracketToken,
    isNotOpeningParenToken,
    isNotSemicolonToken,
    isOpeningBraceToken,
    isOpeningBracketToken,
    isOpeningParenToken,
    isParenthesized,
    isSemicolonToken,
    PatternMatcher,
    READ,
    ReferenceTracker
  };
  exports2.CALL = CALL;
  exports2.CONSTRUCT = CONSTRUCT;
  exports2.ESM = ESM;
  exports2.PatternMatcher = PatternMatcher;
  exports2.READ = READ;
  exports2.ReferenceTracker = ReferenceTracker;
  exports2.default = index;
  exports2.findVariable = findVariable;
  exports2.getFunctionHeadLocation = getFunctionHeadLocation;
  exports2.getFunctionNameWithKind = getFunctionNameWithKind;
  exports2.getInnermostScope = getInnermostScope;
  exports2.getPropertyName = getPropertyName;
  exports2.getStaticValue = getStaticValue;
  exports2.getStringIfConstant = getStringIfConstant;
  exports2.hasSideEffect = hasSideEffect;
  exports2.isArrowToken = isArrowToken;
  exports2.isClosingBraceToken = isClosingBraceToken;
  exports2.isClosingBracketToken = isClosingBracketToken;
  exports2.isClosingParenToken = isClosingParenToken;
  exports2.isColonToken = isColonToken;
  exports2.isCommaToken = isCommaToken;
  exports2.isCommentToken = isCommentToken;
  exports2.isNotArrowToken = isNotArrowToken;
  exports2.isNotClosingBraceToken = isNotClosingBraceToken;
  exports2.isNotClosingBracketToken = isNotClosingBracketToken;
  exports2.isNotClosingParenToken = isNotClosingParenToken;
  exports2.isNotColonToken = isNotColonToken;
  exports2.isNotCommaToken = isNotCommaToken;
  exports2.isNotCommentToken = isNotCommentToken;
  exports2.isNotOpeningBraceToken = isNotOpeningBraceToken;
  exports2.isNotOpeningBracketToken = isNotOpeningBracketToken;
  exports2.isNotOpeningParenToken = isNotOpeningParenToken;
  exports2.isNotSemicolonToken = isNotSemicolonToken;
  exports2.isOpeningBraceToken = isOpeningBraceToken;
  exports2.isOpeningBracketToken = isOpeningBracketToken;
  exports2.isOpeningParenToken = isOpeningParenToken;
  exports2.isParenthesized = isParenthesized;
  exports2.isSemicolonToken = isSemicolonToken;
});

// node_modules/eslint/lib/source-code/token-store/cursor.js
var require_cursor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = class Cursor {
    constructor() {
      this.current = null;
    }
    getOneToken() {
      return this.moveNext() ? this.current : null;
    }
    getAllTokens() {
      const tokens = [];
      while (this.moveNext()) {
        tokens.push(this.current);
      }
      return tokens;
    }
    moveNext() {
      throw new Error("Not implemented.");
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/utils.js
var require_utils6 = __commonJS((exports2) => {
  "use strict";
  var lodash = require_lodash();
  function getStartLocation(token) {
    return token.range[0];
  }
  exports2.search = function search(tokens, location) {
    return lodash.sortedIndexBy(tokens, {range: [location]}, getStartLocation);
  };
  exports2.getFirstIndex = function getFirstIndex(tokens, indexMap, startLoc) {
    if (startLoc in indexMap) {
      return indexMap[startLoc];
    }
    if (startLoc - 1 in indexMap) {
      const index = indexMap[startLoc - 1];
      const token = index >= 0 && index < tokens.length ? tokens[index] : null;
      if (token && token.range[0] >= startLoc) {
        return index;
      }
      return index + 1;
    }
    return 0;
  };
  exports2.getLastIndex = function getLastIndex(tokens, indexMap, endLoc) {
    if (endLoc in indexMap) {
      return indexMap[endLoc] - 1;
    }
    if (endLoc - 1 in indexMap) {
      const index = indexMap[endLoc - 1];
      const token = index >= 0 && index < tokens.length ? tokens[index] : null;
      if (token && token.range[1] > endLoc) {
        return index - 1;
      }
      return index;
    }
    return tokens.length - 1;
  };
});

// node_modules/eslint/lib/source-code/token-store/backward-token-comment-cursor.js
var require_backward_token_comment_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Cursor = require_cursor();
  var utils = require_utils6();
  module2.exports = class BackwardTokenCommentCursor extends Cursor {
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.comments = comments;
      this.tokenIndex = utils.getLastIndex(tokens, indexMap, endLoc);
      this.commentIndex = utils.search(comments, endLoc) - 1;
      this.border = startLoc;
    }
    moveNext() {
      const token = this.tokenIndex >= 0 ? this.tokens[this.tokenIndex] : null;
      const comment = this.commentIndex >= 0 ? this.comments[this.commentIndex] : null;
      if (token && (!comment || token.range[1] > comment.range[1])) {
        this.current = token;
        this.tokenIndex -= 1;
      } else if (comment) {
        this.current = comment;
        this.commentIndex -= 1;
      } else {
        this.current = null;
      }
      return Boolean(this.current) && (this.border === -1 || this.current.range[0] >= this.border);
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/backward-token-cursor.js
var require_backward_token_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Cursor = require_cursor();
  var utils = require_utils6();
  module2.exports = class BackwardTokenCursor extends Cursor {
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.index = utils.getLastIndex(tokens, indexMap, endLoc);
      this.indexEnd = utils.getFirstIndex(tokens, indexMap, startLoc);
    }
    moveNext() {
      if (this.index >= this.indexEnd) {
        this.current = this.tokens[this.index];
        this.index -= 1;
        return true;
      }
      return false;
    }
    getOneToken() {
      return this.index >= this.indexEnd ? this.tokens[this.index] : null;
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/decorative-cursor.js
var require_decorative_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Cursor = require_cursor();
  module2.exports = class DecorativeCursor extends Cursor {
    constructor(cursor) {
      super();
      this.cursor = cursor;
    }
    moveNext() {
      const retv = this.cursor.moveNext();
      this.current = this.cursor.current;
      return retv;
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/filter-cursor.js
var require_filter_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var DecorativeCursor = require_decorative_cursor();
  module2.exports = class FilterCursor extends DecorativeCursor {
    constructor(cursor, predicate) {
      super(cursor);
      this.predicate = predicate;
    }
    moveNext() {
      const predicate = this.predicate;
      while (super.moveNext()) {
        if (predicate(this.current)) {
          return true;
        }
      }
      return false;
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/forward-token-comment-cursor.js
var require_forward_token_comment_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Cursor = require_cursor();
  var utils = require_utils6();
  module2.exports = class ForwardTokenCommentCursor extends Cursor {
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.comments = comments;
      this.tokenIndex = utils.getFirstIndex(tokens, indexMap, startLoc);
      this.commentIndex = utils.search(comments, startLoc);
      this.border = endLoc;
    }
    moveNext() {
      const token = this.tokenIndex < this.tokens.length ? this.tokens[this.tokenIndex] : null;
      const comment = this.commentIndex < this.comments.length ? this.comments[this.commentIndex] : null;
      if (token && (!comment || token.range[0] < comment.range[0])) {
        this.current = token;
        this.tokenIndex += 1;
      } else if (comment) {
        this.current = comment;
        this.commentIndex += 1;
      } else {
        this.current = null;
      }
      return Boolean(this.current) && (this.border === -1 || this.current.range[1] <= this.border);
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/forward-token-cursor.js
var require_forward_token_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var Cursor = require_cursor();
  var utils = require_utils6();
  module2.exports = class ForwardTokenCursor extends Cursor {
    constructor(tokens, comments, indexMap, startLoc, endLoc) {
      super();
      this.tokens = tokens;
      this.index = utils.getFirstIndex(tokens, indexMap, startLoc);
      this.indexEnd = utils.getLastIndex(tokens, indexMap, endLoc);
    }
    moveNext() {
      if (this.index <= this.indexEnd) {
        this.current = this.tokens[this.index];
        this.index += 1;
        return true;
      }
      return false;
    }
    getOneToken() {
      return this.index <= this.indexEnd ? this.tokens[this.index] : null;
    }
    getAllTokens() {
      return this.tokens.slice(this.index, this.indexEnd + 1);
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/limit-cursor.js
var require_limit_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var DecorativeCursor = require_decorative_cursor();
  module2.exports = class LimitCursor extends DecorativeCursor {
    constructor(cursor, count) {
      super(cursor);
      this.count = count;
    }
    moveNext() {
      if (this.count > 0) {
        this.count -= 1;
        return super.moveNext();
      }
      return false;
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/skip-cursor.js
var require_skip_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var DecorativeCursor = require_decorative_cursor();
  module2.exports = class SkipCursor extends DecorativeCursor {
    constructor(cursor, count) {
      super(cursor);
      this.count = count;
    }
    moveNext() {
      while (this.count > 0) {
        this.count -= 1;
        if (!super.moveNext()) {
          return false;
        }
      }
      return super.moveNext();
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/cursors.js
var require_cursors = __commonJS((exports2) => {
  "use strict";
  var BackwardTokenCommentCursor = require_backward_token_comment_cursor();
  var BackwardTokenCursor = require_backward_token_cursor();
  var FilterCursor = require_filter_cursor();
  var ForwardTokenCommentCursor = require_forward_token_comment_cursor();
  var ForwardTokenCursor = require_forward_token_cursor();
  var LimitCursor = require_limit_cursor();
  var SkipCursor = require_skip_cursor();
  var CursorFactory = class {
    constructor(TokenCursor, TokenCommentCursor) {
      this.TokenCursor = TokenCursor;
      this.TokenCommentCursor = TokenCommentCursor;
    }
    createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments) {
      const Cursor = includeComments ? this.TokenCommentCursor : this.TokenCursor;
      return new Cursor(tokens, comments, indexMap, startLoc, endLoc);
    }
    createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, count) {
      let cursor = this.createBaseCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments);
      if (filter) {
        cursor = new FilterCursor(cursor, filter);
      }
      if (skip >= 1) {
        cursor = new SkipCursor(cursor, skip);
      }
      if (count >= 0) {
        cursor = new LimitCursor(cursor, count);
      }
      return cursor;
    }
  };
  exports2.forward = new CursorFactory(ForwardTokenCursor, ForwardTokenCommentCursor);
  exports2.backward = new CursorFactory(BackwardTokenCursor, BackwardTokenCommentCursor);
});

// node_modules/eslint/lib/source-code/token-store/padded-token-cursor.js
var require_padded_token_cursor = __commonJS((exports2, module2) => {
  "use strict";
  var ForwardTokenCursor = require_forward_token_cursor();
  module2.exports = class PaddedTokenCursor extends ForwardTokenCursor {
    constructor(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
      super(tokens, comments, indexMap, startLoc, endLoc);
      this.index = Math.max(0, this.index - beforeCount);
      this.indexEnd = Math.min(tokens.length - 1, this.indexEnd + afterCount);
    }
  };
});

// node_modules/eslint/lib/source-code/token-store/index.js
var require_token_store = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var {isCommentToken} = require_eslint_utils();
  var cursors = require_cursors();
  var ForwardTokenCursor = require_forward_token_cursor();
  var PaddedTokenCursor = require_padded_token_cursor();
  var utils = require_utils6();
  var TOKENS = Symbol("tokens");
  var COMMENTS = Symbol("comments");
  var INDEX_MAP = Symbol("indexMap");
  function createIndexMap(tokens, comments) {
    const map = Object.create(null);
    let tokenIndex = 0;
    let commentIndex = 0;
    let nextStart = 0;
    let range = null;
    while (tokenIndex < tokens.length || commentIndex < comments.length) {
      nextStart = commentIndex < comments.length ? comments[commentIndex].range[0] : Number.MAX_SAFE_INTEGER;
      while (tokenIndex < tokens.length && (range = tokens[tokenIndex].range)[0] < nextStart) {
        map[range[0]] = tokenIndex;
        map[range[1] - 1] = tokenIndex;
        tokenIndex += 1;
      }
      nextStart = tokenIndex < tokens.length ? tokens[tokenIndex].range[0] : Number.MAX_SAFE_INTEGER;
      while (commentIndex < comments.length && (range = comments[commentIndex].range)[0] < nextStart) {
        map[range[0]] = tokenIndex;
        map[range[1] - 1] = tokenIndex;
        commentIndex += 1;
      }
    }
    return map;
  }
  function createCursorWithSkip(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
    let includeComments = false;
    let skip = 0;
    let filter = null;
    if (typeof opts === "number") {
      skip = opts | 0;
    } else if (typeof opts === "function") {
      filter = opts;
    } else if (opts) {
      includeComments = !!opts.includeComments;
      skip = opts.skip | 0;
      filter = opts.filter || null;
    }
    assert(skip >= 0, "options.skip should be zero or a positive integer.");
    assert(!filter || typeof filter === "function", "options.filter should be a function.");
    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, skip, -1);
  }
  function createCursorWithCount(factory, tokens, comments, indexMap, startLoc, endLoc, opts) {
    let includeComments = false;
    let count = 0;
    let countExists = false;
    let filter = null;
    if (typeof opts === "number") {
      count = opts | 0;
      countExists = true;
    } else if (typeof opts === "function") {
      filter = opts;
    } else if (opts) {
      includeComments = !!opts.includeComments;
      count = opts.count | 0;
      countExists = typeof opts.count === "number";
      filter = opts.filter || null;
    }
    assert(count >= 0, "options.count should be zero or a positive integer.");
    assert(!filter || typeof filter === "function", "options.filter should be a function.");
    return factory.createCursor(tokens, comments, indexMap, startLoc, endLoc, includeComments, filter, 0, countExists ? count : -1);
  }
  function createCursorWithPadding(tokens, comments, indexMap, startLoc, endLoc, beforeCount, afterCount) {
    if (typeof beforeCount === "undefined" && typeof afterCount === "undefined") {
      return new ForwardTokenCursor(tokens, comments, indexMap, startLoc, endLoc);
    }
    if (typeof beforeCount === "number" || typeof beforeCount === "undefined") {
      return new PaddedTokenCursor(tokens, comments, indexMap, startLoc, endLoc, beforeCount | 0, afterCount | 0);
    }
    return createCursorWithCount(cursors.forward, tokens, comments, indexMap, startLoc, endLoc, beforeCount);
  }
  function getAdjacentCommentTokensFromCursor(cursor) {
    const tokens = [];
    let currentToken = cursor.getOneToken();
    while (currentToken && isCommentToken(currentToken)) {
      tokens.push(currentToken);
      currentToken = cursor.getOneToken();
    }
    return tokens;
  }
  module2.exports = class TokenStore {
    constructor(tokens, comments) {
      this[TOKENS] = tokens;
      this[COMMENTS] = comments;
      this[INDEX_MAP] = createIndexMap(tokens, comments);
    }
    getTokenByRangeStart(offset, options) {
      const includeComments = options && options.includeComments;
      const token = cursors.forward.createBaseCursor(this[TOKENS], this[COMMENTS], this[INDEX_MAP], offset, -1, includeComments).getOneToken();
      if (token && token.range[0] === offset) {
        return token;
      }
      return null;
    }
    getFirstToken(node, options) {
      return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
    }
    getLastToken(node, options) {
      return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getOneToken();
    }
    getTokenBefore(node, options) {
      return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getOneToken();
    }
    getTokenAfter(node, options) {
      return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getOneToken();
    }
    getFirstTokenBetween(left, right, options) {
      return createCursorWithSkip(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
    }
    getLastTokenBetween(left, right, options) {
      return createCursorWithSkip(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getOneToken();
    }
    getTokenOrCommentBefore(node, skip) {
      return this.getTokenBefore(node, {includeComments: true, skip});
    }
    getTokenOrCommentAfter(node, skip) {
      return this.getTokenAfter(node, {includeComments: true, skip});
    }
    getFirstTokens(node, options) {
      return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens();
    }
    getLastTokens(node, options) {
      return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], options).getAllTokens().reverse();
    }
    getTokensBefore(node, options) {
      return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, node.range[0], options).getAllTokens().reverse();
    }
    getTokensAfter(node, options) {
      return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[1], -1, options).getAllTokens();
    }
    getFirstTokensBetween(left, right, options) {
      return createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens();
    }
    getLastTokensBetween(left, right, options) {
      return createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], options).getAllTokens().reverse();
    }
    getTokens(node, beforeCount, afterCount) {
      return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], node.range[0], node.range[1], beforeCount, afterCount).getAllTokens();
    }
    getTokensBetween(left, right, padding) {
      return createCursorWithPadding(this[TOKENS], this[COMMENTS], this[INDEX_MAP], left.range[1], right.range[0], padding, padding).getAllTokens();
    }
    commentsExistBetween(left, right) {
      const index = utils.search(this[COMMENTS], left.range[1]);
      return index < this[COMMENTS].length && this[COMMENTS][index].range[1] <= right.range[0];
    }
    getCommentsBefore(nodeOrToken) {
      const cursor = createCursorWithCount(cursors.backward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], -1, nodeOrToken.range[0], {includeComments: true});
      return getAdjacentCommentTokensFromCursor(cursor).reverse();
    }
    getCommentsAfter(nodeOrToken) {
      const cursor = createCursorWithCount(cursors.forward, this[TOKENS], this[COMMENTS], this[INDEX_MAP], nodeOrToken.range[1], -1, {includeComments: true});
      return getAdjacentCommentTokensFromCursor(cursor);
    }
    getCommentsInside(node) {
      return this.getTokens(node, {
        includeComments: true,
        filter: isCommentToken
      });
    }
  };
});

// node_modules/eslint/lib/source-code/source-code.js
var require_source_code = __commonJS((exports2, module2) => {
  "use strict";
  var {isCommentToken} = require_eslint_utils();
  var TokenStore = require_token_store();
  var astUtils = require_ast_utils();
  var Traverser = require_traverser();
  var lodash = require_lodash();
  function validate(ast) {
    if (!ast.tokens) {
      throw new Error("AST is missing the tokens array.");
    }
    if (!ast.comments) {
      throw new Error("AST is missing the comments array.");
    }
    if (!ast.loc) {
      throw new Error("AST is missing location information.");
    }
    if (!ast.range) {
      throw new Error("AST is missing range information");
    }
  }
  function looksLikeExport(astNode) {
    return astNode.type === "ExportDefaultDeclaration" || astNode.type === "ExportNamedDeclaration" || astNode.type === "ExportAllDeclaration" || astNode.type === "ExportSpecifier";
  }
  function sortedMerge(tokens, comments) {
    const result = [];
    let tokenIndex = 0;
    let commentIndex = 0;
    while (tokenIndex < tokens.length || commentIndex < comments.length) {
      if (commentIndex >= comments.length || tokenIndex < tokens.length && tokens[tokenIndex].range[0] < comments[commentIndex].range[0]) {
        result.push(tokens[tokenIndex++]);
      } else {
        result.push(comments[commentIndex++]);
      }
    }
    return result;
  }
  function nodesOrTokensOverlap(first, second) {
    return first.range[0] <= second.range[0] && first.range[1] >= second.range[0] || second.range[0] <= first.range[0] && second.range[1] >= first.range[0];
  }
  function isSpaceBetween(sourceCode, first, second, checkInsideOfJSXText) {
    if (nodesOrTokensOverlap(first, second)) {
      return false;
    }
    const [startingNodeOrToken, endingNodeOrToken] = first.range[1] <= second.range[0] ? [first, second] : [second, first];
    const firstToken = sourceCode.getLastToken(startingNodeOrToken) || startingNodeOrToken;
    const finalToken = sourceCode.getFirstToken(endingNodeOrToken) || endingNodeOrToken;
    let currentToken = firstToken;
    while (currentToken !== finalToken) {
      const nextToken = sourceCode.getTokenAfter(currentToken, {includeComments: true});
      if (currentToken.range[1] !== nextToken.range[0] || checkInsideOfJSXText && nextToken !== finalToken && nextToken.type === "JSXText" && /\s/u.test(nextToken.value)) {
        return true;
      }
      currentToken = nextToken;
    }
    return false;
  }
  var SourceCode = class extends TokenStore {
    constructor(textOrConfig, astIfNoConfig) {
      let text, ast, parserServices, scopeManager, visitorKeys;
      if (typeof textOrConfig === "string") {
        text = textOrConfig;
        ast = astIfNoConfig;
      } else if (typeof textOrConfig === "object" && textOrConfig !== null) {
        text = textOrConfig.text;
        ast = textOrConfig.ast;
        parserServices = textOrConfig.parserServices;
        scopeManager = textOrConfig.scopeManager;
        visitorKeys = textOrConfig.visitorKeys;
      }
      validate(ast);
      super(ast.tokens, ast.comments);
      this.hasBOM = text.charCodeAt(0) === 65279;
      this.text = this.hasBOM ? text.slice(1) : text;
      this.ast = ast;
      this.parserServices = parserServices || {};
      this.scopeManager = scopeManager || null;
      this.visitorKeys = visitorKeys || Traverser.DEFAULT_VISITOR_KEYS;
      const shebangMatched = this.text.match(astUtils.shebangPattern);
      const hasShebang = shebangMatched && ast.comments.length && ast.comments[0].value === shebangMatched[1];
      if (hasShebang) {
        ast.comments[0].type = "Shebang";
      }
      this.tokensAndComments = sortedMerge(ast.tokens, ast.comments);
      this.lines = [];
      this.lineStartIndices = [0];
      const lineEndingPattern = astUtils.createGlobalLinebreakMatcher();
      let match;
      while (match = lineEndingPattern.exec(this.text)) {
        this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1], match.index));
        this.lineStartIndices.push(match.index + match[0].length);
      }
      this.lines.push(this.text.slice(this.lineStartIndices[this.lineStartIndices.length - 1]));
      this._commentCache = new WeakMap();
      Object.freeze(this);
      Object.freeze(this.lines);
    }
    static splitLines(text) {
      return text.split(astUtils.createGlobalLinebreakMatcher());
    }
    getText(node, beforeCount, afterCount) {
      if (node) {
        return this.text.slice(Math.max(node.range[0] - (beforeCount || 0), 0), node.range[1] + (afterCount || 0));
      }
      return this.text;
    }
    getLines() {
      return this.lines;
    }
    getAllComments() {
      return this.ast.comments;
    }
    getComments(node) {
      if (this._commentCache.has(node)) {
        return this._commentCache.get(node);
      }
      const comments = {
        leading: [],
        trailing: []
      };
      if (node.type === "Program") {
        if (node.body.length === 0) {
          comments.leading = node.comments;
        }
      } else {
        if ((node.type === "BlockStatement" || node.type === "ClassBody") && node.body.length === 0 || node.type === "ObjectExpression" && node.properties.length === 0 || node.type === "ArrayExpression" && node.elements.length === 0 || node.type === "SwitchStatement" && node.cases.length === 0) {
          comments.trailing = this.getTokens(node, {
            includeComments: true,
            filter: isCommentToken
          });
        }
        let currentToken = this.getTokenBefore(node, {includeComments: true});
        while (currentToken && isCommentToken(currentToken)) {
          if (node.parent && currentToken.start < node.parent.start) {
            break;
          }
          comments.leading.push(currentToken);
          currentToken = this.getTokenBefore(currentToken, {includeComments: true});
        }
        comments.leading.reverse();
        currentToken = this.getTokenAfter(node, {includeComments: true});
        while (currentToken && isCommentToken(currentToken)) {
          if (node.parent && currentToken.end > node.parent.end) {
            break;
          }
          comments.trailing.push(currentToken);
          currentToken = this.getTokenAfter(currentToken, {includeComments: true});
        }
      }
      this._commentCache.set(node, comments);
      return comments;
    }
    getJSDocComment(node) {
      const findJSDocComment = (astNode) => {
        const tokenBefore = this.getTokenBefore(astNode, {includeComments: true});
        if (tokenBefore && isCommentToken(tokenBefore) && tokenBefore.type === "Block" && tokenBefore.value.charAt(0) === "*" && astNode.loc.start.line - tokenBefore.loc.end.line <= 1) {
          return tokenBefore;
        }
        return null;
      };
      let parent = node.parent;
      switch (node.type) {
        case "ClassDeclaration":
        case "FunctionDeclaration":
          return findJSDocComment(looksLikeExport(parent) ? parent : node);
        case "ClassExpression":
          return findJSDocComment(parent.parent);
        case "ArrowFunctionExpression":
        case "FunctionExpression":
          if (parent.type !== "CallExpression" && parent.type !== "NewExpression") {
            while (!this.getCommentsBefore(parent).length && !/Function/u.test(parent.type) && parent.type !== "MethodDefinition" && parent.type !== "Property") {
              parent = parent.parent;
              if (!parent) {
                break;
              }
            }
            if (parent && parent.type !== "FunctionDeclaration" && parent.type !== "Program") {
              return findJSDocComment(parent);
            }
          }
          return findJSDocComment(node);
        default:
          return null;
      }
    }
    getNodeByRangeIndex(index) {
      let result = null;
      Traverser.traverse(this.ast, {
        visitorKeys: this.visitorKeys,
        enter(node) {
          if (node.range[0] <= index && index < node.range[1]) {
            result = node;
          } else {
            this.skip();
          }
        },
        leave(node) {
          if (node === result) {
            this.break();
          }
        }
      });
      return result;
    }
    isSpaceBetween(first, second) {
      return isSpaceBetween(this, first, second, false);
    }
    isSpaceBetweenTokens(first, second) {
      return isSpaceBetween(this, first, second, true);
    }
    getLocFromIndex(index) {
      if (typeof index !== "number") {
        throw new TypeError("Expected `index` to be a number.");
      }
      if (index < 0 || index > this.text.length) {
        throw new RangeError(`Index out of range (requested index ${index}, but source text has length ${this.text.length}).`);
      }
      if (index === this.text.length) {
        return {line: this.lines.length, column: this.lines[this.lines.length - 1].length};
      }
      const lineNumber = lodash.sortedLastIndex(this.lineStartIndices, index);
      return {line: lineNumber, column: index - this.lineStartIndices[lineNumber - 1]};
    }
    getIndexFromLoc(loc) {
      if (typeof loc !== "object" || typeof loc.line !== "number" || typeof loc.column !== "number") {
        throw new TypeError("Expected `loc` to be an object with numeric `line` and `column` properties.");
      }
      if (loc.line <= 0) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested). Line numbers should be 1-based.`);
      }
      if (loc.line > this.lineStartIndices.length) {
        throw new RangeError(`Line number out of range (line ${loc.line} requested, but only ${this.lineStartIndices.length} lines present).`);
      }
      const lineStartIndex = this.lineStartIndices[loc.line - 1];
      const lineEndIndex = loc.line === this.lineStartIndices.length ? this.text.length : this.lineStartIndices[loc.line];
      const positionIndex = lineStartIndex + loc.column;
      if (loc.line === this.lineStartIndices.length && positionIndex > lineEndIndex || loc.line < this.lineStartIndices.length && positionIndex >= lineEndIndex) {
        throw new RangeError(`Column number out of range (column ${loc.column} requested, but the length of line ${loc.line} is ${lineEndIndex - lineStartIndex}).`);
      }
      return positionIndex;
    }
  };
  module2.exports = SourceCode;
});

// node_modules/eslint/lib/source-code/index.js
var require_source_code2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    SourceCode: require_source_code()
  };
});

// node_modules/eslint/lib/linter/code-path-analysis/debug-helpers.js
var require_debug_helpers = __commonJS((exports2, module2) => {
  "use strict";
  var debug5 = require_src()("eslint:code-path");
  function getId(segment) {
    return segment.id + (segment.reachable ? "" : "!");
  }
  function nodeToString(node, label) {
    const suffix = label ? `:${label}` : "";
    switch (node.type) {
      case "Identifier":
        return `${node.type}${suffix} (${node.name})`;
      case "Literal":
        return `${node.type}${suffix} (${node.value})`;
      default:
        return `${node.type}${suffix}`;
    }
  }
  module2.exports = {
    enabled: debug5.enabled,
    dump: debug5,
    dumpState: !debug5.enabled ? debug5 : function(node, state, leaving) {
      for (let i = 0; i < state.currentSegments.length; ++i) {
        const segInternal = state.currentSegments[i].internal;
        if (leaving) {
          const last = segInternal.nodes.length - 1;
          if (last >= 0 && segInternal.nodes[last] === nodeToString(node, "enter")) {
            segInternal.nodes[last] = nodeToString(node, void 0);
          } else {
            segInternal.nodes.push(nodeToString(node, "exit"));
          }
        } else {
          segInternal.nodes.push(nodeToString(node, "enter"));
        }
      }
      debug5([
        `${state.currentSegments.map(getId).join(",")})`,
        `${node.type}${leaving ? ":exit" : ""}`
      ].join(" "));
    },
    dumpDot: !debug5.enabled ? debug5 : function(codePath) {
      let text = '\ndigraph {\nnode[shape=box,style="rounded,filled",fillcolor=white];\ninitial[label="",shape=circle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
      if (codePath.returnedSegments.length > 0) {
        text += 'final[label="",shape=doublecircle,style=filled,fillcolor=black,width=0.25,height=0.25];\n';
      }
      if (codePath.thrownSegments.length > 0) {
        text += 'thrown[label="\u2718",shape=circle,width=0.3,height=0.3,fixedsize];\n';
      }
      const traceMap = Object.create(null);
      const arrows = this.makeDotArrows(codePath, traceMap);
      for (const id in traceMap) {
        const segment = traceMap[id];
        text += `${id}[`;
        if (segment.reachable) {
          text += 'label="';
        } else {
          text += 'style="rounded,dashed,filled",fillcolor="#FF9800",label="<<unreachable>>\\n';
        }
        if (segment.internal.nodes.length > 0) {
          text += segment.internal.nodes.join("\\n");
        } else {
          text += "????";
        }
        text += '"];\n';
      }
      text += `${arrows}
`;
      text += "}";
      debug5("DOT", text);
    },
    makeDotArrows(codePath, traceMap) {
      const stack = [[codePath.initialSegment, 0]];
      const done = traceMap || Object.create(null);
      let lastId = codePath.initialSegment.id;
      let text = `initial->${codePath.initialSegment.id}`;
      while (stack.length > 0) {
        const item = stack.pop();
        const segment = item[0];
        const index = item[1];
        if (done[segment.id] && index === 0) {
          continue;
        }
        done[segment.id] = segment;
        const nextSegment = segment.allNextSegments[index];
        if (!nextSegment) {
          continue;
        }
        if (lastId === segment.id) {
          text += `->${nextSegment.id}`;
        } else {
          text += `;
${segment.id}->${nextSegment.id}`;
        }
        lastId = nextSegment.id;
        stack.unshift([segment, 1 + index]);
        stack.push([nextSegment, 0]);
      }
      codePath.returnedSegments.forEach((finalSegment) => {
        if (lastId === finalSegment.id) {
          text += "->final";
        } else {
          text += `;
${finalSegment.id}->final`;
        }
        lastId = null;
      });
      codePath.thrownSegments.forEach((finalSegment) => {
        if (lastId === finalSegment.id) {
          text += "->thrown";
        } else {
          text += `;
${finalSegment.id}->thrown`;
        }
        lastId = null;
      });
      return `${text};`;
    }
  };
});

// node_modules/eslint/lib/linter/code-path-analysis/code-path-segment.js
var require_code_path_segment = __commonJS((exports2, module2) => {
  "use strict";
  var debug5 = require_debug_helpers();
  function isReachable(segment) {
    return segment.reachable;
  }
  var CodePathSegment = class {
    constructor(id, allPrevSegments, reachable) {
      this.id = id;
      this.nextSegments = [];
      this.prevSegments = allPrevSegments.filter(isReachable);
      this.allNextSegments = [];
      this.allPrevSegments = allPrevSegments;
      this.reachable = reachable;
      Object.defineProperty(this, "internal", {
        value: {
          used: false,
          loopedPrevSegments: []
        }
      });
      if (debug5.enabled) {
        this.internal.nodes = [];
      }
    }
    isLoopedPrevSegment(segment) {
      return this.internal.loopedPrevSegments.indexOf(segment) !== -1;
    }
    static newRoot(id) {
      return new CodePathSegment(id, [], true);
    }
    static newNext(id, allPrevSegments) {
      return new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), allPrevSegments.some(isReachable));
    }
    static newUnreachable(id, allPrevSegments) {
      const segment = new CodePathSegment(id, CodePathSegment.flattenUnusedSegments(allPrevSegments), false);
      CodePathSegment.markUsed(segment);
      return segment;
    }
    static newDisconnected(id, allPrevSegments) {
      return new CodePathSegment(id, [], allPrevSegments.some(isReachable));
    }
    static markUsed(segment) {
      if (segment.internal.used) {
        return;
      }
      segment.internal.used = true;
      let i;
      if (segment.reachable) {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
          const prevSegment = segment.allPrevSegments[i];
          prevSegment.allNextSegments.push(segment);
          prevSegment.nextSegments.push(segment);
        }
      } else {
        for (i = 0; i < segment.allPrevSegments.length; ++i) {
          segment.allPrevSegments[i].allNextSegments.push(segment);
        }
      }
    }
    static markPrevSegmentAsLooped(segment, prevSegment) {
      segment.internal.loopedPrevSegments.push(prevSegment);
    }
    static flattenUnusedSegments(segments) {
      const done = Object.create(null);
      const retv = [];
      for (let i = 0; i < segments.length; ++i) {
        const segment = segments[i];
        if (done[segment.id]) {
          continue;
        }
        if (!segment.internal.used) {
          for (let j = 0; j < segment.allPrevSegments.length; ++j) {
            const prevSegment = segment.allPrevSegments[j];
            if (!done[prevSegment.id]) {
              done[prevSegment.id] = true;
              retv.push(prevSegment);
            }
          }
        } else {
          done[segment.id] = true;
          retv.push(segment);
        }
      }
      return retv;
    }
  };
  module2.exports = CodePathSegment;
});

// node_modules/eslint/lib/linter/code-path-analysis/fork-context.js
var require_fork_context = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var CodePathSegment = require_code_path_segment();
  function isReachable(segment) {
    return segment.reachable;
  }
  function makeSegments(context4, begin, end, create) {
    const list = context4.segmentsList;
    const normalizedBegin = begin >= 0 ? begin : list.length + begin;
    const normalizedEnd = end >= 0 ? end : list.length + end;
    const segments = [];
    for (let i = 0; i < context4.count; ++i) {
      const allPrevSegments = [];
      for (let j = normalizedBegin; j <= normalizedEnd; ++j) {
        allPrevSegments.push(list[j][i]);
      }
      segments.push(create(context4.idGenerator.next(), allPrevSegments));
    }
    return segments;
  }
  function mergeExtraSegments(context4, segments) {
    let currentSegments = segments;
    while (currentSegments.length > context4.count) {
      const merged = [];
      for (let i = 0, length = currentSegments.length / 2 | 0; i < length; ++i) {
        merged.push(CodePathSegment.newNext(context4.idGenerator.next(), [currentSegments[i], currentSegments[i + length]]));
      }
      currentSegments = merged;
    }
    return currentSegments;
  }
  var ForkContext = class {
    constructor(idGenerator, upper, count) {
      this.idGenerator = idGenerator;
      this.upper = upper;
      this.count = count;
      this.segmentsList = [];
    }
    get head() {
      const list = this.segmentsList;
      return list.length === 0 ? [] : list[list.length - 1];
    }
    get empty() {
      return this.segmentsList.length === 0;
    }
    get reachable() {
      const segments = this.head;
      return segments.length > 0 && segments.some(isReachable);
    }
    makeNext(begin, end) {
      return makeSegments(this, begin, end, CodePathSegment.newNext);
    }
    makeUnreachable(begin, end) {
      return makeSegments(this, begin, end, CodePathSegment.newUnreachable);
    }
    makeDisconnected(begin, end) {
      return makeSegments(this, begin, end, CodePathSegment.newDisconnected);
    }
    add(segments) {
      assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
      this.segmentsList.push(mergeExtraSegments(this, segments));
    }
    replaceHead(segments) {
      assert(segments.length >= this.count, `${segments.length} >= ${this.count}`);
      this.segmentsList.splice(-1, 1, mergeExtraSegments(this, segments));
    }
    addAll(context4) {
      assert(context4.count === this.count);
      const source = context4.segmentsList;
      for (let i = 0; i < source.length; ++i) {
        this.segmentsList.push(source[i]);
      }
    }
    clear() {
      this.segmentsList = [];
    }
    static newRoot(idGenerator) {
      const context4 = new ForkContext(idGenerator, null, 1);
      context4.add([CodePathSegment.newRoot(idGenerator.next())]);
      return context4;
    }
    static newEmpty(parentContext, forkLeavingPath) {
      return new ForkContext(parentContext.idGenerator, parentContext, (forkLeavingPath ? 2 : 1) * parentContext.count);
    }
  };
  module2.exports = ForkContext;
});

// node_modules/eslint/lib/linter/code-path-analysis/code-path-state.js
var require_code_path_state = __commonJS((exports2, module2) => {
  "use strict";
  var CodePathSegment = require_code_path_segment();
  var ForkContext = require_fork_context();
  function addToReturnedOrThrown(dest, others, all, segments) {
    for (let i = 0; i < segments.length; ++i) {
      const segment = segments[i];
      dest.push(segment);
      if (others.indexOf(segment) === -1) {
        all.push(segment);
      }
    }
  }
  function getContinueContext(state, label) {
    if (!label) {
      return state.loopContext;
    }
    let context4 = state.loopContext;
    while (context4) {
      if (context4.label === label) {
        return context4;
      }
      context4 = context4.upper;
    }
    return null;
  }
  function getBreakContext(state, label) {
    let context4 = state.breakContext;
    while (context4) {
      if (label ? context4.label === label : context4.breakable) {
        return context4;
      }
      context4 = context4.upper;
    }
    return null;
  }
  function getReturnContext(state) {
    let context4 = state.tryContext;
    while (context4) {
      if (context4.hasFinalizer && context4.position !== "finally") {
        return context4;
      }
      context4 = context4.upper;
    }
    return state;
  }
  function getThrowContext(state) {
    let context4 = state.tryContext;
    while (context4) {
      if (context4.position === "try" || context4.hasFinalizer && context4.position === "catch") {
        return context4;
      }
      context4 = context4.upper;
    }
    return state;
  }
  function remove(xs, x) {
    xs.splice(xs.indexOf(x), 1);
  }
  function removeConnection(prevSegments, nextSegments) {
    for (let i = 0; i < prevSegments.length; ++i) {
      const prevSegment = prevSegments[i];
      const nextSegment = nextSegments[i];
      remove(prevSegment.nextSegments, nextSegment);
      remove(prevSegment.allNextSegments, nextSegment);
      remove(nextSegment.prevSegments, prevSegment);
      remove(nextSegment.allPrevSegments, prevSegment);
    }
  }
  function makeLooped(state, unflattenedFromSegments, unflattenedToSegments) {
    const fromSegments = CodePathSegment.flattenUnusedSegments(unflattenedFromSegments);
    const toSegments = CodePathSegment.flattenUnusedSegments(unflattenedToSegments);
    const end = Math.min(fromSegments.length, toSegments.length);
    for (let i = 0; i < end; ++i) {
      const fromSegment = fromSegments[i];
      const toSegment = toSegments[i];
      if (toSegment.reachable) {
        fromSegment.nextSegments.push(toSegment);
      }
      if (fromSegment.reachable) {
        toSegment.prevSegments.push(fromSegment);
      }
      fromSegment.allNextSegments.push(toSegment);
      toSegment.allPrevSegments.push(fromSegment);
      if (toSegment.allPrevSegments.length >= 2) {
        CodePathSegment.markPrevSegmentAsLooped(toSegment, fromSegment);
      }
      state.notifyLooped(fromSegment, toSegment);
    }
  }
  function finalizeTestSegmentsOfFor(context4, choiceContext, head) {
    if (!choiceContext.processed) {
      choiceContext.trueForkContext.add(head);
      choiceContext.falseForkContext.add(head);
      choiceContext.qqForkContext.add(head);
    }
    if (context4.test !== true) {
      context4.brokenForkContext.addAll(choiceContext.falseForkContext);
    }
    context4.endOfTestSegments = choiceContext.trueForkContext.makeNext(0, -1);
  }
  var CodePathState = class {
    constructor(idGenerator, onLooped) {
      this.idGenerator = idGenerator;
      this.notifyLooped = onLooped;
      this.forkContext = ForkContext.newRoot(idGenerator);
      this.choiceContext = null;
      this.switchContext = null;
      this.tryContext = null;
      this.loopContext = null;
      this.breakContext = null;
      this.chainContext = null;
      this.currentSegments = [];
      this.initialSegment = this.forkContext.head[0];
      const final = this.finalSegments = [];
      const returned = this.returnedForkContext = [];
      const thrown = this.thrownForkContext = [];
      returned.add = addToReturnedOrThrown.bind(null, returned, thrown, final);
      thrown.add = addToReturnedOrThrown.bind(null, thrown, returned, final);
    }
    get headSegments() {
      return this.forkContext.head;
    }
    get parentForkContext() {
      const current = this.forkContext;
      return current && current.upper;
    }
    pushForkContext(forkLeavingPath) {
      this.forkContext = ForkContext.newEmpty(this.forkContext, forkLeavingPath);
      return this.forkContext;
    }
    popForkContext() {
      const lastContext = this.forkContext;
      this.forkContext = lastContext.upper;
      this.forkContext.replaceHead(lastContext.makeNext(0, -1));
      return lastContext;
    }
    forkPath() {
      this.forkContext.add(this.parentForkContext.makeNext(-1, -1));
    }
    forkBypassPath() {
      this.forkContext.add(this.parentForkContext.head);
    }
    pushChoiceContext(kind, isForkingAsResult) {
      this.choiceContext = {
        upper: this.choiceContext,
        kind,
        isForkingAsResult,
        trueForkContext: ForkContext.newEmpty(this.forkContext),
        falseForkContext: ForkContext.newEmpty(this.forkContext),
        qqForkContext: ForkContext.newEmpty(this.forkContext),
        processed: false
      };
    }
    popChoiceContext() {
      const context4 = this.choiceContext;
      this.choiceContext = context4.upper;
      const forkContext = this.forkContext;
      const headSegments = forkContext.head;
      switch (context4.kind) {
        case "&&":
        case "||":
        case "??":
          if (!context4.processed) {
            context4.trueForkContext.add(headSegments);
            context4.falseForkContext.add(headSegments);
            context4.qqForkContext.add(headSegments);
          }
          if (context4.isForkingAsResult) {
            const parentContext = this.choiceContext;
            parentContext.trueForkContext.addAll(context4.trueForkContext);
            parentContext.falseForkContext.addAll(context4.falseForkContext);
            parentContext.qqForkContext.addAll(context4.qqForkContext);
            parentContext.processed = true;
            return context4;
          }
          break;
        case "test":
          if (!context4.processed) {
            context4.trueForkContext.clear();
            context4.trueForkContext.add(headSegments);
          } else {
            context4.falseForkContext.clear();
            context4.falseForkContext.add(headSegments);
          }
          break;
        case "loop":
          return context4;
        default:
          throw new Error("unreachable");
      }
      const prevForkContext = context4.trueForkContext;
      prevForkContext.addAll(context4.falseForkContext);
      forkContext.replaceHead(prevForkContext.makeNext(0, -1));
      return context4;
    }
    makeLogicalRight() {
      const context4 = this.choiceContext;
      const forkContext = this.forkContext;
      if (context4.processed) {
        let prevForkContext;
        switch (context4.kind) {
          case "&&":
            prevForkContext = context4.trueForkContext;
            break;
          case "||":
            prevForkContext = context4.falseForkContext;
            break;
          case "??":
            prevForkContext = context4.qqForkContext;
            break;
          default:
            throw new Error("unreachable");
        }
        forkContext.replaceHead(prevForkContext.makeNext(0, -1));
        prevForkContext.clear();
        context4.processed = false;
      } else {
        switch (context4.kind) {
          case "&&":
            context4.falseForkContext.add(forkContext.head);
            break;
          case "||":
            context4.trueForkContext.add(forkContext.head);
            break;
          case "??":
            context4.trueForkContext.add(forkContext.head);
            context4.falseForkContext.add(forkContext.head);
            break;
          default:
            throw new Error("unreachable");
        }
        forkContext.replaceHead(forkContext.makeNext(-1, -1));
      }
    }
    makeIfConsequent() {
      const context4 = this.choiceContext;
      const forkContext = this.forkContext;
      if (!context4.processed) {
        context4.trueForkContext.add(forkContext.head);
        context4.falseForkContext.add(forkContext.head);
        context4.qqForkContext.add(forkContext.head);
      }
      context4.processed = false;
      forkContext.replaceHead(context4.trueForkContext.makeNext(0, -1));
    }
    makeIfAlternate() {
      const context4 = this.choiceContext;
      const forkContext = this.forkContext;
      context4.trueForkContext.clear();
      context4.trueForkContext.add(forkContext.head);
      context4.processed = true;
      forkContext.replaceHead(context4.falseForkContext.makeNext(0, -1));
    }
    pushChainContext() {
      this.chainContext = {
        upper: this.chainContext,
        countChoiceContexts: 0
      };
    }
    popChainContext() {
      const context4 = this.chainContext;
      this.chainContext = context4.upper;
      for (let i = context4.countChoiceContexts; i > 0; --i) {
        this.popChoiceContext();
      }
    }
    makeOptionalNode() {
      if (this.chainContext) {
        this.chainContext.countChoiceContexts += 1;
        this.pushChoiceContext("??", false);
      }
    }
    makeOptionalRight() {
      if (this.chainContext) {
        this.makeLogicalRight();
      }
    }
    pushSwitchContext(hasCase, label) {
      this.switchContext = {
        upper: this.switchContext,
        hasCase,
        defaultSegments: null,
        defaultBodySegments: null,
        foundDefault: false,
        lastIsDefault: false,
        countForks: 0
      };
      this.pushBreakContext(true, label);
    }
    popSwitchContext() {
      const context4 = this.switchContext;
      this.switchContext = context4.upper;
      const forkContext = this.forkContext;
      const brokenForkContext = this.popBreakContext().brokenForkContext;
      if (context4.countForks === 0) {
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext.makeNext(-1, -1));
          forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
        return;
      }
      const lastSegments = forkContext.head;
      this.forkBypassPath();
      const lastCaseSegments = forkContext.head;
      brokenForkContext.add(lastSegments);
      if (!context4.lastIsDefault) {
        if (context4.defaultBodySegments) {
          removeConnection(context4.defaultSegments, context4.defaultBodySegments);
          makeLooped(this, lastCaseSegments, context4.defaultBodySegments);
        } else {
          brokenForkContext.add(lastCaseSegments);
        }
      }
      for (let i = 0; i < context4.countForks; ++i) {
        this.forkContext = this.forkContext.upper;
      }
      this.forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
    }
    makeSwitchCaseBody(isEmpty, isDefault) {
      const context4 = this.switchContext;
      if (!context4.hasCase) {
        return;
      }
      const parentForkContext = this.forkContext;
      const forkContext = this.pushForkContext();
      forkContext.add(parentForkContext.makeNext(0, -1));
      if (isDefault) {
        context4.defaultSegments = parentForkContext.head;
        if (isEmpty) {
          context4.foundDefault = true;
        } else {
          context4.defaultBodySegments = forkContext.head;
        }
      } else {
        if (!isEmpty && context4.foundDefault) {
          context4.foundDefault = false;
          context4.defaultBodySegments = forkContext.head;
        }
      }
      context4.lastIsDefault = isDefault;
      context4.countForks += 1;
    }
    pushTryContext(hasFinalizer) {
      this.tryContext = {
        upper: this.tryContext,
        position: "try",
        hasFinalizer,
        returnedForkContext: hasFinalizer ? ForkContext.newEmpty(this.forkContext) : null,
        thrownForkContext: ForkContext.newEmpty(this.forkContext),
        lastOfTryIsReachable: false,
        lastOfCatchIsReachable: false
      };
    }
    popTryContext() {
      const context4 = this.tryContext;
      this.tryContext = context4.upper;
      if (context4.position === "catch") {
        this.popForkContext();
        return;
      }
      const returned = context4.returnedForkContext;
      const thrown = context4.thrownForkContext;
      if (returned.empty && thrown.empty) {
        return;
      }
      const headSegments = this.forkContext.head;
      this.forkContext = this.forkContext.upper;
      const normalSegments = headSegments.slice(0, headSegments.length / 2 | 0);
      const leavingSegments = headSegments.slice(headSegments.length / 2 | 0);
      if (!returned.empty) {
        getReturnContext(this).returnedForkContext.add(leavingSegments);
      }
      if (!thrown.empty) {
        getThrowContext(this).thrownForkContext.add(leavingSegments);
      }
      this.forkContext.replaceHead(normalSegments);
      if (!context4.lastOfTryIsReachable && !context4.lastOfCatchIsReachable) {
        this.forkContext.makeUnreachable();
      }
    }
    makeCatchBlock() {
      const context4 = this.tryContext;
      const forkContext = this.forkContext;
      const thrown = context4.thrownForkContext;
      context4.position = "catch";
      context4.thrownForkContext = ForkContext.newEmpty(forkContext);
      context4.lastOfTryIsReachable = forkContext.reachable;
      thrown.add(forkContext.head);
      const thrownSegments = thrown.makeNext(0, -1);
      this.pushForkContext();
      this.forkBypassPath();
      this.forkContext.add(thrownSegments);
    }
    makeFinallyBlock() {
      const context4 = this.tryContext;
      let forkContext = this.forkContext;
      const returned = context4.returnedForkContext;
      const thrown = context4.thrownForkContext;
      const headOfLeavingSegments = forkContext.head;
      if (context4.position === "catch") {
        this.popForkContext();
        forkContext = this.forkContext;
        context4.lastOfCatchIsReachable = forkContext.reachable;
      } else {
        context4.lastOfTryIsReachable = forkContext.reachable;
      }
      context4.position = "finally";
      if (returned.empty && thrown.empty) {
        return;
      }
      const segments = forkContext.makeNext(-1, -1);
      for (let i = 0; i < forkContext.count; ++i) {
        const prevSegsOfLeavingSegment = [headOfLeavingSegments[i]];
        for (let j = 0; j < returned.segmentsList.length; ++j) {
          prevSegsOfLeavingSegment.push(returned.segmentsList[j][i]);
        }
        for (let j = 0; j < thrown.segmentsList.length; ++j) {
          prevSegsOfLeavingSegment.push(thrown.segmentsList[j][i]);
        }
        segments.push(CodePathSegment.newNext(this.idGenerator.next(), prevSegsOfLeavingSegment));
      }
      this.pushForkContext(true);
      this.forkContext.add(segments);
    }
    makeFirstThrowablePathInTryBlock() {
      const forkContext = this.forkContext;
      if (!forkContext.reachable) {
        return;
      }
      const context4 = getThrowContext(this);
      if (context4 === this || context4.position !== "try" || !context4.thrownForkContext.empty) {
        return;
      }
      context4.thrownForkContext.add(forkContext.head);
      forkContext.replaceHead(forkContext.makeNext(-1, -1));
    }
    pushLoopContext(type, label) {
      const forkContext = this.forkContext;
      const breakContext = this.pushBreakContext(true, label);
      switch (type) {
        case "WhileStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
          break;
        case "DoWhileStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            entrySegments: null,
            continueForkContext: ForkContext.newEmpty(forkContext),
            brokenForkContext: breakContext.brokenForkContext
          };
          break;
        case "ForStatement":
          this.pushChoiceContext("loop", false);
          this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            test: void 0,
            endOfInitSegments: null,
            testSegments: null,
            endOfTestSegments: null,
            updateSegments: null,
            endOfUpdateSegments: null,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
          break;
        case "ForInStatement":
        case "ForOfStatement":
          this.loopContext = {
            upper: this.loopContext,
            type,
            label,
            prevSegments: null,
            leftSegments: null,
            endOfLeftSegments: null,
            continueDestSegments: null,
            brokenForkContext: breakContext.brokenForkContext
          };
          break;
        default:
          throw new Error(`unknown type: "${type}"`);
      }
    }
    popLoopContext() {
      const context4 = this.loopContext;
      this.loopContext = context4.upper;
      const forkContext = this.forkContext;
      const brokenForkContext = this.popBreakContext().brokenForkContext;
      switch (context4.type) {
        case "WhileStatement":
        case "ForStatement":
          this.popChoiceContext();
          makeLooped(this, forkContext.head, context4.continueDestSegments);
          break;
        case "DoWhileStatement": {
          const choiceContext = this.popChoiceContext();
          if (!choiceContext.processed) {
            choiceContext.trueForkContext.add(forkContext.head);
            choiceContext.falseForkContext.add(forkContext.head);
          }
          if (context4.test !== true) {
            brokenForkContext.addAll(choiceContext.falseForkContext);
          }
          const segmentsList = choiceContext.trueForkContext.segmentsList;
          for (let i = 0; i < segmentsList.length; ++i) {
            makeLooped(this, segmentsList[i], context4.entrySegments);
          }
          break;
        }
        case "ForInStatement":
        case "ForOfStatement":
          brokenForkContext.add(forkContext.head);
          makeLooped(this, forkContext.head, context4.leftSegments);
          break;
        default:
          throw new Error("unreachable");
      }
      if (brokenForkContext.empty) {
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      } else {
        forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
      }
    }
    makeWhileTest(test) {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const testSegments = forkContext.makeNext(0, -1);
      context4.test = test;
      context4.continueDestSegments = testSegments;
      forkContext.replaceHead(testSegments);
    }
    makeWhileBody() {
      const context4 = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext = this.forkContext;
      if (!choiceContext.processed) {
        choiceContext.trueForkContext.add(forkContext.head);
        choiceContext.falseForkContext.add(forkContext.head);
      }
      if (context4.test !== true) {
        context4.brokenForkContext.addAll(choiceContext.falseForkContext);
      }
      forkContext.replaceHead(choiceContext.trueForkContext.makeNext(0, -1));
    }
    makeDoWhileBody() {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const bodySegments = forkContext.makeNext(-1, -1);
      context4.entrySegments = bodySegments;
      forkContext.replaceHead(bodySegments);
    }
    makeDoWhileTest(test) {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      context4.test = test;
      if (!context4.continueForkContext.empty) {
        context4.continueForkContext.add(forkContext.head);
        const testSegments = context4.continueForkContext.makeNext(0, -1);
        forkContext.replaceHead(testSegments);
      }
    }
    makeForTest(test) {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const endOfInitSegments = forkContext.head;
      const testSegments = forkContext.makeNext(-1, -1);
      context4.test = test;
      context4.endOfInitSegments = endOfInitSegments;
      context4.continueDestSegments = context4.testSegments = testSegments;
      forkContext.replaceHead(testSegments);
    }
    makeForUpdate() {
      const context4 = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext = this.forkContext;
      if (context4.testSegments) {
        finalizeTestSegmentsOfFor(context4, choiceContext, forkContext.head);
      } else {
        context4.endOfInitSegments = forkContext.head;
      }
      const updateSegments = forkContext.makeDisconnected(-1, -1);
      context4.continueDestSegments = context4.updateSegments = updateSegments;
      forkContext.replaceHead(updateSegments);
    }
    makeForBody() {
      const context4 = this.loopContext;
      const choiceContext = this.choiceContext;
      const forkContext = this.forkContext;
      if (context4.updateSegments) {
        context4.endOfUpdateSegments = forkContext.head;
        if (context4.testSegments) {
          makeLooped(this, context4.endOfUpdateSegments, context4.testSegments);
        }
      } else if (context4.testSegments) {
        finalizeTestSegmentsOfFor(context4, choiceContext, forkContext.head);
      } else {
        context4.endOfInitSegments = forkContext.head;
      }
      let bodySegments = context4.endOfTestSegments;
      if (!bodySegments) {
        const prevForkContext = ForkContext.newEmpty(forkContext);
        prevForkContext.add(context4.endOfInitSegments);
        if (context4.endOfUpdateSegments) {
          prevForkContext.add(context4.endOfUpdateSegments);
        }
        bodySegments = prevForkContext.makeNext(0, -1);
      }
      context4.continueDestSegments = context4.continueDestSegments || bodySegments;
      forkContext.replaceHead(bodySegments);
    }
    makeForInOfLeft() {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const leftSegments = forkContext.makeDisconnected(-1, -1);
      context4.prevSegments = forkContext.head;
      context4.leftSegments = context4.continueDestSegments = leftSegments;
      forkContext.replaceHead(leftSegments);
    }
    makeForInOfRight() {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const temp = ForkContext.newEmpty(forkContext);
      temp.add(context4.prevSegments);
      const rightSegments = temp.makeNext(-1, -1);
      context4.endOfLeftSegments = forkContext.head;
      forkContext.replaceHead(rightSegments);
    }
    makeForInOfBody() {
      const context4 = this.loopContext;
      const forkContext = this.forkContext;
      const temp = ForkContext.newEmpty(forkContext);
      temp.add(context4.endOfLeftSegments);
      const bodySegments = temp.makeNext(-1, -1);
      makeLooped(this, forkContext.head, context4.leftSegments);
      context4.brokenForkContext.add(forkContext.head);
      forkContext.replaceHead(bodySegments);
    }
    pushBreakContext(breakable, label) {
      this.breakContext = {
        upper: this.breakContext,
        breakable,
        label,
        brokenForkContext: ForkContext.newEmpty(this.forkContext)
      };
      return this.breakContext;
    }
    popBreakContext() {
      const context4 = this.breakContext;
      const forkContext = this.forkContext;
      this.breakContext = context4.upper;
      if (!context4.breakable) {
        const brokenForkContext = context4.brokenForkContext;
        if (!brokenForkContext.empty) {
          brokenForkContext.add(forkContext.head);
          forkContext.replaceHead(brokenForkContext.makeNext(0, -1));
        }
      }
      return context4;
    }
    makeBreak(label) {
      const forkContext = this.forkContext;
      if (!forkContext.reachable) {
        return;
      }
      const context4 = getBreakContext(this, label);
      if (context4) {
        context4.brokenForkContext.add(forkContext.head);
      }
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
    makeContinue(label) {
      const forkContext = this.forkContext;
      if (!forkContext.reachable) {
        return;
      }
      const context4 = getContinueContext(this, label);
      if (context4) {
        if (context4.continueDestSegments) {
          makeLooped(this, forkContext.head, context4.continueDestSegments);
          if (context4.type === "ForInStatement" || context4.type === "ForOfStatement") {
            context4.brokenForkContext.add(forkContext.head);
          }
        } else {
          context4.continueForkContext.add(forkContext.head);
        }
      }
      forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
    }
    makeReturn() {
      const forkContext = this.forkContext;
      if (forkContext.reachable) {
        getReturnContext(this).returnedForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
    }
    makeThrow() {
      const forkContext = this.forkContext;
      if (forkContext.reachable) {
        getThrowContext(this).thrownForkContext.add(forkContext.head);
        forkContext.replaceHead(forkContext.makeUnreachable(-1, -1));
      }
    }
    makeFinal() {
      const segments = this.currentSegments;
      if (segments.length > 0 && segments[0].reachable) {
        this.returnedForkContext.add(segments);
      }
    }
  };
  module2.exports = CodePathState;
});

// node_modules/eslint/lib/linter/code-path-analysis/id-generator.js
var require_id_generator = __commonJS((exports2, module2) => {
  "use strict";
  var IdGenerator = class {
    constructor(prefix) {
      this.prefix = String(prefix);
      this.n = 0;
    }
    next() {
      this.n = 1 + this.n | 0;
      if (this.n < 0) {
        this.n = 1;
      }
      return this.prefix + this.n;
    }
  };
  module2.exports = IdGenerator;
});

// node_modules/eslint/lib/linter/code-path-analysis/code-path.js
var require_code_path = __commonJS((exports2, module2) => {
  "use strict";
  var CodePathState = require_code_path_state();
  var IdGenerator = require_id_generator();
  var CodePath = class {
    constructor(id, upper, onLooped) {
      this.id = id;
      this.upper = upper;
      this.childCodePaths = [];
      Object.defineProperty(this, "internal", {value: new CodePathState(new IdGenerator(`${id}_`), onLooped)});
      if (upper) {
        upper.childCodePaths.push(this);
      }
    }
    static getState(codePath) {
      return codePath.internal;
    }
    get initialSegment() {
      return this.internal.initialSegment;
    }
    get finalSegments() {
      return this.internal.finalSegments;
    }
    get returnedSegments() {
      return this.internal.returnedForkContext;
    }
    get thrownSegments() {
      return this.internal.thrownForkContext;
    }
    get currentSegments() {
      return this.internal.currentSegments;
    }
    traverseSegments(options, callback) {
      let resolvedOptions;
      let resolvedCallback;
      if (typeof options === "function") {
        resolvedCallback = options;
        resolvedOptions = {};
      } else {
        resolvedOptions = options || {};
        resolvedCallback = callback;
      }
      const startSegment = resolvedOptions.first || this.internal.initialSegment;
      const lastSegment = resolvedOptions.last;
      let item = null;
      let index = 0;
      let end = 0;
      let segment = null;
      const visited = Object.create(null);
      const stack = [[startSegment, 0]];
      let skippedSegment = null;
      let broken = false;
      const controller = {
        skip() {
          if (stack.length <= 1) {
            broken = true;
          } else {
            skippedSegment = stack[stack.length - 2][0];
          }
        },
        break() {
          broken = true;
        }
      };
      function isVisited(prevSegment) {
        return visited[prevSegment.id] || segment.isLoopedPrevSegment(prevSegment);
      }
      while (stack.length > 0) {
        item = stack[stack.length - 1];
        segment = item[0];
        index = item[1];
        if (index === 0) {
          if (visited[segment.id]) {
            stack.pop();
            continue;
          }
          if (segment !== startSegment && segment.prevSegments.length > 0 && !segment.prevSegments.every(isVisited)) {
            stack.pop();
            continue;
          }
          if (skippedSegment && segment.prevSegments.indexOf(skippedSegment) !== -1) {
            skippedSegment = null;
          }
          visited[segment.id] = true;
          if (!skippedSegment) {
            resolvedCallback.call(this, segment, controller);
            if (segment === lastSegment) {
              controller.skip();
            }
            if (broken) {
              break;
            }
          }
        }
        end = segment.nextSegments.length - 1;
        if (index < end) {
          item[1] += 1;
          stack.push([segment.nextSegments[index], 0]);
        } else if (index === end) {
          item[0] = segment.nextSegments[index];
          item[1] = 0;
        } else {
          stack.pop();
        }
      }
    }
  };
  module2.exports = CodePath;
});

// node_modules/eslint/lib/linter/code-path-analysis/code-path-analyzer.js
var require_code_path_analyzer = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var {breakableTypePattern} = require_ast_utils();
  var CodePath = require_code_path();
  var CodePathSegment = require_code_path_segment();
  var IdGenerator = require_id_generator();
  var debug5 = require_debug_helpers();
  function isCaseNode(node) {
    return Boolean(node.test);
  }
  function isHandledLogicalOperator(operator) {
    return operator === "&&" || operator === "||" || operator === "??";
  }
  function isLogicalAssignmentOperator(operator) {
    return operator === "&&=" || operator === "||=" || operator === "??=";
  }
  function getLabel(node) {
    if (node.parent.type === "LabeledStatement") {
      return node.parent.label.name;
    }
    return null;
  }
  function isForkingByTrueOrFalse(node) {
    const parent = node.parent;
    switch (parent.type) {
      case "ConditionalExpression":
      case "IfStatement":
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
        return parent.test === node;
      case "LogicalExpression":
        return isHandledLogicalOperator(parent.operator);
      case "AssignmentExpression":
        return isLogicalAssignmentOperator(parent.operator);
      default:
        return false;
    }
  }
  function getBooleanValueIfSimpleConstant(node) {
    if (node.type === "Literal") {
      return Boolean(node.value);
    }
    return void 0;
  }
  function isIdentifierReference(node) {
    const parent = node.parent;
    switch (parent.type) {
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "ArrayPattern":
      case "RestElement":
      case "ImportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "CatchClause":
        return false;
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
      case "ClassDeclaration":
      case "ClassExpression":
      case "VariableDeclarator":
        return parent.id !== node;
      case "Property":
      case "MethodDefinition":
        return parent.key !== node || parent.computed || parent.shorthand;
      case "AssignmentPattern":
        return parent.key !== node;
      default:
        return true;
    }
  }
  function forwardCurrentToHead(analyzer, node) {
    const codePath = analyzer.codePath;
    const state = CodePath.getState(codePath);
    const currentSegments = state.currentSegments;
    const headSegments = state.headSegments;
    const end = Math.max(currentSegments.length, headSegments.length);
    let i, currentSegment, headSegment;
    for (i = 0; i < end; ++i) {
      currentSegment = currentSegments[i];
      headSegment = headSegments[i];
      if (currentSegment !== headSegment && currentSegment) {
        debug5.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
        if (currentSegment.reachable) {
          analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
        }
      }
    }
    state.currentSegments = headSegments;
    for (i = 0; i < end; ++i) {
      currentSegment = currentSegments[i];
      headSegment = headSegments[i];
      if (currentSegment !== headSegment && headSegment) {
        debug5.dump(`onCodePathSegmentStart ${headSegment.id}`);
        CodePathSegment.markUsed(headSegment);
        if (headSegment.reachable) {
          analyzer.emitter.emit("onCodePathSegmentStart", headSegment, node);
        }
      }
    }
  }
  function leaveFromCurrentSegment(analyzer, node) {
    const state = CodePath.getState(analyzer.codePath);
    const currentSegments = state.currentSegments;
    for (let i = 0; i < currentSegments.length; ++i) {
      const currentSegment = currentSegments[i];
      debug5.dump(`onCodePathSegmentEnd ${currentSegment.id}`);
      if (currentSegment.reachable) {
        analyzer.emitter.emit("onCodePathSegmentEnd", currentSegment, node);
      }
    }
    state.currentSegments = [];
  }
  function preprocess(analyzer, node) {
    const codePath = analyzer.codePath;
    const state = CodePath.getState(codePath);
    const parent = node.parent;
    switch (parent.type) {
      case "CallExpression":
        if (parent.optional === true && parent.arguments.length >= 1 && parent.arguments[0] === node) {
          state.makeOptionalRight();
        }
        break;
      case "MemberExpression":
        if (parent.optional === true && parent.property === node) {
          state.makeOptionalRight();
        }
        break;
      case "LogicalExpression":
        if (parent.right === node && isHandledLogicalOperator(parent.operator)) {
          state.makeLogicalRight();
        }
        break;
      case "AssignmentExpression":
        if (parent.right === node && isLogicalAssignmentOperator(parent.operator)) {
          state.makeLogicalRight();
        }
        break;
      case "ConditionalExpression":
      case "IfStatement":
        if (parent.consequent === node) {
          state.makeIfConsequent();
        } else if (parent.alternate === node) {
          state.makeIfAlternate();
        }
        break;
      case "SwitchCase":
        if (parent.consequent[0] === node) {
          state.makeSwitchCaseBody(false, !parent.test);
        }
        break;
      case "TryStatement":
        if (parent.handler === node) {
          state.makeCatchBlock();
        } else if (parent.finalizer === node) {
          state.makeFinallyBlock();
        }
        break;
      case "WhileStatement":
        if (parent.test === node) {
          state.makeWhileTest(getBooleanValueIfSimpleConstant(node));
        } else {
          assert(parent.body === node);
          state.makeWhileBody();
        }
        break;
      case "DoWhileStatement":
        if (parent.body === node) {
          state.makeDoWhileBody();
        } else {
          assert(parent.test === node);
          state.makeDoWhileTest(getBooleanValueIfSimpleConstant(node));
        }
        break;
      case "ForStatement":
        if (parent.test === node) {
          state.makeForTest(getBooleanValueIfSimpleConstant(node));
        } else if (parent.update === node) {
          state.makeForUpdate();
        } else if (parent.body === node) {
          state.makeForBody();
        }
        break;
      case "ForInStatement":
      case "ForOfStatement":
        if (parent.left === node) {
          state.makeForInOfLeft();
        } else if (parent.right === node) {
          state.makeForInOfRight();
        } else {
          assert(parent.body === node);
          state.makeForInOfBody();
        }
        break;
      case "AssignmentPattern":
        if (parent.right === node) {
          state.pushForkContext();
          state.forkBypassPath();
          state.forkPath();
        }
        break;
      default:
        break;
    }
  }
  function processCodePathToEnter(analyzer, node) {
    let codePath = analyzer.codePath;
    let state = codePath && CodePath.getState(codePath);
    const parent = node.parent;
    switch (node.type) {
      case "Program":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression":
        if (codePath) {
          forwardCurrentToHead(analyzer, node);
          debug5.dumpState(node, state, false);
        }
        codePath = analyzer.codePath = new CodePath(analyzer.idGenerator.next(), codePath, analyzer.onLooped);
        state = CodePath.getState(codePath);
        debug5.dump(`onCodePathStart ${codePath.id}`);
        analyzer.emitter.emit("onCodePathStart", codePath, node);
        break;
      case "ChainExpression":
        state.pushChainContext();
        break;
      case "CallExpression":
        if (node.optional === true) {
          state.makeOptionalNode();
        }
        break;
      case "MemberExpression":
        if (node.optional === true) {
          state.makeOptionalNode();
        }
        break;
      case "LogicalExpression":
        if (isHandledLogicalOperator(node.operator)) {
          state.pushChoiceContext(node.operator, isForkingByTrueOrFalse(node));
        }
        break;
      case "AssignmentExpression":
        if (isLogicalAssignmentOperator(node.operator)) {
          state.pushChoiceContext(node.operator.slice(0, -1), isForkingByTrueOrFalse(node));
        }
        break;
      case "ConditionalExpression":
      case "IfStatement":
        state.pushChoiceContext("test", false);
        break;
      case "SwitchStatement":
        state.pushSwitchContext(node.cases.some(isCaseNode), getLabel(node));
        break;
      case "TryStatement":
        state.pushTryContext(Boolean(node.finalizer));
        break;
      case "SwitchCase":
        if (parent.discriminant !== node && parent.cases[0] !== node) {
          state.forkPath();
        }
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        state.pushLoopContext(node.type, getLabel(node));
        break;
      case "LabeledStatement":
        if (!breakableTypePattern.test(node.body.type)) {
          state.pushBreakContext(false, node.label.name);
        }
        break;
      default:
        break;
    }
    forwardCurrentToHead(analyzer, node);
    debug5.dumpState(node, state, false);
  }
  function processCodePathToExit(analyzer, node) {
    const codePath = analyzer.codePath;
    const state = CodePath.getState(codePath);
    let dontForward = false;
    switch (node.type) {
      case "ChainExpression":
        state.popChainContext();
        break;
      case "IfStatement":
      case "ConditionalExpression":
        state.popChoiceContext();
        break;
      case "LogicalExpression":
        if (isHandledLogicalOperator(node.operator)) {
          state.popChoiceContext();
        }
        break;
      case "AssignmentExpression":
        if (isLogicalAssignmentOperator(node.operator)) {
          state.popChoiceContext();
        }
        break;
      case "SwitchStatement":
        state.popSwitchContext();
        break;
      case "SwitchCase":
        if (node.consequent.length === 0) {
          state.makeSwitchCaseBody(true, !node.test);
        }
        if (state.forkContext.reachable) {
          dontForward = true;
        }
        break;
      case "TryStatement":
        state.popTryContext();
        break;
      case "BreakStatement":
        forwardCurrentToHead(analyzer, node);
        state.makeBreak(node.label && node.label.name);
        dontForward = true;
        break;
      case "ContinueStatement":
        forwardCurrentToHead(analyzer, node);
        state.makeContinue(node.label && node.label.name);
        dontForward = true;
        break;
      case "ReturnStatement":
        forwardCurrentToHead(analyzer, node);
        state.makeReturn();
        dontForward = true;
        break;
      case "ThrowStatement":
        forwardCurrentToHead(analyzer, node);
        state.makeThrow();
        dontForward = true;
        break;
      case "Identifier":
        if (isIdentifierReference(node)) {
          state.makeFirstThrowablePathInTryBlock();
          dontForward = true;
        }
        break;
      case "CallExpression":
      case "ImportExpression":
      case "MemberExpression":
      case "NewExpression":
      case "YieldExpression":
        state.makeFirstThrowablePathInTryBlock();
        break;
      case "WhileStatement":
      case "DoWhileStatement":
      case "ForStatement":
      case "ForInStatement":
      case "ForOfStatement":
        state.popLoopContext();
        break;
      case "AssignmentPattern":
        state.popForkContext();
        break;
      case "LabeledStatement":
        if (!breakableTypePattern.test(node.body.type)) {
          state.popBreakContext();
        }
        break;
      default:
        break;
    }
    if (!dontForward) {
      forwardCurrentToHead(analyzer, node);
    }
    debug5.dumpState(node, state, true);
  }
  function postprocess(analyzer, node) {
    switch (node.type) {
      case "Program":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ArrowFunctionExpression": {
        let codePath = analyzer.codePath;
        CodePath.getState(codePath).makeFinal();
        leaveFromCurrentSegment(analyzer, node);
        debug5.dump(`onCodePathEnd ${codePath.id}`);
        analyzer.emitter.emit("onCodePathEnd", codePath, node);
        debug5.dumpDot(codePath);
        codePath = analyzer.codePath = analyzer.codePath.upper;
        if (codePath) {
          debug5.dumpState(node, CodePath.getState(codePath), true);
        }
        break;
      }
      case "CallExpression":
        if (node.optional === true && node.arguments.length === 0) {
          CodePath.getState(analyzer.codePath).makeOptionalRight();
        }
        break;
      default:
        break;
    }
  }
  var CodePathAnalyzer = class {
    constructor(eventGenerator) {
      this.original = eventGenerator;
      this.emitter = eventGenerator.emitter;
      this.codePath = null;
      this.idGenerator = new IdGenerator("s");
      this.currentNode = null;
      this.onLooped = this.onLooped.bind(this);
    }
    enterNode(node) {
      this.currentNode = node;
      if (node.parent) {
        preprocess(this, node);
      }
      processCodePathToEnter(this, node);
      this.original.enterNode(node);
      this.currentNode = null;
    }
    leaveNode(node) {
      this.currentNode = node;
      processCodePathToExit(this, node);
      this.original.leaveNode(node);
      postprocess(this, node);
      this.currentNode = null;
    }
    onLooped(fromSegment, toSegment) {
      if (fromSegment.reachable && toSegment.reachable) {
        debug5.dump(`onCodePathSegmentLoop ${fromSegment.id} -> ${toSegment.id}`);
        this.emitter.emit("onCodePathSegmentLoop", fromSegment, toSegment, this.currentNode);
      }
    }
  };
  module2.exports = CodePathAnalyzer;
});

// node_modules/eslint/lib/linter/apply-disable-directives.js
var require_apply_disable_directives = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  function compareLocations(itemA, itemB) {
    return itemA.line - itemB.line || itemA.column - itemB.column;
  }
  function applyDirectives(options) {
    const problems = [];
    let nextDirectiveIndex = 0;
    let currentGlobalDisableDirective = null;
    const disabledRuleMap = new Map();
    const enabledRules = new Set();
    const usedDisableDirectives = new Set();
    for (const problem of options.problems) {
      while (nextDirectiveIndex < options.directives.length && compareLocations(options.directives[nextDirectiveIndex], problem) <= 0) {
        const directive = options.directives[nextDirectiveIndex++];
        switch (directive.type) {
          case "disable":
            if (directive.ruleId === null) {
              currentGlobalDisableDirective = directive;
              disabledRuleMap.clear();
              enabledRules.clear();
            } else if (currentGlobalDisableDirective) {
              enabledRules.delete(directive.ruleId);
              disabledRuleMap.set(directive.ruleId, directive);
            } else {
              disabledRuleMap.set(directive.ruleId, directive);
            }
            break;
          case "enable":
            if (directive.ruleId === null) {
              currentGlobalDisableDirective = null;
              disabledRuleMap.clear();
            } else if (currentGlobalDisableDirective) {
              enabledRules.add(directive.ruleId);
              disabledRuleMap.delete(directive.ruleId);
            } else {
              disabledRuleMap.delete(directive.ruleId);
            }
            break;
        }
      }
      if (disabledRuleMap.has(problem.ruleId)) {
        usedDisableDirectives.add(disabledRuleMap.get(problem.ruleId));
      } else if (currentGlobalDisableDirective && !enabledRules.has(problem.ruleId)) {
        usedDisableDirectives.add(currentGlobalDisableDirective);
      } else {
        problems.push(problem);
      }
    }
    const unusedDisableDirectives = options.directives.filter((directive) => directive.type === "disable" && !usedDisableDirectives.has(directive)).map((directive) => ({
      ruleId: null,
      message: directive.ruleId ? `Unused eslint-disable directive (no problems were reported from '${directive.ruleId}').` : "Unused eslint-disable directive (no problems were reported).",
      line: directive.unprocessedDirective.line,
      column: directive.unprocessedDirective.column,
      severity: options.reportUnusedDisableDirectives === "warn" ? 1 : 2,
      nodeType: null
    }));
    return {problems, unusedDisableDirectives};
  }
  module2.exports = ({directives, problems, reportUnusedDisableDirectives = "off"}) => {
    const blockDirectives = directives.filter((directive) => directive.type === "disable" || directive.type === "enable").map((directive) => Object.assign({}, directive, {unprocessedDirective: directive})).sort(compareLocations);
    const lineDirectives = lodash.flatMap(directives, (directive) => {
      switch (directive.type) {
        case "disable":
        case "enable":
          return [];
        case "disable-line":
          return [
            {type: "disable", line: directive.line, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive},
            {type: "enable", line: directive.line + 1, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive}
          ];
        case "disable-next-line":
          return [
            {type: "disable", line: directive.line + 1, column: 1, ruleId: directive.ruleId, unprocessedDirective: directive},
            {type: "enable", line: directive.line + 2, column: 0, ruleId: directive.ruleId, unprocessedDirective: directive}
          ];
        default:
          throw new TypeError(`Unrecognized directive type '${directive.type}'`);
      }
    }).sort(compareLocations);
    const blockDirectivesResult = applyDirectives({
      problems,
      directives: blockDirectives,
      reportUnusedDisableDirectives
    });
    const lineDirectivesResult = applyDirectives({
      problems: blockDirectivesResult.problems,
      directives: lineDirectives,
      reportUnusedDisableDirectives
    });
    return reportUnusedDisableDirectives !== "off" ? lineDirectivesResult.problems.concat(blockDirectivesResult.unusedDisableDirectives).concat(lineDirectivesResult.unusedDisableDirectives).sort(compareLocations) : lineDirectivesResult.problems;
  };
});

// node_modules/eslint/node_modules/prelude-ls/lib/Func.js
var require_Func = __commonJS((exports2, module2) => {
  var apply;
  var curry;
  var flip;
  var fix;
  var over;
  var memoize;
  var toString$ = {}.toString;
  apply = curry$(function(f, list) {
    return f.apply(null, list);
  });
  curry = function(f) {
    return curry$(f);
  };
  flip = curry$(function(f, x, y) {
    return f(y, x);
  });
  fix = function(f) {
    return function(g) {
      return function() {
        return f(g(g)).apply(null, arguments);
      };
    }(function(g) {
      return function() {
        return f(g(g)).apply(null, arguments);
      };
    });
  };
  over = curry$(function(f, g, x, y) {
    return f(g(x), g(y));
  });
  memoize = function(f) {
    var memo;
    memo = {};
    return function() {
      var args, res$, i$, to$, key, arg;
      res$ = [];
      for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
        res$.push(arguments[i$]);
      }
      args = res$;
      key = function() {
        var i$2, ref$, len$, results$ = [];
        for (i$2 = 0, len$ = (ref$ = args).length; i$2 < len$; ++i$2) {
          arg = ref$[i$2];
          results$.push(arg + toString$.call(arg).slice(8, -1));
        }
        return results$;
      }().join("");
      return memo[key] = key in memo ? memo[key] : f.apply(null, args);
    };
  };
  module2.exports = {
    curry,
    flip,
    fix,
    apply,
    over,
    memoize
  };
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
});

// node_modules/eslint/node_modules/prelude-ls/lib/List.js
var require_List = __commonJS((exports2, module2) => {
  var each;
  var map;
  var compact;
  var filter;
  var reject;
  var remove;
  var partition;
  var find;
  var head;
  var first;
  var tail;
  var last;
  var initial;
  var empty;
  var reverse;
  var unique;
  var uniqueBy;
  var fold;
  var foldl;
  var fold1;
  var foldl1;
  var foldr;
  var foldr1;
  var unfoldr;
  var concat;
  var concatMap;
  var flatten;
  var difference;
  var intersection;
  var union;
  var countBy;
  var groupBy;
  var andList;
  var orList;
  var any;
  var all;
  var sort;
  var sortWith;
  var sortBy;
  var sum;
  var product;
  var mean;
  var average;
  var maximum;
  var minimum;
  var maximumBy;
  var minimumBy;
  var scan;
  var scanl;
  var scan1;
  var scanl1;
  var scanr;
  var scanr1;
  var slice;
  var take;
  var drop;
  var splitAt;
  var takeWhile;
  var dropWhile;
  var span;
  var breakList;
  var zip;
  var zipWith;
  var zipAll;
  var zipAllWith;
  var at;
  var elemIndex;
  var elemIndices;
  var findIndex;
  var findIndices;
  var toString$ = {}.toString;
  each = curry$(function(f, xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      f(x);
    }
    return xs;
  });
  map = curry$(function(f, xs) {
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      results$.push(f(x));
    }
    return results$;
  });
  compact = function(xs) {
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (x) {
        results$.push(x);
      }
    }
    return results$;
  };
  filter = curry$(function(f, xs) {
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        results$.push(x);
      }
    }
    return results$;
  });
  reject = curry$(function(f, xs) {
    var i$, len$, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!f(x)) {
        results$.push(x);
      }
    }
    return results$;
  });
  remove = curry$(function(el, xs) {
    var i, x$;
    i = elemIndex(el, xs);
    x$ = xs.slice();
    if (i != null) {
      x$.splice(i, 1);
    }
    return x$;
  });
  partition = curry$(function(f, xs) {
    var passed, failed, i$, len$, x;
    passed = [];
    failed = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      (f(x) ? passed : failed).push(x);
    }
    return [passed, failed];
  });
  find = curry$(function(f, xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        return x;
      }
    }
  });
  head = first = function(xs) {
    return xs[0];
  };
  tail = function(xs) {
    if (!xs.length) {
      return;
    }
    return xs.slice(1);
  };
  last = function(xs) {
    return xs[xs.length - 1];
  };
  initial = function(xs) {
    if (!xs.length) {
      return;
    }
    return xs.slice(0, -1);
  };
  empty = function(xs) {
    return !xs.length;
  };
  reverse = function(xs) {
    return xs.concat().reverse();
  };
  unique = function(xs) {
    var result, i$, len$, x;
    result = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!in$(x, result)) {
        result.push(x);
      }
    }
    return result;
  };
  uniqueBy = curry$(function(f, xs) {
    var seen, i$, len$, x, val, results$ = [];
    seen = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      val = f(x);
      if (in$(val, seen)) {
        continue;
      }
      seen.push(val);
      results$.push(x);
    }
    return results$;
  });
  fold = foldl = curry$(function(f, memo, xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      memo = f(memo, x);
    }
    return memo;
  });
  fold1 = foldl1 = curry$(function(f, xs) {
    return fold(f, xs[0], xs.slice(1));
  });
  foldr = curry$(function(f, memo, xs) {
    var i$, x;
    for (i$ = xs.length - 1; i$ >= 0; --i$) {
      x = xs[i$];
      memo = f(x, memo);
    }
    return memo;
  });
  foldr1 = curry$(function(f, xs) {
    return foldr(f, xs[xs.length - 1], xs.slice(0, -1));
  });
  unfoldr = curry$(function(f, b) {
    var result, x, that;
    result = [];
    x = b;
    while ((that = f(x)) != null) {
      result.push(that[0]);
      x = that[1];
    }
    return result;
  });
  concat = function(xss) {
    return [].concat.apply([], xss);
  };
  concatMap = curry$(function(f, xs) {
    var x;
    return [].concat.apply([], function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push(f(x));
      }
      return results$;
    }());
  });
  flatten = function(xs) {
    var x;
    return [].concat.apply([], function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        if (toString$.call(x).slice(8, -1) === "Array") {
          results$.push(flatten(x));
        } else {
          results$.push(x);
        }
      }
      return results$;
    }());
  };
  difference = function(xs) {
    var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer:
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
          ys = yss[j$];
          if (in$(x, ys)) {
            continue outer;
          }
        }
        results.push(x);
      }
    return results;
  };
  intersection = function(xs) {
    var yss, res$, i$, to$, results, len$, x, j$, len1$, ys;
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    yss = res$;
    results = [];
    outer:
      for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
        x = xs[i$];
        for (j$ = 0, len1$ = yss.length; j$ < len1$; ++j$) {
          ys = yss[j$];
          if (!in$(x, ys)) {
            continue outer;
          }
        }
        results.push(x);
      }
    return results;
  };
  union = function() {
    var xss, res$, i$, to$, results, len$, xs, j$, len1$, x;
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    results = [];
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      for (j$ = 0, len1$ = xs.length; j$ < len1$; ++j$) {
        x = xs[j$];
        if (!in$(x, results)) {
          results.push(x);
        }
      }
    }
    return results;
  };
  countBy = curry$(function(f, xs) {
    var results, i$, len$, x, key;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      key = f(x);
      if (key in results) {
        results[key] += 1;
      } else {
        results[key] = 1;
      }
    }
    return results;
  });
  groupBy = curry$(function(f, xs) {
    var results, i$, len$, x, key;
    results = {};
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      key = f(x);
      if (key in results) {
        results[key].push(x);
      } else {
        results[key] = [x];
      }
    }
    return results;
  });
  andList = function(xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!x) {
        return false;
      }
    }
    return true;
  };
  orList = function(xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (x) {
        return true;
      }
    }
    return false;
  };
  any = curry$(function(f, xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (f(x)) {
        return true;
      }
    }
    return false;
  });
  all = curry$(function(f, xs) {
    var i$, len$, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      if (!f(x)) {
        return false;
      }
    }
    return true;
  });
  sort = function(xs) {
    return xs.concat().sort(function(x, y) {
      if (x > y) {
        return 1;
      } else if (x < y) {
        return -1;
      } else {
        return 0;
      }
    });
  };
  sortWith = curry$(function(f, xs) {
    return xs.concat().sort(f);
  });
  sortBy = curry$(function(f, xs) {
    return xs.concat().sort(function(x, y) {
      if (f(x) > f(y)) {
        return 1;
      } else if (f(x) < f(y)) {
        return -1;
      } else {
        return 0;
      }
    });
  });
  sum = function(xs) {
    var result, i$, len$, x;
    result = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      result += x;
    }
    return result;
  };
  product = function(xs) {
    var result, i$, len$, x;
    result = 1;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      result *= x;
    }
    return result;
  };
  mean = average = function(xs) {
    var sum2, i$, len$, x;
    sum2 = 0;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      x = xs[i$];
      sum2 += x;
    }
    return sum2 / xs.length;
  };
  maximum = function(xs) {
    var max, i$, ref$, len$, x;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x > max) {
        max = x;
      }
    }
    return max;
  };
  minimum = function(xs) {
    var min, i$, ref$, len$, x;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (x < min) {
        min = x;
      }
    }
    return min;
  };
  maximumBy = curry$(function(f, xs) {
    var max, i$, ref$, len$, x;
    max = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (f(x) > f(max)) {
        max = x;
      }
    }
    return max;
  });
  minimumBy = curry$(function(f, xs) {
    var min, i$, ref$, len$, x;
    min = xs[0];
    for (i$ = 0, len$ = (ref$ = xs.slice(1)).length; i$ < len$; ++i$) {
      x = ref$[i$];
      if (f(x) < f(min)) {
        min = x;
      }
    }
    return min;
  });
  scan = scanl = curry$(function(f, memo, xs) {
    var last2, x;
    last2 = memo;
    return [memo].concat(function() {
      var i$, ref$, len$, results$ = [];
      for (i$ = 0, len$ = (ref$ = xs).length; i$ < len$; ++i$) {
        x = ref$[i$];
        results$.push(last2 = f(last2, x));
      }
      return results$;
    }());
  });
  scan1 = scanl1 = curry$(function(f, xs) {
    if (!xs.length) {
      return;
    }
    return scan(f, xs[0], xs.slice(1));
  });
  scanr = curry$(function(f, memo, xs) {
    xs = xs.concat().reverse();
    return scan(f, memo, xs).reverse();
  });
  scanr1 = curry$(function(f, xs) {
    if (!xs.length) {
      return;
    }
    xs = xs.concat().reverse();
    return scan(f, xs[0], xs.slice(1)).reverse();
  });
  slice = curry$(function(x, y, xs) {
    return xs.slice(x, y);
  });
  take = curry$(function(n, xs) {
    if (n <= 0) {
      return xs.slice(0, 0);
    } else {
      return xs.slice(0, n);
    }
  });
  drop = curry$(function(n, xs) {
    if (n <= 0) {
      return xs;
    } else {
      return xs.slice(n);
    }
  });
  splitAt = curry$(function(n, xs) {
    return [take(n, xs), drop(n, xs)];
  });
  takeWhile = curry$(function(p, xs) {
    var len, i;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i = 0;
    while (i < len && p(xs[i])) {
      i += 1;
    }
    return xs.slice(0, i);
  });
  dropWhile = curry$(function(p, xs) {
    var len, i;
    len = xs.length;
    if (!len) {
      return xs;
    }
    i = 0;
    while (i < len && p(xs[i])) {
      i += 1;
    }
    return xs.slice(i);
  });
  span = curry$(function(p, xs) {
    return [takeWhile(p, xs), dropWhile(p, xs)];
  });
  breakList = curry$(function(p, xs) {
    return span(compose$(p, not$), xs);
  });
  zip = curry$(function(xs, ys) {
    var result, len, i$, len$, i, x;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (i === len) {
        break;
      }
      result.push([x, ys[i]]);
    }
    return result;
  });
  zipWith = curry$(function(f, xs, ys) {
    var result, len, i$, len$, i, x;
    result = [];
    len = ys.length;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (i === len) {
        break;
      }
      result.push(f(x, ys[i]));
    }
    return result;
  });
  zipAll = function() {
    var xss, res$, i$, to$, minLength, len$, xs, ref$, i, lresult$, j$, results$ = [];
    res$ = [];
    for (i$ = 0, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = void 0;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i = i$;
      lresult$ = [];
      for (j$ = 0, len$ = xss.length; j$ < len$; ++j$) {
        xs = xss[j$];
        lresult$.push(xs[i]);
      }
      results$.push(lresult$);
    }
    return results$;
  };
  zipAllWith = function(f) {
    var xss, res$, i$, to$, minLength, len$, xs, ref$, i, results$ = [];
    res$ = [];
    for (i$ = 1, to$ = arguments.length; i$ < to$; ++i$) {
      res$.push(arguments[i$]);
    }
    xss = res$;
    minLength = void 0;
    for (i$ = 0, len$ = xss.length; i$ < len$; ++i$) {
      xs = xss[i$];
      minLength <= (ref$ = xs.length) || (minLength = ref$);
    }
    for (i$ = 0; i$ < minLength; ++i$) {
      i = i$;
      results$.push(f.apply(null, fn$()));
    }
    return results$;
    function fn$() {
      var i$2, ref$2, len$2, results$2 = [];
      for (i$2 = 0, len$2 = (ref$2 = xss).length; i$2 < len$2; ++i$2) {
        xs = ref$2[i$2];
        results$2.push(xs[i]);
      }
      return results$2;
    }
  };
  at = curry$(function(n, xs) {
    if (n < 0) {
      return xs[xs.length + n];
    } else {
      return xs[n];
    }
  });
  elemIndex = curry$(function(el, xs) {
    var i$, len$, i, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (x === el) {
        return i;
      }
    }
  });
  elemIndices = curry$(function(el, xs) {
    var i$, len$, i, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (x === el) {
        results$.push(i);
      }
    }
    return results$;
  });
  findIndex = curry$(function(f, xs) {
    var i$, len$, i, x;
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (f(x)) {
        return i;
      }
    }
  });
  findIndices = curry$(function(f, xs) {
    var i$, len$, i, x, results$ = [];
    for (i$ = 0, len$ = xs.length; i$ < len$; ++i$) {
      i = i$;
      x = xs[i$];
      if (f(x)) {
        results$.push(i);
      }
    }
    return results$;
  });
  module2.exports = {
    each,
    map,
    filter,
    compact,
    reject,
    remove,
    partition,
    find,
    head,
    first,
    tail,
    last,
    initial,
    empty,
    reverse,
    difference,
    intersection,
    union,
    countBy,
    groupBy,
    fold,
    fold1,
    foldl,
    foldl1,
    foldr,
    foldr1,
    unfoldr,
    andList,
    orList,
    any,
    all,
    unique,
    uniqueBy,
    sort,
    sortWith,
    sortBy,
    sum,
    product,
    mean,
    average,
    concat,
    concatMap,
    flatten,
    maximum,
    minimum,
    maximumBy,
    minimumBy,
    scan,
    scan1,
    scanl,
    scanl1,
    scanr,
    scanr1,
    slice,
    take,
    drop,
    splitAt,
    takeWhile,
    dropWhile,
    span,
    breakList,
    zip,
    zipWith,
    zipAll,
    zipAllWith,
    at,
    elemIndex,
    elemIndices,
    findIndex,
    findIndices
  };
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
  function in$(x, xs) {
    var i = -1, l = xs.length >>> 0;
    while (++i < l)
      if (x === xs[i])
        return true;
    return false;
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function not$(x) {
    return !x;
  }
});

// node_modules/eslint/node_modules/prelude-ls/lib/Obj.js
var require_Obj = __commonJS((exports2, module2) => {
  var values;
  var keys;
  var pairsToObj;
  var objToPairs;
  var listsToObj;
  var objToLists;
  var empty;
  var each;
  var map;
  var compact;
  var filter;
  var reject;
  var partition;
  var find;
  values = function(object) {
    var i$, x, results$ = [];
    for (i$ in object) {
      x = object[i$];
      results$.push(x);
    }
    return results$;
  };
  keys = function(object) {
    var x, results$ = [];
    for (x in object) {
      results$.push(x);
    }
    return results$;
  };
  pairsToObj = function(object) {
    var i$, len$, x, resultObj$ = {};
    for (i$ = 0, len$ = object.length; i$ < len$; ++i$) {
      x = object[i$];
      resultObj$[x[0]] = x[1];
    }
    return resultObj$;
  };
  objToPairs = function(object) {
    var key, value, results$ = [];
    for (key in object) {
      value = object[key];
      results$.push([key, value]);
    }
    return results$;
  };
  listsToObj = curry$(function(keys2, values2) {
    var i$, len$, i, key, resultObj$ = {};
    for (i$ = 0, len$ = keys2.length; i$ < len$; ++i$) {
      i = i$;
      key = keys2[i$];
      resultObj$[key] = values2[i];
    }
    return resultObj$;
  });
  objToLists = function(object) {
    var keys2, values2, key, value;
    keys2 = [];
    values2 = [];
    for (key in object) {
      value = object[key];
      keys2.push(key);
      values2.push(value);
    }
    return [keys2, values2];
  };
  empty = function(object) {
    var x;
    for (x in object) {
      return false;
    }
    return true;
  };
  each = curry$(function(f, object) {
    var i$, x;
    for (i$ in object) {
      x = object[i$];
      f(x);
    }
    return object;
  });
  map = curry$(function(f, object) {
    var k, x, resultObj$ = {};
    for (k in object) {
      x = object[k];
      resultObj$[k] = f(x);
    }
    return resultObj$;
  });
  compact = function(object) {
    var k, x, resultObj$ = {};
    for (k in object) {
      x = object[k];
      if (x) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  };
  filter = curry$(function(f, object) {
    var k, x, resultObj$ = {};
    for (k in object) {
      x = object[k];
      if (f(x)) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  });
  reject = curry$(function(f, object) {
    var k, x, resultObj$ = {};
    for (k in object) {
      x = object[k];
      if (!f(x)) {
        resultObj$[k] = x;
      }
    }
    return resultObj$;
  });
  partition = curry$(function(f, object) {
    var passed, failed, k, x;
    passed = {};
    failed = {};
    for (k in object) {
      x = object[k];
      (f(x) ? passed : failed)[k] = x;
    }
    return [passed, failed];
  });
  find = curry$(function(f, object) {
    var i$, x;
    for (i$ in object) {
      x = object[i$];
      if (f(x)) {
        return x;
      }
    }
  });
  module2.exports = {
    values,
    keys,
    pairsToObj,
    objToPairs,
    listsToObj,
    objToLists,
    empty,
    each,
    map,
    filter,
    compact,
    reject,
    partition,
    find
  };
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
});

// node_modules/eslint/node_modules/prelude-ls/lib/Str.js
var require_Str = __commonJS((exports2, module2) => {
  var split;
  var join;
  var lines;
  var unlines;
  var words;
  var unwords;
  var chars;
  var unchars;
  var reverse;
  var repeat;
  var capitalize;
  var camelize;
  var dasherize;
  split = curry$(function(sep, str) {
    return str.split(sep);
  });
  join = curry$(function(sep, xs) {
    return xs.join(sep);
  });
  lines = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split("\n");
  };
  unlines = function(it2) {
    return it2.join("\n");
  };
  words = function(str) {
    if (!str.length) {
      return [];
    }
    return str.split(/[ ]+/);
  };
  unwords = function(it2) {
    return it2.join(" ");
  };
  chars = function(it2) {
    return it2.split("");
  };
  unchars = function(it2) {
    return it2.join("");
  };
  reverse = function(str) {
    return str.split("").reverse().join("");
  };
  repeat = curry$(function(n, str) {
    var result, i$;
    result = "";
    for (i$ = 0; i$ < n; ++i$) {
      result += str;
    }
    return result;
  });
  capitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.slice(1);
  };
  camelize = function(it2) {
    return it2.replace(/[-_]+(.)?/g, function(arg$, c) {
      return (c != null ? c : "").toUpperCase();
    });
  };
  dasherize = function(str) {
    return str.replace(/([^-A-Z])([A-Z]+)/g, function(arg$, lower, upper) {
      return lower + "-" + (upper.length > 1 ? upper : upper.toLowerCase());
    }).replace(/^([A-Z]+)/, function(arg$, upper) {
      if (upper.length > 1) {
        return upper + "-";
      } else {
        return upper.toLowerCase();
      }
    });
  };
  module2.exports = {
    split,
    join,
    lines,
    unlines,
    words,
    unwords,
    chars,
    unchars,
    reverse,
    repeat,
    capitalize,
    camelize,
    dasherize
  };
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
});

// node_modules/eslint/node_modules/prelude-ls/lib/Num.js
var require_Num = __commonJS((exports2, module2) => {
  var max;
  var min;
  var negate;
  var abs;
  var signum;
  var quot;
  var rem;
  var div;
  var mod;
  var recip;
  var pi;
  var tau;
  var exp;
  var sqrt;
  var ln;
  var pow;
  var sin;
  var tan;
  var cos;
  var asin;
  var acos;
  var atan;
  var atan2;
  var truncate;
  var round;
  var ceiling;
  var floor;
  var isItNaN;
  var even;
  var odd;
  var gcd;
  var lcm;
  max = curry$(function(x$, y$) {
    return x$ > y$ ? x$ : y$;
  });
  min = curry$(function(x$, y$) {
    return x$ < y$ ? x$ : y$;
  });
  negate = function(x) {
    return -x;
  };
  abs = Math.abs;
  signum = function(x) {
    if (x < 0) {
      return -1;
    } else if (x > 0) {
      return 1;
    } else {
      return 0;
    }
  };
  quot = curry$(function(x, y) {
    return ~~(x / y);
  });
  rem = curry$(function(x$, y$) {
    return x$ % y$;
  });
  div = curry$(function(x, y) {
    return Math.floor(x / y);
  });
  mod = curry$(function(x$, y$) {
    var ref$;
    return (x$ % (ref$ = y$) + ref$) % ref$;
  });
  recip = function(it2) {
    return 1 / it2;
  };
  pi = Math.PI;
  tau = pi * 2;
  exp = Math.exp;
  sqrt = Math.sqrt;
  ln = Math.log;
  pow = curry$(function(x$, y$) {
    return Math.pow(x$, y$);
  });
  sin = Math.sin;
  tan = Math.tan;
  cos = Math.cos;
  asin = Math.asin;
  acos = Math.acos;
  atan = Math.atan;
  atan2 = curry$(function(x, y) {
    return Math.atan2(x, y);
  });
  truncate = function(x) {
    return ~~x;
  };
  round = Math.round;
  ceiling = Math.ceil;
  floor = Math.floor;
  isItNaN = function(x) {
    return x !== x;
  };
  even = function(x) {
    return x % 2 === 0;
  };
  odd = function(x) {
    return x % 2 !== 0;
  };
  gcd = curry$(function(x, y) {
    var z;
    x = Math.abs(x);
    y = Math.abs(y);
    while (y !== 0) {
      z = x % y;
      x = y;
      y = z;
    }
    return x;
  });
  lcm = curry$(function(x, y) {
    return Math.abs(Math.floor(x / gcd(x, y) * y));
  });
  module2.exports = {
    max,
    min,
    negate,
    abs,
    signum,
    quot,
    rem,
    div,
    mod,
    recip,
    pi,
    tau,
    exp,
    sqrt,
    ln,
    pow,
    sin,
    tan,
    cos,
    acos,
    asin,
    atan,
    atan2,
    truncate,
    round,
    ceiling,
    floor,
    isItNaN,
    even,
    odd,
    gcd,
    lcm
  };
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
});

// node_modules/eslint/node_modules/prelude-ls/lib/index.js
var require_lib6 = __commonJS((exports2, module2) => {
  var Func;
  var List;
  var Obj;
  var Str;
  var Num;
  var id;
  var isType;
  var replicate;
  var prelude;
  var toString$ = {}.toString;
  Func = require_Func();
  List = require_List();
  Obj = require_Obj();
  Str = require_Str();
  Num = require_Num();
  id = function(x) {
    return x;
  };
  isType = curry$(function(type, x) {
    return toString$.call(x).slice(8, -1) === type;
  });
  replicate = curry$(function(n, x) {
    var i$, results$ = [];
    for (i$ = 0; i$ < n; ++i$) {
      results$.push(x);
    }
    return results$;
  });
  Str.empty = List.empty;
  Str.slice = List.slice;
  Str.take = List.take;
  Str.drop = List.drop;
  Str.splitAt = List.splitAt;
  Str.takeWhile = List.takeWhile;
  Str.dropWhile = List.dropWhile;
  Str.span = List.span;
  Str.breakStr = List.breakList;
  prelude = {
    Func,
    List,
    Obj,
    Str,
    Num,
    id,
    isType,
    replicate
  };
  prelude.each = List.each;
  prelude.map = List.map;
  prelude.filter = List.filter;
  prelude.compact = List.compact;
  prelude.reject = List.reject;
  prelude.partition = List.partition;
  prelude.find = List.find;
  prelude.head = List.head;
  prelude.first = List.first;
  prelude.tail = List.tail;
  prelude.last = List.last;
  prelude.initial = List.initial;
  prelude.empty = List.empty;
  prelude.reverse = List.reverse;
  prelude.difference = List.difference;
  prelude.intersection = List.intersection;
  prelude.union = List.union;
  prelude.countBy = List.countBy;
  prelude.groupBy = List.groupBy;
  prelude.fold = List.fold;
  prelude.foldl = List.foldl;
  prelude.fold1 = List.fold1;
  prelude.foldl1 = List.foldl1;
  prelude.foldr = List.foldr;
  prelude.foldr1 = List.foldr1;
  prelude.unfoldr = List.unfoldr;
  prelude.andList = List.andList;
  prelude.orList = List.orList;
  prelude.any = List.any;
  prelude.all = List.all;
  prelude.unique = List.unique;
  prelude.uniqueBy = List.uniqueBy;
  prelude.sort = List.sort;
  prelude.sortWith = List.sortWith;
  prelude.sortBy = List.sortBy;
  prelude.sum = List.sum;
  prelude.product = List.product;
  prelude.mean = List.mean;
  prelude.average = List.average;
  prelude.concat = List.concat;
  prelude.concatMap = List.concatMap;
  prelude.flatten = List.flatten;
  prelude.maximum = List.maximum;
  prelude.minimum = List.minimum;
  prelude.maximumBy = List.maximumBy;
  prelude.minimumBy = List.minimumBy;
  prelude.scan = List.scan;
  prelude.scanl = List.scanl;
  prelude.scan1 = List.scan1;
  prelude.scanl1 = List.scanl1;
  prelude.scanr = List.scanr;
  prelude.scanr1 = List.scanr1;
  prelude.slice = List.slice;
  prelude.take = List.take;
  prelude.drop = List.drop;
  prelude.splitAt = List.splitAt;
  prelude.takeWhile = List.takeWhile;
  prelude.dropWhile = List.dropWhile;
  prelude.span = List.span;
  prelude.breakList = List.breakList;
  prelude.zip = List.zip;
  prelude.zipWith = List.zipWith;
  prelude.zipAll = List.zipAll;
  prelude.zipAllWith = List.zipAllWith;
  prelude.at = List.at;
  prelude.elemIndex = List.elemIndex;
  prelude.elemIndices = List.elemIndices;
  prelude.findIndex = List.findIndex;
  prelude.findIndices = List.findIndices;
  prelude.apply = Func.apply;
  prelude.curry = Func.curry;
  prelude.flip = Func.flip;
  prelude.fix = Func.fix;
  prelude.over = Func.over;
  prelude.split = Str.split;
  prelude.join = Str.join;
  prelude.lines = Str.lines;
  prelude.unlines = Str.unlines;
  prelude.words = Str.words;
  prelude.unwords = Str.unwords;
  prelude.chars = Str.chars;
  prelude.unchars = Str.unchars;
  prelude.repeat = Str.repeat;
  prelude.capitalize = Str.capitalize;
  prelude.camelize = Str.camelize;
  prelude.dasherize = Str.dasherize;
  prelude.values = Obj.values;
  prelude.keys = Obj.keys;
  prelude.pairsToObj = Obj.pairsToObj;
  prelude.objToPairs = Obj.objToPairs;
  prelude.listsToObj = Obj.listsToObj;
  prelude.objToLists = Obj.objToLists;
  prelude.max = Num.max;
  prelude.min = Num.min;
  prelude.negate = Num.negate;
  prelude.abs = Num.abs;
  prelude.signum = Num.signum;
  prelude.quot = Num.quot;
  prelude.rem = Num.rem;
  prelude.div = Num.div;
  prelude.mod = Num.mod;
  prelude.recip = Num.recip;
  prelude.pi = Num.pi;
  prelude.tau = Num.tau;
  prelude.exp = Num.exp;
  prelude.sqrt = Num.sqrt;
  prelude.ln = Num.ln;
  prelude.pow = Num.pow;
  prelude.sin = Num.sin;
  prelude.tan = Num.tan;
  prelude.cos = Num.cos;
  prelude.acos = Num.acos;
  prelude.asin = Num.asin;
  prelude.atan = Num.atan;
  prelude.atan2 = Num.atan2;
  prelude.truncate = Num.truncate;
  prelude.round = Num.round;
  prelude.ceiling = Num.ceiling;
  prelude.floor = Num.floor;
  prelude.isItNaN = Num.isItNaN;
  prelude.even = Num.even;
  prelude.odd = Num.odd;
  prelude.gcd = Num.gcd;
  prelude.lcm = Num.lcm;
  prelude.VERSION = "1.2.1";
  module2.exports = prelude;
  function curry$(f, bound) {
    var context4, _curry = function(args) {
      return f.length > 1 ? function() {
        var params = args ? args.concat() : [];
        context4 = bound ? context4 || this : this;
        return params.push.apply(params, arguments) < f.length && arguments.length ? _curry.call(context4, params) : f.apply(context4, params);
      } : f;
    };
    return _curry();
  }
});

// node_modules/eslint/node_modules/levn/lib/parse-string.js
var require_parse_string = __commonJS((exports2, module2) => {
  (function() {
    var reject, special, tokenRegex;
    reject = require_lib6().reject;
    function consumeOp(tokens, op) {
      if (tokens[0] === op) {
        return tokens.shift();
      } else {
        throw new Error("Expected '" + op + "', but got '" + tokens[0] + "' instead in " + JSON.stringify(tokens) + ".");
      }
    }
    function maybeConsumeOp(tokens, op) {
      if (tokens[0] === op) {
        return tokens.shift();
      }
    }
    function consumeList(tokens, arg$, hasDelimiters) {
      var open, close, result, untilTest;
      open = arg$[0], close = arg$[1];
      if (hasDelimiters) {
        consumeOp(tokens, open);
      }
      result = [];
      untilTest = "," + (hasDelimiters ? close : "");
      while (tokens.length && (hasDelimiters && tokens[0] !== close)) {
        result.push(consumeElement(tokens, untilTest));
        maybeConsumeOp(tokens, ",");
      }
      if (hasDelimiters) {
        consumeOp(tokens, close);
      }
      return result;
    }
    function consumeArray(tokens, hasDelimiters) {
      return consumeList(tokens, ["[", "]"], hasDelimiters);
    }
    function consumeTuple(tokens, hasDelimiters) {
      return consumeList(tokens, ["(", ")"], hasDelimiters);
    }
    function consumeFields(tokens, hasDelimiters) {
      var result, untilTest, key;
      if (hasDelimiters) {
        consumeOp(tokens, "{");
      }
      result = {};
      untilTest = "," + (hasDelimiters ? "}" : "");
      while (tokens.length && (!hasDelimiters || tokens[0] !== "}")) {
        key = consumeValue(tokens, ":");
        consumeOp(tokens, ":");
        result[key] = consumeElement(tokens, untilTest);
        maybeConsumeOp(tokens, ",");
      }
      if (hasDelimiters) {
        consumeOp(tokens, "}");
      }
      return result;
    }
    function consumeValue(tokens, untilTest) {
      var out;
      untilTest == null && (untilTest = "");
      out = "";
      while (tokens.length && untilTest.indexOf(tokens[0]) === -1) {
        out += tokens.shift();
      }
      return out;
    }
    function consumeElement(tokens, untilTest) {
      switch (tokens[0]) {
        case "[":
          return consumeArray(tokens, true);
        case "(":
          return consumeTuple(tokens, true);
        case "{":
          return consumeFields(tokens, true);
        default:
          return consumeValue(tokens, untilTest);
      }
    }
    function consumeTopLevel(tokens, types, options) {
      var ref$, type, structure, origTokens, result, finalResult, x$, y$;
      ref$ = types[0], type = ref$.type, structure = ref$.structure;
      origTokens = tokens.concat();
      if (!options.explicit && types.length === 1 && (!type && structure || (type === "Array" || type === "Object"))) {
        result = structure === "array" || type === "Array" ? consumeArray(tokens, tokens[0] === "[") : structure === "tuple" ? consumeTuple(tokens, tokens[0] === "(") : consumeFields(tokens, tokens[0] === "{");
        finalResult = tokens.length ? consumeElement(structure === "array" || type === "Array" ? (x$ = origTokens, x$.unshift("["), x$.push("]"), x$) : (y$ = origTokens, y$.unshift("("), y$.push(")"), y$)) : result;
      } else {
        finalResult = consumeElement(tokens);
      }
      return finalResult;
    }
    special = /\[\]\(\)}{:,/.source;
    tokenRegex = RegExp(`("(?:\\\\"|[^"])*")|('(?:\\\\'|[^'])*')|(/(?:\\\\/|[^/])*/[a-zA-Z]*)|(#.*#)|([` + special + "])|([^\\s" + special + "](?:\\s*[^\\s" + special + "]+)*)|\\s*");
    module2.exports = function(types, string, options) {
      var tokens, node;
      options == null && (options = {});
      if (!options.explicit && types.length === 1 && types[0].type === "String") {
        return string;
      }
      tokens = reject(not$, string.split(tokenRegex));
      node = consumeTopLevel(tokens, types, options);
      if (!node) {
        throw new Error("Error parsing '" + string + "'.");
      }
      return node;
    };
    function not$(x) {
      return !x;
    }
  }).call(exports2);
});

// node_modules/eslint/node_modules/type-check/lib/parse-type.js
var require_parse_type = __commonJS((exports2, module2) => {
  (function() {
    var identifierRegex, tokenRegex;
    identifierRegex = /[\$\w]+/;
    function peek(tokens) {
      var token;
      token = tokens[0];
      if (token == null) {
        throw new Error("Unexpected end of input.");
      }
      return token;
    }
    function consumeIdent(tokens) {
      var token;
      token = peek(tokens);
      if (!identifierRegex.test(token)) {
        throw new Error("Expected text, got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function consumeOp(tokens, op) {
      var token;
      token = peek(tokens);
      if (token !== op) {
        throw new Error("Expected '" + op + "', got '" + token + "' instead.");
      }
      return tokens.shift();
    }
    function maybeConsumeOp(tokens, op) {
      var token;
      token = tokens[0];
      if (token === op) {
        return tokens.shift();
      } else {
        return null;
      }
    }
    function consumeArray(tokens) {
      var types;
      consumeOp(tokens, "[");
      if (peek(tokens) === "]") {
        throw new Error("Must specify type of Array - eg. [Type], got [] instead.");
      }
      types = consumeTypes(tokens);
      consumeOp(tokens, "]");
      return {
        structure: "array",
        of: types
      };
    }
    function consumeTuple(tokens) {
      var components;
      components = [];
      consumeOp(tokens, "(");
      if (peek(tokens) === ")") {
        throw new Error("Tuple must be of at least length 1 - eg. (Type), got () instead.");
      }
      for (; ; ) {
        components.push(consumeTypes(tokens));
        maybeConsumeOp(tokens, ",");
        if (peek(tokens) === ")") {
          break;
        }
      }
      consumeOp(tokens, ")");
      return {
        structure: "tuple",
        of: components
      };
    }
    function consumeFields(tokens) {
      var fields, subset, ref$, key, types;
      fields = {};
      consumeOp(tokens, "{");
      subset = false;
      for (; ; ) {
        if (maybeConsumeOp(tokens, "...")) {
          subset = true;
          break;
        }
        ref$ = consumeField(tokens), key = ref$[0], types = ref$[1];
        fields[key] = types;
        maybeConsumeOp(tokens, ",");
        if (peek(tokens) === "}") {
          break;
        }
      }
      consumeOp(tokens, "}");
      return {
        structure: "fields",
        of: fields,
        subset
      };
    }
    function consumeField(tokens) {
      var key, types;
      key = consumeIdent(tokens);
      consumeOp(tokens, ":");
      types = consumeTypes(tokens);
      return [key, types];
    }
    function maybeConsumeStructure(tokens) {
      switch (tokens[0]) {
        case "[":
          return consumeArray(tokens);
        case "(":
          return consumeTuple(tokens);
        case "{":
          return consumeFields(tokens);
      }
    }
    function consumeType(tokens) {
      var token, wildcard, type, structure;
      token = peek(tokens);
      wildcard = token === "*";
      if (wildcard || identifierRegex.test(token)) {
        type = wildcard ? consumeOp(tokens, "*") : consumeIdent(tokens);
        structure = maybeConsumeStructure(tokens);
        if (structure) {
          return structure.type = type, structure;
        } else {
          return {
            type
          };
        }
      } else {
        structure = maybeConsumeStructure(tokens);
        if (!structure) {
          throw new Error("Unexpected character: " + token);
        }
        return structure;
      }
    }
    function consumeTypes(tokens) {
      var lookahead, types, typesSoFar, typeObj, type, structure;
      if (peek(tokens) === "::") {
        throw new Error("No comment before comment separator '::' found.");
      }
      lookahead = tokens[1];
      if (lookahead != null && lookahead === "::") {
        tokens.shift();
        tokens.shift();
      }
      types = [];
      typesSoFar = {};
      if (peek(tokens) === "Maybe") {
        tokens.shift();
        types = [
          {
            type: "Undefined"
          },
          {
            type: "Null"
          }
        ];
        typesSoFar = {
          Undefined: true,
          Null: true
        };
      }
      for (; ; ) {
        typeObj = consumeType(tokens), type = typeObj.type, structure = typeObj.structure;
        if (!typesSoFar[type]) {
          types.push(typeObj);
        }
        if (structure == null) {
          typesSoFar[type] = true;
        }
        if (!maybeConsumeOp(tokens, "|")) {
          break;
        }
      }
      return types;
    }
    tokenRegex = RegExp("\\.\\.\\.|::|->|" + identifierRegex.source + "|\\S", "g");
    module2.exports = function(input) {
      var tokens, e;
      if (!input.length) {
        throw new Error("No type specified.");
      }
      tokens = input.match(tokenRegex) || [];
      if (in$("->", tokens)) {
        throw new Error("Function types are not supported. To validate that something is a function, you may use 'Function'.");
      }
      try {
        return consumeTypes(tokens);
      } catch (e$) {
        e = e$;
        throw new Error(e.message + " - Remaining tokens: " + JSON.stringify(tokens) + " - Initial input: '" + input + "'");
      }
    };
    function in$(x, xs) {
      var i = -1, l = xs.length >>> 0;
      while (++i < l)
        if (x === xs[i])
          return true;
      return false;
    }
  }).call(exports2);
});

// node_modules/eslint/node_modules/type-check/lib/check.js
var require_check = __commonJS((exports2, module2) => {
  (function() {
    var ref$, any, all, isItNaN, types, defaultType, toString$ = {}.toString;
    ref$ = require_lib6(), any = ref$.any, all = ref$.all, isItNaN = ref$.isItNaN;
    types = {
      Number: {
        typeOf: "Number",
        validate: function(it2) {
          return !isItNaN(it2);
        }
      },
      NaN: {
        typeOf: "Number",
        validate: isItNaN
      },
      Int: {
        typeOf: "Number",
        validate: function(it2) {
          return !isItNaN(it2) && it2 % 1 === 0;
        }
      },
      Float: {
        typeOf: "Number",
        validate: function(it2) {
          return !isItNaN(it2);
        }
      },
      Date: {
        typeOf: "Date",
        validate: function(it2) {
          return !isItNaN(it2.getTime());
        }
      }
    };
    defaultType = {
      array: "Array",
      tuple: "Array"
    };
    function checkArray(input, type, options) {
      return all(function(it2) {
        return checkMultiple(it2, type.of, options);
      }, input);
    }
    function checkTuple(input, type, options) {
      var i, i$, ref$2, len$, types2;
      i = 0;
      for (i$ = 0, len$ = (ref$2 = type.of).length; i$ < len$; ++i$) {
        types2 = ref$2[i$];
        if (!checkMultiple(input[i], types2, options)) {
          return false;
        }
        i++;
      }
      return input.length <= i;
    }
    function checkFields(input, type, options) {
      var inputKeys, numInputKeys, k, numOfKeys, key, ref$2, types2;
      inputKeys = {};
      numInputKeys = 0;
      for (k in input) {
        inputKeys[k] = true;
        numInputKeys++;
      }
      numOfKeys = 0;
      for (key in ref$2 = type.of) {
        types2 = ref$2[key];
        if (!checkMultiple(input[key], types2, options)) {
          return false;
        }
        if (inputKeys[key]) {
          numOfKeys++;
        }
      }
      return type.subset || numInputKeys === numOfKeys;
    }
    function checkStructure(input, type, options) {
      if (!(input instanceof Object)) {
        return false;
      }
      switch (type.structure) {
        case "fields":
          return checkFields(input, type, options);
        case "array":
          return checkArray(input, type, options);
        case "tuple":
          return checkTuple(input, type, options);
      }
    }
    function check(input, typeObj, options) {
      var type, structure, setting, that;
      type = typeObj.type, structure = typeObj.structure;
      if (type) {
        if (type === "*") {
          return true;
        }
        setting = options.customTypes[type] || types[type];
        if (setting) {
          return (setting.typeOf === void 0 || setting.typeOf === toString$.call(input).slice(8, -1)) && setting.validate(input);
        } else {
          return type === toString$.call(input).slice(8, -1) && (!structure || checkStructure(input, typeObj, options));
        }
      } else if (structure) {
        if (that = defaultType[structure]) {
          if (that !== toString$.call(input).slice(8, -1)) {
            return false;
          }
        }
        return checkStructure(input, typeObj, options);
      } else {
        throw new Error("No type defined. Input: " + input + ".");
      }
    }
    function checkMultiple(input, types2, options) {
      if (toString$.call(types2).slice(8, -1) !== "Array") {
        throw new Error("Types must be in an array. Input: " + input + ".");
      }
      return any(function(it2) {
        return check(input, it2, options);
      }, types2);
    }
    module2.exports = function(parsedType, input, options) {
      options == null && (options = {});
      if (options.customTypes == null) {
        options.customTypes = {};
      }
      return checkMultiple(input, parsedType, options);
    };
  }).call(exports2);
});

// node_modules/eslint/node_modules/type-check/lib/index.js
var require_lib7 = __commonJS((exports2, module2) => {
  (function() {
    var VERSION, parseType, parsedTypeCheck, typeCheck;
    VERSION = "0.4.0";
    parseType = require_parse_type();
    parsedTypeCheck = require_check();
    typeCheck = function(type, input, options) {
      return parsedTypeCheck(parseType(type), input, options);
    };
    module2.exports = {
      VERSION,
      typeCheck,
      parsedTypeCheck,
      parseType
    };
  }).call(exports2);
});

// node_modules/eslint/node_modules/levn/lib/cast.js
var require_cast = __commonJS((exports2, module2) => {
  (function() {
    var parsedTypeCheck, types, toString$ = {}.toString;
    parsedTypeCheck = require_lib7().parsedTypeCheck;
    types = {
      "*": function(value, options) {
        switch (toString$.call(value).slice(8, -1)) {
          case "Array":
            return typeCast(value, {
              type: "Array"
            }, options);
          case "Object":
            return typeCast(value, {
              type: "Object"
            }, options);
          default:
            return {
              type: "Just",
              value: typesCast(value, [
                {
                  type: "Undefined"
                },
                {
                  type: "Null"
                },
                {
                  type: "NaN"
                },
                {
                  type: "Boolean"
                },
                {
                  type: "Number"
                },
                {
                  type: "Date"
                },
                {
                  type: "RegExp"
                },
                {
                  type: "Array"
                },
                {
                  type: "Object"
                },
                {
                  type: "String"
                }
              ], (options.explicit = true, options))
            };
        }
      },
      Undefined: function(it2) {
        if (it2 === "undefined" || it2 === void 0) {
          return {
            type: "Just",
            value: void 0
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Null: function(it2) {
        if (it2 === "null") {
          return {
            type: "Just",
            value: null
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      NaN: function(it2) {
        if (it2 === "NaN") {
          return {
            type: "Just",
            value: NaN
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Boolean: function(it2) {
        if (it2 === "true") {
          return {
            type: "Just",
            value: true
          };
        } else if (it2 === "false") {
          return {
            type: "Just",
            value: false
          };
        } else {
          return {
            type: "Nothing"
          };
        }
      },
      Number: function(it2) {
        return {
          type: "Just",
          value: +it2
        };
      },
      Int: function(it2) {
        return {
          type: "Just",
          value: +it2
        };
      },
      Float: function(it2) {
        return {
          type: "Just",
          value: +it2
        };
      },
      Date: function(value, options) {
        var that;
        if (that = /^\#([\s\S]*)\#$/.exec(value)) {
          return {
            type: "Just",
            value: new Date(+that[1] || that[1])
          };
        } else if (options.explicit) {
          return {
            type: "Nothing"
          };
        } else {
          return {
            type: "Just",
            value: new Date(+value || value)
          };
        }
      },
      RegExp: function(value, options) {
        var that;
        if (that = /^\/([\s\S]*)\/([gimy]*)$/.exec(value)) {
          return {
            type: "Just",
            value: new RegExp(that[1], that[2])
          };
        } else if (options.explicit) {
          return {
            type: "Nothing"
          };
        } else {
          return {
            type: "Just",
            value: new RegExp(value)
          };
        }
      },
      Array: function(value, options) {
        return castArray(value, {
          of: [{
            type: "*"
          }]
        }, options);
      },
      Object: function(value, options) {
        return castFields(value, {
          of: {}
        }, options);
      },
      String: function(it2) {
        var replace, that;
        if (toString$.call(it2).slice(8, -1) !== "String") {
          return {
            type: "Nothing"
          };
        }
        replace = function(value, quote) {
          return value.replace(/\\([^u]|u[0-9a-fA-F]{4})/g, function(all, escaped) {
            switch (escaped[0]) {
              case quote:
                return quote;
              case "\\":
                return "\\";
              case "b":
                return "\b";
              case "f":
                return "\f";
              case "n":
                return "\n";
              case "r":
                return "\r";
              case "t":
                return "	";
              case "u":
                return JSON.parse('"' + all + '"');
              default:
                return escaped;
            }
          });
        };
        if (that = it2.match(/^'([\s\S]*)'$/)) {
          return {
            type: "Just",
            value: replace(that[1], "'")
          };
        } else if (that = it2.match(/^"([\s\S]*)"$/)) {
          return {
            type: "Just",
            value: replace(that[1], '"')
          };
        } else {
          return {
            type: "Just",
            value: it2
          };
        }
      }
    };
    function castArray(node, type, options) {
      var typeOf, element;
      if (toString$.call(node).slice(8, -1) !== "Array") {
        return {
          type: "Nothing"
        };
      }
      typeOf = type.of;
      return {
        type: "Just",
        value: function() {
          var i$, ref$, len$, results$ = [];
          for (i$ = 0, len$ = (ref$ = node).length; i$ < len$; ++i$) {
            element = ref$[i$];
            results$.push(typesCast(element, typeOf, options));
          }
          return results$;
        }()
      };
    }
    function castTuple(node, type, options) {
      var result, i, i$, ref$, len$, types2, cast;
      if (toString$.call(node).slice(8, -1) !== "Array") {
        return {
          type: "Nothing"
        };
      }
      result = [];
      i = 0;
      for (i$ = 0, len$ = (ref$ = type.of).length; i$ < len$; ++i$) {
        types2 = ref$[i$];
        cast = typesCast(node[i], types2, options);
        if (toString$.call(cast).slice(8, -1) !== "Undefined") {
          result.push(cast);
        }
        i++;
      }
      if (node.length <= i) {
        return {
          type: "Just",
          value: result
        };
      } else {
        return {
          type: "Nothing"
        };
      }
    }
    function castFields(node, type, options) {
      var typeOf, key, value;
      if (toString$.call(node).slice(8, -1) !== "Object") {
        return {
          type: "Nothing"
        };
      }
      typeOf = type.of;
      return {
        type: "Just",
        value: function() {
          var ref$, resultObj$ = {};
          for (key in ref$ = node) {
            value = ref$[key];
            resultObj$[typesCast(key, [{
              type: "String"
            }], options)] = typesCast(value, typeOf[key] || [{
              type: "*"
            }], options);
          }
          return resultObj$;
        }()
      };
    }
    function typeCast(node, typeObj, options) {
      var type, structure, castFunc, ref$;
      type = typeObj.type, structure = typeObj.structure;
      if (type) {
        castFunc = ((ref$ = options.customTypes[type]) != null ? ref$.cast : void 0) || types[type];
        if (!castFunc) {
          throw new Error("Type not defined: " + type + ".");
        }
        return castFunc(node, options, typesCast);
      } else {
        switch (structure) {
          case "array":
            return castArray(node, typeObj, options);
          case "tuple":
            return castTuple(node, typeObj, options);
          case "fields":
            return castFields(node, typeObj, options);
        }
      }
    }
    function typesCast(node, types2, options) {
      var i$, len$, type, ref$, valueType, value;
      for (i$ = 0, len$ = types2.length; i$ < len$; ++i$) {
        type = types2[i$];
        ref$ = typeCast(node, type, options), valueType = ref$.type, value = ref$.value;
        if (valueType === "Nothing") {
          continue;
        }
        if (parsedTypeCheck([type], value, {
          customTypes: options.customTypes
        })) {
          return value;
        }
      }
      throw new Error("Value " + JSON.stringify(node) + " does not type check against " + JSON.stringify(types2) + ".");
    }
    module2.exports = function(node, types2, options) {
      if (!options.explicit && types2.length === 1 && types2[0].type === "String") {
        return node;
      }
      return typesCast(node, types2, options);
    };
  }).call(exports2);
});

// node_modules/eslint/node_modules/levn/lib/index.js
var require_lib8 = __commonJS((exports2, module2) => {
  (function() {
    var parseString, cast, parseType, VERSION, parsedTypeParse, parse;
    parseString = require_parse_string();
    cast = require_cast();
    parseType = require_lib7().parseType;
    VERSION = "0.4.1";
    parsedTypeParse = function(parsedType, string, options) {
      options == null && (options = {});
      options.explicit == null && (options.explicit = false);
      options.customTypes == null && (options.customTypes = {});
      return cast(parseString(parsedType, string, options), parsedType, options);
    };
    parse = function(type, string, options) {
      return parsedTypeParse(parseType(type), string, options);
    };
    module2.exports = {
      VERSION,
      parse,
      parsedTypeParse
    };
  }).call(exports2);
});

// node_modules/eslint/lib/linter/config-comment-parser.js
var require_config_comment_parser = __commonJS((exports2, module2) => {
  "use strict";
  var levn = require_lib8();
  var ConfigOps = require_config_ops();
  var debug5 = require_src()("eslint:config-comment-parser");
  module2.exports = class ConfigCommentParser {
    parseStringConfig(string, comment) {
      debug5("Parsing String config");
      const items = {};
      const trimmedString = string.replace(/\s*([:,])\s*/gu, "$1");
      trimmedString.split(/\s|,+/u).forEach((name) => {
        if (!name) {
          return;
        }
        const [key, value = null] = name.split(":");
        items[key] = {value, comment};
      });
      return items;
    }
    parseJsonConfig(string, location) {
      debug5("Parsing JSON config");
      let items = {};
      try {
        items = levn.parse("Object", string) || {};
        if (ConfigOps.isEverySeverityValid(items)) {
          return {
            success: true,
            config: items
          };
        }
      } catch (e) {
        debug5("Levn parsing failed; falling back to manual parsing.");
      }
      items = {};
      const normalizedString = string.replace(/([-a-zA-Z0-9/]+):/gu, '"$1":').replace(/(\]|[0-9])\s+(?=")/u, "$1,");
      try {
        items = JSON.parse(`{${normalizedString}}`);
      } catch (ex) {
        debug5("Manual parsing failed.");
        return {
          success: false,
          error: {
            ruleId: null,
            fatal: true,
            severity: 2,
            message: `Failed to parse JSON from '${normalizedString}': ${ex.message}`,
            line: location.start.line,
            column: location.start.column + 1
          }
        };
      }
      return {
        success: true,
        config: items
      };
    }
    parseListConfig(string) {
      debug5("Parsing list config");
      const items = {};
      string.replace(/\s*,\s*/gu, ",").split(/,+/u).forEach((name) => {
        const trimmedName = name.trim();
        if (trimmedName) {
          items[trimmedName] = true;
        }
      });
      return items;
    }
  };
});

// node_modules/esquery/dist/esquery.min.js
var require_esquery_min = __commonJS((exports2, module2) => {
  !function(e, t) {
    typeof exports2 == "object" && typeof module2 != "undefined" ? module2.exports = t() : typeof define == "function" && define.amd ? define(t) : (e = e || self).esquery = t();
  }(exports2, function() {
    "use strict";
    function e(t2) {
      return (e = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e2) {
        return typeof e2;
      } : function(e2) {
        return e2 && typeof Symbol == "function" && e2.constructor === Symbol && e2 !== Symbol.prototype ? "symbol" : typeof e2;
      })(t2);
    }
    function t(e2, t2) {
      return function(e3) {
        if (Array.isArray(e3))
          return e3;
      }(e2) || function(e3, t3) {
        if (typeof Symbol == "undefined" || !(Symbol.iterator in Object(e3)))
          return;
        var r2 = [], n2 = true, o2 = false, a2 = void 0;
        try {
          for (var i2, s2 = e3[Symbol.iterator](); !(n2 = (i2 = s2.next()).done) && (r2.push(i2.value), !t3 || r2.length !== t3); n2 = true)
            ;
        } catch (e4) {
          o2 = true, a2 = e4;
        } finally {
          try {
            n2 || s2.return == null || s2.return();
          } finally {
            if (o2)
              throw a2;
          }
        }
        return r2;
      }(e2, t2) || n(e2, t2) || function() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function r(e2) {
      return function(e3) {
        if (Array.isArray(e3))
          return o(e3);
      }(e2) || function(e3) {
        if (typeof Symbol != "undefined" && Symbol.iterator in Object(e3))
          return Array.from(e3);
      }(e2) || n(e2) || function() {
        throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }();
    }
    function n(e2, t2) {
      if (e2) {
        if (typeof e2 == "string")
          return o(e2, t2);
        var r2 = Object.prototype.toString.call(e2).slice(8, -1);
        return r2 === "Object" && e2.constructor && (r2 = e2.constructor.name), r2 === "Map" || r2 === "Set" ? Array.from(e2) : r2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r2) ? o(e2, t2) : void 0;
      }
    }
    function o(e2, t2) {
      (t2 == null || t2 > e2.length) && (t2 = e2.length);
      for (var r2 = 0, n2 = new Array(t2); r2 < t2; r2++)
        n2[r2] = e2[r2];
      return n2;
    }
    function a(e2, t2) {
      var r2;
      if (typeof Symbol == "undefined" || e2[Symbol.iterator] == null) {
        if (Array.isArray(e2) || (r2 = n(e2)) || t2 && e2 && typeof e2.length == "number") {
          r2 && (e2 = r2);
          var o2 = 0, a2 = function() {
          };
          return {s: a2, n: function() {
            return o2 >= e2.length ? {done: true} : {done: false, value: e2[o2++]};
          }, e: function(e3) {
            throw e3;
          }, f: a2};
        }
        throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      var i2, s2 = true, l2 = false;
      return {s: function() {
        r2 = e2[Symbol.iterator]();
      }, n: function() {
        var e3 = r2.next();
        return s2 = e3.done, e3;
      }, e: function(e3) {
        l2 = true, i2 = e3;
      }, f: function() {
        try {
          s2 || r2.return == null || r2.return();
        } finally {
          if (l2)
            throw i2;
        }
      }};
    }
    typeof globalThis != "undefined" ? globalThis : typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" && self;
    function i(e2, t2) {
      return e2(t2 = {exports: {}}, t2.exports), t2.exports;
    }
    var s = i(function(e2, t2) {
      !function e3(t3) {
        var r2, n2, o2, a2, i2, s2;
        function l2(e4) {
          var t4, r3, n3 = {};
          for (t4 in e4)
            e4.hasOwnProperty(t4) && (r3 = e4[t4], n3[t4] = typeof r3 == "object" && r3 !== null ? l2(r3) : r3);
          return n3;
        }
        function u2(e4, t4) {
          this.parent = e4, this.key = t4;
        }
        function c2(e4, t4, r3, n3) {
          this.node = e4, this.path = t4, this.wrap = r3, this.ref = n3;
        }
        function f2() {
        }
        function p2(e4) {
          return e4 != null && (typeof e4 == "object" && typeof e4.type == "string");
        }
        function h2(e4, t4) {
          return (e4 === r2.ObjectExpression || e4 === r2.ObjectPattern) && t4 === "properties";
        }
        function y2(e4, t4) {
          for (var r3 = e4.length - 1; r3 >= 0; --r3)
            if (e4[r3].node === t4)
              return true;
          return false;
        }
        function d2(e4, t4) {
          return new f2().traverse(e4, t4);
        }
        function m2(e4, t4) {
          var r3;
          return r3 = function(e5, t5) {
            var r4, n3, o3, a3;
            for (n3 = e5.length, o3 = 0; n3; )
              t5(e5[a3 = o3 + (r4 = n3 >>> 1)]) ? n3 = r4 : (o3 = a3 + 1, n3 -= r4 + 1);
            return o3;
          }(t4, function(t5) {
            return t5.range[0] > e4.range[0];
          }), e4.extendedRange = [e4.range[0], e4.range[1]], r3 !== t4.length && (e4.extendedRange[1] = t4[r3].range[0]), (r3 -= 1) >= 0 && (e4.extendedRange[0] = t4[r3].range[1]), e4;
        }
        return r2 = {AssignmentExpression: "AssignmentExpression", AssignmentPattern: "AssignmentPattern", ArrayExpression: "ArrayExpression", ArrayPattern: "ArrayPattern", ArrowFunctionExpression: "ArrowFunctionExpression", AwaitExpression: "AwaitExpression", BlockStatement: "BlockStatement", BinaryExpression: "BinaryExpression", BreakStatement: "BreakStatement", CallExpression: "CallExpression", CatchClause: "CatchClause", ChainExpression: "ChainExpression", ClassBody: "ClassBody", ClassDeclaration: "ClassDeclaration", ClassExpression: "ClassExpression", ComprehensionBlock: "ComprehensionBlock", ComprehensionExpression: "ComprehensionExpression", ConditionalExpression: "ConditionalExpression", ContinueStatement: "ContinueStatement", DebuggerStatement: "DebuggerStatement", DirectiveStatement: "DirectiveStatement", DoWhileStatement: "DoWhileStatement", EmptyStatement: "EmptyStatement", ExportAllDeclaration: "ExportAllDeclaration", ExportDefaultDeclaration: "ExportDefaultDeclaration", ExportNamedDeclaration: "ExportNamedDeclaration", ExportSpecifier: "ExportSpecifier", ExpressionStatement: "ExpressionStatement", ForStatement: "ForStatement", ForInStatement: "ForInStatement", ForOfStatement: "ForOfStatement", FunctionDeclaration: "FunctionDeclaration", FunctionExpression: "FunctionExpression", GeneratorExpression: "GeneratorExpression", Identifier: "Identifier", IfStatement: "IfStatement", ImportExpression: "ImportExpression", ImportDeclaration: "ImportDeclaration", ImportDefaultSpecifier: "ImportDefaultSpecifier", ImportNamespaceSpecifier: "ImportNamespaceSpecifier", ImportSpecifier: "ImportSpecifier", Literal: "Literal", LabeledStatement: "LabeledStatement", LogicalExpression: "LogicalExpression", MemberExpression: "MemberExpression", MetaProperty: "MetaProperty", MethodDefinition: "MethodDefinition", ModuleSpecifier: "ModuleSpecifier", NewExpression: "NewExpression", ObjectExpression: "ObjectExpression", ObjectPattern: "ObjectPattern", Program: "Program", Property: "Property", RestElement: "RestElement", ReturnStatement: "ReturnStatement", SequenceExpression: "SequenceExpression", SpreadElement: "SpreadElement", Super: "Super", SwitchStatement: "SwitchStatement", SwitchCase: "SwitchCase", TaggedTemplateExpression: "TaggedTemplateExpression", TemplateElement: "TemplateElement", TemplateLiteral: "TemplateLiteral", ThisExpression: "ThisExpression", ThrowStatement: "ThrowStatement", TryStatement: "TryStatement", UnaryExpression: "UnaryExpression", UpdateExpression: "UpdateExpression", VariableDeclaration: "VariableDeclaration", VariableDeclarator: "VariableDeclarator", WhileStatement: "WhileStatement", WithStatement: "WithStatement", YieldExpression: "YieldExpression"}, o2 = {AssignmentExpression: ["left", "right"], AssignmentPattern: ["left", "right"], ArrayExpression: ["elements"], ArrayPattern: ["elements"], ArrowFunctionExpression: ["params", "body"], AwaitExpression: ["argument"], BlockStatement: ["body"], BinaryExpression: ["left", "right"], BreakStatement: ["label"], CallExpression: ["callee", "arguments"], CatchClause: ["param", "body"], ChainExpression: ["expression"], ClassBody: ["body"], ClassDeclaration: ["id", "superClass", "body"], ClassExpression: ["id", "superClass", "body"], ComprehensionBlock: ["left", "right"], ComprehensionExpression: ["blocks", "filter", "body"], ConditionalExpression: ["test", "consequent", "alternate"], ContinueStatement: ["label"], DebuggerStatement: [], DirectiveStatement: [], DoWhileStatement: ["body", "test"], EmptyStatement: [], ExportAllDeclaration: ["source"], ExportDefaultDeclaration: ["declaration"], ExportNamedDeclaration: ["declaration", "specifiers", "source"], ExportSpecifier: ["exported", "local"], ExpressionStatement: ["expression"], ForStatement: ["init", "test", "update", "body"], ForInStatement: ["left", "right", "body"], ForOfStatement: ["left", "right", "body"], FunctionDeclaration: ["id", "params", "body"], FunctionExpression: ["id", "params", "body"], GeneratorExpression: ["blocks", "filter", "body"], Identifier: [], IfStatement: ["test", "consequent", "alternate"], ImportExpression: ["source"], ImportDeclaration: ["specifiers", "source"], ImportDefaultSpecifier: ["local"], ImportNamespaceSpecifier: ["local"], ImportSpecifier: ["imported", "local"], Literal: [], LabeledStatement: ["label", "body"], LogicalExpression: ["left", "right"], MemberExpression: ["object", "property"], MetaProperty: ["meta", "property"], MethodDefinition: ["key", "value"], ModuleSpecifier: [], NewExpression: ["callee", "arguments"], ObjectExpression: ["properties"], ObjectPattern: ["properties"], Program: ["body"], Property: ["key", "value"], RestElement: ["argument"], ReturnStatement: ["argument"], SequenceExpression: ["expressions"], SpreadElement: ["argument"], Super: [], SwitchStatement: ["discriminant", "cases"], SwitchCase: ["test", "consequent"], TaggedTemplateExpression: ["tag", "quasi"], TemplateElement: [], TemplateLiteral: ["quasis", "expressions"], ThisExpression: [], ThrowStatement: ["argument"], TryStatement: ["block", "handler", "finalizer"], UnaryExpression: ["argument"], UpdateExpression: ["argument"], VariableDeclaration: ["declarations"], VariableDeclarator: ["id", "init"], WhileStatement: ["test", "body"], WithStatement: ["object", "body"], YieldExpression: ["argument"]}, n2 = {Break: a2 = {}, Skip: i2 = {}, Remove: s2 = {}}, u2.prototype.replace = function(e4) {
          this.parent[this.key] = e4;
        }, u2.prototype.remove = function() {
          return Array.isArray(this.parent) ? (this.parent.splice(this.key, 1), true) : (this.replace(null), false);
        }, f2.prototype.path = function() {
          var e4, t4, r3, n3, o3;
          function a3(e5, t5) {
            if (Array.isArray(t5))
              for (r3 = 0, n3 = t5.length; r3 < n3; ++r3)
                e5.push(t5[r3]);
            else
              e5.push(t5);
          }
          if (!this.__current.path)
            return null;
          for (o3 = [], e4 = 2, t4 = this.__leavelist.length; e4 < t4; ++e4)
            a3(o3, this.__leavelist[e4].path);
          return a3(o3, this.__current.path), o3;
        }, f2.prototype.type = function() {
          return this.current().type || this.__current.wrap;
        }, f2.prototype.parents = function() {
          var e4, t4, r3;
          for (r3 = [], e4 = 1, t4 = this.__leavelist.length; e4 < t4; ++e4)
            r3.push(this.__leavelist[e4].node);
          return r3;
        }, f2.prototype.current = function() {
          return this.__current.node;
        }, f2.prototype.__execute = function(e4, t4) {
          var r3, n3;
          return n3 = void 0, r3 = this.__current, this.__current = t4, this.__state = null, e4 && (n3 = e4.call(this, t4.node, this.__leavelist[this.__leavelist.length - 1].node)), this.__current = r3, n3;
        }, f2.prototype.notify = function(e4) {
          this.__state = e4;
        }, f2.prototype.skip = function() {
          this.notify(i2);
        }, f2.prototype.break = function() {
          this.notify(a2);
        }, f2.prototype.remove = function() {
          this.notify(s2);
        }, f2.prototype.__initialize = function(e4, t4) {
          this.visitor = t4, this.root = e4, this.__worklist = [], this.__leavelist = [], this.__current = null, this.__state = null, this.__fallback = null, t4.fallback === "iteration" ? this.__fallback = Object.keys : typeof t4.fallback == "function" && (this.__fallback = t4.fallback), this.__keys = o2, t4.keys && (this.__keys = Object.assign(Object.create(this.__keys), t4.keys));
        }, f2.prototype.traverse = function(e4, t4) {
          var r3, n3, o3, s3, l3, u3, f3, d3, m3, x2, v2, g2;
          for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, r3.push(new c2(e4, null, null, null)), n3.push(new c2(null, null, null, null)); r3.length; )
            if ((o3 = r3.pop()) !== g2) {
              if (o3.node) {
                if (u3 = this.__execute(t4.enter, o3), this.__state === a2 || u3 === a2)
                  return;
                if (r3.push(g2), n3.push(o3), this.__state === i2 || u3 === i2)
                  continue;
                if (l3 = (s3 = o3.node).type || o3.wrap, !(x2 = this.__keys[l3])) {
                  if (!this.__fallback)
                    throw new Error("Unknown node type " + l3 + ".");
                  x2 = this.__fallback(s3);
                }
                for (d3 = x2.length; (d3 -= 1) >= 0; )
                  if (v2 = s3[f3 = x2[d3]]) {
                    if (Array.isArray(v2)) {
                      for (m3 = v2.length; (m3 -= 1) >= 0; )
                        if (v2[m3] && !y2(n3, v2[m3])) {
                          if (h2(l3, x2[d3]))
                            o3 = new c2(v2[m3], [f3, m3], "Property", null);
                          else {
                            if (!p2(v2[m3]))
                              continue;
                            o3 = new c2(v2[m3], [f3, m3], null, null);
                          }
                          r3.push(o3);
                        }
                    } else if (p2(v2)) {
                      if (y2(n3, v2))
                        continue;
                      r3.push(new c2(v2, f3, null, null));
                    }
                  }
              }
            } else if (o3 = n3.pop(), u3 = this.__execute(t4.leave, o3), this.__state === a2 || u3 === a2)
              return;
        }, f2.prototype.replace = function(e4, t4) {
          var r3, n3, o3, l3, f3, y3, d3, m3, x2, v2, g2, b, A;
          function E(e5) {
            var t5, n4, o4, a3;
            if (e5.ref.remove()) {
              for (n4 = e5.ref.key, a3 = e5.ref.parent, t5 = r3.length; t5--; )
                if ((o4 = r3[t5]).ref && o4.ref.parent === a3) {
                  if (o4.ref.key < n4)
                    break;
                  --o4.ref.key;
                }
            }
          }
          for (this.__initialize(e4, t4), g2 = {}, r3 = this.__worklist, n3 = this.__leavelist, y3 = new c2(e4, null, null, new u2(b = {root: e4}, "root")), r3.push(y3), n3.push(y3); r3.length; )
            if ((y3 = r3.pop()) !== g2) {
              if ((f3 = this.__execute(t4.enter, y3)) !== void 0 && f3 !== a2 && f3 !== i2 && f3 !== s2 && (y3.ref.replace(f3), y3.node = f3), this.__state !== s2 && f3 !== s2 || (E(y3), y3.node = null), this.__state === a2 || f3 === a2)
                return b.root;
              if ((o3 = y3.node) && (r3.push(g2), n3.push(y3), this.__state !== i2 && f3 !== i2)) {
                if (l3 = o3.type || y3.wrap, !(x2 = this.__keys[l3])) {
                  if (!this.__fallback)
                    throw new Error("Unknown node type " + l3 + ".");
                  x2 = this.__fallback(o3);
                }
                for (d3 = x2.length; (d3 -= 1) >= 0; )
                  if (v2 = o3[A = x2[d3]])
                    if (Array.isArray(v2)) {
                      for (m3 = v2.length; (m3 -= 1) >= 0; )
                        if (v2[m3]) {
                          if (h2(l3, x2[d3]))
                            y3 = new c2(v2[m3], [A, m3], "Property", new u2(v2, m3));
                          else {
                            if (!p2(v2[m3]))
                              continue;
                            y3 = new c2(v2[m3], [A, m3], null, new u2(v2, m3));
                          }
                          r3.push(y3);
                        }
                    } else
                      p2(v2) && r3.push(new c2(v2, A, null, new u2(o3, A)));
              }
            } else if (y3 = n3.pop(), (f3 = this.__execute(t4.leave, y3)) !== void 0 && f3 !== a2 && f3 !== i2 && f3 !== s2 && y3.ref.replace(f3), this.__state !== s2 && f3 !== s2 || E(y3), this.__state === a2 || f3 === a2)
              return b.root;
          return b.root;
        }, t3.Syntax = r2, t3.traverse = d2, t3.replace = function(e4, t4) {
          return new f2().replace(e4, t4);
        }, t3.attachComments = function(e4, t4, r3) {
          var o3, a3, i3, s3, u3 = [];
          if (!e4.range)
            throw new Error("attachComments needs range information");
          if (!r3.length) {
            if (t4.length) {
              for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
                (o3 = l2(t4[i3])).extendedRange = [0, e4.range[0]], u3.push(o3);
              e4.leadingComments = u3;
            }
            return e4;
          }
          for (i3 = 0, a3 = t4.length; i3 < a3; i3 += 1)
            u3.push(m2(l2(t4[i3]), r3));
          return s3 = 0, d2(e4, {enter: function(e5) {
            for (var t5; s3 < u3.length && !((t5 = u3[s3]).extendedRange[1] > e5.range[0]); )
              t5.extendedRange[1] === e5.range[0] ? (e5.leadingComments || (e5.leadingComments = []), e5.leadingComments.push(t5), u3.splice(s3, 1)) : s3 += 1;
            return s3 === u3.length ? n2.Break : u3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
          }}), s3 = 0, d2(e4, {leave: function(e5) {
            for (var t5; s3 < u3.length && (t5 = u3[s3], !(e5.range[1] < t5.extendedRange[0])); )
              e5.range[1] === t5.extendedRange[0] ? (e5.trailingComments || (e5.trailingComments = []), e5.trailingComments.push(t5), u3.splice(s3, 1)) : s3 += 1;
            return s3 === u3.length ? n2.Break : u3[s3].extendedRange[0] > e5.range[1] ? n2.Skip : void 0;
          }}), e4;
        }, t3.VisitorKeys = o2, t3.VisitorOption = n2, t3.Controller = f2, t3.cloneEnvironment = function() {
          return e3({});
        }, t3;
      }(t2);
    }), l = i(function(e2) {
      e2.exports && (e2.exports = function() {
        function e3(t2, r2, n2, o2) {
          this.message = t2, this.expected = r2, this.found = n2, this.location = o2, this.name = "SyntaxError", typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, e3);
        }
        return function(e4, t2) {
          function r2() {
            this.constructor = e4;
          }
          r2.prototype = t2.prototype, e4.prototype = new r2();
        }(e3, Error), e3.buildMessage = function(e4, t2) {
          var r2 = {literal: function(e5) {
            return '"' + o2(e5.text) + '"';
          }, class: function(e5) {
            var t3, r3 = "";
            for (t3 = 0; t3 < e5.parts.length; t3++)
              r3 += e5.parts[t3] instanceof Array ? a2(e5.parts[t3][0]) + "-" + a2(e5.parts[t3][1]) : a2(e5.parts[t3]);
            return "[" + (e5.inverted ? "^" : "") + r3 + "]";
          }, any: function(e5) {
            return "any character";
          }, end: function(e5) {
            return "end of input";
          }, other: function(e5) {
            return e5.description;
          }};
          function n2(e5) {
            return e5.charCodeAt(0).toString(16).toUpperCase();
          }
          function o2(e5) {
            return e5.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
              return "\\x0" + n2(e6);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
              return "\\x" + n2(e6);
            });
          }
          function a2(e5) {
            return e5.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(e6) {
              return "\\x0" + n2(e6);
            }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(e6) {
              return "\\x" + n2(e6);
            });
          }
          return "Expected " + function(e5) {
            var t3, n3, o3, a3 = new Array(e5.length);
            for (t3 = 0; t3 < e5.length; t3++)
              a3[t3] = (o3 = e5[t3], r2[o3.type](o3));
            if (a3.sort(), a3.length > 0) {
              for (t3 = 1, n3 = 1; t3 < a3.length; t3++)
                a3[t3 - 1] !== a3[t3] && (a3[n3] = a3[t3], n3++);
              a3.length = n3;
            }
            switch (a3.length) {
              case 1:
                return a3[0];
              case 2:
                return a3[0] + " or " + a3[1];
              default:
                return a3.slice(0, -1).join(", ") + ", or " + a3[a3.length - 1];
            }
          }(e4) + " but " + function(e5) {
            return e5 ? '"' + o2(e5) + '"' : "end of input";
          }(t2) + " found.";
        }, {SyntaxError: e3, parse: function(t2, r2) {
          r2 = r2 !== void 0 ? r2 : {};
          var n2, o2, a2, i2, s2 = {}, l2 = {start: be}, u2 = be, c2 = de(" ", false), f2 = /^[^ [\],():#!=><~+.]/, p2 = me([" ", "[", "]", ",", "(", ")", ":", "#", "!", "=", ">", "<", "~", "+", "."], true, false), h2 = de(">", false), y2 = de("~", false), d2 = de("+", false), m2 = de(",", false), x2 = de("!", false), v2 = de("*", false), g2 = de("#", false), b = de("[", false), A = de("]", false), E = /^[><!]/, S = me([">", "<", "!"], false, false), _ = de("=", false), w = function(e4) {
            return (e4 || "") + "=";
          }, C = /^[><]/, P = me([">", "<"], false, false), k = de(".", false), D = function(e4, t3, r3) {
            return {type: "attribute", name: e4, operator: t3, value: r3};
          }, j = de('"', false), I = /^[^\\"]/, T = me(["\\", '"'], true, false), F = de("\\", false), L = {type: "any"}, O = function(e4, t3) {
            return e4 + t3;
          }, R = function(e4) {
            return {type: "literal", value: (t3 = e4.join(""), t3.replace(/\\(.)/g, function(e5, t4) {
              switch (t4) {
                case "b":
                  return "\b";
                case "f":
                  return "\f";
                case "n":
                  return "\n";
                case "r":
                  return "\r";
                case "t":
                  return "	";
                case "v":
                  return "\v";
                default:
                  return t4;
              }
            }))};
            var t3;
          }, B = de("'", false), M = /^[^\\']/, U = me(["\\", "'"], true, false), q = /^[0-9]/, V = me([["0", "9"]], false, false), N = de("type(", false), W = /^[^ )]/, K = me([" ", ")"], true, false), G = de(")", false), z = /^[imsu]/, H = me(["i", "m", "s", "u"], false, false), Y = de("/", false), $ = /^[^\/]/, J = me(["/"], true, false), Q = de(":not(", false), X = de(":matches(", false), Z = de(":has(", false), ee = de(":first-child", false), te = de(":last-child", false), re = de(":nth-child(", false), ne = de(":nth-last-child(", false), oe = de(":", false), ae = de("statement", true), ie = de("expression", true), se = de("declaration", true), le = de("function", true), ue = de("pattern", true), ce = 0, fe = [{line: 1, column: 1}], pe = 0, he = [], ye = {};
          if ("startRule" in r2) {
            if (!(r2.startRule in l2))
              throw new Error(`Can't start parsing from rule "` + r2.startRule + '".');
            u2 = l2[r2.startRule];
          }
          function de(e4, t3) {
            return {type: "literal", text: e4, ignoreCase: t3};
          }
          function me(e4, t3, r3) {
            return {type: "class", parts: e4, inverted: t3, ignoreCase: r3};
          }
          function xe(e4) {
            var r3, n3 = fe[e4];
            if (n3)
              return n3;
            for (r3 = e4 - 1; !fe[r3]; )
              r3--;
            for (n3 = {line: (n3 = fe[r3]).line, column: n3.column}; r3 < e4; )
              t2.charCodeAt(r3) === 10 ? (n3.line++, n3.column = 1) : n3.column++, r3++;
            return fe[e4] = n3, n3;
          }
          function ve(e4, t3) {
            var r3 = xe(e4), n3 = xe(t3);
            return {start: {offset: e4, line: r3.line, column: r3.column}, end: {offset: t3, line: n3.line, column: n3.column}};
          }
          function ge(e4) {
            ce < pe || (ce > pe && (pe = ce, he = []), he.push(e4));
          }
          function be() {
            var e4, t3, r3, n3, o3 = 30 * ce + 0, a3 = ye[o3];
            return a3 ? (ce = a3.nextPos, a3.result) : (e4 = ce, (t3 = Ae()) !== s2 && (r3 = _e()) !== s2 && Ae() !== s2 ? e4 = t3 = (n3 = r3).length === 1 ? n3[0] : {type: "matches", selectors: n3} : (ce = e4, e4 = s2), e4 === s2 && (e4 = ce, (t3 = Ae()) !== s2 && (t3 = void 0), e4 = t3), ye[o3] = {nextPos: ce, result: e4}, e4);
          }
          function Ae() {
            var e4, r3, n3 = 30 * ce + 1, o3 = ye[n3];
            if (o3)
              return ce = o3.nextPos, o3.result;
            for (e4 = [], t2.charCodeAt(ce) === 32 ? (r3 = " ", ce++) : (r3 = s2, ge(c2)); r3 !== s2; )
              e4.push(r3), t2.charCodeAt(ce) === 32 ? (r3 = " ", ce++) : (r3 = s2, ge(c2));
            return ye[n3] = {nextPos: ce, result: e4}, e4;
          }
          function Ee() {
            var e4, r3, n3, o3 = 30 * ce + 2, a3 = ye[o3];
            if (a3)
              return ce = a3.nextPos, a3.result;
            if (r3 = [], f2.test(t2.charAt(ce)) ? (n3 = t2.charAt(ce), ce++) : (n3 = s2, ge(p2)), n3 !== s2)
              for (; n3 !== s2; )
                r3.push(n3), f2.test(t2.charAt(ce)) ? (n3 = t2.charAt(ce), ce++) : (n3 = s2, ge(p2));
            else
              r3 = s2;
            return r3 !== s2 && (r3 = r3.join("")), e4 = r3, ye[o3] = {nextPos: ce, result: e4}, e4;
          }
          function Se() {
            var e4, r3, n3, o3 = 30 * ce + 3, a3 = ye[o3];
            return a3 ? (ce = a3.nextPos, a3.result) : (e4 = ce, (r3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 62 ? (n3 = ">", ce++) : (n3 = s2, ge(h2)), n3 !== s2 && Ae() !== s2 ? e4 = r3 = "child" : (ce = e4, e4 = s2)) : (ce = e4, e4 = s2), e4 === s2 && (e4 = ce, (r3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 126 ? (n3 = "~", ce++) : (n3 = s2, ge(y2)), n3 !== s2 && Ae() !== s2 ? e4 = r3 = "sibling" : (ce = e4, e4 = s2)) : (ce = e4, e4 = s2), e4 === s2 && (e4 = ce, (r3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 43 ? (n3 = "+", ce++) : (n3 = s2, ge(d2)), n3 !== s2 && Ae() !== s2 ? e4 = r3 = "adjacent" : (ce = e4, e4 = s2)) : (ce = e4, e4 = s2), e4 === s2 && (e4 = ce, t2.charCodeAt(ce) === 32 ? (r3 = " ", ce++) : (r3 = s2, ge(c2)), r3 !== s2 && (n3 = Ae()) !== s2 ? e4 = r3 = "descendant" : (ce = e4, e4 = s2)))), ye[o3] = {nextPos: ce, result: e4}, e4);
          }
          function _e() {
            var e4, r3, n3, o3, a3, i3, l3, u3, c3 = 30 * ce + 4, f3 = ye[c3];
            if (f3)
              return ce = f3.nextPos, f3.result;
            if (e4 = ce, (r3 = we()) !== s2) {
              for (n3 = [], o3 = ce, (a3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 44 ? (i3 = ",", ce++) : (i3 = s2, ge(m2)), i3 !== s2 && (l3 = Ae()) !== s2 && (u3 = we()) !== s2 ? o3 = a3 = [a3, i3, l3, u3] : (ce = o3, o3 = s2)) : (ce = o3, o3 = s2); o3 !== s2; )
                n3.push(o3), o3 = ce, (a3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 44 ? (i3 = ",", ce++) : (i3 = s2, ge(m2)), i3 !== s2 && (l3 = Ae()) !== s2 && (u3 = we()) !== s2 ? o3 = a3 = [a3, i3, l3, u3] : (ce = o3, o3 = s2)) : (ce = o3, o3 = s2);
              n3 !== s2 ? e4 = r3 = [r3].concat(n3.map(function(e5) {
                return e5[3];
              })) : (ce = e4, e4 = s2);
            } else
              ce = e4, e4 = s2;
            return ye[c3] = {nextPos: ce, result: e4}, e4;
          }
          function we() {
            var e4, t3, r3, n3, o3, a3, i3, l3 = 30 * ce + 5, u3 = ye[l3];
            if (u3)
              return ce = u3.nextPos, u3.result;
            if (e4 = ce, (t3 = Ce()) !== s2) {
              for (r3 = [], n3 = ce, (o3 = Se()) !== s2 && (a3 = Ce()) !== s2 ? n3 = o3 = [o3, a3] : (ce = n3, n3 = s2); n3 !== s2; )
                r3.push(n3), n3 = ce, (o3 = Se()) !== s2 && (a3 = Ce()) !== s2 ? n3 = o3 = [o3, a3] : (ce = n3, n3 = s2);
              r3 !== s2 ? (i3 = t3, e4 = t3 = r3.reduce(function(e5, t4) {
                return {type: t4[0], left: e5, right: t4[1]};
              }, i3)) : (ce = e4, e4 = s2);
            } else
              ce = e4, e4 = s2;
            return ye[l3] = {nextPos: ce, result: e4}, e4;
          }
          function Ce() {
            var e4, r3, n3, o3, a3, i3, l3, u3 = 30 * ce + 6, c3 = ye[u3];
            if (c3)
              return ce = c3.nextPos, c3.result;
            if (e4 = ce, t2.charCodeAt(ce) === 33 ? (r3 = "!", ce++) : (r3 = s2, ge(x2)), r3 === s2 && (r3 = null), r3 !== s2) {
              if (n3 = [], (o3 = Pe()) !== s2)
                for (; o3 !== s2; )
                  n3.push(o3), o3 = Pe();
              else
                n3 = s2;
              n3 !== s2 ? (a3 = r3, l3 = (i3 = n3).length === 1 ? i3[0] : {type: "compound", selectors: i3}, a3 && (l3.subject = true), e4 = r3 = l3) : (ce = e4, e4 = s2);
            } else
              ce = e4, e4 = s2;
            return ye[u3] = {nextPos: ce, result: e4}, e4;
          }
          function Pe() {
            var e4, r3 = 30 * ce + 7, n3 = ye[r3];
            return n3 ? (ce = n3.nextPos, n3.result) : ((e4 = function() {
              var e5, r4, n4 = 30 * ce + 8, o3 = ye[n4];
              return o3 ? (ce = o3.nextPos, o3.result) : (t2.charCodeAt(ce) === 42 ? (r4 = "*", ce++) : (r4 = s2, ge(v2)), r4 !== s2 && (r4 = {type: "wildcard", value: r4}), e5 = r4, ye[n4] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3 = 30 * ce + 9, a3 = ye[o3];
              return a3 ? (ce = a3.nextPos, a3.result) : (e5 = ce, t2.charCodeAt(ce) === 35 ? (r4 = "#", ce++) : (r4 = s2, ge(g2)), r4 === s2 && (r4 = null), r4 !== s2 && (n4 = Ee()) !== s2 ? e5 = r4 = {type: "identifier", value: n4} : (ce = e5, e5 = s2), ye[o3] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3 = 30 * ce + 10, i3 = ye[a3];
              return i3 ? (ce = i3.nextPos, i3.result) : (e5 = ce, t2.charCodeAt(ce) === 91 ? (r4 = "[", ce++) : (r4 = s2, ge(b)), r4 !== s2 && Ae() !== s2 && (n4 = function() {
                var e6, r5, n5, o4, a4 = 30 * ce + 14, i4 = ye[a4];
                return i4 ? (ce = i4.nextPos, i4.result) : (e6 = ce, (r5 = ke()) !== s2 && Ae() !== s2 && (n5 = function() {
                  var e7, r6, n6, o5 = 30 * ce + 12, a5 = ye[o5];
                  return a5 ? (ce = a5.nextPos, a5.result) : (e7 = ce, t2.charCodeAt(ce) === 33 ? (r6 = "!", ce++) : (r6 = s2, ge(x2)), r6 === s2 && (r6 = null), r6 !== s2 ? (t2.charCodeAt(ce) === 61 ? (n6 = "=", ce++) : (n6 = s2, ge(_)), n6 !== s2 ? (r6 = w(r6), e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2), ye[o5] = {nextPos: ce, result: e7}, e7);
                }()) !== s2 && Ae() !== s2 ? ((o4 = function() {
                  var e7, r6, n6, o5, a5, i5 = 30 * ce + 18, l3 = ye[i5];
                  if (l3)
                    return ce = l3.nextPos, l3.result;
                  if (e7 = ce, t2.substr(ce, 5) === "type(" ? (r6 = "type(", ce += 5) : (r6 = s2, ge(N)), r6 !== s2)
                    if (Ae() !== s2) {
                      if (n6 = [], W.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(K)), o5 !== s2)
                        for (; o5 !== s2; )
                          n6.push(o5), W.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(K));
                      else
                        n6 = s2;
                      n6 !== s2 && (o5 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 41 ? (a5 = ")", ce++) : (a5 = s2, ge(G)), a5 !== s2 ? (r6 = {type: "type", value: n6.join("")}, e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2);
                    } else
                      ce = e7, e7 = s2;
                  else
                    ce = e7, e7 = s2;
                  return ye[i5] = {nextPos: ce, result: e7}, e7;
                }()) === s2 && (o4 = function() {
                  var e7, r6, n6, o5, a5, i5, l3 = 30 * ce + 20, u3 = ye[l3];
                  if (u3)
                    return ce = u3.nextPos, u3.result;
                  if (e7 = ce, t2.charCodeAt(ce) === 47 ? (r6 = "/", ce++) : (r6 = s2, ge(Y)), r6 !== s2) {
                    if (n6 = [], $.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(J)), o5 !== s2)
                      for (; o5 !== s2; )
                        n6.push(o5), $.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(J));
                    else
                      n6 = s2;
                    n6 !== s2 ? (t2.charCodeAt(ce) === 47 ? (o5 = "/", ce++) : (o5 = s2, ge(Y)), o5 !== s2 ? ((a5 = function() {
                      var e8, r7, n7 = 30 * ce + 19, o6 = ye[n7];
                      if (o6)
                        return ce = o6.nextPos, o6.result;
                      if (e8 = [], z.test(t2.charAt(ce)) ? (r7 = t2.charAt(ce), ce++) : (r7 = s2, ge(H)), r7 !== s2)
                        for (; r7 !== s2; )
                          e8.push(r7), z.test(t2.charAt(ce)) ? (r7 = t2.charAt(ce), ce++) : (r7 = s2, ge(H));
                      else
                        e8 = s2;
                      return ye[n7] = {nextPos: ce, result: e8}, e8;
                    }()) === s2 && (a5 = null), a5 !== s2 ? (i5 = a5, r6 = {type: "regexp", value: new RegExp(n6.join(""), i5 ? i5.join("") : "")}, e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2);
                  } else
                    ce = e7, e7 = s2;
                  return ye[l3] = {nextPos: ce, result: e7}, e7;
                }()), o4 !== s2 ? (r5 = D(r5, n5, o4), e6 = r5) : (ce = e6, e6 = s2)) : (ce = e6, e6 = s2), e6 === s2 && (e6 = ce, (r5 = ke()) !== s2 && Ae() !== s2 && (n5 = function() {
                  var e7, r6, n6, o5 = 30 * ce + 11, a5 = ye[o5];
                  return a5 ? (ce = a5.nextPos, a5.result) : (e7 = ce, E.test(t2.charAt(ce)) ? (r6 = t2.charAt(ce), ce++) : (r6 = s2, ge(S)), r6 === s2 && (r6 = null), r6 !== s2 ? (t2.charCodeAt(ce) === 61 ? (n6 = "=", ce++) : (n6 = s2, ge(_)), n6 !== s2 ? (r6 = w(r6), e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2), e7 === s2 && (C.test(t2.charAt(ce)) ? (e7 = t2.charAt(ce), ce++) : (e7 = s2, ge(P))), ye[o5] = {nextPos: ce, result: e7}, e7);
                }()) !== s2 && Ae() !== s2 ? ((o4 = function() {
                  var e7, r6, n6, o5, a5, i5, l3 = 30 * ce + 15, u3 = ye[l3];
                  if (u3)
                    return ce = u3.nextPos, u3.result;
                  if (e7 = ce, t2.charCodeAt(ce) === 34 ? (r6 = '"', ce++) : (r6 = s2, ge(j)), r6 !== s2) {
                    for (n6 = [], I.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(T)), o5 === s2 && (o5 = ce, t2.charCodeAt(ce) === 92 ? (a5 = "\\", ce++) : (a5 = s2, ge(F)), a5 !== s2 ? (t2.length > ce ? (i5 = t2.charAt(ce), ce++) : (i5 = s2, ge(L)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ce = o5, o5 = s2)) : (ce = o5, o5 = s2)); o5 !== s2; )
                      n6.push(o5), I.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(T)), o5 === s2 && (o5 = ce, t2.charCodeAt(ce) === 92 ? (a5 = "\\", ce++) : (a5 = s2, ge(F)), a5 !== s2 ? (t2.length > ce ? (i5 = t2.charAt(ce), ce++) : (i5 = s2, ge(L)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ce = o5, o5 = s2)) : (ce = o5, o5 = s2));
                    n6 !== s2 ? (t2.charCodeAt(ce) === 34 ? (o5 = '"', ce++) : (o5 = s2, ge(j)), o5 !== s2 ? (r6 = R(n6), e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2);
                  } else
                    ce = e7, e7 = s2;
                  if (e7 === s2)
                    if (e7 = ce, t2.charCodeAt(ce) === 39 ? (r6 = "'", ce++) : (r6 = s2, ge(B)), r6 !== s2) {
                      for (n6 = [], M.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(U)), o5 === s2 && (o5 = ce, t2.charCodeAt(ce) === 92 ? (a5 = "\\", ce++) : (a5 = s2, ge(F)), a5 !== s2 ? (t2.length > ce ? (i5 = t2.charAt(ce), ce++) : (i5 = s2, ge(L)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ce = o5, o5 = s2)) : (ce = o5, o5 = s2)); o5 !== s2; )
                        n6.push(o5), M.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(U)), o5 === s2 && (o5 = ce, t2.charCodeAt(ce) === 92 ? (a5 = "\\", ce++) : (a5 = s2, ge(F)), a5 !== s2 ? (t2.length > ce ? (i5 = t2.charAt(ce), ce++) : (i5 = s2, ge(L)), i5 !== s2 ? (a5 = O(a5, i5), o5 = a5) : (ce = o5, o5 = s2)) : (ce = o5, o5 = s2));
                      n6 !== s2 ? (t2.charCodeAt(ce) === 39 ? (o5 = "'", ce++) : (o5 = s2, ge(B)), o5 !== s2 ? (r6 = R(n6), e7 = r6) : (ce = e7, e7 = s2)) : (ce = e7, e7 = s2);
                    } else
                      ce = e7, e7 = s2;
                  return ye[l3] = {nextPos: ce, result: e7}, e7;
                }()) === s2 && (o4 = function() {
                  var e7, r6, n6, o5, a5, i5, l3, u3 = 30 * ce + 16, c3 = ye[u3];
                  if (c3)
                    return ce = c3.nextPos, c3.result;
                  for (e7 = ce, r6 = ce, n6 = [], q.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(V)); o5 !== s2; )
                    n6.push(o5), q.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(V));
                  if (n6 !== s2 ? (t2.charCodeAt(ce) === 46 ? (o5 = ".", ce++) : (o5 = s2, ge(k)), o5 !== s2 ? r6 = n6 = [n6, o5] : (ce = r6, r6 = s2)) : (ce = r6, r6 = s2), r6 === s2 && (r6 = null), r6 !== s2) {
                    if (n6 = [], q.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(V)), o5 !== s2)
                      for (; o5 !== s2; )
                        n6.push(o5), q.test(t2.charAt(ce)) ? (o5 = t2.charAt(ce), ce++) : (o5 = s2, ge(V));
                    else
                      n6 = s2;
                    n6 !== s2 ? (i5 = n6, l3 = (a5 = r6) ? [].concat.apply([], a5).join("") : "", r6 = {type: "literal", value: parseFloat(l3 + i5.join(""))}, e7 = r6) : (ce = e7, e7 = s2);
                  } else
                    ce = e7, e7 = s2;
                  return ye[u3] = {nextPos: ce, result: e7}, e7;
                }()) === s2 && (o4 = function() {
                  var e7, t3, r6 = 30 * ce + 17, n6 = ye[r6];
                  return n6 ? (ce = n6.nextPos, n6.result) : ((t3 = Ee()) !== s2 && (t3 = {type: "literal", value: t3}), e7 = t3, ye[r6] = {nextPos: ce, result: e7}, e7);
                }()), o4 !== s2 ? (r5 = D(r5, n5, o4), e6 = r5) : (ce = e6, e6 = s2)) : (ce = e6, e6 = s2), e6 === s2 && (e6 = ce, (r5 = ke()) !== s2 && (r5 = {type: "attribute", name: r5}), e6 = r5)), ye[a4] = {nextPos: ce, result: e6}, e6);
              }()) !== s2 && Ae() !== s2 ? (t2.charCodeAt(ce) === 93 ? (o3 = "]", ce++) : (o3 = s2, ge(A)), o3 !== s2 ? e5 = r4 = n4 : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2), ye[a3] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3, i3, l3, u3, c3 = 30 * ce + 21, f3 = ye[c3];
              if (f3)
                return ce = f3.nextPos, f3.result;
              if (e5 = ce, t2.charCodeAt(ce) === 46 ? (r4 = ".", ce++) : (r4 = s2, ge(k)), r4 !== s2)
                if ((n4 = Ee()) !== s2) {
                  for (o3 = [], a3 = ce, t2.charCodeAt(ce) === 46 ? (i3 = ".", ce++) : (i3 = s2, ge(k)), i3 !== s2 && (l3 = Ee()) !== s2 ? a3 = i3 = [i3, l3] : (ce = a3, a3 = s2); a3 !== s2; )
                    o3.push(a3), a3 = ce, t2.charCodeAt(ce) === 46 ? (i3 = ".", ce++) : (i3 = s2, ge(k)), i3 !== s2 && (l3 = Ee()) !== s2 ? a3 = i3 = [i3, l3] : (ce = a3, a3 = s2);
                  o3 !== s2 ? (u3 = n4, r4 = {type: "field", name: o3.reduce(function(e6, t3) {
                    return e6 + t3[0] + t3[1];
                  }, u3)}, e5 = r4) : (ce = e5, e5 = s2);
                } else
                  ce = e5, e5 = s2;
              else
                ce = e5, e5 = s2;
              return ye[c3] = {nextPos: ce, result: e5}, e5;
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3 = 30 * ce + 22, i3 = ye[a3];
              return i3 ? (ce = i3.nextPos, i3.result) : (e5 = ce, t2.substr(ce, 5) === ":not(" ? (r4 = ":not(", ce += 5) : (r4 = s2, ge(Q)), r4 !== s2 && Ae() !== s2 && (n4 = _e()) !== s2 && Ae() !== s2 ? (t2.charCodeAt(ce) === 41 ? (o3 = ")", ce++) : (o3 = s2, ge(G)), o3 !== s2 ? e5 = r4 = {type: "not", selectors: n4} : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2), ye[a3] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3 = 30 * ce + 23, i3 = ye[a3];
              return i3 ? (ce = i3.nextPos, i3.result) : (e5 = ce, t2.substr(ce, 9) === ":matches(" ? (r4 = ":matches(", ce += 9) : (r4 = s2, ge(X)), r4 !== s2 && Ae() !== s2 && (n4 = _e()) !== s2 && Ae() !== s2 ? (t2.charCodeAt(ce) === 41 ? (o3 = ")", ce++) : (o3 = s2, ge(G)), o3 !== s2 ? e5 = r4 = {type: "matches", selectors: n4} : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2), ye[a3] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3 = 30 * ce + 24, i3 = ye[a3];
              return i3 ? (ce = i3.nextPos, i3.result) : (e5 = ce, t2.substr(ce, 5) === ":has(" ? (r4 = ":has(", ce += 5) : (r4 = s2, ge(Z)), r4 !== s2 && Ae() !== s2 && (n4 = _e()) !== s2 && Ae() !== s2 ? (t2.charCodeAt(ce) === 41 ? (o3 = ")", ce++) : (o3 = s2, ge(G)), o3 !== s2 ? e5 = r4 = {type: "has", selectors: n4} : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2), ye[a3] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4 = 30 * ce + 25, o3 = ye[n4];
              return o3 ? (ce = o3.nextPos, o3.result) : (t2.substr(ce, 12) === ":first-child" ? (r4 = ":first-child", ce += 12) : (r4 = s2, ge(ee)), r4 !== s2 && (r4 = De(1)), e5 = r4, ye[n4] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4 = 30 * ce + 26, o3 = ye[n4];
              return o3 ? (ce = o3.nextPos, o3.result) : (t2.substr(ce, 11) === ":last-child" ? (r4 = ":last-child", ce += 11) : (r4 = s2, ge(te)), r4 !== s2 && (r4 = je(1)), e5 = r4, ye[n4] = {nextPos: ce, result: e5}, e5);
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3, i3 = 30 * ce + 27, l3 = ye[i3];
              if (l3)
                return ce = l3.nextPos, l3.result;
              if (e5 = ce, t2.substr(ce, 11) === ":nth-child(" ? (r4 = ":nth-child(", ce += 11) : (r4 = s2, ge(re)), r4 !== s2)
                if (Ae() !== s2) {
                  if (n4 = [], q.test(t2.charAt(ce)) ? (o3 = t2.charAt(ce), ce++) : (o3 = s2, ge(V)), o3 !== s2)
                    for (; o3 !== s2; )
                      n4.push(o3), q.test(t2.charAt(ce)) ? (o3 = t2.charAt(ce), ce++) : (o3 = s2, ge(V));
                  else
                    n4 = s2;
                  n4 !== s2 && (o3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 41 ? (a3 = ")", ce++) : (a3 = s2, ge(G)), a3 !== s2 ? (r4 = De(parseInt(n4.join(""), 10)), e5 = r4) : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2);
                } else
                  ce = e5, e5 = s2;
              else
                ce = e5, e5 = s2;
              return ye[i3] = {nextPos: ce, result: e5}, e5;
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3, a3, i3 = 30 * ce + 28, l3 = ye[i3];
              if (l3)
                return ce = l3.nextPos, l3.result;
              if (e5 = ce, t2.substr(ce, 16) === ":nth-last-child(" ? (r4 = ":nth-last-child(", ce += 16) : (r4 = s2, ge(ne)), r4 !== s2)
                if (Ae() !== s2) {
                  if (n4 = [], q.test(t2.charAt(ce)) ? (o3 = t2.charAt(ce), ce++) : (o3 = s2, ge(V)), o3 !== s2)
                    for (; o3 !== s2; )
                      n4.push(o3), q.test(t2.charAt(ce)) ? (o3 = t2.charAt(ce), ce++) : (o3 = s2, ge(V));
                  else
                    n4 = s2;
                  n4 !== s2 && (o3 = Ae()) !== s2 ? (t2.charCodeAt(ce) === 41 ? (a3 = ")", ce++) : (a3 = s2, ge(G)), a3 !== s2 ? (r4 = je(parseInt(n4.join(""), 10)), e5 = r4) : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2);
                } else
                  ce = e5, e5 = s2;
              else
                ce = e5, e5 = s2;
              return ye[i3] = {nextPos: ce, result: e5}, e5;
            }()) === s2 && (e4 = function() {
              var e5, r4, n4, o3 = 30 * ce + 29, a3 = ye[o3];
              return a3 ? (ce = a3.nextPos, a3.result) : (e5 = ce, t2.charCodeAt(ce) === 58 ? (r4 = ":", ce++) : (r4 = s2, ge(oe)), r4 !== s2 ? (t2.substr(ce, 9).toLowerCase() === "statement" ? (n4 = t2.substr(ce, 9), ce += 9) : (n4 = s2, ge(ae)), n4 === s2 && (t2.substr(ce, 10).toLowerCase() === "expression" ? (n4 = t2.substr(ce, 10), ce += 10) : (n4 = s2, ge(ie)), n4 === s2 && (t2.substr(ce, 11).toLowerCase() === "declaration" ? (n4 = t2.substr(ce, 11), ce += 11) : (n4 = s2, ge(se)), n4 === s2 && (t2.substr(ce, 8).toLowerCase() === "function" ? (n4 = t2.substr(ce, 8), ce += 8) : (n4 = s2, ge(le)), n4 === s2 && (t2.substr(ce, 7).toLowerCase() === "pattern" ? (n4 = t2.substr(ce, 7), ce += 7) : (n4 = s2, ge(ue)))))), n4 !== s2 ? e5 = r4 = {type: "class", name: n4} : (ce = e5, e5 = s2)) : (ce = e5, e5 = s2), ye[o3] = {nextPos: ce, result: e5}, e5);
            }()), ye[r3] = {nextPos: ce, result: e4}, e4);
          }
          function ke() {
            var e4, r3, n3, o3, a3, i3, l3, u3, c3 = 30 * ce + 13, f3 = ye[c3];
            if (f3)
              return ce = f3.nextPos, f3.result;
            if (e4 = ce, (r3 = Ee()) !== s2) {
              for (n3 = [], o3 = ce, t2.charCodeAt(ce) === 46 ? (a3 = ".", ce++) : (a3 = s2, ge(k)), a3 !== s2 && (i3 = Ee()) !== s2 ? o3 = a3 = [a3, i3] : (ce = o3, o3 = s2); o3 !== s2; )
                n3.push(o3), o3 = ce, t2.charCodeAt(ce) === 46 ? (a3 = ".", ce++) : (a3 = s2, ge(k)), a3 !== s2 && (i3 = Ee()) !== s2 ? o3 = a3 = [a3, i3] : (ce = o3, o3 = s2);
              n3 !== s2 ? (l3 = r3, u3 = n3, e4 = r3 = [].concat.apply([l3], u3).join("")) : (ce = e4, e4 = s2);
            } else
              ce = e4, e4 = s2;
            return ye[c3] = {nextPos: ce, result: e4}, e4;
          }
          function De(e4) {
            return {type: "nth-child", index: {type: "literal", value: e4}};
          }
          function je(e4) {
            return {type: "nth-last-child", index: {type: "literal", value: e4}};
          }
          if ((n2 = u2()) !== s2 && ce === t2.length)
            return n2;
          throw n2 !== s2 && ce < t2.length && ge({type: "end"}), o2 = he, a2 = pe < t2.length ? t2.charAt(pe) : null, i2 = pe < t2.length ? ve(pe, pe + 1) : ve(pe, pe), new e3(e3.buildMessage(o2, a2), o2, a2, i2);
        }};
      }());
    });
    function u(t2, r2, n2, o2) {
      if (!r2)
        return true;
      if (!t2)
        return false;
      switch (n2 || (n2 = []), r2.type) {
        case "wildcard":
          return true;
        case "identifier":
          return r2.value.toLowerCase() === t2.type.toLowerCase();
        case "field":
          var i2 = r2.name.split("."), l2 = n2[i2.length - 1];
          return function e2(t3, r3, n3) {
            if (n3.length === 0)
              return t3 === r3;
            if (r3 == null)
              return false;
            var o3 = r3[n3[0]], i3 = n3.slice(1);
            if (Array.isArray(o3)) {
              var s2, l3 = a(o3);
              try {
                for (l3.s(); !(s2 = l3.n()).done; ) {
                  if (e2(t3, s2.value, i3))
                    return true;
                }
              } catch (e3) {
                l3.e(e3);
              } finally {
                l3.f();
              }
              return false;
            }
            return e2(t3, o3, i3);
          }(t2, l2, i2);
        case "matches":
          var c2, f2 = a(r2.selectors);
          try {
            for (f2.s(); !(c2 = f2.n()).done; ) {
              var d2 = c2.value;
              if (u(t2, d2, n2, o2))
                return true;
            }
          } catch (e2) {
            f2.e(e2);
          } finally {
            f2.f();
          }
          return false;
        case "compound":
          var m2, x2 = a(r2.selectors);
          try {
            for (x2.s(); !(m2 = x2.n()).done; ) {
              var v2 = m2.value;
              if (!u(t2, v2, n2, o2))
                return false;
            }
          } catch (e2) {
            x2.e(e2);
          } finally {
            x2.f();
          }
          return true;
        case "not":
          var g2, b = a(r2.selectors);
          try {
            for (b.s(); !(g2 = b.n()).done; ) {
              var A = g2.value;
              if (u(t2, A, n2, o2))
                return false;
            }
          } catch (e2) {
            b.e(e2);
          } finally {
            b.f();
          }
          return true;
        case "has":
          var E = function() {
            var e2, n3 = [], i3 = a(r2.selectors);
            try {
              var l3 = function() {
                var r3 = e2.value, a2 = [];
                s.traverse(t2, {enter: function(e3, t3) {
                  t3 != null && a2.unshift(t3), u(e3, r3, a2, o2) && n3.push(e3);
                }, leave: function() {
                  a2.shift();
                }, keys: o2 && o2.visitorKeys, fallback: o2 && o2.fallback || "iteration"});
              };
              for (i3.s(); !(e2 = i3.n()).done; )
                l3();
            } catch (e3) {
              i3.e(e3);
            } finally {
              i3.f();
            }
            return {v: n3.length !== 0};
          }();
          if (e(E) === "object")
            return E.v;
        case "child":
          return !!u(t2, r2.right, n2, o2) && u(n2[0], r2.left, n2.slice(1), o2);
        case "descendant":
          if (u(t2, r2.right, n2, o2)) {
            for (var S = 0, _ = n2.length; S < _; ++S)
              if (u(n2[S], r2.left, n2.slice(S + 1), o2))
                return true;
          }
          return false;
        case "attribute":
          var w = function(e2, t3) {
            var r3, n3 = a(t3.split("."));
            try {
              for (n3.s(); !(r3 = n3.n()).done; ) {
                var o3 = r3.value;
                if (e2 == null)
                  return e2;
                e2 = e2[o3];
              }
            } catch (e3) {
              n3.e(e3);
            } finally {
              n3.f();
            }
            return e2;
          }(t2, r2.name);
          switch (r2.operator) {
            case void 0:
              return w != null;
            case "=":
              switch (r2.value.type) {
                case "regexp":
                  return typeof w == "string" && r2.value.value.test(w);
                case "literal":
                  return "".concat(r2.value.value) === "".concat(w);
                case "type":
                  return r2.value.value === e(w);
              }
              throw new Error("Unknown selector value type: ".concat(r2.value.type));
            case "!=":
              switch (r2.value.type) {
                case "regexp":
                  return !r2.value.value.test(w);
                case "literal":
                  return "".concat(r2.value.value) !== "".concat(w);
                case "type":
                  return r2.value.value !== e(w);
              }
              throw new Error("Unknown selector value type: ".concat(r2.value.type));
            case "<=":
              return w <= r2.value.value;
            case "<":
              return w < r2.value.value;
            case ">":
              return w > r2.value.value;
            case ">=":
              return w >= r2.value.value;
          }
          throw new Error("Unknown operator: ".concat(r2.operator));
        case "sibling":
          return u(t2, r2.right, n2, o2) && p(t2, r2.left, n2, "LEFT_SIDE", o2) || r2.left.subject && u(t2, r2.left, n2, o2) && p(t2, r2.right, n2, "RIGHT_SIDE", o2);
        case "adjacent":
          return u(t2, r2.right, n2, o2) && h(t2, r2.left, n2, "LEFT_SIDE", o2) || r2.right.subject && u(t2, r2.left, n2, o2) && h(t2, r2.right, n2, "RIGHT_SIDE", o2);
        case "nth-child":
          return u(t2, r2.right, n2, o2) && y(t2, n2, function() {
            return r2.index.value - 1;
          }, o2);
        case "nth-last-child":
          return u(t2, r2.right, n2, o2) && y(t2, n2, function(e2) {
            return e2 - r2.index.value;
          }, o2);
        case "class":
          switch (r2.name.toLowerCase()) {
            case "statement":
              if (t2.type.slice(-9) === "Statement")
                return true;
            case "declaration":
              return t2.type.slice(-11) === "Declaration";
            case "pattern":
              if (t2.type.slice(-7) === "Pattern")
                return true;
            case "expression":
              return t2.type.slice(-10) === "Expression" || t2.type.slice(-7) === "Literal" || t2.type === "Identifier" && (n2.length === 0 || n2[0].type !== "MetaProperty") || t2.type === "MetaProperty";
            case "function":
              return t2.type === "FunctionDeclaration" || t2.type === "FunctionExpression" || t2.type === "ArrowFunctionExpression";
          }
          throw new Error("Unknown class name: ".concat(r2.name));
      }
      throw new Error("Unknown selector type: ".concat(r2.type));
    }
    function c(e2, t2) {
      var r2 = e2.type;
      return t2 && t2.visitorKeys && t2.visitorKeys[r2] ? t2.visitorKeys[r2] : s.VisitorKeys[r2] ? s.VisitorKeys[r2] : t2 && typeof t2.fallback == "function" ? t2.fallback(e2) : Object.keys(e2).filter(function(e3) {
        return e3 !== "type";
      });
    }
    function f(t2) {
      return t2 !== null && e(t2) === "object" && typeof t2.type == "string";
    }
    function p(e2, r2, n2, o2, i2) {
      var s2 = t(n2, 1)[0];
      if (!s2)
        return false;
      var l2, p2 = a(c(s2, i2));
      try {
        for (p2.s(); !(l2 = p2.n()).done; ) {
          var h2 = s2[l2.value];
          if (Array.isArray(h2)) {
            var y2 = h2.indexOf(e2);
            if (y2 < 0)
              continue;
            var d2 = void 0, m2 = void 0;
            o2 === "LEFT_SIDE" ? (d2 = 0, m2 = y2) : (d2 = y2 + 1, m2 = h2.length);
            for (var x2 = d2; x2 < m2; ++x2)
              if (f(h2[x2]) && u(h2[x2], r2, n2, i2))
                return true;
          }
        }
      } catch (e3) {
        p2.e(e3);
      } finally {
        p2.f();
      }
      return false;
    }
    function h(e2, r2, n2, o2, i2) {
      var s2 = t(n2, 1)[0];
      if (!s2)
        return false;
      var l2, p2 = a(c(s2, i2));
      try {
        for (p2.s(); !(l2 = p2.n()).done; ) {
          var h2 = s2[l2.value];
          if (Array.isArray(h2)) {
            var y2 = h2.indexOf(e2);
            if (y2 < 0)
              continue;
            if (o2 === "LEFT_SIDE" && y2 > 0 && f(h2[y2 - 1]) && u(h2[y2 - 1], r2, n2, i2))
              return true;
            if (o2 === "RIGHT_SIDE" && y2 < h2.length - 1 && f(h2[y2 + 1]) && u(h2[y2 + 1], r2, n2, i2))
              return true;
          }
        }
      } catch (e3) {
        p2.e(e3);
      } finally {
        p2.f();
      }
      return false;
    }
    function y(e2, r2, n2, o2) {
      var i2 = t(r2, 1)[0];
      if (!i2)
        return false;
      var s2, l2 = a(c(i2, o2));
      try {
        for (l2.s(); !(s2 = l2.n()).done; ) {
          var u2 = i2[s2.value];
          if (Array.isArray(u2)) {
            var f2 = u2.indexOf(e2);
            if (f2 >= 0 && f2 === n2(u2.length))
              return true;
          }
        }
      } catch (e3) {
        l2.e(e3);
      } finally {
        l2.f();
      }
      return false;
    }
    function d(n2, o2) {
      if (n2 == null || e(n2) != "object")
        return [];
      o2 == null && (o2 = n2);
      for (var a2 = n2.subject ? [o2] : [], i2 = 0, s2 = function(e2) {
        for (var t2 = [], r2 = Object.keys(e2), n3 = 0; n3 < r2.length; n3++)
          t2.push([r2[n3], e2[r2[n3]]]);
        return t2;
      }(n2); i2 < s2.length; i2++) {
        var l2 = t(s2[i2], 2), u2 = l2[0], c2 = l2[1];
        a2.push.apply(a2, r(d(c2, u2 === "left" ? c2 : o2)));
      }
      return a2;
    }
    function m(e2, t2, r2, n2) {
      if (t2) {
        var o2 = [], a2 = d(t2);
        s.traverse(e2, {enter: function(e3, i2) {
          if (i2 != null && o2.unshift(i2), u(e3, t2, o2, n2))
            if (a2.length)
              for (var s2 = 0, l2 = a2.length; s2 < l2; ++s2) {
                u(e3, a2[s2], o2, n2) && r2(e3, i2, o2);
                for (var c2 = 0, f2 = o2.length; c2 < f2; ++c2) {
                  var p2 = o2.slice(c2 + 1);
                  u(o2[c2], a2[s2], p2, n2) && r2(o2[c2], i2, p2);
                }
              }
            else
              r2(e3, i2, o2);
        }, leave: function() {
          o2.shift();
        }, keys: n2 && n2.visitorKeys, fallback: n2 && n2.fallback || "iteration"});
      }
    }
    function x(e2, t2, r2) {
      var n2 = [];
      return m(e2, t2, function(e3) {
        n2.push(e3);
      }, r2), n2;
    }
    function v(e2) {
      return l.parse(e2);
    }
    function g(e2, t2, r2) {
      return x(e2, v(t2), r2);
    }
    return g.parse = v, g.match = x, g.traverse = m, g.matches = u, g.query = g, g;
  });
});

// node_modules/eslint/lib/linter/node-event-generator.js
var require_node_event_generator = __commonJS((exports2, module2) => {
  "use strict";
  var esquery = require_esquery_min();
  var lodash = require_lodash();
  function getPossibleTypes(parsedSelector) {
    switch (parsedSelector.type) {
      case "identifier":
        return [parsedSelector.value];
      case "matches": {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes);
        if (typesForComponents.every(Boolean)) {
          return lodash.union(...typesForComponents);
        }
        return null;
      }
      case "compound": {
        const typesForComponents = parsedSelector.selectors.map(getPossibleTypes).filter((typesForComponent) => typesForComponent);
        if (!typesForComponents.length) {
          return null;
        }
        return lodash.intersection(...typesForComponents);
      }
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return getPossibleTypes(parsedSelector.right);
      default:
        return null;
    }
  }
  function countClassAttributes(parsedSelector) {
    switch (parsedSelector.type) {
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return countClassAttributes(parsedSelector.left) + countClassAttributes(parsedSelector.right);
      case "compound":
      case "not":
      case "matches":
        return parsedSelector.selectors.reduce((sum, childSelector) => sum + countClassAttributes(childSelector), 0);
      case "attribute":
      case "field":
      case "nth-child":
      case "nth-last-child":
        return 1;
      default:
        return 0;
    }
  }
  function countIdentifiers(parsedSelector) {
    switch (parsedSelector.type) {
      case "child":
      case "descendant":
      case "sibling":
      case "adjacent":
        return countIdentifiers(parsedSelector.left) + countIdentifiers(parsedSelector.right);
      case "compound":
      case "not":
      case "matches":
        return parsedSelector.selectors.reduce((sum, childSelector) => sum + countIdentifiers(childSelector), 0);
      case "identifier":
        return 1;
      default:
        return 0;
    }
  }
  function compareSpecificity(selectorA, selectorB) {
    return selectorA.attributeCount - selectorB.attributeCount || selectorA.identifierCount - selectorB.identifierCount || (selectorA.rawSelector <= selectorB.rawSelector ? -1 : 1);
  }
  function tryParseSelector(rawSelector) {
    try {
      return esquery.parse(rawSelector.replace(/:exit$/u, ""));
    } catch (err) {
      if (err.location && err.location.start && typeof err.location.start.offset === "number") {
        throw new SyntaxError(`Syntax error in selector "${rawSelector}" at position ${err.location.start.offset}: ${err.message}`);
      }
      throw err;
    }
  }
  var parseSelector = lodash.memoize((rawSelector) => {
    const parsedSelector = tryParseSelector(rawSelector);
    return {
      rawSelector,
      isExit: rawSelector.endsWith(":exit"),
      parsedSelector,
      listenerTypes: getPossibleTypes(parsedSelector),
      attributeCount: countClassAttributes(parsedSelector),
      identifierCount: countIdentifiers(parsedSelector)
    };
  });
  var NodeEventGenerator = class {
    constructor(emitter, esqueryOptions) {
      this.emitter = emitter;
      this.esqueryOptions = esqueryOptions;
      this.currentAncestry = [];
      this.enterSelectorsByNodeType = new Map();
      this.exitSelectorsByNodeType = new Map();
      this.anyTypeEnterSelectors = [];
      this.anyTypeExitSelectors = [];
      emitter.eventNames().forEach((rawSelector) => {
        const selector = parseSelector(rawSelector);
        if (selector.listenerTypes) {
          const typeMap = selector.isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType;
          selector.listenerTypes.forEach((nodeType) => {
            if (!typeMap.has(nodeType)) {
              typeMap.set(nodeType, []);
            }
            typeMap.get(nodeType).push(selector);
          });
          return;
        }
        const selectors = selector.isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
        selectors.push(selector);
      });
      this.anyTypeEnterSelectors.sort(compareSpecificity);
      this.anyTypeExitSelectors.sort(compareSpecificity);
      this.enterSelectorsByNodeType.forEach((selectorList) => selectorList.sort(compareSpecificity));
      this.exitSelectorsByNodeType.forEach((selectorList) => selectorList.sort(compareSpecificity));
    }
    applySelector(node, selector) {
      if (esquery.matches(node, selector.parsedSelector, this.currentAncestry, this.esqueryOptions)) {
        this.emitter.emit(selector.rawSelector, node);
      }
    }
    applySelectors(node, isExit) {
      const selectorsByNodeType = (isExit ? this.exitSelectorsByNodeType : this.enterSelectorsByNodeType).get(node.type) || [];
      const anyTypeSelectors = isExit ? this.anyTypeExitSelectors : this.anyTypeEnterSelectors;
      let selectorsByTypeIndex = 0;
      let anyTypeSelectorsIndex = 0;
      while (selectorsByTypeIndex < selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length) {
        if (selectorsByTypeIndex >= selectorsByNodeType.length || anyTypeSelectorsIndex < anyTypeSelectors.length && compareSpecificity(anyTypeSelectors[anyTypeSelectorsIndex], selectorsByNodeType[selectorsByTypeIndex]) < 0) {
          this.applySelector(node, anyTypeSelectors[anyTypeSelectorsIndex++]);
        } else {
          this.applySelector(node, selectorsByNodeType[selectorsByTypeIndex++]);
        }
      }
    }
    enterNode(node) {
      if (node.parent) {
        this.currentAncestry.unshift(node.parent);
      }
      this.applySelectors(node, false);
    }
    leaveNode(node) {
      this.applySelectors(node, true);
      this.currentAncestry.shift();
    }
  };
  module2.exports = NodeEventGenerator;
});

// node_modules/eslint/lib/linter/rule-fixer.js
var require_rule_fixer = __commonJS((exports2, module2) => {
  "use strict";
  function insertTextAt(index, text) {
    return {
      range: [index, index],
      text
    };
  }
  var ruleFixer = Object.freeze({
    insertTextAfter(nodeOrToken, text) {
      return this.insertTextAfterRange(nodeOrToken.range, text);
    },
    insertTextAfterRange(range, text) {
      return insertTextAt(range[1], text);
    },
    insertTextBefore(nodeOrToken, text) {
      return this.insertTextBeforeRange(nodeOrToken.range, text);
    },
    insertTextBeforeRange(range, text) {
      return insertTextAt(range[0], text);
    },
    replaceText(nodeOrToken, text) {
      return this.replaceTextRange(nodeOrToken.range, text);
    },
    replaceTextRange(range, text) {
      return {
        range,
        text
      };
    },
    remove(nodeOrToken) {
      return this.removeRange(nodeOrToken.range);
    },
    removeRange(range) {
      return {
        range,
        text: ""
      };
    }
  });
  module2.exports = ruleFixer;
});

// node_modules/eslint/lib/linter/interpolate.js
var require_interpolate = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (text, data) => {
    if (!data) {
      return text;
    }
    return text.replace(/\{\{([^{}]+?)\}\}/gu, (fullMatch, termWithWhitespace) => {
      const term = termWithWhitespace.trim();
      if (term in data) {
        return data[term];
      }
      return fullMatch;
    });
  };
});

// node_modules/eslint/lib/linter/report-translator.js
var require_report_translator = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var ruleFixer = require_rule_fixer();
  var interpolate = require_interpolate();
  function normalizeMultiArgReportCall(...args) {
    if (args.length === 1) {
      return Object.assign({}, args[0]);
    }
    if (typeof args[1] === "string") {
      return {
        node: args[0],
        message: args[1],
        data: args[2],
        fix: args[3]
      };
    }
    return {
      node: args[0],
      loc: args[1],
      message: args[2],
      data: args[3],
      fix: args[4]
    };
  }
  function assertValidNodeInfo(descriptor) {
    if (descriptor.node) {
      assert(typeof descriptor.node === "object", "Node must be an object");
    } else {
      assert(descriptor.loc, "Node must be provided when reporting error if location is not provided");
    }
  }
  function normalizeReportLoc(descriptor) {
    if (descriptor.loc) {
      if (descriptor.loc.start) {
        return descriptor.loc;
      }
      return {start: descriptor.loc, end: null};
    }
    return descriptor.node.loc;
  }
  function assertValidFix(fix) {
    if (fix) {
      assert(fix.range && typeof fix.range[0] === "number" && typeof fix.range[1] === "number", `Fix has invalid range: ${JSON.stringify(fix, null, 2)}`);
    }
  }
  function compareFixesByRange(a, b) {
    return a.range[0] - b.range[0] || a.range[1] - b.range[1];
  }
  function mergeFixes(fixes, sourceCode) {
    for (const fix of fixes) {
      assertValidFix(fix);
    }
    if (fixes.length === 0) {
      return null;
    }
    if (fixes.length === 1) {
      return fixes[0];
    }
    fixes.sort(compareFixesByRange);
    const originalText = sourceCode.text;
    const start = fixes[0].range[0];
    const end = fixes[fixes.length - 1].range[1];
    let text = "";
    let lastPos = Number.MIN_SAFE_INTEGER;
    for (const fix of fixes) {
      assert(fix.range[0] >= lastPos, "Fix objects must not be overlapped in a report.");
      if (fix.range[0] >= 0) {
        text += originalText.slice(Math.max(0, start, lastPos), fix.range[0]);
      }
      text += fix.text;
      lastPos = fix.range[1];
    }
    text += originalText.slice(Math.max(0, start, lastPos), end);
    return {range: [start, end], text};
  }
  function normalizeFixes(descriptor, sourceCode) {
    if (typeof descriptor.fix !== "function") {
      return null;
    }
    const fix = descriptor.fix(ruleFixer);
    if (fix && Symbol.iterator in fix) {
      return mergeFixes(Array.from(fix), sourceCode);
    }
    assertValidFix(fix);
    return fix;
  }
  function mapSuggestions(descriptor, sourceCode, messages) {
    if (!descriptor.suggest || !Array.isArray(descriptor.suggest)) {
      return [];
    }
    return descriptor.suggest.map((suggestInfo) => {
      const computedDesc = suggestInfo.desc || messages[suggestInfo.messageId];
      return __objSpread(__objSpread({}, suggestInfo), {
        desc: interpolate(computedDesc, suggestInfo.data),
        fix: normalizeFixes(suggestInfo, sourceCode)
      });
    }).filter(({fix}) => fix);
  }
  function createProblem(options) {
    const problem = {
      ruleId: options.ruleId,
      severity: options.severity,
      message: options.message,
      line: options.loc.start.line,
      column: options.loc.start.column + 1,
      nodeType: options.node && options.node.type || null
    };
    if (options.messageId) {
      problem.messageId = options.messageId;
    }
    if (options.loc.end) {
      problem.endLine = options.loc.end.line;
      problem.endColumn = options.loc.end.column + 1;
    }
    if (options.fix) {
      problem.fix = options.fix;
    }
    if (options.suggestions && options.suggestions.length > 0) {
      problem.suggestions = options.suggestions;
    }
    return problem;
  }
  function validateSuggestions(suggest, messages) {
    if (suggest && Array.isArray(suggest)) {
      suggest.forEach((suggestion) => {
        if (suggestion.messageId) {
          const {messageId} = suggestion;
          if (!messages) {
            throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}', but no messages were present in the rule metadata.`);
          }
          if (!messages[messageId]) {
            throw new TypeError(`context.report() called with a suggest option with a messageId '${messageId}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
          }
          if (suggestion.desc) {
            throw new TypeError("context.report() called with a suggest option that defines both a 'messageId' and an 'desc'. Please only pass one.");
          }
        } else if (!suggestion.desc) {
          throw new TypeError("context.report() called with a suggest option that doesn't have either a `desc` or `messageId`");
        }
        if (typeof suggestion.fix !== "function") {
          throw new TypeError(`context.report() called with a suggest option without a fix function. See: ${suggestion}`);
        }
      });
    }
  }
  module2.exports = function createReportTranslator(metadata) {
    return (...args) => {
      const descriptor = normalizeMultiArgReportCall(...args);
      const messages = metadata.messageIds;
      assertValidNodeInfo(descriptor);
      let computedMessage;
      if (descriptor.messageId) {
        if (!messages) {
          throw new TypeError("context.report() called with a messageId, but no messages were present in the rule metadata.");
        }
        const id = descriptor.messageId;
        if (descriptor.message) {
          throw new TypeError("context.report() called with a message and a messageId. Please only pass one.");
        }
        if (!messages || !Object.prototype.hasOwnProperty.call(messages, id)) {
          throw new TypeError(`context.report() called with a messageId of '${id}' which is not present in the 'messages' config: ${JSON.stringify(messages, null, 2)}`);
        }
        computedMessage = messages[id];
      } else if (descriptor.message) {
        computedMessage = descriptor.message;
      } else {
        throw new TypeError("Missing `message` property in report() call; add a message that describes the linting problem.");
      }
      validateSuggestions(descriptor.suggest, messages);
      return createProblem({
        ruleId: metadata.ruleId,
        severity: metadata.severity,
        node: descriptor.node,
        message: interpolate(computedMessage, descriptor.data),
        messageId: descriptor.messageId,
        loc: normalizeReportLoc(descriptor),
        fix: metadata.disableFixes ? null : normalizeFixes(descriptor, metadata.sourceCode),
        suggestions: metadata.disableFixes ? [] : mapSuggestions(descriptor, metadata.sourceCode, messages)
      });
    };
  };
});

// node_modules/eslint/lib/rules/utils/lazy-loading-rule-map.js
var require_lazy_loading_rule_map = __commonJS((exports2, module2) => {
  "use strict";
  var debug5 = require_src()("eslint:rules");
  var LazyLoadingRuleMap = class extends Map {
    constructor(loaders) {
      let remaining = loaders.length;
      super(debug5.enabled ? loaders.map(([ruleId, load]) => {
        let cache = null;
        return [
          ruleId,
          () => {
            if (!cache) {
              debug5("Loading rule %o (remaining=%d)", ruleId, --remaining);
              cache = load();
            }
            return cache;
          }
        ];
      }) : loaders);
      Object.defineProperty(LazyLoadingRuleMap.prototype, "set", {
        configurable: true,
        value: void 0
      });
    }
    get(ruleId) {
      const load = super.get(ruleId);
      return load && load();
    }
    *values() {
      for (const load of super.values()) {
        yield load();
      }
    }
    *entries() {
      for (const [ruleId, load] of super.entries()) {
        yield [ruleId, load()];
      }
    }
    forEach(callbackFn, thisArg) {
      for (const [ruleId, load] of super.entries()) {
        callbackFn.call(thisArg, load(), ruleId, this);
      }
    }
  };
  Object.defineProperties(LazyLoadingRuleMap.prototype, {
    clear: {configurable: true, value: void 0},
    delete: {configurable: true, value: void 0},
    [Symbol.iterator]: {
      configurable: true,
      writable: true,
      value: LazyLoadingRuleMap.prototype.entries
    }
  });
  module2.exports = {LazyLoadingRuleMap};
});

// node_modules/esutils/lib/ast.js
var require_ast = __commonJS((exports2, module2) => {
  (function() {
    "use strict";
    function isExpression(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "ArrayExpression":
        case "AssignmentExpression":
        case "BinaryExpression":
        case "CallExpression":
        case "ConditionalExpression":
        case "FunctionExpression":
        case "Identifier":
        case "Literal":
        case "LogicalExpression":
        case "MemberExpression":
        case "NewExpression":
        case "ObjectExpression":
        case "SequenceExpression":
        case "ThisExpression":
        case "UnaryExpression":
        case "UpdateExpression":
          return true;
      }
      return false;
    }
    function isIterationStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "DoWhileStatement":
        case "ForInStatement":
        case "ForStatement":
        case "WhileStatement":
          return true;
      }
      return false;
    }
    function isStatement(node) {
      if (node == null) {
        return false;
      }
      switch (node.type) {
        case "BlockStatement":
        case "BreakStatement":
        case "ContinueStatement":
        case "DebuggerStatement":
        case "DoWhileStatement":
        case "EmptyStatement":
        case "ExpressionStatement":
        case "ForInStatement":
        case "ForStatement":
        case "IfStatement":
        case "LabeledStatement":
        case "ReturnStatement":
        case "SwitchStatement":
        case "ThrowStatement":
        case "TryStatement":
        case "VariableDeclaration":
        case "WhileStatement":
        case "WithStatement":
          return true;
      }
      return false;
    }
    function isSourceElement(node) {
      return isStatement(node) || node != null && node.type === "FunctionDeclaration";
    }
    function trailingStatement(node) {
      switch (node.type) {
        case "IfStatement":
          if (node.alternate != null) {
            return node.alternate;
          }
          return node.consequent;
        case "LabeledStatement":
        case "ForStatement":
        case "ForInStatement":
        case "WhileStatement":
        case "WithStatement":
          return node.body;
      }
      return null;
    }
    function isProblematicIfStatement(node) {
      var current;
      if (node.type !== "IfStatement") {
        return false;
      }
      if (node.alternate == null) {
        return false;
      }
      current = node.consequent;
      do {
        if (current.type === "IfStatement") {
          if (current.alternate == null) {
            return true;
          }
        }
        current = trailingStatement(current);
      } while (current);
      return false;
    }
    module2.exports = {
      isExpression,
      isStatement,
      isIterationStatement,
      isSourceElement,
      isProblematicIfStatement,
      trailingStatement
    };
  })();
});

// node_modules/esutils/lib/code.js
var require_code = __commonJS((exports2, module2) => {
  (function() {
    "use strict";
    var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
    ES5Regex = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
    };
    ES6Regex = {
      NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
      NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
    };
    function isDecimalDigit(ch2) {
      return 48 <= ch2 && ch2 <= 57;
    }
    function isHexDigit(ch2) {
      return 48 <= ch2 && ch2 <= 57 || 97 <= ch2 && ch2 <= 102 || 65 <= ch2 && ch2 <= 70;
    }
    function isOctalDigit(ch2) {
      return ch2 >= 48 && ch2 <= 55;
    }
    NON_ASCII_WHITESPACES = [
      5760,
      8192,
      8193,
      8194,
      8195,
      8196,
      8197,
      8198,
      8199,
      8200,
      8201,
      8202,
      8239,
      8287,
      12288,
      65279
    ];
    function isWhiteSpace(ch2) {
      return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
    }
    function isLineTerminator(ch2) {
      return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
    }
    function fromCodePoint(cp) {
      if (cp <= 65535) {
        return String.fromCharCode(cp);
      }
      var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
      var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
      return cu1 + cu2;
    }
    IDENTIFIER_START = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch === 36 || ch === 95;
    }
    IDENTIFIER_PART = new Array(128);
    for (ch = 0; ch < 128; ++ch) {
      IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57 || ch === 36 || ch === 95;
    }
    function isIdentifierStartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES5(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    function isIdentifierStartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
    }
    function isIdentifierPartES6(ch2) {
      return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
    }
    module2.exports = {
      isDecimalDigit,
      isHexDigit,
      isOctalDigit,
      isWhiteSpace,
      isLineTerminator,
      isIdentifierStartES5,
      isIdentifierPartES5,
      isIdentifierStartES6,
      isIdentifierPartES6
    };
  })();
});

// node_modules/esutils/lib/keyword.js
var require_keyword2 = __commonJS((exports2, module2) => {
  (function() {
    "use strict";
    var code = require_code();
    function isStrictModeReservedWordES6(id) {
      switch (id) {
        case "implements":
        case "interface":
        case "package":
        case "private":
        case "protected":
        case "public":
        case "static":
        case "let":
          return true;
        default:
          return false;
      }
    }
    function isKeywordES5(id, strict) {
      if (!strict && id === "yield") {
        return false;
      }
      return isKeywordES6(id, strict);
    }
    function isKeywordES6(id, strict) {
      if (strict && isStrictModeReservedWordES6(id)) {
        return true;
      }
      switch (id.length) {
        case 2:
          return id === "if" || id === "in" || id === "do";
        case 3:
          return id === "var" || id === "for" || id === "new" || id === "try";
        case 4:
          return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
        case 5:
          return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
        case 6:
          return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
        case 7:
          return id === "default" || id === "finally" || id === "extends";
        case 8:
          return id === "function" || id === "continue" || id === "debugger";
        case 10:
          return id === "instanceof";
        default:
          return false;
      }
    }
    function isReservedWordES5(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
    }
    function isReservedWordES6(id, strict) {
      return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
    }
    function isRestrictedWord(id) {
      return id === "eval" || id === "arguments";
    }
    function isIdentifierNameES5(id) {
      var i, iz, ch;
      if (id.length === 0) {
        return false;
      }
      ch = id.charCodeAt(0);
      if (!code.isIdentifierStartES5(ch)) {
        return false;
      }
      for (i = 1, iz = id.length; i < iz; ++i) {
        ch = id.charCodeAt(i);
        if (!code.isIdentifierPartES5(ch)) {
          return false;
        }
      }
      return true;
    }
    function decodeUtf16(lead, trail) {
      return (lead - 55296) * 1024 + (trail - 56320) + 65536;
    }
    function isIdentifierNameES6(id) {
      var i, iz, ch, lowCh, check;
      if (id.length === 0) {
        return false;
      }
      check = code.isIdentifierStartES6;
      for (i = 0, iz = id.length; i < iz; ++i) {
        ch = id.charCodeAt(i);
        if (55296 <= ch && ch <= 56319) {
          ++i;
          if (i >= iz) {
            return false;
          }
          lowCh = id.charCodeAt(i);
          if (!(56320 <= lowCh && lowCh <= 57343)) {
            return false;
          }
          ch = decodeUtf16(ch, lowCh);
        }
        if (!check(ch)) {
          return false;
        }
        check = code.isIdentifierPartES6;
      }
      return true;
    }
    function isIdentifierES5(id, strict) {
      return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
    }
    function isIdentifierES6(id, strict) {
      return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
    }
    module2.exports = {
      isKeywordES5,
      isKeywordES6,
      isReservedWordES5,
      isReservedWordES6,
      isRestrictedWord,
      isIdentifierNameES5,
      isIdentifierNameES6,
      isIdentifierES5,
      isIdentifierES6
    };
  })();
});

// node_modules/esutils/lib/utils.js
var require_utils7 = __commonJS((exports2) => {
  (function() {
    "use strict";
    exports2.ast = require_ast();
    exports2.code = require_code();
    exports2.keyword = require_keyword2();
  })();
});

// node_modules/eslint/lib/rules/utils/ast-utils.js
var require_ast_utils2 = __commonJS((exports2, module2) => {
  "use strict";
  var esutils = require_utils7();
  var espree = require("espree");
  var lodash = require_lodash();
  var {
    breakableTypePattern,
    createGlobalLinebreakMatcher,
    lineBreakPattern,
    shebangPattern
  } = require_ast_utils();
  var anyFunctionPattern = /^(?:Function(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
  var anyLoopPattern = /^(?:DoWhile|For|ForIn|ForOf|While)Statement$/u;
  var arrayOrTypedArrayPattern = /Array$/u;
  var arrayMethodPattern = /^(?:every|filter|find|findIndex|forEach|map|some)$/u;
  var bindOrCallOrApplyPattern = /^(?:bind|call|apply)$/u;
  var thisTagPattern = /^[\s*]*@this/mu;
  var COMMENTS_IGNORE_PATTERN = /^\s*(?:eslint|jshint\s+|jslint\s+|istanbul\s+|globals?\s+|exported\s+|jscs)/u;
  var LINEBREAKS = new Set(["\r\n", "\r", "\n", "\u2028", "\u2029"]);
  var STATEMENT_LIST_PARENTS = new Set(["Program", "BlockStatement", "SwitchCase"]);
  var DECIMAL_INTEGER_PATTERN = /^(?:0|0[0-7]*[89]\d*|[1-9](?:_?\d)*)$/u;
  var OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN = /^(?:[^\\]|\\.)*\\(?:[1-9]|0[0-9])/su;
  var LOGICAL_ASSIGNMENT_OPERATORS = new Set(["&&=", "||=", "??="]);
  function isModifyingReference(reference, index, references) {
    const identifier = reference.identifier;
    const modifyingDifferentIdentifier = index === 0 || references[index - 1].identifier !== identifier;
    return identifier && reference.init === false && reference.isWrite() && modifyingDifferentIdentifier;
  }
  function startsWithUpperCase(s) {
    return s[0] !== s[0].toLocaleLowerCase();
  }
  function isES5Constructor(node) {
    return node.id && startsWithUpperCase(node.id.name);
  }
  function getUpperFunction(node) {
    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
      if (anyFunctionPattern.test(currentNode.type)) {
        return currentNode;
      }
    }
    return null;
  }
  function isFunction(node) {
    return Boolean(node && anyFunctionPattern.test(node.type));
  }
  function isLoop(node) {
    return Boolean(node && anyLoopPattern.test(node.type));
  }
  function isInLoop(node) {
    for (let currentNode = node; currentNode && !isFunction(currentNode); currentNode = currentNode.parent) {
      if (isLoop(currentNode)) {
        return true;
      }
    }
    return false;
  }
  function isNullLiteral(node) {
    return node.type === "Literal" && node.value === null && !node.regex && !node.bigint;
  }
  function isNullOrUndefined(node) {
    return isNullLiteral(node) || node.type === "Identifier" && node.name === "undefined" || node.type === "UnaryExpression" && node.operator === "void";
  }
  function isCallee(node) {
    return node.parent.type === "CallExpression" && node.parent.callee === node;
  }
  function getStaticStringValue(node) {
    switch (node.type) {
      case "Literal":
        if (node.value === null) {
          if (isNullLiteral(node)) {
            return String(node.value);
          }
          if (node.regex) {
            return `/${node.regex.pattern}/${node.regex.flags}`;
          }
          if (node.bigint) {
            return node.bigint;
          }
        } else {
          return String(node.value);
        }
        break;
      case "TemplateLiteral":
        if (node.expressions.length === 0 && node.quasis.length === 1) {
          return node.quasis[0].value.cooked;
        }
        break;
    }
    return null;
  }
  function getStaticPropertyName(node) {
    let prop;
    switch (node && node.type) {
      case "ChainExpression":
        return getStaticPropertyName(node.expression);
      case "Property":
      case "MethodDefinition":
        prop = node.key;
        break;
      case "MemberExpression":
        prop = node.property;
        break;
    }
    if (prop) {
      if (prop.type === "Identifier" && !node.computed) {
        return prop.name;
      }
      return getStaticStringValue(prop);
    }
    return null;
  }
  function skipChainExpression(node) {
    return node && node.type === "ChainExpression" ? node.expression : node;
  }
  function checkText(actual, expected) {
    return typeof expected === "string" ? actual === expected : expected.test(actual);
  }
  function isSpecificId(node, name) {
    return node.type === "Identifier" && checkText(node.name, name);
  }
  function isSpecificMemberAccess(node, objectName, propertyName) {
    const checkNode = skipChainExpression(node);
    if (checkNode.type !== "MemberExpression") {
      return false;
    }
    if (objectName && !isSpecificId(checkNode.object, objectName)) {
      return false;
    }
    if (propertyName) {
      const actualPropertyName = getStaticPropertyName(checkNode);
      if (typeof actualPropertyName !== "string" || !checkText(actualPropertyName, propertyName)) {
        return false;
      }
    }
    return true;
  }
  function equalLiteralValue(left, right) {
    if (left.regex || right.regex) {
      return Boolean(left.regex && right.regex && left.regex.pattern === right.regex.pattern && left.regex.flags === right.regex.flags);
    }
    if (left.bigint || right.bigint) {
      return left.bigint === right.bigint;
    }
    return left.value === right.value;
  }
  function isSameReference(left, right, disableStaticComputedKey = false) {
    if (left.type !== right.type) {
      if (left.type === "ChainExpression") {
        return isSameReference(left.expression, right, disableStaticComputedKey);
      }
      if (right.type === "ChainExpression") {
        return isSameReference(left, right.expression, disableStaticComputedKey);
      }
      return false;
    }
    switch (left.type) {
      case "Super":
      case "ThisExpression":
        return true;
      case "Identifier":
        return left.name === right.name;
      case "Literal":
        return equalLiteralValue(left, right);
      case "ChainExpression":
        return isSameReference(left.expression, right.expression, disableStaticComputedKey);
      case "MemberExpression": {
        if (!disableStaticComputedKey) {
          const nameA = getStaticPropertyName(left);
          if (nameA !== null) {
            return isSameReference(left.object, right.object, disableStaticComputedKey) && nameA === getStaticPropertyName(right);
          }
        }
        return left.computed === right.computed && isSameReference(left.object, right.object, disableStaticComputedKey) && isSameReference(left.property, right.property, disableStaticComputedKey);
      }
      default:
        return false;
    }
  }
  function isReflectApply(node) {
    return isSpecificMemberAccess(node, "Reflect", "apply");
  }
  function isArrayFromMethod(node) {
    return isSpecificMemberAccess(node, arrayOrTypedArrayPattern, "from");
  }
  function isMethodWhichHasThisArg(node) {
    return isSpecificMemberAccess(node, null, arrayMethodPattern);
  }
  function negate(f) {
    return (token) => !f(token);
  }
  function hasJSDocThisTag(node, sourceCode) {
    const jsdocComment = sourceCode.getJSDocComment(node);
    if (jsdocComment && thisTagPattern.test(jsdocComment.value)) {
      return true;
    }
    return sourceCode.getCommentsBefore(node).some((comment) => thisTagPattern.test(comment.value));
  }
  function isParenthesised(sourceCode, node) {
    const previousToken = sourceCode.getTokenBefore(node), nextToken = sourceCode.getTokenAfter(node);
    return Boolean(previousToken && nextToken) && previousToken.value === "(" && previousToken.range[1] <= node.range[0] && nextToken.value === ")" && nextToken.range[0] >= node.range[1];
  }
  function isArrowToken(token) {
    return token.value === "=>" && token.type === "Punctuator";
  }
  function isCommaToken(token) {
    return token.value === "," && token.type === "Punctuator";
  }
  function isDotToken(token) {
    return token.value === "." && token.type === "Punctuator";
  }
  function isQuestionDotToken(token) {
    return token.value === "?." && token.type === "Punctuator";
  }
  function isSemicolonToken(token) {
    return token.value === ";" && token.type === "Punctuator";
  }
  function isColonToken(token) {
    return token.value === ":" && token.type === "Punctuator";
  }
  function isOpeningParenToken(token) {
    return token.value === "(" && token.type === "Punctuator";
  }
  function isClosingParenToken(token) {
    return token.value === ")" && token.type === "Punctuator";
  }
  function isOpeningBracketToken(token) {
    return token.value === "[" && token.type === "Punctuator";
  }
  function isClosingBracketToken(token) {
    return token.value === "]" && token.type === "Punctuator";
  }
  function isOpeningBraceToken(token) {
    return token.value === "{" && token.type === "Punctuator";
  }
  function isClosingBraceToken(token) {
    return token.value === "}" && token.type === "Punctuator";
  }
  function isCommentToken(token) {
    return token.type === "Line" || token.type === "Block" || token.type === "Shebang";
  }
  function isKeywordToken(token) {
    return token.type === "Keyword";
  }
  function getOpeningParenOfParams(node, sourceCode) {
    return node.id ? sourceCode.getTokenAfter(node.id, isOpeningParenToken) : sourceCode.getFirstToken(node, isOpeningParenToken);
  }
  function equalTokens(left, right, sourceCode) {
    const tokensL = sourceCode.getTokens(left);
    const tokensR = sourceCode.getTokens(right);
    if (tokensL.length !== tokensR.length) {
      return false;
    }
    for (let i = 0; i < tokensL.length; ++i) {
      if (tokensL[i].type !== tokensR[i].type || tokensL[i].value !== tokensR[i].value) {
        return false;
      }
    }
    return true;
  }
  function isLogicalExpression(node) {
    return node.type === "LogicalExpression" && (node.operator === "&&" || node.operator === "||");
  }
  function isCoalesceExpression(node) {
    return node.type === "LogicalExpression" && node.operator === "??";
  }
  function isMixedLogicalAndCoalesceExpressions(left, right) {
    return isLogicalExpression(left) && isCoalesceExpression(right) || isCoalesceExpression(left) && isLogicalExpression(right);
  }
  function isLogicalAssignmentOperator(operator) {
    return LOGICAL_ASSIGNMENT_OPERATORS.has(operator);
  }
  module2.exports = {
    COMMENTS_IGNORE_PATTERN,
    LINEBREAKS,
    LINEBREAK_MATCHER: lineBreakPattern,
    SHEBANG_MATCHER: shebangPattern,
    STATEMENT_LIST_PARENTS,
    isTokenOnSameLine(left, right) {
      return left.loc.end.line === right.loc.start.line;
    },
    isNullOrUndefined,
    isCallee,
    isES5Constructor,
    getUpperFunction,
    isFunction,
    isLoop,
    isInLoop,
    isArrayFromMethod,
    isParenthesised,
    createGlobalLinebreakMatcher,
    equalTokens,
    isArrowToken,
    isClosingBraceToken,
    isClosingBracketToken,
    isClosingParenToken,
    isColonToken,
    isCommaToken,
    isCommentToken,
    isDotToken,
    isQuestionDotToken,
    isKeywordToken,
    isNotClosingBraceToken: negate(isClosingBraceToken),
    isNotClosingBracketToken: negate(isClosingBracketToken),
    isNotClosingParenToken: negate(isClosingParenToken),
    isNotColonToken: negate(isColonToken),
    isNotCommaToken: negate(isCommaToken),
    isNotDotToken: negate(isDotToken),
    isNotQuestionDotToken: negate(isQuestionDotToken),
    isNotOpeningBraceToken: negate(isOpeningBraceToken),
    isNotOpeningBracketToken: negate(isOpeningBracketToken),
    isNotOpeningParenToken: negate(isOpeningParenToken),
    isNotSemicolonToken: negate(isSemicolonToken),
    isOpeningBraceToken,
    isOpeningBracketToken,
    isOpeningParenToken,
    isSemicolonToken,
    isStringLiteral(node) {
      return node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral";
    },
    isBreakableStatement(node) {
      return breakableTypePattern.test(node.type);
    },
    getModifyingReferences(references) {
      return references.filter(isModifyingReference);
    },
    isSurroundedBy(val, character) {
      return val[0] === character && val[val.length - 1] === character;
    },
    isDirectiveComment(node) {
      const comment = node.value.trim();
      return node.type === "Line" && comment.indexOf("eslint-") === 0 || node.type === "Block" && (comment.indexOf("global ") === 0 || comment.indexOf("eslint ") === 0 || comment.indexOf("eslint-") === 0);
    },
    getTrailingStatement: esutils.ast.trailingStatement,
    getVariableByName(initScope, name) {
      let scope = initScope;
      while (scope) {
        const variable = scope.set.get(name);
        if (variable) {
          return variable;
        }
        scope = scope.upper;
      }
      return null;
    },
    isDefaultThisBinding(node, sourceCode, {capIsConstructor = true} = {}) {
      if (capIsConstructor && isES5Constructor(node) || hasJSDocThisTag(node, sourceCode)) {
        return false;
      }
      const isAnonymous = node.id === null;
      let currentNode = node;
      while (currentNode) {
        const parent = currentNode.parent;
        switch (parent.type) {
          case "LogicalExpression":
          case "ConditionalExpression":
          case "ChainExpression":
            currentNode = parent;
            break;
          case "ReturnStatement": {
            const func = getUpperFunction(parent);
            if (func === null || !isCallee(func)) {
              return true;
            }
            currentNode = func.parent;
            break;
          }
          case "ArrowFunctionExpression":
            if (currentNode !== parent.body || !isCallee(parent)) {
              return true;
            }
            currentNode = parent.parent;
            break;
          case "Property":
          case "MethodDefinition":
            return parent.value !== currentNode;
          case "AssignmentExpression":
          case "AssignmentPattern":
            if (parent.left.type === "MemberExpression") {
              return false;
            }
            if (capIsConstructor && isAnonymous && parent.left.type === "Identifier" && startsWithUpperCase(parent.left.name)) {
              return false;
            }
            return true;
          case "VariableDeclarator":
            return !(capIsConstructor && isAnonymous && parent.init === currentNode && parent.id.type === "Identifier" && startsWithUpperCase(parent.id.name));
          case "MemberExpression":
            if (parent.object === currentNode && isSpecificMemberAccess(parent, null, bindOrCallOrApplyPattern)) {
              const maybeCalleeNode = parent.parent.type === "ChainExpression" ? parent.parent : parent;
              return !(isCallee(maybeCalleeNode) && maybeCalleeNode.parent.arguments.length >= 1 && !isNullOrUndefined(maybeCalleeNode.parent.arguments[0]));
            }
            return true;
          case "CallExpression":
            if (isReflectApply(parent.callee)) {
              return parent.arguments.length !== 3 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
            }
            if (isArrayFromMethod(parent.callee)) {
              return parent.arguments.length !== 3 || parent.arguments[1] !== currentNode || isNullOrUndefined(parent.arguments[2]);
            }
            if (isMethodWhichHasThisArg(parent.callee)) {
              return parent.arguments.length !== 2 || parent.arguments[0] !== currentNode || isNullOrUndefined(parent.arguments[1]);
            }
            return true;
          default:
            return true;
        }
      }
      return true;
    },
    getPrecedence(node) {
      switch (node.type) {
        case "SequenceExpression":
          return 0;
        case "AssignmentExpression":
        case "ArrowFunctionExpression":
        case "YieldExpression":
          return 1;
        case "ConditionalExpression":
          return 3;
        case "LogicalExpression":
          switch (node.operator) {
            case "||":
            case "??":
              return 4;
            case "&&":
              return 5;
          }
        case "BinaryExpression":
          switch (node.operator) {
            case "|":
              return 6;
            case "^":
              return 7;
            case "&":
              return 8;
            case "==":
            case "!=":
            case "===":
            case "!==":
              return 9;
            case "<":
            case "<=":
            case ">":
            case ">=":
            case "in":
            case "instanceof":
              return 10;
            case "<<":
            case ">>":
            case ">>>":
              return 11;
            case "+":
            case "-":
              return 12;
            case "*":
            case "/":
            case "%":
              return 13;
            case "**":
              return 15;
          }
        case "UnaryExpression":
        case "AwaitExpression":
          return 16;
        case "UpdateExpression":
          return 17;
        case "CallExpression":
        case "ChainExpression":
        case "ImportExpression":
          return 18;
        case "NewExpression":
          return 19;
        default:
          return 20;
      }
    },
    isEmptyBlock(node) {
      return Boolean(node && node.type === "BlockStatement" && node.body.length === 0);
    },
    isEmptyFunction(node) {
      return isFunction(node) && module2.exports.isEmptyBlock(node.body);
    },
    getDirectivePrologue(node) {
      const directives = [];
      if (node.type === "Program" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement") {
        const statements = node.type === "Program" ? node.body : node.body.body;
        for (const statement of statements) {
          if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal") {
            directives.push(statement);
          } else {
            break;
          }
        }
      }
      return directives;
    },
    isDecimalInteger(node) {
      return node.type === "Literal" && typeof node.value === "number" && DECIMAL_INTEGER_PATTERN.test(node.raw);
    },
    isDecimalIntegerNumericToken(token) {
      return token.type === "Numeric" && DECIMAL_INTEGER_PATTERN.test(token.value);
    },
    getFunctionNameWithKind(node) {
      const parent = node.parent;
      const tokens = [];
      if (parent.type === "MethodDefinition" && parent.static) {
        tokens.push("static");
      }
      if (node.async) {
        tokens.push("async");
      }
      if (node.generator) {
        tokens.push("generator");
      }
      if (node.type === "ArrowFunctionExpression") {
        tokens.push("arrow", "function");
      } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        if (parent.kind === "constructor") {
          return "constructor";
        }
        if (parent.kind === "get") {
          tokens.push("getter");
        } else if (parent.kind === "set") {
          tokens.push("setter");
        } else {
          tokens.push("method");
        }
      } else {
        tokens.push("function");
      }
      if (node.id) {
        tokens.push(`'${node.id.name}'`);
      } else {
        const name = getStaticPropertyName(parent);
        if (name !== null) {
          tokens.push(`'${name}'`);
        }
      }
      return tokens.join(" ");
    },
    getFunctionHeadLoc(node, sourceCode) {
      const parent = node.parent;
      let start = null;
      let end = null;
      if (node.type === "ArrowFunctionExpression") {
        const arrowToken = sourceCode.getTokenBefore(node.body, isArrowToken);
        start = arrowToken.loc.start;
        end = arrowToken.loc.end;
      } else if (parent.type === "Property" || parent.type === "MethodDefinition") {
        start = parent.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      } else {
        start = node.loc.start;
        end = getOpeningParenOfParams(node, sourceCode).loc.start;
      }
      return {
        start: Object.assign({}, start),
        end: Object.assign({}, end)
      };
    },
    getNextLocation(sourceCode, {line, column}) {
      if (column < sourceCode.lines[line - 1].length) {
        return {
          line,
          column: column + 1
        };
      }
      if (line < sourceCode.lines.length) {
        return {
          line: line + 1,
          column: 0
        };
      }
      return null;
    },
    getParenthesisedText(sourceCode, node) {
      let leftToken = sourceCode.getFirstToken(node);
      let rightToken = sourceCode.getLastToken(node);
      while (sourceCode.getTokenBefore(leftToken) && sourceCode.getTokenBefore(leftToken).type === "Punctuator" && sourceCode.getTokenBefore(leftToken).value === "(" && sourceCode.getTokenAfter(rightToken) && sourceCode.getTokenAfter(rightToken).type === "Punctuator" && sourceCode.getTokenAfter(rightToken).value === ")") {
        leftToken = sourceCode.getTokenBefore(leftToken);
        rightToken = sourceCode.getTokenAfter(rightToken);
      }
      return sourceCode.getText().slice(leftToken.range[0], rightToken.range[1]);
    },
    couldBeError(node) {
      switch (node.type) {
        case "Identifier":
        case "CallExpression":
        case "NewExpression":
        case "MemberExpression":
        case "TaggedTemplateExpression":
        case "YieldExpression":
        case "AwaitExpression":
        case "ChainExpression":
          return true;
        case "AssignmentExpression":
          if (["=", "&&="].includes(node.operator)) {
            return module2.exports.couldBeError(node.right);
          }
          if (["||=", "??="].includes(node.operator)) {
            return module2.exports.couldBeError(node.left) || module2.exports.couldBeError(node.right);
          }
          return false;
        case "SequenceExpression": {
          const exprs = node.expressions;
          return exprs.length !== 0 && module2.exports.couldBeError(exprs[exprs.length - 1]);
        }
        case "LogicalExpression":
          if (node.operator === "&&") {
            return module2.exports.couldBeError(node.right);
          }
          return module2.exports.couldBeError(node.left) || module2.exports.couldBeError(node.right);
        case "ConditionalExpression":
          return module2.exports.couldBeError(node.consequent) || module2.exports.couldBeError(node.alternate);
        default:
          return false;
      }
    },
    isNumericLiteral(node) {
      return node.type === "Literal" && (typeof node.value === "number" || Boolean(node.bigint));
    },
    canTokensBeAdjacent(leftValue, rightValue) {
      const espreeOptions = {
        ecmaVersion: espree.latestEcmaVersion,
        comment: true,
        range: true
      };
      let leftToken;
      if (typeof leftValue === "string") {
        let tokens;
        try {
          tokens = espree.tokenize(leftValue, espreeOptions);
        } catch (e) {
          return false;
        }
        const comments = tokens.comments;
        leftToken = tokens[tokens.length - 1];
        if (comments.length) {
          const lastComment = comments[comments.length - 1];
          if (lastComment.range[0] > leftToken.range[0]) {
            leftToken = lastComment;
          }
        }
      } else {
        leftToken = leftValue;
      }
      if (leftToken.type === "Shebang") {
        return false;
      }
      let rightToken;
      if (typeof rightValue === "string") {
        let tokens;
        try {
          tokens = espree.tokenize(rightValue, espreeOptions);
        } catch (e) {
          return false;
        }
        const comments = tokens.comments;
        rightToken = tokens[0];
        if (comments.length) {
          const firstComment = comments[0];
          if (firstComment.range[0] < rightToken.range[0]) {
            rightToken = firstComment;
          }
        }
      } else {
        rightToken = rightValue;
      }
      if (leftToken.type === "Punctuator" || rightToken.type === "Punctuator") {
        if (leftToken.type === "Punctuator" && rightToken.type === "Punctuator") {
          const PLUS_TOKENS = new Set(["+", "++"]);
          const MINUS_TOKENS = new Set(["-", "--"]);
          return !(PLUS_TOKENS.has(leftToken.value) && PLUS_TOKENS.has(rightToken.value) || MINUS_TOKENS.has(leftToken.value) && MINUS_TOKENS.has(rightToken.value));
        }
        if (leftToken.type === "Punctuator" && leftToken.value === "/") {
          return !["Block", "Line", "RegularExpression"].includes(rightToken.type);
        }
        return true;
      }
      if (leftToken.type === "String" || rightToken.type === "String" || leftToken.type === "Template" || rightToken.type === "Template") {
        return true;
      }
      if (leftToken.type !== "Numeric" && rightToken.type === "Numeric" && rightToken.value.startsWith(".")) {
        return true;
      }
      if (leftToken.type === "Block" || rightToken.type === "Block" || rightToken.type === "Line") {
        return true;
      }
      return false;
    },
    getNameLocationInGlobalDirectiveComment(sourceCode, comment, name) {
      const namePattern = new RegExp(`[\\s,]${lodash.escapeRegExp(name)}(?:$|[\\s,:])`, "gu");
      namePattern.lastIndex = comment.value.indexOf("global") + 6;
      const match = namePattern.exec(comment.value);
      const start = sourceCode.getLocFromIndex(comment.range[0] + "/*".length + (match ? match.index + 1 : 0));
      const end = {
        line: start.line,
        column: start.column + (match ? name.length : 1)
      };
      return {start, end};
    },
    hasOctalOrNonOctalDecimalEscapeSequence(rawString) {
      return OCTAL_OR_NON_OCTAL_DECIMAL_ESCAPE_PATTERN.test(rawString);
    },
    isLogicalExpression,
    isCoalesceExpression,
    isMixedLogicalAndCoalesceExpressions,
    isNullLiteral,
    getStaticStringValue,
    getStaticPropertyName,
    skipChainExpression,
    isSpecificId,
    isSpecificMemberAccess,
    equalLiteralValue,
    isSameReference,
    isLogicalAssignmentOperator
  };
});

// node_modules/eslint/lib/rules/accessor-pairs.js
var require_accessor_pairs = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function areEqualTokenLists(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i = 0; i < left.length; i++) {
      const leftToken = left[i], rightToken = right[i];
      if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
        return false;
      }
    }
    return true;
  }
  function areEqualKeys(left, right) {
    if (typeof left === "string" && typeof right === "string") {
      return left === right;
    }
    if (Array.isArray(left) && Array.isArray(right)) {
      return areEqualTokenLists(left, right);
    }
    return false;
  }
  function isAccessorKind(node) {
    return node.kind === "get" || node.kind === "set";
  }
  function isArgumentOfMethodCall(node, index, object, property) {
    const parent = node.parent;
    return parent.type === "CallExpression" && astUtils.isSpecificMemberAccess(parent.callee, object, property) && parent.arguments[index] === node;
  }
  function isPropertyDescriptor(node) {
    if (isArgumentOfMethodCall(node, 2, "Object", "defineProperty") || isArgumentOfMethodCall(node, 2, "Reflect", "defineProperty")) {
      return true;
    }
    const grandparent = node.parent.parent;
    return grandparent.type === "ObjectExpression" && (isArgumentOfMethodCall(grandparent, 1, "Object", "create") || isArgumentOfMethodCall(grandparent, 1, "Object", "defineProperties"));
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce getter and setter pairs in objects and classes",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/accessor-pairs"
      },
      schema: [{
        type: "object",
        properties: {
          getWithoutSet: {
            type: "boolean",
            default: false
          },
          setWithoutGet: {
            type: "boolean",
            default: true
          },
          enforceForClassMembers: {
            type: "boolean",
            default: true
          }
        },
        additionalProperties: false
      }],
      messages: {
        missingGetterInPropertyDescriptor: "Getter is not present in property descriptor.",
        missingSetterInPropertyDescriptor: "Setter is not present in property descriptor.",
        missingGetterInObjectLiteral: "Getter is not present for {{ name }}.",
        missingSetterInObjectLiteral: "Setter is not present for {{ name }}.",
        missingGetterInClass: "Getter is not present for class {{ name }}.",
        missingSetterInClass: "Setter is not present for class {{ name }}."
      }
    },
    create(context4) {
      const config = context4.options[0] || {};
      const checkGetWithoutSet = config.getWithoutSet === true;
      const checkSetWithoutGet = config.setWithoutGet !== false;
      const enforceForClassMembers = config.enforceForClassMembers !== false;
      const sourceCode = context4.getSourceCode();
      function report(node, messageKind) {
        if (node.type === "Property") {
          context4.report({
            node,
            messageId: `${messageKind}InObjectLiteral`,
            loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
            data: {name: astUtils.getFunctionNameWithKind(node.value)}
          });
        } else if (node.type === "MethodDefinition") {
          context4.report({
            node,
            messageId: `${messageKind}InClass`,
            loc: astUtils.getFunctionHeadLoc(node.value, sourceCode),
            data: {name: astUtils.getFunctionNameWithKind(node.value)}
          });
        } else {
          context4.report({
            node,
            messageId: `${messageKind}InPropertyDescriptor`
          });
        }
      }
      function reportList(nodes, messageKind) {
        for (const node of nodes) {
          report(node, messageKind);
        }
      }
      function createAccessorData(node) {
        const name = astUtils.getStaticPropertyName(node);
        const key = name !== null ? name : sourceCode.getTokens(node.key);
        return {
          key,
          getters: node.kind === "get" ? [node] : [],
          setters: node.kind === "set" ? [node] : []
        };
      }
      function mergeAccessorData(accessors, accessorData) {
        const equalKeyElement = accessors.find((a) => areEqualKeys(a.key, accessorData.key));
        if (equalKeyElement) {
          equalKeyElement.getters.push(...accessorData.getters);
          equalKeyElement.setters.push(...accessorData.setters);
        } else {
          accessors.push(accessorData);
        }
        return accessors;
      }
      function checkList(nodes) {
        const accessors = nodes.filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);
        for (const {getters, setters} of accessors) {
          if (checkSetWithoutGet && setters.length && !getters.length) {
            reportList(setters, "missingGetter");
          }
          if (checkGetWithoutSet && getters.length && !setters.length) {
            reportList(getters, "missingSetter");
          }
        }
      }
      function checkObjectLiteral(node) {
        checkList(node.properties.filter((p) => p.type === "Property"));
      }
      function checkPropertyDescriptor(node) {
        const namesToCheck = node.properties.filter((p) => p.type === "Property" && p.kind === "init" && !p.computed).map(({key}) => key.name);
        const hasGetter = namesToCheck.includes("get");
        const hasSetter = namesToCheck.includes("set");
        if (checkSetWithoutGet && hasSetter && !hasGetter) {
          report(node, "missingGetter");
        }
        if (checkGetWithoutSet && hasGetter && !hasSetter) {
          report(node, "missingSetter");
        }
      }
      function checkObjectExpression(node) {
        checkObjectLiteral(node);
        if (isPropertyDescriptor(node)) {
          checkPropertyDescriptor(node);
        }
      }
      function checkClassBody(node) {
        const methodDefinitions = node.body.filter((m) => m.type === "MethodDefinition");
        checkList(methodDefinitions.filter((m) => m.static));
        checkList(methodDefinitions.filter((m) => !m.static));
      }
      const listeners = {};
      if (checkSetWithoutGet || checkGetWithoutSet) {
        listeners.ObjectExpression = checkObjectExpression;
        if (enforceForClassMembers) {
          listeners.ClassBody = checkClassBody;
        }
      }
      return listeners;
    }
  };
});

// node_modules/eslint/lib/rules/array-bracket-newline.js
var require_array_bracket_newline = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce linebreaks after opening and before closing array brackets",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/array-bracket-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consistent"]
            },
            {
              type: "object",
              properties: {
                multiline: {
                  type: "boolean"
                },
                minItems: {
                  type: ["integer", "null"],
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedOpeningLinebreak: "There should be no linebreak after '['.",
        unexpectedClosingLinebreak: "There should be no linebreak before ']'.",
        missingOpeningLinebreak: "A linebreak is required after '['.",
        missingClosingLinebreak: "A linebreak is required before ']'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function normalizeOptionValue(option) {
        let consistent = false;
        let multiline = false;
        let minItems = 0;
        if (option) {
          if (option === "consistent") {
            consistent = true;
            minItems = Number.POSITIVE_INFINITY;
          } else if (option === "always" || option.minItems === 0) {
            minItems = 0;
          } else if (option === "never") {
            minItems = Number.POSITIVE_INFINITY;
          } else {
            multiline = Boolean(option.multiline);
            minItems = option.minItems || Number.POSITIVE_INFINITY;
          }
        } else {
          consistent = false;
          multiline = true;
          minItems = Number.POSITIVE_INFINITY;
        }
        return {consistent, multiline, minItems};
      }
      function normalizeOptions(options) {
        const value = normalizeOptionValue(options);
        return {ArrayExpression: value, ArrayPattern: value};
      }
      function reportNoBeginningLinebreak(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "unexpectedOpeningLinebreak",
          fix(fixer) {
            const nextToken = sourceCode.getTokenAfter(token, {includeComments: true});
            if (astUtils.isCommentToken(nextToken)) {
              return null;
            }
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
      function reportNoEndingLinebreak(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "unexpectedClosingLinebreak",
          fix(fixer) {
            const previousToken = sourceCode.getTokenBefore(token, {includeComments: true});
            if (astUtils.isCommentToken(previousToken)) {
              return null;
            }
            return fixer.removeRange([previousToken.range[1], token.range[0]]);
          }
        });
      }
      function reportRequiredBeginningLinebreak(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingOpeningLinebreak",
          fix(fixer) {
            return fixer.insertTextAfter(token, "\n");
          }
        });
      }
      function reportRequiredEndingLinebreak(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingClosingLinebreak",
          fix(fixer) {
            return fixer.insertTextBefore(token, "\n");
          }
        });
      }
      function check(node) {
        const elements = node.elements;
        const normalizedOptions = normalizeOptions(context4.options[0]);
        const options = normalizedOptions[node.type];
        const openBracket = sourceCode.getFirstToken(node);
        const closeBracket = sourceCode.getLastToken(node);
        const firstIncComment = sourceCode.getTokenAfter(openBracket, {includeComments: true});
        const lastIncComment = sourceCode.getTokenBefore(closeBracket, {includeComments: true});
        const first = sourceCode.getTokenAfter(openBracket);
        const last = sourceCode.getTokenBefore(closeBracket);
        const needsLinebreaks = elements.length >= options.minItems || options.multiline && elements.length > 0 && firstIncComment.loc.start.line !== lastIncComment.loc.end.line || elements.length === 0 && firstIncComment.type === "Block" && firstIncComment.loc.start.line !== lastIncComment.loc.end.line && firstIncComment === lastIncComment || options.consistent && openBracket.loc.end.line !== first.loc.start.line;
        if (needsLinebreaks) {
          if (astUtils.isTokenOnSameLine(openBracket, first)) {
            reportRequiredBeginningLinebreak(node, openBracket);
          }
          if (astUtils.isTokenOnSameLine(last, closeBracket)) {
            reportRequiredEndingLinebreak(node, closeBracket);
          }
        } else {
          if (!astUtils.isTokenOnSameLine(openBracket, first)) {
            reportNoBeginningLinebreak(node, openBracket);
          }
          if (!astUtils.isTokenOnSameLine(last, closeBracket)) {
            reportNoEndingLinebreak(node, closeBracket);
          }
        }
      }
      return {
        ArrayPattern: check,
        ArrayExpression: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/array-bracket-spacing.js
var require_array_bracket_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing inside array brackets",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/array-bracket-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            singleValue: {
              type: "boolean"
            },
            objectsInArrays: {
              type: "boolean"
            },
            arraysInArrays: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'."
      }
    },
    create(context4) {
      const spaced = context4.options[0] === "always", sourceCode = context4.getSourceCode();
      function isOptionSet(option) {
        return context4.options[1] ? context4.options[1][option] === !spaced : false;
      }
      const options = {
        spaced,
        singleElementException: isOptionSet("singleValue"),
        objectsInArraysException: isOptionSet("objectsInArrays"),
        arraysInArraysException: isOptionSet("arraysInArrays")
      };
      function reportNoBeginningSpace(node, token) {
        const nextToken = sourceCode.getTokenAfter(token);
        context4.report({
          node,
          loc: {start: token.loc.end, end: nextToken.loc.start},
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
      function reportNoEndingSpace(node, token) {
        const previousToken = sourceCode.getTokenBefore(token);
        context4.report({
          node,
          loc: {start: previousToken.loc.end, end: token.loc.start},
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([previousToken.range[1], token.range[0]]);
          }
        });
      }
      function reportRequiredBeginningSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function isObjectType(node) {
        return node && (node.type === "ObjectExpression" || node.type === "ObjectPattern");
      }
      function isArrayType(node) {
        return node && (node.type === "ArrayExpression" || node.type === "ArrayPattern");
      }
      function validateArraySpacing(node) {
        if (options.spaced && node.elements.length === 0) {
          return;
        }
        const first = sourceCode.getFirstToken(node), second = sourceCode.getFirstToken(node, 1), last = node.typeAnnotation ? sourceCode.getTokenBefore(node.typeAnnotation) : sourceCode.getLastToken(node), penultimate = sourceCode.getTokenBefore(last), firstElement = node.elements[0], lastElement = node.elements[node.elements.length - 1];
        const openingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(firstElement) || options.arraysInArraysException && isArrayType(firstElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
        const closingBracketMustBeSpaced = options.objectsInArraysException && isObjectType(lastElement) || options.arraysInArraysException && isArrayType(lastElement) || options.singleElementException && node.elements.length === 1 ? !options.spaced : options.spaced;
        if (astUtils.isTokenOnSameLine(first, second)) {
          if (openingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(first, second)) {
            reportRequiredBeginningSpace(node, first);
          }
          if (!openingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(first, second)) {
            reportNoBeginningSpace(node, first);
          }
        }
        if (first !== penultimate && astUtils.isTokenOnSameLine(penultimate, last)) {
          if (closingBracketMustBeSpaced && !sourceCode.isSpaceBetweenTokens(penultimate, last)) {
            reportRequiredEndingSpace(node, last);
          }
          if (!closingBracketMustBeSpaced && sourceCode.isSpaceBetweenTokens(penultimate, last)) {
            reportNoEndingSpace(node, last);
          }
        }
      }
      return {
        ArrayPattern: validateArraySpacing,
        ArrayExpression: validateArraySpacing
      };
    }
  };
});

// node_modules/eslint/lib/rules/array-callback-return.js
var require_array_callback_return = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
  var TARGET_METHODS = /^(?:every|filter|find(?:Index)?|flatMap|forEach|map|reduce(?:Right)?|some|sort)$/u;
  function isReachable(segment) {
    return segment.reachable;
  }
  function isTargetMethod(node) {
    return astUtils.isSpecificMemberAccess(node, null, TARGET_METHODS);
  }
  function fullMethodName(arrayMethodName) {
    if (["from", "of", "isArray"].includes(arrayMethodName)) {
      return "Array.".concat(arrayMethodName);
    }
    return "Array.prototype.".concat(arrayMethodName);
  }
  function getArrayMethodName(node) {
    let currentNode = node;
    while (currentNode) {
      const parent = currentNode.parent;
      switch (parent.type) {
        case "LogicalExpression":
        case "ConditionalExpression":
        case "ChainExpression":
          currentNode = parent;
          break;
        case "ReturnStatement": {
          const func = astUtils.getUpperFunction(parent);
          if (func === null || !astUtils.isCallee(func)) {
            return null;
          }
          currentNode = func.parent;
          break;
        }
        case "CallExpression":
          if (astUtils.isArrayFromMethod(parent.callee)) {
            if (parent.arguments.length >= 2 && parent.arguments[1] === currentNode) {
              return "from";
            }
          }
          if (isTargetMethod(parent.callee)) {
            if (parent.arguments.length >= 1 && parent.arguments[0] === currentNode) {
              return astUtils.getStaticPropertyName(parent.callee);
            }
          }
          return null;
        default:
          return null;
      }
    }
    return null;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "enforce `return` statements in callbacks of array methods",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/array-callback-return"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean",
              default: false
            },
            checkForEach: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedAtEnd: "{{arrayMethodName}}() expects a value to be returned at the end of {{name}}.",
        expectedInside: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedReturnValue: "{{arrayMethodName}}() expects a return value from {{name}}.",
        expectedNoReturnValue: "{{arrayMethodName}}() expects no useless return value from {{name}}."
      }
    },
    create(context4) {
      const options = context4.options[0] || {allowImplicit: false, checkForEach: false};
      const sourceCode = context4.getSourceCode();
      let funcInfo = {
        arrayMethodName: null,
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false,
        node: null
      };
      function checkLastSegment(node) {
        if (!funcInfo.shouldCheck) {
          return;
        }
        let messageId = null;
        if (funcInfo.arrayMethodName === "forEach") {
          if (options.checkForEach && node.type === "ArrowFunctionExpression" && node.expression) {
            messageId = "expectedNoReturnValue";
          }
        } else {
          if (node.body.type === "BlockStatement" && funcInfo.codePath.currentSegments.some(isReachable)) {
            messageId = funcInfo.hasReturn ? "expectedAtEnd" : "expectedInside";
          }
        }
        if (messageId) {
          const name = astUtils.getFunctionNameWithKind(node);
          context4.report({
            node,
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            messageId,
            data: {name, arrayMethodName: fullMethodName(funcInfo.arrayMethodName)}
          });
        }
      }
      return {
        onCodePathStart(codePath, node) {
          let methodName = null;
          if (TARGET_NODE_TYPE.test(node.type)) {
            methodName = getArrayMethodName(node);
          }
          funcInfo = {
            arrayMethodName: methodName,
            upper: funcInfo,
            codePath,
            hasReturn: false,
            shouldCheck: methodName && !node.async && !node.generator,
            node
          };
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        ReturnStatement(node) {
          if (!funcInfo.shouldCheck) {
            return;
          }
          funcInfo.hasReturn = true;
          let messageId = null;
          if (funcInfo.arrayMethodName === "forEach") {
            if (options.checkForEach && node.argument) {
              messageId = "expectedNoReturnValue";
            }
          } else {
            if (!options.allowImplicit && !node.argument) {
              messageId = "expectedReturnValue";
            }
          }
          if (messageId) {
            context4.report({
              node,
              messageId,
              data: {
                name: astUtils.getFunctionNameWithKind(funcInfo.node),
                arrayMethodName: fullMethodName(funcInfo.arrayMethodName)
              }
            });
          }
        },
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
});

// node_modules/eslint/lib/rules/array-element-newline.js
var require_array_element_newline = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce line breaks after each array element",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/array-element-newline"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          basicConfig: {
            oneOf: [
              {
                enum: ["always", "never", "consistent"]
              },
              {
                type: "object",
                properties: {
                  multiline: {
                    type: "boolean"
                  },
                  minItems: {
                    type: ["integer", "null"],
                    minimum: 0
                  }
                },
                additionalProperties: false
              }
            ]
          }
        },
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/basicConfig"
              },
              {
                type: "object",
                properties: {
                  ArrayExpression: {
                    $ref: "#/definitions/basicConfig"
                  },
                  ArrayPattern: {
                    $ref: "#/definitions/basicConfig"
                  }
                },
                additionalProperties: false,
                minProperties: 1
              }
            ]
          }
        ]
      },
      messages: {
        unexpectedLineBreak: "There should be no linebreak here.",
        missingLineBreak: "There should be a linebreak after this element."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function normalizeOptionValue(providedOption) {
        let consistent = false;
        let multiline = false;
        let minItems;
        const option = providedOption || "always";
        if (!option || option === "always" || option.minItems === 0) {
          minItems = 0;
        } else if (option === "never") {
          minItems = Number.POSITIVE_INFINITY;
        } else if (option === "consistent") {
          consistent = true;
          minItems = Number.POSITIVE_INFINITY;
        } else {
          multiline = Boolean(option.multiline);
          minItems = option.minItems || Number.POSITIVE_INFINITY;
        }
        return {consistent, multiline, minItems};
      }
      function normalizeOptions(options) {
        if (options && (options.ArrayExpression || options.ArrayPattern)) {
          let expressionOptions, patternOptions;
          if (options.ArrayExpression) {
            expressionOptions = normalizeOptionValue(options.ArrayExpression);
          }
          if (options.ArrayPattern) {
            patternOptions = normalizeOptionValue(options.ArrayPattern);
          }
          return {ArrayExpression: expressionOptions, ArrayPattern: patternOptions};
        }
        const value = normalizeOptionValue(options);
        return {ArrayExpression: value, ArrayPattern: value};
      }
      function reportNoLineBreak(token) {
        const tokenBefore = sourceCode.getTokenBefore(token, {includeComments: true});
        context4.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: "unexpectedLineBreak",
          fix(fixer) {
            if (astUtils.isCommentToken(tokenBefore)) {
              return null;
            }
            if (!astUtils.isTokenOnSameLine(tokenBefore, token)) {
              return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ");
            }
            const twoTokensBefore = sourceCode.getTokenBefore(tokenBefore, {includeComments: true});
            if (astUtils.isCommentToken(twoTokensBefore)) {
              return null;
            }
            return fixer.replaceTextRange([twoTokensBefore.range[1], tokenBefore.range[0]], "");
          }
        });
      }
      function reportRequiredLineBreak(token) {
        const tokenBefore = sourceCode.getTokenBefore(token, {includeComments: true});
        context4.report({
          loc: {
            start: tokenBefore.loc.end,
            end: token.loc.start
          },
          messageId: "missingLineBreak",
          fix(fixer) {
            return fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n");
          }
        });
      }
      function check(node) {
        const elements = node.elements;
        const normalizedOptions = normalizeOptions(context4.options[0]);
        const options = normalizedOptions[node.type];
        if (!options) {
          return;
        }
        let elementBreak = false;
        if (options.multiline) {
          elementBreak = elements.filter((element) => element !== null).some((element) => element.loc.start.line !== element.loc.end.line);
        }
        const linebreaksCount = node.elements.map((element, i) => {
          const previousElement = elements[i - 1];
          if (i === 0 || element === null || previousElement === null) {
            return false;
          }
          const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
          const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
          const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
          return !astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement);
        }).filter((isBreak) => isBreak === true).length;
        const needsLinebreaks = elements.length >= options.minItems || options.multiline && elementBreak || options.consistent && linebreaksCount > 0 && linebreaksCount < node.elements.length;
        elements.forEach((element, i) => {
          const previousElement = elements[i - 1];
          if (i === 0 || element === null || previousElement === null) {
            return;
          }
          const commaToken = sourceCode.getFirstTokenBetween(previousElement, element, astUtils.isCommaToken);
          const lastTokenOfPreviousElement = sourceCode.getTokenBefore(commaToken);
          const firstTokenOfCurrentElement = sourceCode.getTokenAfter(commaToken);
          if (needsLinebreaks) {
            if (astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
              reportRequiredLineBreak(firstTokenOfCurrentElement);
            }
          } else {
            if (!astUtils.isTokenOnSameLine(lastTokenOfPreviousElement, firstTokenOfCurrentElement)) {
              reportNoLineBreak(firstTokenOfCurrentElement);
            }
          }
        });
      }
      return {
        ArrayPattern: check,
        ArrayExpression: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/arrow-body-style.js
var require_arrow_body_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require braces around arrow function bodies",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/arrow-body-style"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["as-needed"]
              },
              {
                type: "object",
                properties: {
                  requireReturnForObjectLiteral: {type: "boolean"}
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpectedOtherBlock: "Unexpected block statement surrounding arrow body.",
        unexpectedEmptyBlock: "Unexpected block statement surrounding arrow body; put a value of `undefined` immediately after the `=>`.",
        unexpectedObjectBlock: "Unexpected block statement surrounding arrow body; parenthesize the returned value and move it immediately after the `=>`.",
        unexpectedSingleBlock: "Unexpected block statement surrounding arrow body; move the returned value immediately after the `=>`.",
        expectedBlock: "Expected block statement surrounding arrow body."
      }
    },
    create(context4) {
      const options = context4.options;
      const always = options[0] === "always";
      const asNeeded = !options[0] || options[0] === "as-needed";
      const never = options[0] === "never";
      const requireReturnForObjectLiteral = options[1] && options[1].requireReturnForObjectLiteral;
      const sourceCode = context4.getSourceCode();
      let funcInfo = null;
      function hasASIProblem(token) {
        return token && token.type === "Punctuator" && /^[([/`+-]/u.test(token.value);
      }
      function findClosingParen(token) {
        let node = sourceCode.getNodeByRangeIndex(token.range[0]);
        while (!astUtils.isParenthesised(sourceCode, node)) {
          node = node.parent;
        }
        return sourceCode.getTokenAfter(node);
      }
      function isInsideForLoopInitializer(node) {
        if (node && node.parent) {
          if (node.parent.type === "ForStatement" && node.parent.init === node) {
            return true;
          }
          return isInsideForLoopInitializer(node.parent);
        }
        return false;
      }
      function validate(node) {
        const arrowBody = node.body;
        if (arrowBody.type === "BlockStatement") {
          const blockBody = arrowBody.body;
          if (blockBody.length !== 1 && !never) {
            return;
          }
          if (asNeeded && requireReturnForObjectLiteral && blockBody[0].type === "ReturnStatement" && blockBody[0].argument && blockBody[0].argument.type === "ObjectExpression") {
            return;
          }
          if (never || asNeeded && blockBody[0].type === "ReturnStatement") {
            let messageId;
            if (blockBody.length === 0) {
              messageId = "unexpectedEmptyBlock";
            } else if (blockBody.length > 1) {
              messageId = "unexpectedOtherBlock";
            } else if (blockBody[0].argument === null) {
              messageId = "unexpectedSingleBlock";
            } else if (astUtils.isOpeningBraceToken(sourceCode.getFirstToken(blockBody[0], {skip: 1}))) {
              messageId = "unexpectedObjectBlock";
            } else {
              messageId = "unexpectedSingleBlock";
            }
            context4.report({
              node,
              loc: arrowBody.loc,
              messageId,
              fix(fixer) {
                const fixes = [];
                if (blockBody.length !== 1 || blockBody[0].type !== "ReturnStatement" || !blockBody[0].argument || hasASIProblem(sourceCode.getTokenAfter(arrowBody))) {
                  return fixes;
                }
                const openingBrace = sourceCode.getFirstToken(arrowBody);
                const closingBrace = sourceCode.getLastToken(arrowBody);
                const firstValueToken = sourceCode.getFirstToken(blockBody[0], 1);
                const lastValueToken = sourceCode.getLastToken(blockBody[0]);
                const commentsExist = sourceCode.commentsExistBetween(openingBrace, firstValueToken) || sourceCode.commentsExistBetween(lastValueToken, closingBrace);
                if (commentsExist) {
                  fixes.push(fixer.remove(openingBrace), fixer.remove(closingBrace), fixer.remove(sourceCode.getTokenAfter(openingBrace)));
                } else {
                  fixes.push(fixer.removeRange([openingBrace.range[0], firstValueToken.range[0]]), fixer.removeRange([lastValueToken.range[1], closingBrace.range[1]]));
                }
                if (astUtils.isOpeningBraceToken(firstValueToken) || blockBody[0].argument.type === "SequenceExpression" || funcInfo.hasInOperator && isInsideForLoopInitializer(node)) {
                  if (!astUtils.isParenthesised(sourceCode, blockBody[0].argument)) {
                    fixes.push(fixer.insertTextBefore(firstValueToken, "("), fixer.insertTextAfter(lastValueToken, ")"));
                  }
                }
                if (astUtils.isSemicolonToken(lastValueToken)) {
                  fixes.push(fixer.remove(lastValueToken));
                }
                return fixes;
              }
            });
          }
        } else {
          if (always || asNeeded && requireReturnForObjectLiteral && arrowBody.type === "ObjectExpression") {
            context4.report({
              node,
              loc: arrowBody.loc,
              messageId: "expectedBlock",
              fix(fixer) {
                const fixes = [];
                const arrowToken = sourceCode.getTokenBefore(arrowBody, astUtils.isArrowToken);
                const [firstTokenAfterArrow, secondTokenAfterArrow] = sourceCode.getTokensAfter(arrowToken, {count: 2});
                const lastToken = sourceCode.getLastToken(node);
                const isParenthesisedObjectLiteral = astUtils.isOpeningParenToken(firstTokenAfterArrow) && astUtils.isOpeningBraceToken(secondTokenAfterArrow);
                if (isParenthesisedObjectLiteral) {
                  const openingParenToken = firstTokenAfterArrow;
                  const openingBraceToken = secondTokenAfterArrow;
                  if (astUtils.isTokenOnSameLine(openingParenToken, openingBraceToken)) {
                    fixes.push(fixer.replaceText(openingParenToken, "{return "));
                  } else {
                    fixes.push(fixer.replaceText(openingParenToken, "{"), fixer.insertTextBefore(openingBraceToken, "return "));
                  }
                  fixes.push(fixer.remove(findClosingParen(openingBraceToken)));
                  fixes.push(fixer.insertTextAfter(lastToken, "}"));
                } else {
                  fixes.push(fixer.insertTextBefore(firstTokenAfterArrow, "{return "));
                  fixes.push(fixer.insertTextAfter(lastToken, "}"));
                }
                return fixes;
              }
            });
          }
        }
      }
      return {
        "BinaryExpression[operator='in']"() {
          let info3 = funcInfo;
          while (info3) {
            info3.hasInOperator = true;
            info3 = info3.upper;
          }
        },
        ArrowFunctionExpression() {
          funcInfo = {
            upper: funcInfo,
            hasInOperator: false
          };
        },
        "ArrowFunctionExpression:exit"(node) {
          validate(node);
          funcInfo = funcInfo.upper;
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/arrow-parens.js
var require_arrow_parens = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function hasBlockBody(node) {
    return node.body.type === "BlockStatement";
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require parentheses around arrow function arguments",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/arrow-parens"
      },
      fixable: "code",
      schema: [
        {
          enum: ["always", "as-needed"]
        },
        {
          type: "object",
          properties: {
            requireForBlockBody: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedParens: "Unexpected parentheses around single function argument.",
        expectedParens: "Expected parentheses around arrow function argument.",
        unexpectedParensInline: "Unexpected parentheses around single function argument having a body with no curly braces.",
        expectedParensBlock: "Expected parentheses around arrow function argument having a body with curly braces."
      }
    },
    create(context4) {
      const asNeeded = context4.options[0] === "as-needed";
      const requireForBlockBody = asNeeded && context4.options[1] && context4.options[1].requireForBlockBody === true;
      const sourceCode = context4.getSourceCode();
      function findOpeningParenOfParams(node) {
        const tokenBeforeParams = sourceCode.getTokenBefore(node.params[0]);
        if (tokenBeforeParams && astUtils.isOpeningParenToken(tokenBeforeParams) && node.range[0] <= tokenBeforeParams.range[0]) {
          return tokenBeforeParams;
        }
        return null;
      }
      function getClosingParenOfParams(node) {
        return sourceCode.getTokenAfter(node.params[0], astUtils.isClosingParenToken);
      }
      function hasCommentsInParensOfParams(node, openingParen) {
        return sourceCode.commentsExistBetween(openingParen, getClosingParenOfParams(node));
      }
      function hasUnexpectedTokensBeforeOpeningParen(node, openingParen) {
        const expectedCount = node.async ? 1 : 0;
        return sourceCode.getFirstToken(node, {skip: expectedCount}) !== openingParen;
      }
      return {
        "ArrowFunctionExpression[params.length=1]"(node) {
          const shouldHaveParens = !asNeeded || requireForBlockBody && hasBlockBody(node);
          const openingParen = findOpeningParenOfParams(node);
          const hasParens = openingParen !== null;
          const [param] = node.params;
          if (shouldHaveParens && !hasParens) {
            context4.report({
              node,
              messageId: requireForBlockBody ? "expectedParensBlock" : "expectedParens",
              loc: param.loc,
              *fix(fixer) {
                yield fixer.insertTextBefore(param, "(");
                yield fixer.insertTextAfter(param, ")");
              }
            });
          }
          if (!shouldHaveParens && hasParens && param.type === "Identifier" && !param.typeAnnotation && !node.returnType && !hasCommentsInParensOfParams(node, openingParen) && !hasUnexpectedTokensBeforeOpeningParen(node, openingParen)) {
            context4.report({
              node,
              messageId: requireForBlockBody ? "unexpectedParensInline" : "unexpectedParens",
              loc: param.loc,
              *fix(fixer) {
                const tokenBeforeOpeningParen = sourceCode.getTokenBefore(openingParen);
                const closingParen = getClosingParenOfParams(node);
                if (tokenBeforeOpeningParen && tokenBeforeOpeningParen.range[1] === openingParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeOpeningParen, sourceCode.getFirstToken(param))) {
                  yield fixer.insertTextBefore(openingParen, " ");
                }
                yield fixer.removeRange([openingParen.range[0], param.range[0]]);
                yield fixer.removeRange([param.range[1], closingParen.range[1]]);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/arrow-spacing.js
var require_arrow_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before and after the arrow in arrow functions",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/arrow-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: true
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedBefore: "Missing space before =>.",
        unexpectedBefore: "Unexpected space before =>.",
        expectedAfter: "Missing space after =>.",
        unexpectedAfter: "Unexpected space after =>."
      }
    },
    create(context4) {
      const rule = Object.assign({}, context4.options[0]);
      rule.before = rule.before !== false;
      rule.after = rule.after !== false;
      const sourceCode = context4.getSourceCode();
      function getTokens(node) {
        const arrow = sourceCode.getTokenBefore(node.body, astUtils.isArrowToken);
        return {
          before: sourceCode.getTokenBefore(arrow),
          arrow,
          after: sourceCode.getTokenAfter(arrow)
        };
      }
      function countSpaces(tokens) {
        const before = tokens.arrow.range[0] - tokens.before.range[1];
        const after = tokens.after.range[0] - tokens.arrow.range[1];
        return {before, after};
      }
      function spaces(node) {
        const tokens = getTokens(node);
        const countSpace = countSpaces(tokens);
        if (rule.before) {
          if (countSpace.before === 0) {
            context4.report({
              node: tokens.before,
              messageId: "expectedBefore",
              fix(fixer) {
                return fixer.insertTextBefore(tokens.arrow, " ");
              }
            });
          }
        } else {
          if (countSpace.before > 0) {
            context4.report({
              node: tokens.before,
              messageId: "unexpectedBefore",
              fix(fixer) {
                return fixer.removeRange([tokens.before.range[1], tokens.arrow.range[0]]);
              }
            });
          }
        }
        if (rule.after) {
          if (countSpace.after === 0) {
            context4.report({
              node: tokens.after,
              messageId: "expectedAfter",
              fix(fixer) {
                return fixer.insertTextAfter(tokens.arrow, " ");
              }
            });
          }
        } else {
          if (countSpace.after > 0) {
            context4.report({
              node: tokens.after,
              messageId: "unexpectedAfter",
              fix(fixer) {
                return fixer.removeRange([tokens.arrow.range[1], tokens.after.range[0]]);
              }
            });
          }
        }
      }
      return {
        ArrowFunctionExpression: spaces
      };
    }
  };
});

// node_modules/eslint/lib/rules/block-scoped-var.js
var require_block_scoped_var = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce the use of variables within the scope they are defined",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/block-scoped-var"
      },
      schema: [],
      messages: {
        outOfScope: "'{{name}}' used outside of binding context."
      }
    },
    create(context4) {
      let stack = [];
      function enterScope(node) {
        stack.push(node.range);
      }
      function exitScope() {
        stack.pop();
      }
      function report(reference) {
        const identifier = reference.identifier;
        context4.report({node: identifier, messageId: "outOfScope", data: {name: identifier.name}});
      }
      function checkForVariables(node) {
        if (node.kind !== "var") {
          return;
        }
        const scopeRange = stack[stack.length - 1];
        function isOutsideOfScope(reference) {
          const idRange = reference.identifier.range;
          return idRange[0] < scopeRange[0] || idRange[1] > scopeRange[1];
        }
        const variables = context4.getDeclaredVariables(node);
        for (let i = 0; i < variables.length; ++i) {
          variables[i].references.filter(isOutsideOfScope).forEach(report);
        }
      }
      return {
        Program(node) {
          stack = [node.range];
        },
        BlockStatement: enterScope,
        "BlockStatement:exit": exitScope,
        ForStatement: enterScope,
        "ForStatement:exit": exitScope,
        ForInStatement: enterScope,
        "ForInStatement:exit": exitScope,
        ForOfStatement: enterScope,
        "ForOfStatement:exit": exitScope,
        SwitchStatement: enterScope,
        "SwitchStatement:exit": exitScope,
        CatchClause: enterScope,
        "CatchClause:exit": exitScope,
        VariableDeclaration: checkForVariables
      };
    }
  };
});

// node_modules/eslint/lib/rules/block-spacing.js
var require_block_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow or enforce spaces inside of blocks after opening block and before closing block",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/block-spacing"
      },
      fixable: "whitespace",
      schema: [
        {enum: ["always", "never"]}
      ],
      messages: {
        missing: "Requires a space {{location}} '{{token}}'.",
        extra: "Unexpected space(s) {{location}} '{{token}}'."
      }
    },
    create(context4) {
      const always = context4.options[0] !== "never", messageId = always ? "missing" : "extra", sourceCode = context4.getSourceCode();
      function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
          if (node.cases.length > 0) {
            return sourceCode.getTokenBefore(node.cases[0]);
          }
          return sourceCode.getLastToken(node, 1);
        }
        return sourceCode.getFirstToken(node);
      }
      function isValid(left, right) {
        return !util.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === always;
      }
      function checkSpacingInsideBraces(node) {
        const openBrace = getOpenBrace(node);
        const closeBrace = sourceCode.getLastToken(node);
        const firstToken = sourceCode.getTokenAfter(openBrace, {includeComments: true});
        const lastToken = sourceCode.getTokenBefore(closeBrace, {includeComments: true});
        if (openBrace.type !== "Punctuator" || openBrace.value !== "{" || closeBrace.type !== "Punctuator" || closeBrace.value !== "}" || firstToken === closeBrace) {
          return;
        }
        if (!always && firstToken.type === "Line") {
          return;
        }
        if (!isValid(openBrace, firstToken)) {
          let loc = openBrace.loc;
          if (messageId === "extra") {
            loc = {
              start: openBrace.loc.end,
              end: firstToken.loc.start
            };
          }
          context4.report({
            node,
            loc,
            messageId,
            data: {
              location: "after",
              token: openBrace.value
            },
            fix(fixer) {
              if (always) {
                return fixer.insertTextBefore(firstToken, " ");
              }
              return fixer.removeRange([openBrace.range[1], firstToken.range[0]]);
            }
          });
        }
        if (!isValid(lastToken, closeBrace)) {
          let loc = closeBrace.loc;
          if (messageId === "extra") {
            loc = {
              start: lastToken.loc.end,
              end: closeBrace.loc.start
            };
          }
          context4.report({
            node,
            loc,
            messageId,
            data: {
              location: "before",
              token: closeBrace.value
            },
            fix(fixer) {
              if (always) {
                return fixer.insertTextAfter(lastToken, " ");
              }
              return fixer.removeRange([lastToken.range[1], closeBrace.range[0]]);
            }
          });
        }
      }
      return {
        BlockStatement: checkSpacingInsideBraces,
        SwitchStatement: checkSpacingInsideBraces
      };
    }
  };
});

// node_modules/eslint/lib/rules/brace-style.js
var require_brace_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent brace style for blocks",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/brace-style"
      },
      schema: [
        {
          enum: ["1tbs", "stroustrup", "allman"]
        },
        {
          type: "object",
          properties: {
            allowSingleLine: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        nextLineOpen: "Opening curly brace does not appear on the same line as controlling statement.",
        sameLineOpen: "Opening curly brace appears on the same line as controlling statement.",
        blockSameLine: "Statement inside of curly braces should be on next line.",
        nextLineClose: "Closing curly brace does not appear on the same line as the subsequent block.",
        singleLineClose: "Closing curly brace should be on the same line as opening curly brace or on the line after the previous block.",
        sameLineClose: "Closing curly brace appears on the same line as the subsequent block."
      }
    },
    create(context4) {
      const style = context4.options[0] || "1tbs", params = context4.options[1] || {}, sourceCode = context4.getSourceCode();
      function removeNewlineBetween(firstToken, secondToken) {
        const textRange = [firstToken.range[1], secondToken.range[0]];
        const textBetween = sourceCode.text.slice(textRange[0], textRange[1]);
        if (textBetween.trim()) {
          return null;
        }
        return (fixer) => fixer.replaceTextRange(textRange, " ");
      }
      function validateCurlyPair(openingCurly, closingCurly) {
        const tokenBeforeOpeningCurly = sourceCode.getTokenBefore(openingCurly);
        const tokenAfterOpeningCurly = sourceCode.getTokenAfter(openingCurly);
        const tokenBeforeClosingCurly = sourceCode.getTokenBefore(closingCurly);
        const singleLineException = params.allowSingleLine && astUtils.isTokenOnSameLine(openingCurly, closingCurly);
        if (style !== "allman" && !astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly)) {
          context4.report({
            node: openingCurly,
            messageId: "nextLineOpen",
            fix: removeNewlineBetween(tokenBeforeOpeningCurly, openingCurly)
          });
        }
        if (style === "allman" && astUtils.isTokenOnSameLine(tokenBeforeOpeningCurly, openingCurly) && !singleLineException) {
          context4.report({
            node: openingCurly,
            messageId: "sameLineOpen",
            fix: (fixer) => fixer.insertTextBefore(openingCurly, "\n")
          });
        }
        if (astUtils.isTokenOnSameLine(openingCurly, tokenAfterOpeningCurly) && tokenAfterOpeningCurly !== closingCurly && !singleLineException) {
          context4.report({
            node: openingCurly,
            messageId: "blockSameLine",
            fix: (fixer) => fixer.insertTextAfter(openingCurly, "\n")
          });
        }
        if (tokenBeforeClosingCurly !== openingCurly && !singleLineException && astUtils.isTokenOnSameLine(tokenBeforeClosingCurly, closingCurly)) {
          context4.report({
            node: closingCurly,
            messageId: "singleLineClose",
            fix: (fixer) => fixer.insertTextBefore(closingCurly, "\n")
          });
        }
      }
      function validateCurlyBeforeKeyword(curlyToken) {
        const keywordToken = sourceCode.getTokenAfter(curlyToken);
        if (style === "1tbs" && !astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
          context4.report({
            node: curlyToken,
            messageId: "nextLineClose",
            fix: removeNewlineBetween(curlyToken, keywordToken)
          });
        }
        if (style !== "1tbs" && astUtils.isTokenOnSameLine(curlyToken, keywordToken)) {
          context4.report({
            node: curlyToken,
            messageId: "sameLineClose",
            fix: (fixer) => fixer.insertTextAfter(curlyToken, "\n")
          });
        }
      }
      return {
        BlockStatement(node) {
          if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
            validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
          }
        },
        ClassBody(node) {
          validateCurlyPair(sourceCode.getFirstToken(node), sourceCode.getLastToken(node));
        },
        SwitchStatement(node) {
          const closingCurly = sourceCode.getLastToken(node);
          const openingCurly = sourceCode.getTokenBefore(node.cases.length ? node.cases[0] : closingCurly);
          validateCurlyPair(openingCurly, closingCurly);
        },
        IfStatement(node) {
          if (node.consequent.type === "BlockStatement" && node.alternate) {
            validateCurlyBeforeKeyword(sourceCode.getLastToken(node.consequent));
          }
        },
        TryStatement(node) {
          validateCurlyBeforeKeyword(sourceCode.getLastToken(node.block));
          if (node.handler && node.finalizer) {
            validateCurlyBeforeKeyword(sourceCode.getLastToken(node.handler.body));
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/callback-return.js
var require_callback_return = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "require `return` statements after callbacks",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/callback-return"
      },
      schema: [{
        type: "array",
        items: {type: "string"}
      }],
      messages: {
        missingReturn: "Expected return with your callback function."
      }
    },
    create(context4) {
      const callbacks = context4.options[0] || ["callback", "cb", "next"], sourceCode = context4.getSourceCode();
      function findClosestParentOfType(node, types) {
        if (!node.parent) {
          return null;
        }
        if (types.indexOf(node.parent.type) === -1) {
          return findClosestParentOfType(node.parent, types);
        }
        return node.parent;
      }
      function containsOnlyIdentifiers(node) {
        if (node.type === "Identifier") {
          return true;
        }
        if (node.type === "MemberExpression") {
          if (node.object.type === "Identifier") {
            return true;
          }
          if (node.object.type === "MemberExpression") {
            return containsOnlyIdentifiers(node.object);
          }
        }
        return false;
      }
      function isCallback(node) {
        return containsOnlyIdentifiers(node.callee) && callbacks.indexOf(sourceCode.getText(node.callee)) > -1;
      }
      function isCallbackExpression(node, parentNode) {
        if (!parentNode || parentNode.type !== "ExpressionStatement") {
          return false;
        }
        if (parentNode.expression === node) {
          return true;
        }
        if (parentNode.expression.type === "BinaryExpression" || parentNode.expression.type === "LogicalExpression") {
          if (parentNode.expression.right === node) {
            return true;
          }
        }
        return false;
      }
      return {
        CallExpression(node) {
          if (!isCallback(node)) {
            return;
          }
          const closestBlock = findClosestParentOfType(node, ["BlockStatement", "ReturnStatement", "ArrowFunctionExpression"]) || {};
          if (closestBlock.type === "ReturnStatement") {
            return;
          }
          if (closestBlock.type === "ArrowFunctionExpression") {
            return;
          }
          if (closestBlock.type === "BlockStatement") {
            const lastItem = closestBlock.body[closestBlock.body.length - 1];
            if (isCallbackExpression(node, lastItem)) {
              const parentType = closestBlock.parent.type;
              if (parentType === "FunctionExpression" || parentType === "FunctionDeclaration" || parentType === "ArrowFunctionExpression") {
                return;
              }
            }
            if (lastItem.type === "ReturnStatement") {
              if (isCallbackExpression(node, closestBlock.body[closestBlock.body.length - 2])) {
                return;
              }
            }
          }
          if (findClosestParentOfType(node, ["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"])) {
            context4.report({node, messageId: "missingReturn"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/camelcase.js
var require_camelcase = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce camelcase naming convention",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/camelcase"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: {
              type: "boolean",
              default: false
            },
            ignoreImports: {
              type: "boolean",
              default: false
            },
            ignoreGlobals: {
              type: "boolean",
              default: false
            },
            properties: {
              enum: ["always", "never"]
            },
            allow: {
              type: "array",
              items: [
                {
                  type: "string"
                }
              ],
              minItems: 0,
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        notCamelCase: "Identifier '{{name}}' is not in camel case."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      let properties = options.properties || "";
      const ignoreDestructuring = options.ignoreDestructuring;
      const ignoreImports = options.ignoreImports;
      const ignoreGlobals = options.ignoreGlobals;
      const allow = options.allow || [];
      let globalScope;
      if (properties !== "always" && properties !== "never") {
        properties = "always";
      }
      const reported = [];
      const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
      function isUnderscored(name) {
        return name.includes("_") && name !== name.toUpperCase();
      }
      function isAllowed(name) {
        return allow.some((entry) => name === entry || name.match(new RegExp(entry, "u")));
      }
      function isInsideObjectPattern(node) {
        let current = node;
        while (current) {
          const parent = current.parent;
          if (parent && parent.type === "Property" && parent.computed && parent.key === current) {
            return false;
          }
          if (current.type === "ObjectPattern") {
            return true;
          }
          current = parent;
        }
        return false;
      }
      function isAssignmentTargetPropertyInDestructuring(node) {
        if (node.parent.type === "MemberExpression" && node.parent.property === node && !node.parent.computed) {
          const effectiveParent = node.parent.parent;
          return effectiveParent.type === "Property" && effectiveParent.value === node.parent && effectiveParent.parent.type === "ObjectPattern" || effectiveParent.type === "ArrayPattern" || effectiveParent.type === "RestElement" || effectiveParent.type === "AssignmentPattern" && effectiveParent.left === node.parent;
        }
        return false;
      }
      function isReferenceToGlobalVariable(node) {
        const variable = globalScope.set.get(node.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
      }
      function isPropertyNameInObjectLiteral(node) {
        const parent = node.parent;
        return parent.type === "Property" && parent.parent.type === "ObjectExpression" && !parent.computed && parent.key === node;
      }
      function report(node) {
        if (!reported.includes(node)) {
          reported.push(node);
          context4.report({node, messageId: "notCamelCase", data: {name: node.name}});
        }
      }
      return {
        Program() {
          globalScope = context4.getScope();
        },
        Identifier(node) {
          const name = node.name, nameIsUnderscored = isUnderscored(name.replace(/^_+|_+$/gu, "")), effectiveParent = node.parent.type === "MemberExpression" ? node.parent.parent : node.parent;
          if (isAllowed(name)) {
            return;
          }
          if (ignoreGlobals && isReferenceToGlobalVariable(node) && !isPropertyNameInObjectLiteral(node)) {
            return;
          }
          if (node.parent.type === "MemberExpression") {
            if (properties === "never") {
              return;
            }
            if (node.parent.object.type === "Identifier" && node.parent.object.name === node.name && nameIsUnderscored) {
              report(node);
            } else if (effectiveParent.type === "AssignmentExpression" && nameIsUnderscored && (effectiveParent.right.type !== "MemberExpression" || effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name)) {
              report(node);
            } else if (isAssignmentTargetPropertyInDestructuring(node) && nameIsUnderscored) {
              report(node);
            }
          } else if (node.parent.type === "Property" || node.parent.type === "AssignmentPattern") {
            if (node.parent.parent && node.parent.parent.type === "ObjectPattern") {
              if (node.parent.shorthand && node.parent.value.left && nameIsUnderscored) {
                report(node);
              }
              const assignmentKeyEqualsValue = node.parent.key.name === node.parent.value.name;
              if (nameIsUnderscored && node.parent.computed) {
                report(node);
              }
              if (node.parent.key === node && node.parent.value !== node) {
                return;
              }
              const valueIsUnderscored = node.parent.value.name && nameIsUnderscored;
              if (valueIsUnderscored && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
                report(node);
              }
            }
            if (properties === "never" || ignoreDestructuring && isInsideObjectPattern(node)) {
              return;
            }
            if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && !(node.parent.right === node)) {
              report(node);
            }
          } else if (["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"].includes(node.parent.type)) {
            if (node.parent.type === "ImportSpecifier" && ignoreImports) {
              return;
            }
            if (node.parent.local && node.parent.local.name === node.name && nameIsUnderscored) {
              report(node);
            }
          } else if (nameIsUnderscored && !ALLOWED_PARENT_TYPES.has(effectiveParent.type)) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/utils/patterns/letters.js
var require_letters = __commonJS((exports2, module2) => {
  /**
   * @fileoverview Pattern for detecting any letter (even letters outside of ASCII).
   * NOTE: This file was generated using this script in JSCS based on the Unicode 7.0.0 standard: https://github.com/jscs-dev/node-jscs/blob/f5ed14427deb7e7aac84f3056a5aab2d9f3e563e/publish/helpers/generate-patterns.js
   * Do not edit this file by hand-- please use https://github.com/mathiasbynens/regenerate to regenerate the regular expression exported from this file.
   * @author Kevin Partington
   * @license MIT License (from JSCS). See below.
   */
  "use strict";
  module2.exports = /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B2\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA7AD\uA7B0\uA7B1\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB5F\uAB64\uAB65\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDE00-\uDE11\uDE13-\uDE2B\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDE00-\uDE2F\uDE44\uDE80-\uDEAA]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF98]|[\uD80C\uD840-\uD868\uD86A-\uD86C][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D]|\uD87E[\uDC00-\uDE1D]/u;
});

// node_modules/eslint/lib/rules/capitalized-comments.js
var require_capitalized_comments = __commonJS((exports2, module2) => {
  "use strict";
  var LETTER_PATTERN = require_letters();
  var astUtils = require_ast_utils2();
  var DEFAULT_IGNORE_PATTERN = astUtils.COMMENTS_IGNORE_PATTERN;
  var WHITESPACE = /\s/gu;
  var MAYBE_URL = /^\s*[^:/?#\s]+:\/\/[^?#]/u;
  var SCHEMA_BODY = {
    type: "object",
    properties: {
      ignorePattern: {
        type: "string"
      },
      ignoreInlineComments: {
        type: "boolean"
      },
      ignoreConsecutiveComments: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  var DEFAULTS = {
    ignorePattern: "",
    ignoreInlineComments: false,
    ignoreConsecutiveComments: false
  };
  function getNormalizedOptions(rawOptions, which) {
    return Object.assign({}, DEFAULTS, rawOptions[which] || rawOptions);
  }
  function getAllNormalizedOptions(rawOptions = {}) {
    return {
      Line: getNormalizedOptions(rawOptions, "line"),
      Block: getNormalizedOptions(rawOptions, "block")
    };
  }
  function createRegExpForIgnorePatterns(normalizedOptions) {
    Object.keys(normalizedOptions).forEach((key) => {
      const ignorePatternStr = normalizedOptions[key].ignorePattern;
      if (ignorePatternStr) {
        const regExp = RegExp(`^\\s*(?:${ignorePatternStr})`, "u");
        normalizedOptions[key].ignorePatternRegExp = regExp;
      }
    });
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce or disallow capitalization of the first letter of a comment",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/capitalized-comments"
      },
      fixable: "code",
      schema: [
        {enum: ["always", "never"]},
        {
          oneOf: [
            SCHEMA_BODY,
            {
              type: "object",
              properties: {
                line: SCHEMA_BODY,
                block: SCHEMA_BODY
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedLowercaseComment: "Comments should not begin with a lowercase character.",
        unexpectedUppercaseComment: "Comments should not begin with an uppercase character."
      }
    },
    create(context4) {
      const capitalize = context4.options[0] || "always", normalizedOptions = getAllNormalizedOptions(context4.options[1]), sourceCode = context4.getSourceCode();
      createRegExpForIgnorePatterns(normalizedOptions);
      function isInlineComment(comment) {
        const previousToken = sourceCode.getTokenBefore(comment, {includeComments: true}), nextToken = sourceCode.getTokenAfter(comment, {includeComments: true});
        return Boolean(previousToken && nextToken && comment.loc.start.line === previousToken.loc.end.line && comment.loc.end.line === nextToken.loc.start.line);
      }
      function isConsecutiveComment(comment) {
        const previousTokenOrComment = sourceCode.getTokenBefore(comment, {includeComments: true});
        return Boolean(previousTokenOrComment && ["Block", "Line"].indexOf(previousTokenOrComment.type) !== -1);
      }
      function isCommentValid(comment, options) {
        if (DEFAULT_IGNORE_PATTERN.test(comment.value)) {
          return true;
        }
        const commentWithoutAsterisks = comment.value.replace(/\*/gu, "");
        if (options.ignorePatternRegExp && options.ignorePatternRegExp.test(commentWithoutAsterisks)) {
          return true;
        }
        if (options.ignoreInlineComments && isInlineComment(comment)) {
          return true;
        }
        if (options.ignoreConsecutiveComments && isConsecutiveComment(comment)) {
          return true;
        }
        if (MAYBE_URL.test(commentWithoutAsterisks)) {
          return true;
        }
        const commentWordCharsOnly = commentWithoutAsterisks.replace(WHITESPACE, "");
        if (commentWordCharsOnly.length === 0) {
          return true;
        }
        const firstWordChar = commentWordCharsOnly[0];
        if (!LETTER_PATTERN.test(firstWordChar)) {
          return true;
        }
        const isUppercase = firstWordChar !== firstWordChar.toLocaleLowerCase(), isLowercase = firstWordChar !== firstWordChar.toLocaleUpperCase();
        if (capitalize === "always" && isLowercase) {
          return false;
        }
        if (capitalize === "never" && isUppercase) {
          return false;
        }
        return true;
      }
      function processComment(comment) {
        const options = normalizedOptions[comment.type], commentValid = isCommentValid(comment, options);
        if (!commentValid) {
          const messageId = capitalize === "always" ? "unexpectedLowercaseComment" : "unexpectedUppercaseComment";
          context4.report({
            node: null,
            loc: comment.loc,
            messageId,
            fix(fixer) {
              const match = comment.value.match(LETTER_PATTERN);
              return fixer.replaceTextRange([comment.range[0] + match.index + 2, comment.range[0] + match.index + 3], capitalize === "always" ? match[0].toLocaleUpperCase() : match[0].toLocaleLowerCase());
            }
          });
        }
      }
      return {
        Program() {
          const comments = sourceCode.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(processComment);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/class-methods-use-this.js
var require_class_methods_use_this = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce that class methods utilize `this`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/class-methods-use-this"
      },
      schema: [{
        type: "object",
        properties: {
          exceptMethods: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        additionalProperties: false
      }],
      messages: {
        missingThis: "Expected 'this' to be used by class {{name}}."
      }
    },
    create(context4) {
      const config = Object.assign({}, context4.options[0]);
      const exceptMethods = new Set(config.exceptMethods || []);
      const stack = [];
      function enterFunction() {
        stack.push(false);
      }
      function isInstanceMethod(node) {
        return !node.static && node.kind !== "constructor" && node.type === "MethodDefinition";
      }
      function isIncludedInstanceMethod(node) {
        return isInstanceMethod(node) && (node.computed || !exceptMethods.has(node.key.name));
      }
      function exitFunction(node) {
        const methodUsesThis = stack.pop();
        if (isIncludedInstanceMethod(node.parent) && !methodUsesThis) {
          context4.report({
            node,
            messageId: "missingThis",
            data: {
              name: astUtils.getFunctionNameWithKind(node)
            }
          });
        }
      }
      function markThisUsed() {
        if (stack.length) {
          stack[stack.length - 1] = true;
        }
      }
      return {
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        ThisExpression: markThisUsed,
        Super: markThisUsed
      };
    }
  };
});

// node_modules/eslint/lib/rules/comma-dangle.js
var require_comma_dangle = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  var DEFAULT_OPTIONS = Object.freeze({
    arrays: "never",
    objects: "never",
    imports: "never",
    exports: "never",
    functions: "never"
  });
  function isTrailingCommaAllowed(lastItem) {
    return !(lastItem.type === "RestElement" || lastItem.type === "RestProperty" || lastItem.type === "ExperimentalRestProperty");
  }
  function normalizeOptions(optionValue, ecmaVersion) {
    if (typeof optionValue === "string") {
      return {
        arrays: optionValue,
        objects: optionValue,
        imports: optionValue,
        exports: optionValue,
        functions: !ecmaVersion || ecmaVersion < 8 ? "ignore" : optionValue
      };
    }
    if (typeof optionValue === "object" && optionValue !== null) {
      return {
        arrays: optionValue.arrays || DEFAULT_OPTIONS.arrays,
        objects: optionValue.objects || DEFAULT_OPTIONS.objects,
        imports: optionValue.imports || DEFAULT_OPTIONS.imports,
        exports: optionValue.exports || DEFAULT_OPTIONS.exports,
        functions: optionValue.functions || DEFAULT_OPTIONS.functions
      };
    }
    return DEFAULT_OPTIONS;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow trailing commas",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/comma-dangle"
      },
      fixable: "code",
      schema: {
        definitions: {
          value: {
            enum: [
              "always-multiline",
              "always",
              "never",
              "only-multiline"
            ]
          },
          valueWithIgnore: {
            enum: [
              "always-multiline",
              "always",
              "ignore",
              "never",
              "only-multiline"
            ]
          }
        },
        type: "array",
        items: [
          {
            oneOf: [
              {
                $ref: "#/definitions/value"
              },
              {
                type: "object",
                properties: {
                  arrays: {$ref: "#/definitions/valueWithIgnore"},
                  objects: {$ref: "#/definitions/valueWithIgnore"},
                  imports: {$ref: "#/definitions/valueWithIgnore"},
                  exports: {$ref: "#/definitions/valueWithIgnore"},
                  functions: {$ref: "#/definitions/valueWithIgnore"}
                },
                additionalProperties: false
              }
            ]
          }
        ]
      },
      messages: {
        unexpected: "Unexpected trailing comma.",
        missing: "Missing trailing comma."
      }
    },
    create(context4) {
      const options = normalizeOptions(context4.options[0], context4.parserOptions.ecmaVersion);
      const sourceCode = context4.getSourceCode();
      function getLastItem(node) {
        switch (node.type) {
          case "ObjectExpression":
          case "ObjectPattern":
            return lodash.last(node.properties);
          case "ArrayExpression":
          case "ArrayPattern":
            return lodash.last(node.elements);
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
            return lodash.last(node.specifiers);
          case "FunctionDeclaration":
          case "FunctionExpression":
          case "ArrowFunctionExpression":
            return lodash.last(node.params);
          case "CallExpression":
          case "NewExpression":
            return lodash.last(node.arguments);
          default:
            return null;
        }
      }
      function getTrailingToken(node, lastItem) {
        switch (node.type) {
          case "ObjectExpression":
          case "ArrayExpression":
          case "CallExpression":
          case "NewExpression":
            return sourceCode.getLastToken(node, 1);
          default: {
            const nextToken = sourceCode.getTokenAfter(lastItem);
            if (astUtils.isCommaToken(nextToken)) {
              return nextToken;
            }
            return sourceCode.getLastToken(lastItem);
          }
        }
      }
      function isMultiline(node) {
        const lastItem = getLastItem(node);
        if (!lastItem) {
          return false;
        }
        const penultimateToken = getTrailingToken(node, lastItem);
        const lastToken = sourceCode.getTokenAfter(penultimateToken);
        return lastToken.loc.end.line !== penultimateToken.loc.end.line;
      }
      function forbidTrailingComma(node) {
        const lastItem = getLastItem(node);
        if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
          return;
        }
        const trailingToken = getTrailingToken(node, lastItem);
        if (astUtils.isCommaToken(trailingToken)) {
          context4.report({
            node: lastItem,
            loc: trailingToken.loc,
            messageId: "unexpected",
            fix(fixer) {
              return fixer.remove(trailingToken);
            }
          });
        }
      }
      function forceTrailingComma(node) {
        const lastItem = getLastItem(node);
        if (!lastItem || node.type === "ImportDeclaration" && lastItem.type !== "ImportSpecifier") {
          return;
        }
        if (!isTrailingCommaAllowed(lastItem)) {
          forbidTrailingComma(node);
          return;
        }
        const trailingToken = getTrailingToken(node, lastItem);
        if (trailingToken.value !== ",") {
          context4.report({
            node: lastItem,
            loc: {
              start: trailingToken.loc.end,
              end: astUtils.getNextLocation(sourceCode, trailingToken.loc.end)
            },
            messageId: "missing",
            fix(fixer) {
              return fixer.insertTextAfter(trailingToken, ",");
            }
          });
        }
      }
      function forceTrailingCommaIfMultiline(node) {
        if (isMultiline(node)) {
          forceTrailingComma(node);
        } else {
          forbidTrailingComma(node);
        }
      }
      function allowTrailingCommaIfMultiline(node) {
        if (!isMultiline(node)) {
          forbidTrailingComma(node);
        }
      }
      const predicate = {
        always: forceTrailingComma,
        "always-multiline": forceTrailingCommaIfMultiline,
        "only-multiline": allowTrailingCommaIfMultiline,
        never: forbidTrailingComma,
        ignore: lodash.noop
      };
      return {
        ObjectExpression: predicate[options.objects],
        ObjectPattern: predicate[options.objects],
        ArrayExpression: predicate[options.arrays],
        ArrayPattern: predicate[options.arrays],
        ImportDeclaration: predicate[options.imports],
        ExportNamedDeclaration: predicate[options.exports],
        FunctionDeclaration: predicate[options.functions],
        FunctionExpression: predicate[options.functions],
        ArrowFunctionExpression: predicate[options.functions],
        CallExpression: predicate[options.functions],
        NewExpression: predicate[options.functions]
      };
    }
  };
});

// node_modules/eslint/lib/rules/comma-spacing.js
var require_comma_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before and after commas",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/comma-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: false
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missing: "A space is required {{loc}} ','.",
        unexpected: "There should be no space {{loc}} ','."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const tokensAndComments = sourceCode.tokensAndComments;
      const options = {
        before: context4.options[0] ? context4.options[0].before : false,
        after: context4.options[0] ? context4.options[0].after : true
      };
      const commaTokensToIgnore = [];
      function report(node, loc, otherNode) {
        context4.report({
          node,
          fix(fixer) {
            if (options[loc]) {
              if (loc === "before") {
                return fixer.insertTextBefore(node, " ");
              }
              return fixer.insertTextAfter(node, " ");
            }
            let start, end;
            const newText = "";
            if (loc === "before") {
              start = otherNode.range[1];
              end = node.range[0];
            } else {
              start = node.range[1];
              end = otherNode.range[0];
            }
            return fixer.replaceTextRange([start, end], newText);
          },
          messageId: options[loc] ? "missing" : "unexpected",
          data: {
            loc
          }
        });
      }
      function validateCommaItemSpacing(tokens, reportItem) {
        if (tokens.left && astUtils.isTokenOnSameLine(tokens.left, tokens.comma) && options.before !== sourceCode.isSpaceBetweenTokens(tokens.left, tokens.comma)) {
          report(reportItem, "before", tokens.left);
        }
        if (tokens.right && astUtils.isClosingParenToken(tokens.right)) {
          return;
        }
        if (tokens.right && !options.after && tokens.right.type === "Line") {
          return;
        }
        if (tokens.right && astUtils.isTokenOnSameLine(tokens.comma, tokens.right) && options.after !== sourceCode.isSpaceBetweenTokens(tokens.comma, tokens.right)) {
          report(reportItem, "after", tokens.right);
        }
      }
      function addNullElementsToIgnoreList(node) {
        let previousToken = sourceCode.getFirstToken(node);
        node.elements.forEach((element) => {
          let token;
          if (element === null) {
            token = sourceCode.getTokenAfter(previousToken);
            if (astUtils.isCommaToken(token)) {
              commaTokensToIgnore.push(token);
            }
          } else {
            token = sourceCode.getTokenAfter(element);
          }
          previousToken = token;
        });
      }
      return {
        "Program:exit"() {
          tokensAndComments.forEach((token, i) => {
            if (!astUtils.isCommaToken(token)) {
              return;
            }
            if (token && token.type === "JSXText") {
              return;
            }
            const previousToken = tokensAndComments[i - 1];
            const nextToken = tokensAndComments[i + 1];
            validateCommaItemSpacing({
              comma: token,
              left: astUtils.isCommaToken(previousToken) || commaTokensToIgnore.indexOf(token) > -1 ? null : previousToken,
              right: astUtils.isCommaToken(nextToken) ? null : nextToken
            }, token);
          });
        },
        ArrayExpression: addNullElementsToIgnoreList,
        ArrayPattern: addNullElementsToIgnoreList
      };
    }
  };
});

// node_modules/eslint/lib/rules/comma-style.js
var require_comma_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent comma style",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/comma-style"
      },
      fixable: "code",
      schema: [
        {
          enum: ["first", "last"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedLineBeforeAndAfterComma: "Bad line breaking before and after ','.",
        expectedCommaFirst: "',' should be placed first.",
        expectedCommaLast: "',' should be placed last."
      }
    },
    create(context4) {
      const style = context4.options[0] || "last", sourceCode = context4.getSourceCode();
      const exceptions = {
        ArrayPattern: true,
        ArrowFunctionExpression: true,
        CallExpression: true,
        FunctionDeclaration: true,
        FunctionExpression: true,
        ImportDeclaration: true,
        ObjectPattern: true,
        NewExpression: true
      };
      if (context4.options.length === 2 && Object.prototype.hasOwnProperty.call(context4.options[1], "exceptions")) {
        const keys = Object.keys(context4.options[1].exceptions);
        for (let i = 0; i < keys.length; i++) {
          exceptions[keys[i]] = context4.options[1].exceptions[keys[i]];
        }
      }
      function getReplacedText(styleType, text) {
        switch (styleType) {
          case "between":
            return `,${text.replace(astUtils.LINEBREAK_MATCHER, "")}`;
          case "first":
            return `${text},`;
          case "last":
            return `,${text}`;
          default:
            return "";
        }
      }
      function getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken) {
        const text = sourceCode.text.slice(previousItemToken.range[1], commaToken.range[0]) + sourceCode.text.slice(commaToken.range[1], currentItemToken.range[0]);
        const range = [previousItemToken.range[1], currentItemToken.range[0]];
        return function(fixer) {
          return fixer.replaceTextRange(range, getReplacedText(styleType, text));
        };
      }
      function validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem) {
        if (astUtils.isTokenOnSameLine(commaToken, currentItemToken) && astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
        } else if (!astUtils.isTokenOnSameLine(commaToken, currentItemToken) && !astUtils.isTokenOnSameLine(previousItemToken, commaToken)) {
          const comment = sourceCode.getCommentsAfter(commaToken)[0];
          const styleType = comment && comment.type === "Block" && astUtils.isTokenOnSameLine(commaToken, comment) ? style : "between";
          context4.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "unexpectedLineBeforeAndAfterComma",
            fix: getFixerFunction(styleType, previousItemToken, commaToken, currentItemToken)
          });
        } else if (style === "first" && !astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
          context4.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "expectedCommaFirst",
            fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
          });
        } else if (style === "last" && astUtils.isTokenOnSameLine(commaToken, currentItemToken)) {
          context4.report({
            node: reportItem,
            loc: commaToken.loc,
            messageId: "expectedCommaLast",
            fix: getFixerFunction(style, previousItemToken, commaToken, currentItemToken)
          });
        }
      }
      function validateComma(node, property) {
        const items = node[property], arrayLiteral = node.type === "ArrayExpression" || node.type === "ArrayPattern";
        if (items.length > 1 || arrayLiteral) {
          let previousItemToken = sourceCode.getFirstToken(node);
          items.forEach((item) => {
            const commaToken = item ? sourceCode.getTokenBefore(item) : previousItemToken, currentItemToken = item ? sourceCode.getFirstToken(item) : sourceCode.getTokenAfter(commaToken), reportItem = item || currentItemToken;
            if (astUtils.isCommaToken(commaToken)) {
              validateCommaItemSpacing(previousItemToken, commaToken, currentItemToken, reportItem);
            }
            if (item) {
              const tokenAfterItem = sourceCode.getTokenAfter(item, astUtils.isNotClosingParenToken);
              previousItemToken = tokenAfterItem ? sourceCode.getTokenBefore(tokenAfterItem) : sourceCode.ast.tokens[sourceCode.ast.tokens.length - 1];
            }
          });
          if (arrayLiteral) {
            const lastToken = sourceCode.getLastToken(node), nextToLastToken = sourceCode.getTokenBefore(lastToken);
            if (astUtils.isCommaToken(nextToLastToken)) {
              validateCommaItemSpacing(sourceCode.getTokenBefore(nextToLastToken), nextToLastToken, lastToken, lastToken);
            }
          }
        }
      }
      const nodes = {};
      if (!exceptions.VariableDeclaration) {
        nodes.VariableDeclaration = function(node) {
          validateComma(node, "declarations");
        };
      }
      if (!exceptions.ObjectExpression) {
        nodes.ObjectExpression = function(node) {
          validateComma(node, "properties");
        };
      }
      if (!exceptions.ObjectPattern) {
        nodes.ObjectPattern = function(node) {
          validateComma(node, "properties");
        };
      }
      if (!exceptions.ArrayExpression) {
        nodes.ArrayExpression = function(node) {
          validateComma(node, "elements");
        };
      }
      if (!exceptions.ArrayPattern) {
        nodes.ArrayPattern = function(node) {
          validateComma(node, "elements");
        };
      }
      if (!exceptions.FunctionDeclaration) {
        nodes.FunctionDeclaration = function(node) {
          validateComma(node, "params");
        };
      }
      if (!exceptions.FunctionExpression) {
        nodes.FunctionExpression = function(node) {
          validateComma(node, "params");
        };
      }
      if (!exceptions.ArrowFunctionExpression) {
        nodes.ArrowFunctionExpression = function(node) {
          validateComma(node, "params");
        };
      }
      if (!exceptions.CallExpression) {
        nodes.CallExpression = function(node) {
          validateComma(node, "arguments");
        };
      }
      if (!exceptions.ImportDeclaration) {
        nodes.ImportDeclaration = function(node) {
          validateComma(node, "specifiers");
        };
      }
      if (!exceptions.NewExpression) {
        nodes.NewExpression = function(node) {
          validateComma(node, "arguments");
        };
      }
      return nodes;
    }
  };
});

// node_modules/eslint/lib/rules/complexity.js
var require_complexity = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum cyclomatic complexity allowed in a program",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/complexity"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        complex: "{{name}} has a complexity of {{complexity}}. Maximum allowed is {{max}}."
      }
    },
    create(context4) {
      const option = context4.options[0];
      let THRESHOLD = 20;
      if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
        THRESHOLD = option.maximum || option.max;
      } else if (typeof option === "number") {
        THRESHOLD = option;
      }
      const fns = [];
      function startFunction() {
        fns.push(1);
      }
      function endFunction(node) {
        const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
        const complexity = fns.pop();
        if (complexity > THRESHOLD) {
          context4.report({
            node,
            messageId: "complex",
            data: {name, complexity, max: THRESHOLD}
          });
        }
      }
      function increaseComplexity() {
        if (fns.length) {
          fns[fns.length - 1]++;
        }
      }
      function increaseSwitchComplexity(node) {
        if (node.test) {
          increaseComplexity();
        }
      }
      return {
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        CatchClause: increaseComplexity,
        ConditionalExpression: increaseComplexity,
        LogicalExpression: increaseComplexity,
        ForStatement: increaseComplexity,
        ForInStatement: increaseComplexity,
        ForOfStatement: increaseComplexity,
        IfStatement: increaseComplexity,
        SwitchCase: increaseSwitchComplexity,
        WhileStatement: increaseComplexity,
        DoWhileStatement: increaseComplexity,
        AssignmentExpression(node) {
          if (astUtils.isLogicalAssignmentOperator(node.operator)) {
            increaseComplexity();
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/computed-property-spacing.js
var require_computed_property_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing inside computed property brackets",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/computed-property-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            enforceForClassMembers: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceBefore: "There should be no space before '{{tokenValue}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{tokenValue}}'.",
        missingSpaceBefore: "A space is required before '{{tokenValue}}'.",
        missingSpaceAfter: "A space is required after '{{tokenValue}}'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const propertyNameMustBeSpaced = context4.options[0] === "always";
      const enforceForClassMembers = !context4.options[1] || context4.options[1].enforceForClassMembers;
      function reportNoBeginningSpace(node, token, tokenAfter) {
        context4.report({
          node,
          loc: {start: token.loc.end, end: tokenAfter.loc.start},
          messageId: "unexpectedSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
          }
        });
      }
      function reportNoEndingSpace(node, token, tokenBefore) {
        context4.report({
          node,
          loc: {start: tokenBefore.loc.end, end: token.loc.start},
          messageId: "unexpectedSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
          }
        });
      }
      function reportRequiredBeginningSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingSpaceAfter",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "missingSpaceBefore",
          data: {
            tokenValue: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function checkSpacing(propertyName) {
        return function(node) {
          if (!node.computed) {
            return;
          }
          const property = node[propertyName];
          const before = sourceCode.getTokenBefore(property, astUtils.isOpeningBracketToken), first = sourceCode.getTokenAfter(before, {includeComments: true}), after = sourceCode.getTokenAfter(property, astUtils.isClosingBracketToken), last = sourceCode.getTokenBefore(after, {includeComments: true});
          if (astUtils.isTokenOnSameLine(before, first)) {
            if (propertyNameMustBeSpaced) {
              if (!sourceCode.isSpaceBetweenTokens(before, first) && astUtils.isTokenOnSameLine(before, first)) {
                reportRequiredBeginningSpace(node, before);
              }
            } else {
              if (sourceCode.isSpaceBetweenTokens(before, first)) {
                reportNoBeginningSpace(node, before, first);
              }
            }
          }
          if (astUtils.isTokenOnSameLine(last, after)) {
            if (propertyNameMustBeSpaced) {
              if (!sourceCode.isSpaceBetweenTokens(last, after) && astUtils.isTokenOnSameLine(last, after)) {
                reportRequiredEndingSpace(node, after);
              }
            } else {
              if (sourceCode.isSpaceBetweenTokens(last, after)) {
                reportNoEndingSpace(node, after, last);
              }
            }
          }
        };
      }
      const listeners = {
        Property: checkSpacing("key"),
        MemberExpression: checkSpacing("property")
      };
      if (enforceForClassMembers) {
        listeners.MethodDefinition = checkSpacing("key");
      }
      return listeners;
    }
  };
});

// node_modules/eslint/lib/rules/consistent-return.js
var require_consistent_return = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  function isUnreachable(segment) {
    return !segment.reachable;
  }
  function isClassConstructor(node) {
    return node.type === "FunctionExpression" && node.parent && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `return` statements to either always or never specify values",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/consistent-return"
      },
      schema: [{
        type: "object",
        properties: {
          treatUndefinedAsUnspecified: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      messages: {
        missingReturn: "Expected to return a value at the end of {{name}}.",
        missingReturnValue: "{{name}} expected a return value.",
        unexpectedReturnValue: "{{name}} expected no return value."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const treatUndefinedAsUnspecified = options.treatUndefinedAsUnspecified === true;
      let funcInfo = null;
      function checkLastSegment(node) {
        let loc, name;
        if (!funcInfo.hasReturnValue || funcInfo.codePath.currentSegments.every(isUnreachable) || astUtils.isES5Constructor(node) || isClassConstructor(node)) {
          return;
        }
        if (node.type === "Program") {
          loc = {line: 1, column: 0};
          name = "program";
        } else if (node.type === "ArrowFunctionExpression") {
          loc = context4.getSourceCode().getTokenBefore(node.body, astUtils.isArrowToken).loc.start;
        } else if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
          loc = node.parent.key.loc.start;
        } else {
          loc = (node.id || node).loc.start;
        }
        if (!name) {
          name = astUtils.getFunctionNameWithKind(node);
        }
        context4.report({
          node,
          loc,
          messageId: "missingReturn",
          data: {name}
        });
      }
      return {
        onCodePathStart(codePath, node) {
          funcInfo = {
            upper: funcInfo,
            codePath,
            hasReturn: false,
            hasReturnValue: false,
            messageId: "",
            node
          };
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        ReturnStatement(node) {
          const argument = node.argument;
          let hasReturnValue = Boolean(argument);
          if (treatUndefinedAsUnspecified && hasReturnValue) {
            hasReturnValue = !astUtils.isSpecificId(argument, "undefined") && argument.operator !== "void";
          }
          if (!funcInfo.hasReturn) {
            funcInfo.hasReturn = true;
            funcInfo.hasReturnValue = hasReturnValue;
            funcInfo.messageId = hasReturnValue ? "missingReturnValue" : "unexpectedReturnValue";
            funcInfo.data = {
              name: funcInfo.node.type === "Program" ? "Program" : lodash.upperFirst(astUtils.getFunctionNameWithKind(funcInfo.node))
            };
          } else if (funcInfo.hasReturnValue !== hasReturnValue) {
            context4.report({
              node,
              messageId: funcInfo.messageId,
              data: funcInfo.data
            });
          }
        },
        "Program:exit": checkLastSegment,
        "FunctionDeclaration:exit": checkLastSegment,
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
});

// node_modules/eslint/lib/rules/consistent-this.js
var require_consistent_this = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce consistent naming when capturing the current execution context",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/consistent-this"
      },
      schema: {
        type: "array",
        items: {
          type: "string",
          minLength: 1
        },
        uniqueItems: true
      },
      messages: {
        aliasNotAssignedToThis: "Designated alias '{{name}}' is not assigned to 'this'.",
        unexpectedAlias: "Unexpected alias '{{name}}' for 'this'."
      }
    },
    create(context4) {
      let aliases = [];
      if (context4.options.length === 0) {
        aliases.push("that");
      } else {
        aliases = context4.options;
      }
      function reportBadAssignment(node, name) {
        context4.report({node, messageId: "aliasNotAssignedToThis", data: {name}});
      }
      function checkAssignment(node, name, value) {
        const isThis = value.type === "ThisExpression";
        if (aliases.indexOf(name) !== -1) {
          if (!isThis || node.operator && node.operator !== "=") {
            reportBadAssignment(node, name);
          }
        } else if (isThis) {
          context4.report({node, messageId: "unexpectedAlias", data: {name}});
        }
      }
      function checkWasAssigned(alias, scope) {
        const variable = scope.set.get(alias);
        if (!variable) {
          return;
        }
        if (variable.defs.some((def) => def.node.type === "VariableDeclarator" && def.node.init !== null)) {
          return;
        }
        if (!variable.references.some((reference) => {
          const write = reference.writeExpr;
          return reference.from === scope && write && write.type === "ThisExpression" && write.parent.operator === "=";
        })) {
          variable.defs.map((def) => def.node).forEach((node) => {
            reportBadAssignment(node, alias);
          });
        }
      }
      function ensureWasAssigned() {
        const scope = context4.getScope();
        aliases.forEach((alias) => {
          checkWasAssigned(alias, scope);
        });
      }
      return {
        "Program:exit": ensureWasAssigned,
        "FunctionExpression:exit": ensureWasAssigned,
        "FunctionDeclaration:exit": ensureWasAssigned,
        VariableDeclarator(node) {
          const id = node.id;
          const isDestructuring = id.type === "ArrayPattern" || id.type === "ObjectPattern";
          if (node.init !== null && !isDestructuring) {
            checkAssignment(node, id.name, node.init);
          }
        },
        AssignmentExpression(node) {
          if (node.left.type === "Identifier") {
            checkAssignment(node, node.left.name, node.right);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/constructor-super.js
var require_constructor_super = __commonJS((exports2, module2) => {
  "use strict";
  function isReachable(segment) {
    return segment.reachable;
  }
  function isConstructorFunction(node) {
    return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
  }
  function isPossibleConstructor(node) {
    if (!node) {
      return false;
    }
    switch (node.type) {
      case "ClassExpression":
      case "FunctionExpression":
      case "ThisExpression":
      case "MemberExpression":
      case "CallExpression":
      case "NewExpression":
      case "ChainExpression":
      case "YieldExpression":
      case "TaggedTemplateExpression":
      case "MetaProperty":
        return true;
      case "Identifier":
        return node.name !== "undefined";
      case "AssignmentExpression":
        if (["=", "&&="].includes(node.operator)) {
          return isPossibleConstructor(node.right);
        }
        if (["||=", "??="].includes(node.operator)) {
          return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
        }
        return false;
      case "LogicalExpression":
        if (node.operator === "&&") {
          return isPossibleConstructor(node.right);
        }
        return isPossibleConstructor(node.left) || isPossibleConstructor(node.right);
      case "ConditionalExpression":
        return isPossibleConstructor(node.alternate) || isPossibleConstructor(node.consequent);
      case "SequenceExpression": {
        const lastExpression = node.expressions[node.expressions.length - 1];
        return isPossibleConstructor(lastExpression);
      }
      default:
        return false;
    }
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "require `super()` calls in constructors",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/constructor-super"
      },
      schema: [],
      messages: {
        missingSome: "Lacked a call of 'super()' in some code paths.",
        missingAll: "Expected to call 'super()'.",
        duplicate: "Unexpected duplicate 'super()'.",
        badSuper: "Unexpected 'super()' because 'super' is not a constructor.",
        unexpected: "Unexpected 'super()'."
      }
    },
    create(context4) {
      let funcInfo = null;
      let segInfoMap = Object.create(null);
      function isCalledInSomePath(segment) {
        return segment.reachable && segInfoMap[segment.id].calledInSomePaths;
      }
      function isCalledInEveryPath(segment) {
        if (segment.nextSegments.length === 1 && segment.nextSegments[0].isLoopedPrevSegment(segment)) {
          return true;
        }
        return segment.reachable && segInfoMap[segment.id].calledInEveryPaths;
      }
      return {
        onCodePathStart(codePath, node) {
          if (isConstructorFunction(node)) {
            const classNode = node.parent.parent.parent;
            const superClass = classNode.superClass;
            funcInfo = {
              upper: funcInfo,
              isConstructor: true,
              hasExtends: Boolean(superClass),
              superIsConstructor: isPossibleConstructor(superClass),
              codePath
            };
          } else {
            funcInfo = {
              upper: funcInfo,
              isConstructor: false,
              hasExtends: false,
              superIsConstructor: false,
              codePath
            };
          }
        },
        onCodePathEnd(codePath, node) {
          const hasExtends = funcInfo.hasExtends;
          funcInfo = funcInfo.upper;
          if (!hasExtends) {
            return;
          }
          const segments = codePath.returnedSegments;
          const calledInEveryPaths = segments.every(isCalledInEveryPath);
          const calledInSomePaths = segments.some(isCalledInSomePath);
          if (!calledInEveryPaths) {
            context4.report({
              messageId: calledInSomePaths ? "missingSome" : "missingAll",
              node: node.parent
            });
          }
        },
        onCodePathSegmentStart(segment) {
          if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          const info3 = segInfoMap[segment.id] = {
            calledInSomePaths: false,
            calledInEveryPaths: false,
            validNodes: []
          };
          const prevSegments = segment.prevSegments;
          if (prevSegments.length > 0) {
            info3.calledInSomePaths = prevSegments.some(isCalledInSomePath);
            info3.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
          }
        },
        onCodePathSegmentLoop(fromSegment, toSegment) {
          if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          const isRealLoop = toSegment.prevSegments.length >= 2;
          funcInfo.codePath.traverseSegments({first: toSegment, last: fromSegment}, (segment) => {
            const info3 = segInfoMap[segment.id];
            const prevSegments = segment.prevSegments;
            info3.calledInSomePaths = prevSegments.some(isCalledInSomePath);
            info3.calledInEveryPaths = prevSegments.every(isCalledInEveryPath);
            if (info3.calledInSomePaths || isRealLoop) {
              const nodes = info3.validNodes;
              info3.validNodes = [];
              for (let i = 0; i < nodes.length; ++i) {
                const node = nodes[i];
                context4.report({
                  messageId: "duplicate",
                  node
                });
              }
            }
          });
        },
        "CallExpression:exit"(node) {
          if (!(funcInfo && funcInfo.isConstructor)) {
            return;
          }
          if (node.callee.type !== "Super") {
            return;
          }
          if (funcInfo.hasExtends) {
            const segments = funcInfo.codePath.currentSegments;
            let duplicate = false;
            let info3 = null;
            for (let i = 0; i < segments.length; ++i) {
              const segment = segments[i];
              if (segment.reachable) {
                info3 = segInfoMap[segment.id];
                duplicate = duplicate || info3.calledInSomePaths;
                info3.calledInSomePaths = info3.calledInEveryPaths = true;
              }
            }
            if (info3) {
              if (duplicate) {
                context4.report({
                  messageId: "duplicate",
                  node
                });
              } else if (!funcInfo.superIsConstructor) {
                context4.report({
                  messageId: "badSuper",
                  node
                });
              } else {
                info3.validNodes.push(node);
              }
            }
          } else if (funcInfo.codePath.currentSegments.some(isReachable)) {
            context4.report({
              messageId: "unexpected",
              node
            });
          }
        },
        ReturnStatement(node) {
          if (!(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends)) {
            return;
          }
          if (!node.argument) {
            return;
          }
          const segments = funcInfo.codePath.currentSegments;
          for (let i = 0; i < segments.length; ++i) {
            const segment = segments[i];
            if (segment.reachable) {
              const info3 = segInfoMap[segment.id];
              info3.calledInSomePaths = info3.calledInEveryPaths = true;
            }
          }
        },
        "Program:exit"() {
          segInfoMap = Object.create(null);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/curly.js
var require_curly = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce consistent brace style for all control statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/curly"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["multi", "multi-line", "multi-or-nest"]
              },
              {
                enum: ["consistent"]
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        missingCurlyAfter: "Expected { after '{{name}}'.",
        missingCurlyAfterCondition: "Expected { after '{{name}}' condition.",
        unexpectedCurlyAfter: "Unnecessary { after '{{name}}'.",
        unexpectedCurlyAfterCondition: "Unnecessary { after '{{name}}' condition."
      }
    },
    create(context4) {
      const multiOnly = context4.options[0] === "multi";
      const multiLine = context4.options[0] === "multi-line";
      const multiOrNest = context4.options[0] === "multi-or-nest";
      const consistent = context4.options[1] === "consistent";
      const sourceCode = context4.getSourceCode();
      function isCollapsedOneLiner(node) {
        const before = sourceCode.getTokenBefore(node);
        const last = sourceCode.getLastToken(node);
        const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
        return before.loc.start.line === lastExcludingSemicolon.loc.end.line;
      }
      function isOneLiner(node) {
        if (node.type === "EmptyStatement") {
          return true;
        }
        const first = sourceCode.getFirstToken(node);
        const last = sourceCode.getLastToken(node);
        const lastExcludingSemicolon = astUtils.isSemicolonToken(last) ? sourceCode.getTokenBefore(last) : last;
        return first.loc.start.line === lastExcludingSemicolon.loc.end.line;
      }
      function isLexicalDeclaration(node) {
        if (node.type === "VariableDeclaration") {
          return node.kind === "const" || node.kind === "let";
        }
        return node.type === "FunctionDeclaration" || node.type === "ClassDeclaration";
      }
      function isElseKeywordToken(token) {
        return token.value === "else" && token.type === "Keyword";
      }
      function getElseKeyword(node) {
        return node.alternate && sourceCode.getFirstTokenBetween(node.consequent, node.alternate, isElseKeywordToken);
      }
      function isFollowedByElseKeyword(node) {
        const nextToken = sourceCode.getTokenAfter(node);
        return Boolean(nextToken) && isElseKeywordToken(nextToken);
      }
      function needsSemicolon(closingBracket) {
        const tokenBefore = sourceCode.getTokenBefore(closingBracket);
        const tokenAfter = sourceCode.getTokenAfter(closingBracket);
        const lastBlockNode = sourceCode.getNodeByRangeIndex(tokenBefore.range[0]);
        if (astUtils.isSemicolonToken(tokenBefore)) {
          return false;
        }
        if (!tokenAfter) {
          return false;
        }
        if (lastBlockNode.type === "BlockStatement" && lastBlockNode.parent.type !== "FunctionExpression" && lastBlockNode.parent.type !== "ArrowFunctionExpression") {
          return false;
        }
        if (tokenBefore.loc.end.line === tokenAfter.loc.start.line) {
          return true;
        }
        if (/^[([/`+-]/u.test(tokenAfter.value)) {
          return true;
        }
        if (tokenBefore.type === "Punctuator" && (tokenBefore.value === "++" || tokenBefore.value === "--")) {
          return true;
        }
        return false;
      }
      function hasUnsafeIf(node) {
        switch (node.type) {
          case "IfStatement":
            if (!node.alternate) {
              return true;
            }
            return hasUnsafeIf(node.alternate);
          case "ForStatement":
          case "ForInStatement":
          case "ForOfStatement":
          case "LabeledStatement":
          case "WithStatement":
          case "WhileStatement":
            return hasUnsafeIf(node.body);
          default:
            return false;
        }
      }
      function areBracesNecessary(node) {
        const statement = node.body[0];
        return isLexicalDeclaration(statement) || hasUnsafeIf(statement) && isFollowedByElseKeyword(node);
      }
      function prepareCheck(node, body, name, opts) {
        const hasBlock = body.type === "BlockStatement";
        let expected = null;
        if (hasBlock && (body.body.length !== 1 || areBracesNecessary(body))) {
          expected = true;
        } else if (multiOnly) {
          expected = false;
        } else if (multiLine) {
          if (!isCollapsedOneLiner(body)) {
            expected = true;
          }
        } else if (multiOrNest) {
          if (hasBlock) {
            const statement = body.body[0];
            const leadingCommentsInBlock = sourceCode.getCommentsBefore(statement);
            expected = !isOneLiner(statement) || leadingCommentsInBlock.length > 0;
          } else {
            expected = !isOneLiner(body);
          }
        } else {
          expected = true;
        }
        return {
          actual: hasBlock,
          expected,
          check() {
            if (this.expected !== null && this.expected !== this.actual) {
              if (this.expected) {
                context4.report({
                  node,
                  loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                  messageId: opts && opts.condition ? "missingCurlyAfterCondition" : "missingCurlyAfter",
                  data: {
                    name
                  },
                  fix: (fixer) => fixer.replaceText(body, `{${sourceCode.getText(body)}}`)
                });
              } else {
                context4.report({
                  node,
                  loc: (name !== "else" ? node : getElseKeyword(node)).loc.start,
                  messageId: opts && opts.condition ? "unexpectedCurlyAfterCondition" : "unexpectedCurlyAfter",
                  data: {
                    name
                  },
                  fix(fixer) {
                    const needsPrecedingSpace = node.type === "DoWhileStatement" && sourceCode.getTokenBefore(body).range[1] === body.range[0] && !astUtils.canTokensBeAdjacent("do", sourceCode.getFirstToken(body, {skip: 1}));
                    const openingBracket = sourceCode.getFirstToken(body);
                    const closingBracket = sourceCode.getLastToken(body);
                    const lastTokenInBlock = sourceCode.getTokenBefore(closingBracket);
                    if (needsSemicolon(closingBracket)) {
                      return null;
                    }
                    const resultingBodyText = sourceCode.getText().slice(openingBracket.range[1], lastTokenInBlock.range[0]) + sourceCode.getText(lastTokenInBlock) + sourceCode.getText().slice(lastTokenInBlock.range[1], closingBracket.range[0]);
                    return fixer.replaceText(body, (needsPrecedingSpace ? " " : "") + resultingBodyText);
                  }
                });
              }
            }
          }
        };
      }
      function prepareIfChecks(node) {
        const preparedChecks = [];
        for (let currentNode = node; currentNode; currentNode = currentNode.alternate) {
          preparedChecks.push(prepareCheck(currentNode, currentNode.consequent, "if", {condition: true}));
          if (currentNode.alternate && currentNode.alternate.type !== "IfStatement") {
            preparedChecks.push(prepareCheck(currentNode, currentNode.alternate, "else"));
            break;
          }
        }
        if (consistent) {
          const expected = preparedChecks.some((preparedCheck) => {
            if (preparedCheck.expected !== null) {
              return preparedCheck.expected;
            }
            return preparedCheck.actual;
          });
          preparedChecks.forEach((preparedCheck) => {
            preparedCheck.expected = expected;
          });
        }
        return preparedChecks;
      }
      return {
        IfStatement(node) {
          const parent = node.parent;
          const isElseIf = parent.type === "IfStatement" && parent.alternate === node;
          if (!isElseIf) {
            prepareIfChecks(node).forEach((preparedCheck) => {
              preparedCheck.check();
            });
          }
        },
        WhileStatement(node) {
          prepareCheck(node, node.body, "while", {condition: true}).check();
        },
        DoWhileStatement(node) {
          prepareCheck(node, node.body, "do").check();
        },
        ForStatement(node) {
          prepareCheck(node, node.body, "for", {condition: true}).check();
        },
        ForInStatement(node) {
          prepareCheck(node, node.body, "for-in").check();
        },
        ForOfStatement(node) {
          prepareCheck(node, node.body, "for-of").check();
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/default-case.js
var require_default_case = __commonJS((exports2, module2) => {
  "use strict";
  var DEFAULT_COMMENT_PATTERN = /^no default$/iu;
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `default` cases in `switch` statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/default-case"
      },
      schema: [{
        type: "object",
        properties: {
          commentPattern: {
            type: "string"
          }
        },
        additionalProperties: false
      }],
      messages: {
        missingDefaultCase: "Expected a default case."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const commentPattern = options.commentPattern ? new RegExp(options.commentPattern, "u") : DEFAULT_COMMENT_PATTERN;
      const sourceCode = context4.getSourceCode();
      function last(collection) {
        return collection[collection.length - 1];
      }
      return {
        SwitchStatement(node) {
          if (!node.cases.length) {
            return;
          }
          const hasDefault = node.cases.some((v) => v.test === null);
          if (!hasDefault) {
            let comment;
            const lastCase = last(node.cases);
            const comments = sourceCode.getCommentsAfter(lastCase);
            if (comments.length) {
              comment = last(comments);
            }
            if (!comment || !commentPattern.test(comment.value.trim())) {
              context4.report({node, messageId: "missingDefaultCase"});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/default-case-last.js
var require_default_case_last = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce default clauses in switch statements to be last",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/default-case-last"
      },
      schema: [],
      messages: {
        notLast: "Default clause should be the last clause."
      }
    },
    create(context4) {
      return {
        SwitchStatement(node) {
          const cases = node.cases, indexOfDefault = cases.findIndex((c) => c.test === null);
          if (indexOfDefault !== -1 && indexOfDefault !== cases.length - 1) {
            const defaultClause = cases[indexOfDefault];
            context4.report({node: defaultClause, messageId: "notLast"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/default-param-last.js
var require_default_param_last = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce default parameters to be last",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/default-param-last"
      },
      schema: [],
      messages: {
        shouldBeLast: "Default parameters should be last."
      }
    },
    create(context4) {
      function handleFunction(node) {
        let hasSeenPlainParam = false;
        for (let i = node.params.length - 1; i >= 0; i -= 1) {
          const param = node.params[i];
          if (param.type !== "AssignmentPattern" && param.type !== "RestElement") {
            hasSeenPlainParam = true;
            continue;
          }
          if (hasSeenPlainParam && param.type === "AssignmentPattern") {
            context4.report({
              node: param,
              messageId: "shouldBeLast"
            });
          }
        }
      }
      return {
        FunctionDeclaration: handleFunction,
        FunctionExpression: handleFunction,
        ArrowFunctionExpression: handleFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/dot-location.js
var require_dot_location = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent newlines before and after dots",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/dot-location"
      },
      schema: [
        {
          enum: ["object", "property"]
        }
      ],
      fixable: "code",
      messages: {
        expectedDotAfterObject: "Expected dot to be on same line as object.",
        expectedDotBeforeProperty: "Expected dot to be on same line as property."
      }
    },
    create(context4) {
      const config = context4.options[0];
      const onObject = config === "object" || !config;
      const sourceCode = context4.getSourceCode();
      function checkDotLocation(node) {
        const property = node.property;
        const dotToken = sourceCode.getTokenBefore(property);
        if (onObject) {
          const tokenBeforeDot = sourceCode.getTokenBefore(dotToken);
          if (!astUtils.isTokenOnSameLine(tokenBeforeDot, dotToken)) {
            context4.report({
              node,
              loc: dotToken.loc,
              messageId: "expectedDotAfterObject",
              *fix(fixer) {
                if (dotToken.value.startsWith(".") && astUtils.isDecimalIntegerNumericToken(tokenBeforeDot)) {
                  yield fixer.insertTextAfter(tokenBeforeDot, ` ${dotToken.value}`);
                } else {
                  yield fixer.insertTextAfter(tokenBeforeDot, dotToken.value);
                }
                yield fixer.remove(dotToken);
              }
            });
          }
        } else if (!astUtils.isTokenOnSameLine(dotToken, property)) {
          context4.report({
            node,
            loc: dotToken.loc,
            messageId: "expectedDotBeforeProperty",
            *fix(fixer) {
              yield fixer.remove(dotToken);
              yield fixer.insertTextBefore(property, dotToken.value);
            }
          });
        }
      }
      function checkNode(node) {
        if (!node.computed) {
          checkDotLocation(node);
        }
      }
      return {
        MemberExpression: checkNode
      };
    }
  };
});

// node_modules/eslint/lib/rules/utils/keywords.js
var require_keywords = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = [
    "abstract",
    "boolean",
    "break",
    "byte",
    "case",
    "catch",
    "char",
    "class",
    "const",
    "continue",
    "debugger",
    "default",
    "delete",
    "do",
    "double",
    "else",
    "enum",
    "export",
    "extends",
    "false",
    "final",
    "finally",
    "float",
    "for",
    "function",
    "goto",
    "if",
    "implements",
    "import",
    "in",
    "instanceof",
    "int",
    "interface",
    "long",
    "native",
    "new",
    "null",
    "package",
    "private",
    "protected",
    "public",
    "return",
    "short",
    "static",
    "super",
    "switch",
    "synchronized",
    "this",
    "throw",
    "throws",
    "transient",
    "true",
    "try",
    "typeof",
    "var",
    "void",
    "volatile",
    "while",
    "with"
  ];
});

// node_modules/eslint/lib/rules/dot-notation.js
var require_dot_notation = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var keywords = require_keywords();
  var validIdentifier = /^[a-zA-Z_$][a-zA-Z0-9_$]*$/u;
  var literalTypesToCheck = new Set(["string", "boolean"]);
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce dot notation whenever possible",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/dot-notation"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowKeywords: {
              type: "boolean",
              default: true
            },
            allowPattern: {
              type: "string",
              default: ""
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        useDot: "[{{key}}] is better written in dot notation.",
        useBrackets: ".{{key}} is a syntax error."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const allowKeywords = options.allowKeywords === void 0 || options.allowKeywords;
      const sourceCode = context4.getSourceCode();
      let allowPattern;
      if (options.allowPattern) {
        allowPattern = new RegExp(options.allowPattern, "u");
      }
      function checkComputedProperty(node, value) {
        if (validIdentifier.test(value) && (allowKeywords || keywords.indexOf(String(value)) === -1) && !(allowPattern && allowPattern.test(value))) {
          const formattedValue = node.property.type === "Literal" ? JSON.stringify(value) : `\`${value}\``;
          context4.report({
            node: node.property,
            messageId: "useDot",
            data: {
              key: formattedValue
            },
            *fix(fixer) {
              const leftBracket = sourceCode.getTokenAfter(node.object, astUtils.isOpeningBracketToken);
              const rightBracket = sourceCode.getLastToken(node);
              const nextToken = sourceCode.getTokenAfter(node);
              if (sourceCode.commentsExistBetween(leftBracket, rightBracket)) {
                return;
              }
              if (!node.optional) {
                yield fixer.insertTextBefore(leftBracket, astUtils.isDecimalInteger(node.object) ? " ." : ".");
              }
              yield fixer.replaceTextRange([leftBracket.range[0], rightBracket.range[1]], value);
              if (nextToken && rightBracket.range[1] === nextToken.range[0] && !astUtils.canTokensBeAdjacent(String(value), nextToken)) {
                yield fixer.insertTextAfter(node, " ");
              }
            }
          });
        }
      }
      return {
        MemberExpression(node) {
          if (node.computed && node.property.type === "Literal" && (literalTypesToCheck.has(typeof node.property.value) || astUtils.isNullLiteral(node.property))) {
            checkComputedProperty(node, node.property.value);
          }
          if (node.computed && node.property.type === "TemplateLiteral" && node.property.expressions.length === 0) {
            checkComputedProperty(node, node.property.quasis[0].value.cooked);
          }
          if (!allowKeywords && !node.computed && keywords.indexOf(String(node.property.name)) !== -1) {
            context4.report({
              node: node.property,
              messageId: "useBrackets",
              data: {
                key: node.property.name
              },
              *fix(fixer) {
                const dotToken = sourceCode.getTokenBefore(node.property);
                if (node.object.type === "Identifier" && node.object.name === "let" && !node.optional) {
                  return;
                }
                if (sourceCode.commentsExistBetween(dotToken, node.property)) {
                  return;
                }
                if (!node.optional) {
                  yield fixer.remove(dotToken);
                }
                yield fixer.replaceText(node.property, `["${node.property.name}"]`);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/eol-last.js
var require_eol_last = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow newline at the end of files",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/eol-last"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "unix", "windows"]
        }
      ],
      messages: {
        missing: "Newline required at end of file but not found.",
        unexpected: "Newline not allowed at end of file."
      }
    },
    create(context4) {
      return {
        Program: function checkBadEOF(node) {
          const sourceCode = context4.getSourceCode(), src = sourceCode.getText(), location = {
            column: lodash.last(sourceCode.lines).length,
            line: sourceCode.lines.length
          }, LF = "\n", CRLF = `\r${LF}`, endsWithNewline = src.endsWith(LF);
          if (!src.length) {
            return;
          }
          let mode = context4.options[0] || "always", appendCRLF = false;
          if (mode === "unix") {
            mode = "always";
          }
          if (mode === "windows") {
            mode = "always";
            appendCRLF = true;
          }
          if (mode === "always" && !endsWithNewline) {
            context4.report({
              node,
              loc: location,
              messageId: "missing",
              fix(fixer) {
                return fixer.insertTextAfterRange([0, src.length], appendCRLF ? CRLF : LF);
              }
            });
          } else if (mode === "never" && endsWithNewline) {
            context4.report({
              node,
              loc: location,
              messageId: "unexpected",
              fix(fixer) {
                const finalEOLs = /(?:\r?\n)+$/u, match = finalEOLs.exec(sourceCode.text), start = match.index, end = sourceCode.text.length;
                return fixer.replaceTextRange([start, end], "");
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/eqeqeq.js
var require_eqeqeq = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require the use of `===` and `!==`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/eqeqeq"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  null: {
                    enum: ["always", "never", "ignore"]
                  }
                },
                additionalProperties: false
              }
            ],
            additionalItems: false
          },
          {
            type: "array",
            items: [
              {
                enum: ["smart", "allow-null"]
              }
            ],
            additionalItems: false
          }
        ]
      },
      fixable: "code",
      messages: {
        unexpected: "Expected '{{expectedOperator}}' and instead saw '{{actualOperator}}'."
      }
    },
    create(context4) {
      const config = context4.options[0] || "always";
      const options = context4.options[1] || {};
      const sourceCode = context4.getSourceCode();
      const nullOption = config === "always" ? options.null || "always" : "ignore";
      const enforceRuleForNull = nullOption === "always";
      const enforceInverseRuleForNull = nullOption === "never";
      function isTypeOf(node) {
        return node.type === "UnaryExpression" && node.operator === "typeof";
      }
      function isTypeOfBinary(node) {
        return isTypeOf(node.left) || isTypeOf(node.right);
      }
      function areLiteralsAndSameType(node) {
        return node.left.type === "Literal" && node.right.type === "Literal" && typeof node.left.value === typeof node.right.value;
      }
      function isNullCheck(node) {
        return astUtils.isNullLiteral(node.right) || astUtils.isNullLiteral(node.left);
      }
      function report(node, expectedOperator) {
        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
        context4.report({
          node,
          loc: operatorToken.loc,
          messageId: "unexpected",
          data: {expectedOperator, actualOperator: node.operator},
          fix(fixer) {
            if (isTypeOfBinary(node) || areLiteralsAndSameType(node)) {
              return fixer.replaceText(operatorToken, expectedOperator);
            }
            return null;
          }
        });
      }
      return {
        BinaryExpression(node) {
          const isNull = isNullCheck(node);
          if (node.operator !== "==" && node.operator !== "!=") {
            if (enforceInverseRuleForNull && isNull) {
              report(node, node.operator.slice(0, -1));
            }
            return;
          }
          if (config === "smart" && (isTypeOfBinary(node) || areLiteralsAndSameType(node) || isNull)) {
            return;
          }
          if (!enforceRuleForNull && isNull) {
            return;
          }
          report(node, `${node.operator}=`);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/for-direction.js
var require_for_direction = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: 'enforce "for" loop update clause moving the counter in the right direction.',
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/for-direction"
      },
      fixable: null,
      schema: [],
      messages: {
        incorrectDirection: "The update clause in this loop moves the variable in the wrong direction."
      }
    },
    create(context4) {
      function report(node) {
        context4.report({
          node,
          messageId: "incorrectDirection"
        });
      }
      function getRightDirection(update, dir) {
        if (update.right.type === "UnaryExpression") {
          if (update.right.operator === "-") {
            return -dir;
          }
        } else if (update.right.type === "Identifier") {
          return 0;
        }
        return dir;
      }
      function getUpdateDirection(update, counter) {
        if (update.argument.type === "Identifier" && update.argument.name === counter) {
          if (update.operator === "++") {
            return 1;
          }
          if (update.operator === "--") {
            return -1;
          }
        }
        return 0;
      }
      function getAssignmentDirection(update, counter) {
        if (update.left.name === counter) {
          if (update.operator === "+=") {
            return getRightDirection(update, 1);
          }
          if (update.operator === "-=") {
            return getRightDirection(update, -1);
          }
        }
        return 0;
      }
      return {
        ForStatement(node) {
          if (node.test && node.test.type === "BinaryExpression" && node.test.left.type === "Identifier" && node.update) {
            const counter = node.test.left.name;
            const operator = node.test.operator;
            const update = node.update;
            let wrongDirection;
            if (operator === "<" || operator === "<=") {
              wrongDirection = -1;
            } else if (operator === ">" || operator === ">=") {
              wrongDirection = 1;
            } else {
              return;
            }
            if (update.type === "UpdateExpression") {
              if (getUpdateDirection(update, counter) === wrongDirection) {
                report(node);
              }
            } else if (update.type === "AssignmentExpression" && getAssignmentDirection(update, counter) === wrongDirection) {
              report(node);
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/func-call-spacing.js
var require_func_call_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow spacing between function identifiers and their invocations",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/func-call-spacing"
      },
      fixable: "whitespace",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  allowNewlines: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpectedWhitespace: "Unexpected whitespace between function name and paren.",
        unexpectedNewline: "Unexpected newline between function name and paren.",
        missing: "Missing space between function name and paren."
      }
    },
    create(context4) {
      const never = context4.options[0] !== "always";
      const allowNewlines = !never && context4.options[1] && context4.options[1].allowNewlines;
      const sourceCode = context4.getSourceCode();
      const text = sourceCode.getText();
      function checkSpacing(node, leftToken, rightToken) {
        const textBetweenTokens = text.slice(leftToken.range[1], rightToken.range[0]).replace(/\/\*.*?\*\//gu, "");
        const hasWhitespace = /\s/u.test(textBetweenTokens);
        const hasNewline = hasWhitespace && astUtils.LINEBREAK_MATCHER.test(textBetweenTokens);
        if (never && hasWhitespace) {
          context4.report({
            node,
            loc: {
              start: leftToken.loc.end,
              end: {
                line: rightToken.loc.start.line,
                column: rightToken.loc.start.column - 1
              }
            },
            messageId: "unexpectedWhitespace",
            fix(fixer) {
              if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                return null;
              }
              if (node.optional) {
                return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], "?.");
              }
              if (hasNewline) {
                return null;
              }
              return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
            }
          });
        } else if (!never && !hasWhitespace) {
          context4.report({
            node,
            loc: {
              start: {
                line: leftToken.loc.end.line,
                column: leftToken.loc.end.column - 1
              },
              end: rightToken.loc.start
            },
            messageId: "missing",
            fix(fixer) {
              if (node.optional) {
                return null;
              }
              return fixer.insertTextBefore(rightToken, " ");
            }
          });
        } else if (!never && !allowNewlines && hasNewline) {
          context4.report({
            node,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId: "unexpectedNewline",
            fix(fixer) {
              if (!node.optional) {
                return null;
              }
              if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
                return null;
              }
              const range = [leftToken.range[1], rightToken.range[0]];
              const qdToken = sourceCode.getTokenAfter(leftToken);
              if (qdToken.range[0] === leftToken.range[1]) {
                return fixer.replaceTextRange(range, "?. ");
              }
              if (qdToken.range[1] === rightToken.range[0]) {
                return fixer.replaceTextRange(range, " ?.");
              }
              return fixer.replaceTextRange(range, " ?. ");
            }
          });
        }
      }
      return {
        "CallExpression, NewExpression"(node) {
          const lastToken = sourceCode.getLastToken(node);
          const lastCalleeToken = sourceCode.getLastToken(node.callee);
          const parenToken = sourceCode.getFirstTokenBetween(lastCalleeToken, lastToken, astUtils.isOpeningParenToken);
          const prevToken = parenToken && sourceCode.getTokenBefore(parenToken, astUtils.isNotQuestionDotToken);
          if (!(parenToken && parenToken.range[1] < node.range[1])) {
            return;
          }
          checkSpacing(node, prevToken, parenToken);
        },
        ImportExpression(node) {
          const leftToken = sourceCode.getFirstToken(node);
          const rightToken = sourceCode.getTokenAfter(leftToken);
          checkSpacing(node, leftToken, rightToken);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/func-name-matching.js
var require_func_name_matching = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var esutils = require_utils7();
  function isModuleExports(pattern) {
    if (pattern.type === "MemberExpression" && pattern.object.type === "Identifier" && pattern.object.name === "module") {
      if (pattern.property.type === "Identifier" && pattern.property.name === "exports") {
        return true;
      }
      if (pattern.property.type === "Literal" && pattern.property.value === "exports") {
        return true;
      }
    }
    return false;
  }
  function isIdentifier(name, ecmaVersion) {
    if (ecmaVersion >= 6) {
      return esutils.keyword.isIdentifierES6(name);
    }
    return esutils.keyword.isIdentifierES5(name);
  }
  var alwaysOrNever = {enum: ["always", "never"]};
  var optionsObject = {
    type: "object",
    properties: {
      considerPropertyDescriptor: {
        type: "boolean"
      },
      includeCommonJSModuleExports: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require function names to match the name of the variable or property to which they are assigned",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/func-name-matching"
      },
      schema: {
        anyOf: [{
          type: "array",
          additionalItems: false,
          items: [alwaysOrNever, optionsObject]
        }, {
          type: "array",
          additionalItems: false,
          items: [optionsObject]
        }]
      },
      messages: {
        matchProperty: "Function name `{{funcName}}` should match property name `{{name}}`.",
        matchVariable: "Function name `{{funcName}}` should match variable name `{{name}}`.",
        notMatchProperty: "Function name `{{funcName}}` should not match property name `{{name}}`.",
        notMatchVariable: "Function name `{{funcName}}` should not match variable name `{{name}}`."
      }
    },
    create(context4) {
      const options = (typeof context4.options[0] === "object" ? context4.options[0] : context4.options[1]) || {};
      const nameMatches = typeof context4.options[0] === "string" ? context4.options[0] : "always";
      const considerPropertyDescriptor = options.considerPropertyDescriptor;
      const includeModuleExports = options.includeCommonJSModuleExports;
      const ecmaVersion = context4.parserOptions && context4.parserOptions.ecmaVersion ? context4.parserOptions.ecmaVersion : 5;
      function isPropertyCall(objName, funcName, node) {
        if (!node) {
          return false;
        }
        return node.type === "CallExpression" && astUtils.isSpecificMemberAccess(node.callee, objName, funcName);
      }
      function shouldWarn(x, y) {
        return nameMatches === "always" && x !== y || nameMatches === "never" && x === y;
      }
      function report(node, name, funcName, isProp) {
        let messageId;
        if (nameMatches === "always" && isProp) {
          messageId = "matchProperty";
        } else if (nameMatches === "always") {
          messageId = "matchVariable";
        } else if (isProp) {
          messageId = "notMatchProperty";
        } else {
          messageId = "notMatchVariable";
        }
        context4.report({
          node,
          messageId,
          data: {
            name,
            funcName
          }
        });
      }
      function isStringLiteral(node) {
        return node.type === "Literal" && typeof node.value === "string";
      }
      return {
        VariableDeclarator(node) {
          if (!node.init || node.init.type !== "FunctionExpression" || node.id.type !== "Identifier") {
            return;
          }
          if (node.init.id && shouldWarn(node.id.name, node.init.id.name)) {
            report(node, node.id.name, node.init.id.name, false);
          }
        },
        AssignmentExpression(node) {
          if (node.right.type !== "FunctionExpression" || node.left.computed && node.left.property.type !== "Literal" || !includeModuleExports && isModuleExports(node.left) || node.left.type !== "Identifier" && node.left.type !== "MemberExpression") {
            return;
          }
          const isProp = node.left.type === "MemberExpression";
          const name = isProp ? astUtils.getStaticPropertyName(node.left) : node.left.name;
          if (node.right.id && isIdentifier(name) && shouldWarn(name, node.right.id.name)) {
            report(node, name, node.right.id.name, isProp);
          }
        },
        Property(node) {
          if (node.value.type !== "FunctionExpression" || !node.value.id || node.computed && !isStringLiteral(node.key)) {
            return;
          }
          if (node.key.type === "Identifier") {
            const functionName = node.value.id.name;
            let propertyName = node.key.name;
            if (considerPropertyDescriptor && propertyName === "value") {
              if (isPropertyCall("Object", "defineProperty", node.parent.parent) || isPropertyCall("Reflect", "defineProperty", node.parent.parent)) {
                const property = node.parent.parent.arguments[1];
                if (isStringLiteral(property) && shouldWarn(property.value, functionName)) {
                  report(node, property.value, functionName, true);
                }
              } else if (isPropertyCall("Object", "defineProperties", node.parent.parent.parent.parent)) {
                propertyName = node.parent.parent.key.name;
                if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                  report(node, propertyName, functionName, true);
                }
              } else if (isPropertyCall("Object", "create", node.parent.parent.parent.parent)) {
                propertyName = node.parent.parent.key.name;
                if (!node.parent.parent.computed && shouldWarn(propertyName, functionName)) {
                  report(node, propertyName, functionName, true);
                }
              } else if (shouldWarn(propertyName, functionName)) {
                report(node, propertyName, functionName, true);
              }
            } else if (shouldWarn(propertyName, functionName)) {
              report(node, propertyName, functionName, true);
            }
            return;
          }
          if (isStringLiteral(node.key) && isIdentifier(node.key.value, ecmaVersion) && shouldWarn(node.key.value, node.value.id.name)) {
            report(node, node.key.value, node.value.id.name, true);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/func-names.js
var require_func_names = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow named `function` expressions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/func-names"
      },
      schema: {
        definitions: {
          value: {
            enum: [
              "always",
              "as-needed",
              "never"
            ]
          }
        },
        items: [
          {
            $ref: "#/definitions/value"
          },
          {
            type: "object",
            properties: {
              generators: {
                $ref: "#/definitions/value"
              }
            },
            additionalProperties: false
          }
        ]
      },
      messages: {
        unnamed: "Unexpected unnamed {{name}}.",
        named: "Unexpected named {{name}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function getConfigForNode(node) {
        if (node.generator && context4.options.length > 1 && context4.options[1].generators) {
          return context4.options[1].generators;
        }
        return context4.options[0] || "always";
      }
      function isObjectOrClassMethod(node) {
        const parent = node.parent;
        return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.method || parent.kind === "get" || parent.kind === "set");
      }
      function hasInferredName(node) {
        const parent = node.parent;
        return isObjectOrClassMethod(node) || parent.type === "VariableDeclarator" && parent.id.type === "Identifier" && parent.init === node || parent.type === "Property" && parent.value === node || parent.type === "AssignmentExpression" && parent.left.type === "Identifier" && parent.right === node || parent.type === "AssignmentPattern" && parent.left.type === "Identifier" && parent.right === node;
      }
      function reportUnexpectedUnnamedFunction(node) {
        context4.report({
          node,
          messageId: "unnamed",
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          data: {name: astUtils.getFunctionNameWithKind(node)}
        });
      }
      function reportUnexpectedNamedFunction(node) {
        context4.report({
          node,
          messageId: "named",
          loc: astUtils.getFunctionHeadLoc(node, sourceCode),
          data: {name: astUtils.getFunctionNameWithKind(node)}
        });
      }
      function handleFunction(node) {
        const nameVar = context4.getDeclaredVariables(node)[0];
        if (isFunctionName(nameVar) && nameVar.references.length > 0) {
          return;
        }
        const hasName = Boolean(node.id && node.id.name);
        const config = getConfigForNode(node);
        if (config === "never") {
          if (hasName && node.type !== "FunctionDeclaration") {
            reportUnexpectedNamedFunction(node);
          }
        } else if (config === "as-needed") {
          if (!hasName && !hasInferredName(node)) {
            reportUnexpectedUnnamedFunction(node);
          }
        } else {
          if (!hasName && !isObjectOrClassMethod(node)) {
            reportUnexpectedUnnamedFunction(node);
          }
        }
      }
      return {
        "FunctionExpression:exit": handleFunction,
        "ExportDefaultDeclaration > FunctionDeclaration": handleFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/func-style.js
var require_func_style = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce the consistent use of either `function` declarations or expressions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/func-style"
      },
      schema: [
        {
          enum: ["declaration", "expression"]
        },
        {
          type: "object",
          properties: {
            allowArrowFunctions: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expression: "Expected a function expression.",
        declaration: "Expected a function declaration."
      }
    },
    create(context4) {
      const style = context4.options[0], allowArrowFunctions = context4.options[1] && context4.options[1].allowArrowFunctions, enforceDeclarations = style === "declaration", stack = [];
      const nodesToCheck = {
        FunctionDeclaration(node) {
          stack.push(false);
          if (!enforceDeclarations && node.parent.type !== "ExportDefaultDeclaration") {
            context4.report({node, messageId: "expression"});
          }
        },
        "FunctionDeclaration:exit"() {
          stack.pop();
        },
        FunctionExpression(node) {
          stack.push(false);
          if (enforceDeclarations && node.parent.type === "VariableDeclarator") {
            context4.report({node: node.parent, messageId: "declaration"});
          }
        },
        "FunctionExpression:exit"() {
          stack.pop();
        },
        ThisExpression() {
          if (stack.length > 0) {
            stack[stack.length - 1] = true;
          }
        }
      };
      if (!allowArrowFunctions) {
        nodesToCheck.ArrowFunctionExpression = function() {
          stack.push(false);
        };
        nodesToCheck["ArrowFunctionExpression:exit"] = function(node) {
          const hasThisExpr = stack.pop();
          if (enforceDeclarations && !hasThisExpr && node.parent.type === "VariableDeclarator") {
            context4.report({node: node.parent, messageId: "declaration"});
          }
        };
      }
      return nodesToCheck;
    }
  };
});

// node_modules/eslint/lib/rules/function-call-argument-newline.js
var require_function_call_argument_newline = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce line breaks between arguments of a function call",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/function-call-argument-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never", "consistent"]
        }
      ],
      messages: {
        unexpectedLineBreak: "There should be no line break here.",
        missingLineBreak: "There should be a line break after this argument."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const checkers = {
        unexpected: {
          messageId: "unexpectedLineBreak",
          check: (prevToken, currentToken) => prevToken.loc.end.line !== currentToken.loc.start.line,
          createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], " ")
        },
        missing: {
          messageId: "missingLineBreak",
          check: (prevToken, currentToken) => prevToken.loc.end.line === currentToken.loc.start.line,
          createFix: (token, tokenBefore) => (fixer) => fixer.replaceTextRange([tokenBefore.range[1], token.range[0]], "\n")
        }
      };
      function checkArguments(node, checker) {
        for (let i = 1; i < node.arguments.length; i++) {
          const prevArgToken = sourceCode.getLastToken(node.arguments[i - 1]);
          const currentArgToken = sourceCode.getFirstToken(node.arguments[i]);
          if (checker.check(prevArgToken, currentArgToken)) {
            const tokenBefore = sourceCode.getTokenBefore(currentArgToken, {includeComments: true});
            const hasLineCommentBefore = tokenBefore.type === "Line";
            context4.report({
              node,
              loc: {
                start: tokenBefore.loc.end,
                end: currentArgToken.loc.start
              },
              messageId: checker.messageId,
              fix: hasLineCommentBefore ? null : checker.createFix(currentArgToken, tokenBefore)
            });
          }
        }
      }
      function check(node) {
        if (node.arguments.length < 2) {
          return;
        }
        const option = context4.options[0] || "always";
        if (option === "never") {
          checkArguments(node, checkers.unexpected);
        } else if (option === "always") {
          checkArguments(node, checkers.missing);
        } else if (option === "consistent") {
          const firstArgToken = sourceCode.getLastToken(node.arguments[0]);
          const secondArgToken = sourceCode.getFirstToken(node.arguments[1]);
          if (firstArgToken.loc.end.line === secondArgToken.loc.start.line) {
            checkArguments(node, checkers.unexpected);
          } else {
            checkArguments(node, checkers.missing);
          }
        }
      }
      return {
        CallExpression: check,
        NewExpression: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/function-paren-newline.js
var require_function_paren_newline = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent line breaks inside function parentheses",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/function-paren-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consistent", "multiline", "multiline-arguments"]
            },
            {
              type: "object",
              properties: {
                minItems: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        expectedBefore: "Expected newline before ')'.",
        expectedAfter: "Expected newline after '('.",
        expectedBetween: "Expected newline between arguments/params.",
        unexpectedBefore: "Unexpected newline before ')'.",
        unexpectedAfter: "Unexpected newline after '('."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const rawOption = context4.options[0] || "multiline";
      const multilineOption = rawOption === "multiline";
      const multilineArgumentsOption = rawOption === "multiline-arguments";
      const consistentOption = rawOption === "consistent";
      let minItems;
      if (typeof rawOption === "object") {
        minItems = rawOption.minItems;
      } else if (rawOption === "always") {
        minItems = 0;
      } else if (rawOption === "never") {
        minItems = Infinity;
      } else {
        minItems = null;
      }
      function shouldHaveNewlines(elements, hasLeftNewline) {
        if (multilineArgumentsOption && elements.length === 1) {
          return hasLeftNewline;
        }
        if (multilineOption || multilineArgumentsOption) {
          return elements.some((element, index) => index !== elements.length - 1 && element.loc.end.line !== elements[index + 1].loc.start.line);
        }
        if (consistentOption) {
          return hasLeftNewline;
        }
        return elements.length >= minItems;
      }
      function validateParens(parens, elements) {
        const leftParen = parens.leftParen;
        const rightParen = parens.rightParen;
        const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
        const tokenBeforeRightParen = sourceCode.getTokenBefore(rightParen);
        const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
        const hasRightNewline = !astUtils.isTokenOnSameLine(tokenBeforeRightParen, rightParen);
        const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
        if (hasLeftNewline && !needsNewlines) {
          context4.report({
            node: leftParen,
            messageId: "unexpectedAfter",
            fix(fixer) {
              return sourceCode.getText().slice(leftParen.range[1], tokenAfterLeftParen.range[0]).trim() ? null : fixer.removeRange([leftParen.range[1], tokenAfterLeftParen.range[0]]);
            }
          });
        } else if (!hasLeftNewline && needsNewlines) {
          context4.report({
            node: leftParen,
            messageId: "expectedAfter",
            fix: (fixer) => fixer.insertTextAfter(leftParen, "\n")
          });
        }
        if (hasRightNewline && !needsNewlines) {
          context4.report({
            node: rightParen,
            messageId: "unexpectedBefore",
            fix(fixer) {
              return sourceCode.getText().slice(tokenBeforeRightParen.range[1], rightParen.range[0]).trim() ? null : fixer.removeRange([tokenBeforeRightParen.range[1], rightParen.range[0]]);
            }
          });
        } else if (!hasRightNewline && needsNewlines) {
          context4.report({
            node: rightParen,
            messageId: "expectedBefore",
            fix: (fixer) => fixer.insertTextBefore(rightParen, "\n")
          });
        }
      }
      function validateArguments(parens, elements) {
        const leftParen = parens.leftParen;
        const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParen);
        const hasLeftNewline = !astUtils.isTokenOnSameLine(leftParen, tokenAfterLeftParen);
        const needsNewlines = shouldHaveNewlines(elements, hasLeftNewline);
        for (let i = 0; i <= elements.length - 2; i++) {
          const currentElement = elements[i];
          const nextElement = elements[i + 1];
          const hasNewLine = currentElement.loc.end.line !== nextElement.loc.start.line;
          if (!hasNewLine && needsNewlines) {
            context4.report({
              node: currentElement,
              messageId: "expectedBetween",
              fix: (fixer) => fixer.insertTextBefore(nextElement, "\n")
            });
          }
        }
      }
      function getParenTokens(node) {
        switch (node.type) {
          case "NewExpression":
            if (!node.arguments.length && !(astUtils.isOpeningParenToken(sourceCode.getLastToken(node, {skip: 1})) && astUtils.isClosingParenToken(sourceCode.getLastToken(node)))) {
              return null;
            }
          case "CallExpression":
            return {
              leftParen: sourceCode.getTokenAfter(node.callee, astUtils.isOpeningParenToken),
              rightParen: sourceCode.getLastToken(node)
            };
          case "FunctionDeclaration":
          case "FunctionExpression": {
            const leftParen = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
            const rightParen = node.params.length ? sourceCode.getTokenAfter(node.params[node.params.length - 1], astUtils.isClosingParenToken) : sourceCode.getTokenAfter(leftParen);
            return {leftParen, rightParen};
          }
          case "ArrowFunctionExpression": {
            const firstToken = sourceCode.getFirstToken(node, {skip: node.async ? 1 : 0});
            if (!astUtils.isOpeningParenToken(firstToken)) {
              return null;
            }
            return {
              leftParen: firstToken,
              rightParen: sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken)
            };
          }
          case "ImportExpression": {
            const leftParen = sourceCode.getFirstToken(node, 1);
            const rightParen = sourceCode.getLastToken(node);
            return {leftParen, rightParen};
          }
          default:
            throw new TypeError(`unexpected node with type ${node.type}`);
        }
      }
      return {
        [[
          "ArrowFunctionExpression",
          "CallExpression",
          "FunctionDeclaration",
          "FunctionExpression",
          "ImportExpression",
          "NewExpression"
        ]](node) {
          const parens = getParenTokens(node);
          let params;
          if (node.type === "ImportExpression") {
            params = [node.source];
          } else if (astUtils.isFunction(node)) {
            params = node.params;
          } else {
            params = node.arguments;
          }
          if (parens) {
            validateParens(parens, params);
            if (multilineArgumentsOption) {
              validateArguments(parens, params);
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/generator-star-spacing.js
var require_generator_star_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var OVERRIDE_SCHEMA = {
    oneOf: [
      {
        enum: ["before", "after", "both", "neither"]
      },
      {
        type: "object",
        properties: {
          before: {type: "boolean"},
          after: {type: "boolean"}
        },
        additionalProperties: false
      }
    ]
  };
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing around `*` operators in generator functions",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/generator-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: {type: "boolean"},
                after: {type: "boolean"},
                named: OVERRIDE_SCHEMA,
                anonymous: OVERRIDE_SCHEMA,
                method: OVERRIDE_SCHEMA
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(context4) {
      const optionDefinitions = {
        before: {before: true, after: false},
        after: {before: false, after: true},
        both: {before: true, after: true},
        neither: {before: false, after: false}
      };
      function optionToDefinition(option, defaults) {
        if (!option) {
          return defaults;
        }
        return typeof option === "string" ? optionDefinitions[option] : Object.assign({}, defaults, option);
      }
      const modes = function(option) {
        const defaults = optionToDefinition(option, optionDefinitions.before);
        return {
          named: optionToDefinition(option.named, defaults),
          anonymous: optionToDefinition(option.anonymous, defaults),
          method: optionToDefinition(option.method, defaults)
        };
      }(context4.options[0] || {});
      const sourceCode = context4.getSourceCode();
      function isStarToken(token) {
        return token.value === "*" && token.type === "Punctuator";
      }
      function getStarToken(node) {
        return sourceCode.getFirstToken(node.parent.method || node.parent.type === "MethodDefinition" ? node.parent : node, isStarToken);
      }
      function capitalize(str) {
        return str[0].toUpperCase() + str.slice(1);
      }
      function checkSpacing(kind, side, leftToken, rightToken) {
        if (!!(rightToken.range[0] - leftToken.range[1]) !== modes[kind][side]) {
          const after = leftToken.value === "*";
          const spaceRequired = modes[kind][side];
          const node = after ? leftToken : rightToken;
          const messageId = `${spaceRequired ? "missing" : "unexpected"}${capitalize(side)}`;
          context4.report({
            node,
            messageId,
            fix(fixer) {
              if (spaceRequired) {
                if (after) {
                  return fixer.insertTextAfter(node, " ");
                }
                return fixer.insertTextBefore(node, " ");
              }
              return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
            }
          });
        }
      }
      function checkFunction(node) {
        if (!node.generator) {
          return;
        }
        const starToken = getStarToken(node);
        const prevToken = sourceCode.getTokenBefore(starToken);
        const nextToken = sourceCode.getTokenAfter(starToken);
        let kind = "named";
        if (node.parent.type === "MethodDefinition" || node.parent.type === "Property" && node.parent.method) {
          kind = "method";
        } else if (!node.id) {
          kind = "anonymous";
        }
        if (!(kind === "method" && starToken === sourceCode.getFirstToken(node.parent))) {
          checkSpacing(kind, "before", prevToken, starToken);
        }
        checkSpacing(kind, "after", starToken, nextToken);
      }
      return {
        FunctionDeclaration: checkFunction,
        FunctionExpression: checkFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/getter-return.js
var require_getter_return = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var TARGET_NODE_TYPE = /^(?:Arrow)?FunctionExpression$/u;
  function isReachable(segment) {
    return segment.reachable;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "enforce `return` statements in getters",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/getter-return"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowImplicit: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expected: "Expected to return a value in {{name}}.",
        expectedAlways: "Expected {{name}} to always return a value."
      }
    },
    create(context4) {
      const options = context4.options[0] || {allowImplicit: false};
      const sourceCode = context4.getSourceCode();
      let funcInfo = {
        upper: null,
        codePath: null,
        hasReturn: false,
        shouldCheck: false,
        node: null
      };
      function checkLastSegment(node) {
        if (funcInfo.shouldCheck && funcInfo.codePath.currentSegments.some(isReachable)) {
          context4.report({
            node,
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            messageId: funcInfo.hasReturn ? "expectedAlways" : "expected",
            data: {
              name: astUtils.getFunctionNameWithKind(funcInfo.node)
            }
          });
        }
      }
      function isGetter(node) {
        const parent = node.parent;
        if (TARGET_NODE_TYPE.test(node.type) && node.body.type === "BlockStatement") {
          if (parent.kind === "get") {
            return true;
          }
          if (parent.type === "Property" && astUtils.getStaticPropertyName(parent) === "get" && parent.parent.type === "ObjectExpression") {
            if (parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.callee) === "defineProperty") {
              return true;
            }
            if (parent.parent.parent.type === "Property" && parent.parent.parent.parent.type === "ObjectExpression" && parent.parent.parent.parent.parent.type === "CallExpression" && astUtils.getStaticPropertyName(parent.parent.parent.parent.parent.callee) === "defineProperties") {
              return true;
            }
          }
        }
        return false;
      }
      return {
        onCodePathStart(codePath, node) {
          funcInfo = {
            upper: funcInfo,
            codePath,
            hasReturn: false,
            shouldCheck: isGetter(node),
            node
          };
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        ReturnStatement(node) {
          if (funcInfo.shouldCheck) {
            funcInfo.hasReturn = true;
            if (!options.allowImplicit && !node.argument) {
              context4.report({
                node,
                messageId: "expected",
                data: {
                  name: astUtils.getFunctionNameWithKind(funcInfo.node)
                }
              });
            }
          }
        },
        "FunctionExpression:exit": checkLastSegment,
        "ArrowFunctionExpression:exit": checkLastSegment
      };
    }
  };
});

// node_modules/eslint/lib/rules/global-require.js
var require_global_require = __commonJS((exports2, module2) => {
  "use strict";
  var ACCEPTABLE_PARENTS = [
    "AssignmentExpression",
    "VariableDeclarator",
    "MemberExpression",
    "ExpressionStatement",
    "CallExpression",
    "ConditionalExpression",
    "Program",
    "VariableDeclaration",
    "ChainExpression"
  ];
  function findReference(scope, node) {
    const references = scope.references.filter((reference) => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);
    if (references.length === 1) {
      return references[0];
    }
    return null;
  }
  function isShadowed(scope, node) {
    const reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
  }
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "require `require()` calls to be placed at top-level module scope",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/global-require"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected require()."
      }
    },
    create(context4) {
      return {
        CallExpression(node) {
          const currentScope = context4.getScope();
          if (node.callee.name === "require" && !isShadowed(currentScope, node.callee)) {
            const isGoodRequire = context4.getAncestors().every((parent) => ACCEPTABLE_PARENTS.indexOf(parent.type) > -1);
            if (!isGoodRequire) {
              context4.report({node, messageId: "unexpected"});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/grouped-accessor-pairs.js
var require_grouped_accessor_pairs = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function areEqualTokenLists(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (let i = 0; i < left.length; i++) {
      const leftToken = left[i], rightToken = right[i];
      if (leftToken.type !== rightToken.type || leftToken.value !== rightToken.value) {
        return false;
      }
    }
    return true;
  }
  function areEqualKeys(left, right) {
    if (typeof left === "string" && typeof right === "string") {
      return left === right;
    }
    if (Array.isArray(left) && Array.isArray(right)) {
      return areEqualTokenLists(left, right);
    }
    return false;
  }
  function isAccessorKind(node) {
    return node.kind === "get" || node.kind === "set";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require grouped accessor pairs in object literals and classes",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/grouped-accessor-pairs"
      },
      schema: [
        {
          enum: ["anyOrder", "getBeforeSet", "setBeforeGet"]
        }
      ],
      messages: {
        notGrouped: "Accessor pair {{ formerName }} and {{ latterName }} should be grouped.",
        invalidOrder: "Expected {{ latterName }} to be before {{ formerName }}."
      }
    },
    create(context4) {
      const order = context4.options[0] || "anyOrder";
      const sourceCode = context4.getSourceCode();
      function report(messageId, formerNode, latterNode) {
        context4.report({
          node: latterNode,
          messageId,
          loc: astUtils.getFunctionHeadLoc(latterNode.value, sourceCode),
          data: {
            formerName: astUtils.getFunctionNameWithKind(formerNode.value),
            latterName: astUtils.getFunctionNameWithKind(latterNode.value)
          }
        });
      }
      function createAccessorData(node) {
        const name = astUtils.getStaticPropertyName(node);
        const key = name !== null ? name : sourceCode.getTokens(node.key);
        return {
          key,
          getters: node.kind === "get" ? [node] : [],
          setters: node.kind === "set" ? [node] : []
        };
      }
      function mergeAccessorData(accessors, accessorData) {
        const equalKeyElement = accessors.find((a) => areEqualKeys(a.key, accessorData.key));
        if (equalKeyElement) {
          equalKeyElement.getters.push(...accessorData.getters);
          equalKeyElement.setters.push(...accessorData.setters);
        } else {
          accessors.push(accessorData);
        }
        return accessors;
      }
      function checkList(nodes, shouldCheck) {
        const accessors = nodes.filter(shouldCheck).filter(isAccessorKind).map(createAccessorData).reduce(mergeAccessorData, []);
        for (const {getters, setters} of accessors) {
          if (getters.length === 1 && setters.length === 1) {
            const [getter] = getters, [setter] = setters, getterIndex = nodes.indexOf(getter), setterIndex = nodes.indexOf(setter), formerNode = getterIndex < setterIndex ? getter : setter, latterNode = getterIndex < setterIndex ? setter : getter;
            if (Math.abs(getterIndex - setterIndex) > 1) {
              report("notGrouped", formerNode, latterNode);
            } else if (order === "getBeforeSet" && getterIndex > setterIndex || order === "setBeforeGet" && getterIndex < setterIndex) {
              report("invalidOrder", formerNode, latterNode);
            }
          }
        }
      }
      return {
        ObjectExpression(node) {
          checkList(node.properties, (n) => n.type === "Property");
        },
        ClassBody(node) {
          checkList(node.body, (n) => n.type === "MethodDefinition" && !n.static);
          checkList(node.body, (n) => n.type === "MethodDefinition" && n.static);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/guard-for-in.js
var require_guard_for_in = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `for-in` loops to include an `if` statement",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/guard-for-in"
      },
      schema: [],
      messages: {
        wrap: "The body of a for-in should be wrapped in an if statement to filter unwanted properties from the prototype."
      }
    },
    create(context4) {
      return {
        ForInStatement(node) {
          const body = node.body;
          if (body.type === "EmptyStatement") {
            return;
          }
          if (body.type === "IfStatement") {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length === 0) {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length === 1 && body.body[0].type === "IfStatement") {
            return;
          }
          if (body.type === "BlockStatement" && body.body.length >= 1 && body.body[0].type === "IfStatement") {
            const i = body.body[0];
            if (i.consequent.type === "ContinueStatement") {
              return;
            }
            if (i.consequent.type === "BlockStatement" && i.consequent.body.length === 1 && i.consequent.body[0].type === "ContinueStatement") {
              return;
            }
          }
          context4.report({node, messageId: "wrap"});
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/handle-callback-err.js
var require_handle_callback_err = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "require error handling in callbacks",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/handle-callback-err"
      },
      schema: [
        {
          type: "string"
        }
      ],
      messages: {
        expected: "Expected error to be handled."
      }
    },
    create(context4) {
      const errorArgument = context4.options[0] || "err";
      function isPattern(stringToCheck) {
        const firstChar = stringToCheck[0];
        return firstChar === "^";
      }
      function matchesConfiguredErrorName(name) {
        if (isPattern(errorArgument)) {
          const regexp = new RegExp(errorArgument, "u");
          return regexp.test(name);
        }
        return name === errorArgument;
      }
      function getParameters(scope) {
        return scope.variables.filter((variable) => variable.defs[0] && variable.defs[0].type === "Parameter");
      }
      function checkForError(node) {
        const scope = context4.getScope(), parameters = getParameters(scope), firstParameter = parameters[0];
        if (firstParameter && matchesConfiguredErrorName(firstParameter.name)) {
          if (firstParameter.references.length === 0) {
            context4.report({node, messageId: "expected"});
          }
        }
      }
      return {
        FunctionDeclaration: checkForError,
        FunctionExpression: checkForError,
        ArrowFunctionExpression: checkForError
      };
    }
  };
});

// node_modules/eslint/lib/rules/id-blacklist.js
var require_id_blacklist = __commonJS((exports2, module2) => {
  "use strict";
  function isAssignmentTarget(node) {
    const parent = node.parent;
    return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node;
  }
  function isRenamedImport(node) {
    const parent = node.parent;
    return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && parent.local !== parent.exported && parent.local === node;
  }
  function isRenamedInDestructuring(node) {
    const parent = node.parent;
    return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node && parent.key === node;
  }
  function isShorthandPropertyDefinition(node) {
    const parent = node.parent;
    return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
  }
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: ["id-denylist"],
      type: "suggestion",
      docs: {
        description: "disallow specified identifiers",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/id-blacklist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted."
      }
    },
    create(context4) {
      const denyList = new Set(context4.options);
      const reportedNodes = new Set();
      let globalScope;
      function isRestricted(name) {
        return denyList.has(name);
      }
      function isReferenceToGlobalVariable(node) {
        const variable = globalScope.set.get(node.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
      }
      function shouldCheck(node) {
        const parent = node.parent;
        if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
          return isAssignmentTarget(parent);
        }
        return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));
      }
      function report(node) {
        if (!reportedNodes.has(node)) {
          context4.report({
            node,
            messageId: "restricted",
            data: {
              name: node.name
            }
          });
          reportedNodes.add(node);
        }
      }
      return {
        Program() {
          globalScope = context4.getScope();
        },
        Identifier(node) {
          if (isRestricted(node.name) && shouldCheck(node)) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/id-denylist.js
var require_id_denylist = __commonJS((exports2, module2) => {
  "use strict";
  function isAssignmentTarget(node) {
    const parent = node.parent;
    return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "RestElement" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "AssignmentPattern" && parent.left === node;
  }
  function isRenamedImport(node) {
    const parent = node.parent;
    return parent.type === "ImportSpecifier" && parent.imported !== parent.local && parent.imported === node || parent.type === "ExportSpecifier" && parent.parent.source && parent.local !== parent.exported && parent.local === node;
  }
  function isRenamedInDestructuring(node) {
    const parent = node.parent;
    return !parent.computed && parent.type === "Property" && parent.parent.type === "ObjectPattern" && parent.value !== node && parent.key === node;
  }
  function isShorthandPropertyDefinition(node) {
    const parent = node.parent;
    return parent.type === "Property" && parent.parent.type === "ObjectExpression" && parent.shorthand;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified identifiers",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/id-denylist"
      },
      schema: {
        type: "array",
        items: {
          type: "string"
        },
        uniqueItems: true
      },
      messages: {
        restricted: "Identifier '{{name}}' is restricted."
      }
    },
    create(context4) {
      const denyList = new Set(context4.options);
      const reportedNodes = new Set();
      let globalScope;
      function isRestricted(name) {
        return denyList.has(name);
      }
      function isReferenceToGlobalVariable(node) {
        const variable = globalScope.set.get(node.name);
        return variable && variable.defs.length === 0 && variable.references.some((ref) => ref.identifier === node);
      }
      function shouldCheck(node) {
        const parent = node.parent;
        if (parent.type === "MemberExpression" && parent.property === node && !parent.computed) {
          return isAssignmentTarget(parent);
        }
        return parent.type !== "CallExpression" && parent.type !== "NewExpression" && !isRenamedImport(node) && !isRenamedInDestructuring(node) && !(isReferenceToGlobalVariable(node) && !isShorthandPropertyDefinition(node));
      }
      function report(node) {
        if (!reportedNodes.has(node)) {
          context4.report({
            node,
            messageId: "restricted",
            data: {
              name: node.name
            }
          });
          reportedNodes.add(node);
        }
      }
      return {
        Program() {
          globalScope = context4.getScope();
        },
        Identifier(node) {
          if (isRestricted(node.name) && shouldCheck(node)) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/id-length.js
var require_id_length = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce minimum and maximum identifier lengths",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/id-length"
      },
      schema: [
        {
          type: "object",
          properties: {
            min: {
              type: "integer",
              default: 2
            },
            max: {
              type: "integer"
            },
            exceptions: {
              type: "array",
              uniqueItems: true,
              items: {
                type: "string"
              }
            },
            exceptionPatterns: {
              type: "array",
              uniqueItems: true,
              items: {
                type: "string"
              }
            },
            properties: {
              enum: ["always", "never"]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        tooShort: "Identifier name '{{name}}' is too short (< {{min}}).",
        tooLong: "Identifier name '{{name}}' is too long (> {{max}})."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const minLength = typeof options.min !== "undefined" ? options.min : 2;
      const maxLength = typeof options.max !== "undefined" ? options.max : Infinity;
      const properties = options.properties !== "never";
      const exceptions = new Set(options.exceptions);
      const exceptionPatterns = (options.exceptionPatterns || []).map((pattern) => new RegExp(pattern, "u"));
      const reportedNode = new Set();
      function matchesExceptionPattern(name) {
        return exceptionPatterns.some((pattern) => pattern.test(name));
      }
      const SUPPORTED_EXPRESSIONS = {
        MemberExpression: properties && function(parent) {
          return !parent.computed && (parent.parent.left === parent && parent.parent.type === "AssignmentExpression" || parent.parent.type === "Property" && parent.parent.value === parent && parent.parent.parent.type === "ObjectPattern" && parent.parent.parent.parent.left === parent.parent.parent);
        },
        AssignmentPattern(parent, node) {
          return parent.left === node;
        },
        VariableDeclarator(parent, node) {
          return parent.id === node;
        },
        Property(parent, node) {
          if (parent.parent.type === "ObjectPattern") {
            return parent.value !== parent.key && parent.value === node || parent.value === parent.key && parent.key === node && properties;
          }
          return properties && !parent.computed && parent.key === node;
        },
        ImportDefaultSpecifier: true,
        RestElement: true,
        FunctionExpression: true,
        ArrowFunctionExpression: true,
        ClassDeclaration: true,
        FunctionDeclaration: true,
        MethodDefinition: true,
        CatchClause: true,
        ArrayPattern: true
      };
      return {
        Identifier(node) {
          const name = node.name;
          const parent = node.parent;
          const isShort = name.length < minLength;
          const isLong = name.length > maxLength;
          if (!(isShort || isLong) || exceptions.has(name) || matchesExceptionPattern(name)) {
            return;
          }
          const isValidExpression = SUPPORTED_EXPRESSIONS[parent.type];
          if (isValidExpression && !reportedNode.has(node) && (isValidExpression === true || isValidExpression(parent, node))) {
            reportedNode.add(node);
            context4.report({
              node,
              messageId: isShort ? "tooShort" : "tooLong",
              data: {name, min: minLength, max: maxLength}
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/id-match.js
var require_id_match = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require identifiers to match a specified regular expression",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/id-match"
      },
      schema: [
        {
          type: "string"
        },
        {
          type: "object",
          properties: {
            properties: {
              type: "boolean",
              default: false
            },
            onlyDeclarations: {
              type: "boolean",
              default: false
            },
            ignoreDestructuring: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        notMatch: "Identifier '{{name}}' does not match the pattern '{{pattern}}'."
      }
    },
    create(context4) {
      const pattern = context4.options[0] || "^.+$", regexp = new RegExp(pattern, "u");
      const options = context4.options[1] || {}, properties = !!options.properties, onlyDeclarations = !!options.onlyDeclarations, ignoreDestructuring = !!options.ignoreDestructuring;
      const reported = new Map();
      const ALLOWED_PARENT_TYPES = new Set(["CallExpression", "NewExpression"]);
      const DECLARATION_TYPES = new Set(["FunctionDeclaration", "VariableDeclarator"]);
      const IMPORT_TYPES = new Set(["ImportSpecifier", "ImportNamespaceSpecifier", "ImportDefaultSpecifier"]);
      function isInvalid(name) {
        return !regexp.test(name);
      }
      function isInsideObjectPattern(node) {
        let {parent} = node;
        while (parent) {
          if (parent.type === "ObjectPattern") {
            return true;
          }
          parent = parent.parent;
        }
        return false;
      }
      function shouldReport(effectiveParent, name) {
        return (!onlyDeclarations || DECLARATION_TYPES.has(effectiveParent.type)) && !ALLOWED_PARENT_TYPES.has(effectiveParent.type) && isInvalid(name);
      }
      function report(node) {
        if (!reported.has(node)) {
          context4.report({
            node,
            messageId: "notMatch",
            data: {
              name: node.name,
              pattern
            }
          });
          reported.set(node, true);
        }
      }
      return {
        Identifier(node) {
          const name = node.name, parent = node.parent, effectiveParent = parent.type === "MemberExpression" ? parent.parent : parent;
          if (parent.type === "MemberExpression") {
            if (!properties) {
              return;
            }
            if (parent.object.type === "Identifier" && parent.object.name === name) {
              if (isInvalid(name)) {
                report(node);
              }
            } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.left.type === "MemberExpression" && effectiveParent.left.property.name === node.name) {
              if (isInvalid(name)) {
                report(node);
              }
            } else if (effectiveParent.type === "AssignmentExpression" && effectiveParent.right.type !== "MemberExpression") {
              if (isInvalid(name)) {
                report(node);
              }
            }
          } else if (parent.type === "Property" || parent.type === "AssignmentPattern") {
            if (parent.parent && parent.parent.type === "ObjectPattern") {
              if (parent.shorthand && parent.value.left && isInvalid(name)) {
                report(node);
              }
              const assignmentKeyEqualsValue = parent.key.name === parent.value.name;
              if (!assignmentKeyEqualsValue && parent.key === node) {
                return;
              }
              const valueIsInvalid = parent.value.name && isInvalid(name);
              if (valueIsInvalid && !(assignmentKeyEqualsValue && ignoreDestructuring)) {
                report(node);
              }
            }
            if (!properties || ignoreDestructuring && isInsideObjectPattern(node)) {
              return;
            }
            if (parent.right !== node && shouldReport(effectiveParent, name)) {
              report(node);
            }
          } else if (IMPORT_TYPES.has(parent.type)) {
            if (parent.local && parent.local.name === node.name && isInvalid(name)) {
              report(node);
            }
          } else if (shouldReport(effectiveParent, name)) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/implicit-arrow-linebreak.js
var require_implicit_arrow_linebreak = __commonJS((exports2, module2) => {
  "use strict";
  var {isCommentToken, isNotOpeningParenToken} = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce the location of arrow function bodies",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/implicit-arrow-linebreak"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["beside", "below"]
        }
      ],
      messages: {
        expected: "Expected a linebreak before this expression.",
        unexpected: "Expected no linebreak before this expression."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const option = context4.options[0] || "beside";
      function validateExpression(node) {
        if (node.body.type === "BlockStatement") {
          return;
        }
        const arrowToken = sourceCode.getTokenBefore(node.body, isNotOpeningParenToken);
        const firstTokenOfBody = sourceCode.getTokenAfter(arrowToken);
        if (arrowToken.loc.end.line === firstTokenOfBody.loc.start.line && option === "below") {
          context4.report({
            node: firstTokenOfBody,
            messageId: "expected",
            fix: (fixer) => fixer.insertTextBefore(firstTokenOfBody, "\n")
          });
        } else if (arrowToken.loc.end.line !== firstTokenOfBody.loc.start.line && option === "beside") {
          context4.report({
            node: firstTokenOfBody,
            messageId: "unexpected",
            fix(fixer) {
              if (sourceCode.getFirstTokenBetween(arrowToken, firstTokenOfBody, {includeComments: true, filter: isCommentToken})) {
                return null;
              }
              return fixer.replaceTextRange([arrowToken.range[1], firstTokenOfBody.range[0]], " ");
            }
          });
        }
      }
      return {
        ArrowFunctionExpression: (node) => validateExpression(node)
      };
    }
  };
});

// node_modules/functional-red-black-tree/rbtree.js
var require_rbtree = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = createRBTree;
  var RED = 0;
  var BLACK = 1;
  function RBNode(color, key, value, left, right, count) {
    this._color = color;
    this.key = key;
    this.value = value;
    this.left = left;
    this.right = right;
    this._count = count;
  }
  function cloneNode(node) {
    return new RBNode(node._color, node.key, node.value, node.left, node.right, node._count);
  }
  function repaint(color, node) {
    return new RBNode(color, node.key, node.value, node.left, node.right, node._count);
  }
  function recount(node) {
    node._count = 1 + (node.left ? node.left._count : 0) + (node.right ? node.right._count : 0);
  }
  function RedBlackTree(compare, root) {
    this._compare = compare;
    this.root = root;
  }
  var proto = RedBlackTree.prototype;
  Object.defineProperty(proto, "keys", {
    get: function() {
      var result = [];
      this.forEach(function(k, v) {
        result.push(k);
      });
      return result;
    }
  });
  Object.defineProperty(proto, "values", {
    get: function() {
      var result = [];
      this.forEach(function(k, v) {
        result.push(v);
      });
      return result;
    }
  });
  Object.defineProperty(proto, "length", {
    get: function() {
      if (this.root) {
        return this.root._count;
      }
      return 0;
    }
  });
  proto.insert = function(key, value) {
    var cmp = this._compare;
    var n = this.root;
    var n_stack = [];
    var d_stack = [];
    while (n) {
      var d = cmp(key, n.key);
      n_stack.push(n);
      d_stack.push(d);
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    n_stack.push(new RBNode(RED, key, value, null, null, 1));
    for (var s = n_stack.length - 2; s >= 0; --s) {
      var n = n_stack[s];
      if (d_stack[s] <= 0) {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n_stack[s + 1], n.right, n._count + 1);
      } else {
        n_stack[s] = new RBNode(n._color, n.key, n.value, n.left, n_stack[s + 1], n._count + 1);
      }
    }
    for (var s = n_stack.length - 1; s > 1; --s) {
      var p = n_stack[s - 1];
      var n = n_stack[s];
      if (p._color === BLACK || n._color === BLACK) {
        break;
      }
      var pp = n_stack[s - 2];
      if (pp.left === p) {
        if (p.left === n) {
          var y = pp.right;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            pp._color = RED;
            pp.left = p.right;
            p._color = BLACK;
            p.right = pp;
            n_stack[s - 2] = p;
            n_stack[s - 1] = n;
            recount(pp);
            recount(p);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.left === pp) {
                ppp.left = p;
              } else {
                ppp.right = p;
              }
            }
            break;
          }
        } else {
          var y = pp.right;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.right = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            p.right = n.left;
            pp._color = RED;
            pp.left = n.right;
            n._color = BLACK;
            n.left = p;
            n.right = pp;
            n_stack[s - 2] = n;
            n_stack[s - 1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.left === pp) {
                ppp.left = n;
              } else {
                ppp.right = n;
              }
            }
            break;
          }
        }
      } else {
        if (p.right === n) {
          var y = pp.left;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            pp._color = RED;
            pp.right = p.left;
            p._color = BLACK;
            p.left = pp;
            n_stack[s - 2] = p;
            n_stack[s - 1] = n;
            recount(pp);
            recount(p);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.right === pp) {
                ppp.right = p;
              } else {
                ppp.left = p;
              }
            }
            break;
          }
        } else {
          var y = pp.left;
          if (y && y._color === RED) {
            p._color = BLACK;
            pp.left = repaint(BLACK, y);
            pp._color = RED;
            s -= 1;
          } else {
            p.left = n.right;
            pp._color = RED;
            pp.right = n.left;
            n._color = BLACK;
            n.right = p;
            n.left = pp;
            n_stack[s - 2] = n;
            n_stack[s - 1] = p;
            recount(pp);
            recount(p);
            recount(n);
            if (s >= 3) {
              var ppp = n_stack[s - 3];
              if (ppp.right === pp) {
                ppp.right = n;
              } else {
                ppp.left = n;
              }
            }
            break;
          }
        }
      }
    }
    n_stack[0]._color = BLACK;
    return new RedBlackTree(cmp, n_stack[0]);
  };
  function doVisitFull(visit, node) {
    if (node.left) {
      var v = doVisitFull(visit, node.left);
      if (v) {
        return v;
      }
    }
    var v = visit(node.key, node.value);
    if (v) {
      return v;
    }
    if (node.right) {
      return doVisitFull(visit, node.right);
    }
  }
  function doVisitHalf(lo, compare, visit, node) {
    var l = compare(lo, node.key);
    if (l <= 0) {
      if (node.left) {
        var v = doVisitHalf(lo, compare, visit, node.left);
        if (v) {
          return v;
        }
      }
      var v = visit(node.key, node.value);
      if (v) {
        return v;
      }
    }
    if (node.right) {
      return doVisitHalf(lo, compare, visit, node.right);
    }
  }
  function doVisit(lo, hi, compare, visit, node) {
    var l = compare(lo, node.key);
    var h = compare(hi, node.key);
    var v;
    if (l <= 0) {
      if (node.left) {
        v = doVisit(lo, hi, compare, visit, node.left);
        if (v) {
          return v;
        }
      }
      if (h > 0) {
        v = visit(node.key, node.value);
        if (v) {
          return v;
        }
      }
    }
    if (h > 0 && node.right) {
      return doVisit(lo, hi, compare, visit, node.right);
    }
  }
  proto.forEach = function rbTreeForEach(visit, lo, hi) {
    if (!this.root) {
      return;
    }
    switch (arguments.length) {
      case 1:
        return doVisitFull(visit, this.root);
        break;
      case 2:
        return doVisitHalf(lo, this._compare, visit, this.root);
        break;
      case 3:
        if (this._compare(lo, hi) >= 0) {
          return;
        }
        return doVisit(lo, hi, this._compare, visit, this.root);
        break;
    }
  };
  Object.defineProperty(proto, "begin", {
    get: function() {
      var stack = [];
      var n = this.root;
      while (n) {
        stack.push(n);
        n = n.left;
      }
      return new RedBlackTreeIterator(this, stack);
    }
  });
  Object.defineProperty(proto, "end", {
    get: function() {
      var stack = [];
      var n = this.root;
      while (n) {
        stack.push(n);
        n = n.right;
      }
      return new RedBlackTreeIterator(this, stack);
    }
  });
  proto.at = function(idx) {
    if (idx < 0) {
      return new RedBlackTreeIterator(this, []);
    }
    var n = this.root;
    var stack = [];
    while (true) {
      stack.push(n);
      if (n.left) {
        if (idx < n.left._count) {
          n = n.left;
          continue;
        }
        idx -= n.left._count;
      }
      if (!idx) {
        return new RedBlackTreeIterator(this, stack);
      }
      idx -= 1;
      if (n.right) {
        if (idx >= n.right._count) {
          break;
        }
        n = n.right;
      } else {
        break;
      }
    }
    return new RedBlackTreeIterator(this, []);
  };
  proto.ge = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d <= 0) {
        last_ptr = stack.length;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.gt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d < 0) {
        last_ptr = stack.length;
      }
      if (d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.lt = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d > 0) {
        last_ptr = stack.length;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.le = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    var last_ptr = 0;
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d >= 0) {
        last_ptr = stack.length;
      }
      if (d < 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    stack.length = last_ptr;
    return new RedBlackTreeIterator(this, stack);
  };
  proto.find = function(key) {
    var cmp = this._compare;
    var n = this.root;
    var stack = [];
    while (n) {
      var d = cmp(key, n.key);
      stack.push(n);
      if (d === 0) {
        return new RedBlackTreeIterator(this, stack);
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return new RedBlackTreeIterator(this, []);
  };
  proto.remove = function(key) {
    var iter = this.find(key);
    if (iter) {
      return iter.remove();
    }
    return this;
  };
  proto.get = function(key) {
    var cmp = this._compare;
    var n = this.root;
    while (n) {
      var d = cmp(key, n.key);
      if (d === 0) {
        return n.value;
      }
      if (d <= 0) {
        n = n.left;
      } else {
        n = n.right;
      }
    }
    return;
  };
  function RedBlackTreeIterator(tree, stack) {
    this.tree = tree;
    this._stack = stack;
  }
  var iproto = RedBlackTreeIterator.prototype;
  Object.defineProperty(iproto, "valid", {
    get: function() {
      return this._stack.length > 0;
    }
  });
  Object.defineProperty(iproto, "node", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1];
      }
      return null;
    },
    enumerable: true
  });
  iproto.clone = function() {
    return new RedBlackTreeIterator(this.tree, this._stack.slice());
  };
  function swapNode(n, v) {
    n.key = v.key;
    n.value = v.value;
    n.left = v.left;
    n.right = v.right;
    n._color = v._color;
    n._count = v._count;
  }
  function fixDoubleBlack(stack) {
    var n, p, s, z;
    for (var i = stack.length - 1; i >= 0; --i) {
      n = stack[i];
      if (i === 0) {
        n._color = BLACK;
        return;
      }
      p = stack[i - 1];
      if (p.left === n) {
        s = p.right;
        if (s.right && s.right._color === RED) {
          s = p.right = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.right = s.left;
          s.left = p;
          s.right = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i - 1] = s;
          return;
        } else if (s.left && s.left._color === RED) {
          s = p.right = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.right = z.left;
          s.left = z.right;
          z.left = p;
          z.right = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = z;
            } else {
              pp.right = z;
            }
          }
          stack[i - 1] = z;
          return;
        }
        if (s._color === BLACK) {
          if (p._color === RED) {
            p._color = BLACK;
            p.right = repaint(RED, s);
            return;
          } else {
            p.right = repaint(RED, s);
            continue;
          }
        } else {
          s = cloneNode(s);
          p.right = s.left;
          s.left = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.left === p) {
              pp.left = s;
            } else {
              pp.right = s;
            }
          }
          stack[i - 1] = s;
          stack[i] = p;
          if (i + 1 < stack.length) {
            stack[i + 1] = n;
          } else {
            stack.push(n);
          }
          i = i + 2;
        }
      } else {
        s = p.left;
        if (s.left && s.left._color === RED) {
          s = p.left = cloneNode(s);
          z = s.left = cloneNode(s.left);
          p.left = s.right;
          s.right = p;
          s.left = z;
          s._color = p._color;
          n._color = BLACK;
          p._color = BLACK;
          z._color = BLACK;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i - 1] = s;
          return;
        } else if (s.right && s.right._color === RED) {
          s = p.left = cloneNode(s);
          z = s.right = cloneNode(s.right);
          p.left = z.right;
          s.right = z.left;
          z.right = p;
          z.left = s;
          z._color = p._color;
          p._color = BLACK;
          s._color = BLACK;
          n._color = BLACK;
          recount(p);
          recount(s);
          recount(z);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = z;
            } else {
              pp.left = z;
            }
          }
          stack[i - 1] = z;
          return;
        }
        if (s._color === BLACK) {
          if (p._color === RED) {
            p._color = BLACK;
            p.left = repaint(RED, s);
            return;
          } else {
            p.left = repaint(RED, s);
            continue;
          }
        } else {
          s = cloneNode(s);
          p.left = s.right;
          s.right = p;
          s._color = p._color;
          p._color = RED;
          recount(p);
          recount(s);
          if (i > 1) {
            var pp = stack[i - 2];
            if (pp.right === p) {
              pp.right = s;
            } else {
              pp.left = s;
            }
          }
          stack[i - 1] = s;
          stack[i] = p;
          if (i + 1 < stack.length) {
            stack[i + 1] = n;
          } else {
            stack.push(n);
          }
          i = i + 2;
        }
      }
    }
  }
  iproto.remove = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return this.tree;
    }
    var cstack = new Array(stack.length);
    var n = stack[stack.length - 1];
    cstack[cstack.length - 1] = new RBNode(n._color, n.key, n.value, n.left, n.right, n._count);
    for (var i = stack.length - 2; i >= 0; --i) {
      var n = stack[i];
      if (n.left === stack[i + 1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
    }
    n = cstack[cstack.length - 1];
    if (n.left && n.right) {
      var split = cstack.length;
      n = n.left;
      while (n.right) {
        cstack.push(n);
        n = n.right;
      }
      var v = cstack[split - 1];
      cstack.push(new RBNode(n._color, v.key, v.value, n.left, n.right, n._count));
      cstack[split - 1].key = n.key;
      cstack[split - 1].value = n.value;
      for (var i = cstack.length - 2; i >= split; --i) {
        n = cstack[i];
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
      cstack[split - 1].left = cstack[split];
    }
    n = cstack[cstack.length - 1];
    if (n._color === RED) {
      var p = cstack[cstack.length - 2];
      if (p.left === n) {
        p.left = null;
      } else if (p.right === n) {
        p.right = null;
      }
      cstack.pop();
      for (var i = 0; i < cstack.length; ++i) {
        cstack[i]._count--;
      }
      return new RedBlackTree(this.tree._compare, cstack[0]);
    } else {
      if (n.left || n.right) {
        if (n.left) {
          swapNode(n, n.left);
        } else if (n.right) {
          swapNode(n, n.right);
        }
        n._color = BLACK;
        for (var i = 0; i < cstack.length - 1; ++i) {
          cstack[i]._count--;
        }
        return new RedBlackTree(this.tree._compare, cstack[0]);
      } else if (cstack.length === 1) {
        return new RedBlackTree(this.tree._compare, null);
      } else {
        for (var i = 0; i < cstack.length; ++i) {
          cstack[i]._count--;
        }
        var parent = cstack[cstack.length - 2];
        fixDoubleBlack(cstack);
        if (parent.left === n) {
          parent.left = null;
        } else {
          parent.right = null;
        }
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  };
  Object.defineProperty(iproto, "key", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1].key;
      }
      return;
    },
    enumerable: true
  });
  Object.defineProperty(iproto, "value", {
    get: function() {
      if (this._stack.length > 0) {
        return this._stack[this._stack.length - 1].value;
      }
      return;
    },
    enumerable: true
  });
  Object.defineProperty(iproto, "index", {
    get: function() {
      var idx = 0;
      var stack = this._stack;
      if (stack.length === 0) {
        var r = this.tree.root;
        if (r) {
          return r._count;
        }
        return 0;
      } else if (stack[stack.length - 1].left) {
        idx = stack[stack.length - 1].left._count;
      }
      for (var s = stack.length - 2; s >= 0; --s) {
        if (stack[s + 1] === stack[s].right) {
          ++idx;
          if (stack[s].left) {
            idx += stack[s].left._count;
          }
        }
      }
      return idx;
    },
    enumerable: true
  });
  iproto.next = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return;
    }
    var n = stack[stack.length - 1];
    if (n.right) {
      n = n.right;
      while (n) {
        stack.push(n);
        n = n.left;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].right === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  };
  Object.defineProperty(iproto, "hasNext", {
    get: function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return false;
      }
      if (stack[stack.length - 1].right) {
        return true;
      }
      for (var s = stack.length - 1; s > 0; --s) {
        if (stack[s - 1].left === stack[s]) {
          return true;
        }
      }
      return false;
    }
  });
  iproto.update = function(value) {
    var stack = this._stack;
    if (stack.length === 0) {
      throw new Error("Can't update empty node!");
    }
    var cstack = new Array(stack.length);
    var n = stack[stack.length - 1];
    cstack[cstack.length - 1] = new RBNode(n._color, n.key, value, n.left, n.right, n._count);
    for (var i = stack.length - 2; i >= 0; --i) {
      n = stack[i];
      if (n.left === stack[i + 1]) {
        cstack[i] = new RBNode(n._color, n.key, n.value, cstack[i + 1], n.right, n._count);
      } else {
        cstack[i] = new RBNode(n._color, n.key, n.value, n.left, cstack[i + 1], n._count);
      }
    }
    return new RedBlackTree(this.tree._compare, cstack[0]);
  };
  iproto.prev = function() {
    var stack = this._stack;
    if (stack.length === 0) {
      return;
    }
    var n = stack[stack.length - 1];
    if (n.left) {
      n = n.left;
      while (n) {
        stack.push(n);
        n = n.right;
      }
    } else {
      stack.pop();
      while (stack.length > 0 && stack[stack.length - 1].left === n) {
        n = stack[stack.length - 1];
        stack.pop();
      }
    }
  };
  Object.defineProperty(iproto, "hasPrev", {
    get: function() {
      var stack = this._stack;
      if (stack.length === 0) {
        return false;
      }
      if (stack[stack.length - 1].left) {
        return true;
      }
      for (var s = stack.length - 1; s > 0; --s) {
        if (stack[s - 1].right === stack[s]) {
          return true;
        }
      }
      return false;
    }
  });
  function defaultCompare(a, b) {
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  function createRBTree(compare) {
    return new RedBlackTree(compare || defaultCompare, null);
  }
});

// node_modules/eslint/lib/rules/indent.js
var require_indent = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  var createTree = require_rbtree();
  var KNOWN_NODES = new Set([
    "AssignmentExpression",
    "AssignmentPattern",
    "ArrayExpression",
    "ArrayPattern",
    "ArrowFunctionExpression",
    "AwaitExpression",
    "BlockStatement",
    "BinaryExpression",
    "BreakStatement",
    "CallExpression",
    "CatchClause",
    "ChainExpression",
    "ClassBody",
    "ClassDeclaration",
    "ClassExpression",
    "ConditionalExpression",
    "ContinueStatement",
    "DoWhileStatement",
    "DebuggerStatement",
    "EmptyStatement",
    "ExperimentalRestProperty",
    "ExperimentalSpreadProperty",
    "ExpressionStatement",
    "ForStatement",
    "ForInStatement",
    "ForOfStatement",
    "FunctionDeclaration",
    "FunctionExpression",
    "Identifier",
    "IfStatement",
    "Literal",
    "LabeledStatement",
    "LogicalExpression",
    "MemberExpression",
    "MetaProperty",
    "MethodDefinition",
    "NewExpression",
    "ObjectExpression",
    "ObjectPattern",
    "Program",
    "Property",
    "RestElement",
    "ReturnStatement",
    "SequenceExpression",
    "SpreadElement",
    "Super",
    "SwitchCase",
    "SwitchStatement",
    "TaggedTemplateExpression",
    "TemplateElement",
    "TemplateLiteral",
    "ThisExpression",
    "ThrowStatement",
    "TryStatement",
    "UnaryExpression",
    "UpdateExpression",
    "VariableDeclaration",
    "VariableDeclarator",
    "WhileStatement",
    "WithStatement",
    "YieldExpression",
    "JSXFragment",
    "JSXOpeningFragment",
    "JSXClosingFragment",
    "JSXIdentifier",
    "JSXNamespacedName",
    "JSXMemberExpression",
    "JSXEmptyExpression",
    "JSXExpressionContainer",
    "JSXElement",
    "JSXClosingElement",
    "JSXOpeningElement",
    "JSXAttribute",
    "JSXSpreadAttribute",
    "JSXText",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExportAllDeclaration",
    "ExportSpecifier",
    "ImportDeclaration",
    "ImportSpecifier",
    "ImportDefaultSpecifier",
    "ImportNamespaceSpecifier",
    "ImportExpression"
  ]);
  var BinarySearchTree = class {
    constructor() {
      this._rbTree = createTree();
    }
    insert(key, value) {
      const iterator = this._rbTree.find(key);
      if (iterator.valid) {
        this._rbTree = iterator.update(value);
      } else {
        this._rbTree = this._rbTree.insert(key, value);
      }
    }
    findLe(key) {
      const iterator = this._rbTree.le(key);
      return iterator && {key: iterator.key, value: iterator.value};
    }
    deleteRange(start, end) {
      if (start === end) {
        return;
      }
      const iterator = this._rbTree.ge(start);
      while (iterator.valid && iterator.key < end) {
        this._rbTree = this._rbTree.remove(iterator.key);
        iterator.next();
      }
    }
  };
  var TokenInfo = class {
    constructor(sourceCode) {
      this.sourceCode = sourceCode;
      this.firstTokensByLineNumber = sourceCode.tokensAndComments.reduce((map, token) => {
        if (!map.has(token.loc.start.line)) {
          map.set(token.loc.start.line, token);
        }
        if (!map.has(token.loc.end.line) && sourceCode.text.slice(token.range[1] - token.loc.end.column, token.range[1]).trim()) {
          map.set(token.loc.end.line, token);
        }
        return map;
      }, new Map());
    }
    getFirstTokenOfLine(token) {
      return this.firstTokensByLineNumber.get(token.loc.start.line);
    }
    isFirstTokenOfLine(token) {
      return this.getFirstTokenOfLine(token) === token;
    }
    getTokenIndent(token) {
      return this.sourceCode.text.slice(token.range[0] - token.loc.start.column, token.range[0]);
    }
  };
  var OffsetStorage = class {
    constructor(tokenInfo, indentSize, indentType) {
      this._tokenInfo = tokenInfo;
      this._indentSize = indentSize;
      this._indentType = indentType;
      this._tree = new BinarySearchTree();
      this._tree.insert(0, {offset: 0, from: null, force: false});
      this._lockedFirstTokens = new WeakMap();
      this._desiredIndentCache = new WeakMap();
      this._ignoredTokens = new WeakSet();
    }
    _getOffsetDescriptor(token) {
      return this._tree.findLe(token.range[0]).value;
    }
    matchOffsetOf(baseToken, offsetToken) {
      this._lockedFirstTokens.set(offsetToken, baseToken);
    }
    setDesiredOffset(token, fromToken, offset) {
      return this.setDesiredOffsets(token.range, fromToken, offset);
    }
    setDesiredOffsets(range, fromToken, offset, force) {
      const descriptorToInsert = {offset, from: fromToken, force};
      const descriptorAfterRange = this._tree.findLe(range[1]).value;
      const fromTokenIsInRange = fromToken && fromToken.range[0] >= range[0] && fromToken.range[1] <= range[1];
      const fromTokenDescriptor = fromTokenIsInRange && this._getOffsetDescriptor(fromToken);
      this._tree.deleteRange(range[0] + 1, range[1]);
      this._tree.insert(range[0], descriptorToInsert);
      if (fromTokenIsInRange) {
        this._tree.insert(fromToken.range[0], fromTokenDescriptor);
        this._tree.insert(fromToken.range[1], descriptorToInsert);
      }
      this._tree.insert(range[1], descriptorAfterRange);
    }
    getDesiredIndent(token) {
      if (!this._desiredIndentCache.has(token)) {
        if (this._ignoredTokens.has(token)) {
          this._desiredIndentCache.set(token, this._tokenInfo.getTokenIndent(token));
        } else if (this._lockedFirstTokens.has(token)) {
          const firstToken = this._lockedFirstTokens.get(token);
          this._desiredIndentCache.set(token, this.getDesiredIndent(this._tokenInfo.getFirstTokenOfLine(firstToken)) + this._indentType.repeat(firstToken.loc.start.column - this._tokenInfo.getFirstTokenOfLine(firstToken).loc.start.column));
        } else {
          const offsetInfo = this._getOffsetDescriptor(token);
          const offset = offsetInfo.from && offsetInfo.from.loc.start.line === token.loc.start.line && !/^\s*?\n/u.test(token.value) && !offsetInfo.force ? 0 : offsetInfo.offset * this._indentSize;
          this._desiredIndentCache.set(token, (offsetInfo.from ? this.getDesiredIndent(offsetInfo.from) : "") + this._indentType.repeat(offset));
        }
      }
      return this._desiredIndentCache.get(token);
    }
    ignoreToken(token) {
      if (this._tokenInfo.isFirstTokenOfLine(token)) {
        this._ignoredTokens.add(token);
      }
    }
    getFirstDependency(token) {
      return this._getOffsetDescriptor(token).from;
    }
  };
  var ELEMENT_LIST_SCHEMA = {
    oneOf: [
      {
        type: "integer",
        minimum: 0
      },
      {
        enum: ["first", "off"]
      }
    ]
  };
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent indentation",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/indent"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0,
              default: 0
            },
            VariableDeclarator: {
              oneOf: [
                ELEMENT_LIST_SCHEMA,
                {
                  type: "object",
                  properties: {
                    var: ELEMENT_LIST_SCHEMA,
                    let: ELEMENT_LIST_SCHEMA,
                    const: ELEMENT_LIST_SCHEMA
                  },
                  additionalProperties: false
                }
              ]
            },
            outerIIFEBody: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            MemberExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["off"]
                }
              ]
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: ELEMENT_LIST_SCHEMA,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: ELEMENT_LIST_SCHEMA,
                body: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            },
            CallExpression: {
              type: "object",
              properties: {
                arguments: ELEMENT_LIST_SCHEMA
              },
              additionalProperties: false
            },
            ArrayExpression: ELEMENT_LIST_SCHEMA,
            ObjectExpression: ELEMENT_LIST_SCHEMA,
            ImportDeclaration: ELEMENT_LIST_SCHEMA,
            flatTernaryExpressions: {
              type: "boolean",
              default: false
            },
            offsetTernaryExpressions: {
              type: "boolean",
              default: false
            },
            ignoredNodes: {
              type: "array",
              items: {
                type: "string",
                not: {
                  pattern: ":exit$"
                }
              }
            },
            ignoreComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        wrongIndentation: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(context4) {
      const DEFAULT_VARIABLE_INDENT = 1;
      const DEFAULT_PARAMETER_INDENT = 1;
      const DEFAULT_FUNCTION_BODY_INDENT = 1;
      let indentType = "space";
      let indentSize = 4;
      const options = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: DEFAULT_VARIABLE_INDENT,
          let: DEFAULT_VARIABLE_INDENT,
          const: DEFAULT_VARIABLE_INDENT
        },
        outerIIFEBody: 1,
        FunctionDeclaration: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        FunctionExpression: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        CallExpression: {
          arguments: DEFAULT_PARAMETER_INDENT
        },
        MemberExpression: 1,
        ArrayExpression: 1,
        ObjectExpression: 1,
        ImportDeclaration: 1,
        flatTernaryExpressions: false,
        ignoredNodes: [],
        ignoreComments: false
      };
      if (context4.options.length) {
        if (context4.options[0] === "tab") {
          indentSize = 1;
          indentType = "tab";
        } else {
          indentSize = context4.options[0];
          indentType = "space";
        }
        if (context4.options[1]) {
          Object.assign(options, context4.options[1]);
          if (typeof options.VariableDeclarator === "number" || options.VariableDeclarator === "first") {
            options.VariableDeclarator = {
              var: options.VariableDeclarator,
              let: options.VariableDeclarator,
              const: options.VariableDeclarator
            };
          }
        }
      }
      const sourceCode = context4.getSourceCode();
      const tokenInfo = new TokenInfo(sourceCode);
      const offsets = new OffsetStorage(tokenInfo, indentSize, indentType === "space" ? " " : "	");
      const parameterParens = new WeakSet();
      function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
        const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
        const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
        const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
        let foundStatement;
        if (actualSpaces > 0) {
          foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
        } else if (actualTabs > 0) {
          foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
        } else {
          foundStatement = "0";
        }
        return {
          expected: expectedStatement,
          actual: foundStatement
        };
      }
      function report(token, neededIndent) {
        const actualIndent = Array.from(tokenInfo.getTokenIndent(token));
        const numSpaces = actualIndent.filter((char) => char === " ").length;
        const numTabs = actualIndent.filter((char) => char === "	").length;
        context4.report({
          node: token,
          messageId: "wrongIndentation",
          data: createErrorMessageData(neededIndent.length, numSpaces, numTabs),
          loc: {
            start: {line: token.loc.start.line, column: 0},
            end: {line: token.loc.start.line, column: token.loc.start.column}
          },
          fix(fixer) {
            const range = [token.range[0] - token.loc.start.column, token.range[0]];
            const newText = neededIndent;
            return fixer.replaceTextRange(range, newText);
          }
        });
      }
      function validateTokenIndent(token, desiredIndent) {
        const indentation = tokenInfo.getTokenIndent(token);
        return indentation === desiredIndent || indentation.includes(" ") && indentation.includes("	");
      }
      function isOuterIIFE(node) {
        if (!node.parent || node.parent.type !== "CallExpression" || node.parent.callee !== node) {
          return false;
        }
        let statement = node.parent && node.parent.parent;
        while (statement.type === "UnaryExpression" && ["!", "~", "+", "-"].indexOf(statement.operator) > -1 || statement.type === "AssignmentExpression" || statement.type === "LogicalExpression" || statement.type === "SequenceExpression" || statement.type === "VariableDeclarator") {
          statement = statement.parent;
        }
        return (statement.type === "ExpressionStatement" || statement.type === "VariableDeclaration") && statement.parent.type === "Program";
      }
      function countTrailingLinebreaks(string) {
        const trailingWhitespace = string.match(/\s*$/u)[0];
        const linebreakMatches = trailingWhitespace.match(astUtils.createGlobalLinebreakMatcher());
        return linebreakMatches === null ? 0 : linebreakMatches.length;
      }
      function addElementListIndent(elements, startToken, endToken, offset) {
        function getFirstToken(element) {
          let token = sourceCode.getTokenBefore(element);
          while (astUtils.isOpeningParenToken(token) && token !== startToken) {
            token = sourceCode.getTokenBefore(token);
          }
          return sourceCode.getTokenAfter(token);
        }
        offsets.setDesiredOffsets([startToken.range[1], endToken.range[0]], startToken, typeof offset === "number" ? offset : 1);
        offsets.setDesiredOffset(endToken, startToken, 0);
        if (offset === "first" && elements.length && !elements[0]) {
          return;
        }
        elements.forEach((element, index) => {
          if (!element) {
            return;
          }
          if (offset === "off") {
            offsets.ignoreToken(getFirstToken(element));
          }
          if (index === 0) {
            return;
          }
          if (offset === "first" && tokenInfo.isFirstTokenOfLine(getFirstToken(element))) {
            offsets.matchOffsetOf(getFirstToken(elements[0]), getFirstToken(element));
          } else {
            const previousElement = elements[index - 1];
            const firstTokenOfPreviousElement = previousElement && getFirstToken(previousElement);
            const previousElementLastToken = previousElement && sourceCode.getLastToken(previousElement);
            if (previousElement && previousElementLastToken.loc.end.line - countTrailingLinebreaks(previousElementLastToken.value) > startToken.loc.end.line) {
              offsets.setDesiredOffsets([previousElement.range[1], element.range[1]], firstTokenOfPreviousElement, 0);
            }
          }
        });
      }
      function addBlocklessNodeIndent(node) {
        if (node.type !== "BlockStatement") {
          const lastParentToken = sourceCode.getTokenBefore(node, astUtils.isNotOpeningParenToken);
          let firstBodyToken = sourceCode.getFirstToken(node);
          let lastBodyToken = sourceCode.getLastToken(node);
          while (astUtils.isOpeningParenToken(sourceCode.getTokenBefore(firstBodyToken)) && astUtils.isClosingParenToken(sourceCode.getTokenAfter(lastBodyToken))) {
            firstBodyToken = sourceCode.getTokenBefore(firstBodyToken);
            lastBodyToken = sourceCode.getTokenAfter(lastBodyToken);
          }
          offsets.setDesiredOffsets([firstBodyToken.range[0], lastBodyToken.range[1]], lastParentToken, 1);
          const lastToken = sourceCode.getLastToken(node);
          if (node.type !== "EmptyStatement" && astUtils.isSemicolonToken(lastToken)) {
            offsets.setDesiredOffset(lastToken, lastParentToken, 0);
          }
        }
      }
      function addFunctionCallIndent(node) {
        let openingParen;
        if (node.arguments.length) {
          openingParen = sourceCode.getFirstTokenBetween(node.callee, node.arguments[0], astUtils.isOpeningParenToken);
        } else {
          openingParen = sourceCode.getLastToken(node, 1);
        }
        const closingParen = sourceCode.getLastToken(node);
        parameterParens.add(openingParen);
        parameterParens.add(closingParen);
        if (node.optional) {
          const dotToken = sourceCode.getTokenAfter(node.callee, astUtils.isQuestionDotToken);
          const calleeParenCount = sourceCode.getTokensBetween(node.callee, dotToken, {filter: astUtils.isClosingParenToken}).length;
          const firstTokenOfCallee = calleeParenCount ? sourceCode.getTokenBefore(node.callee, {skip: calleeParenCount - 1}) : sourceCode.getFirstToken(node.callee);
          const lastTokenOfCallee = sourceCode.getTokenBefore(dotToken);
          const offsetBase = lastTokenOfCallee.loc.end.line === openingParen.loc.start.line ? lastTokenOfCallee : firstTokenOfCallee;
          offsets.setDesiredOffset(dotToken, offsetBase, 1);
        }
        const offsetAfterToken = node.callee.type === "TaggedTemplateExpression" ? sourceCode.getFirstToken(node.callee.quasi) : openingParen;
        const offsetToken = sourceCode.getTokenBefore(offsetAfterToken);
        offsets.setDesiredOffset(openingParen, offsetToken, 0);
        addElementListIndent(node.arguments, openingParen, closingParen, options.CallExpression.arguments);
      }
      function addParensIndent(tokens) {
        const parenStack = [];
        const parenPairs = [];
        tokens.forEach((nextToken) => {
          if (astUtils.isOpeningParenToken(nextToken)) {
            parenStack.push(nextToken);
          } else if (astUtils.isClosingParenToken(nextToken)) {
            parenPairs.unshift({left: parenStack.pop(), right: nextToken});
          }
        });
        parenPairs.forEach((pair) => {
          const leftParen = pair.left;
          const rightParen = pair.right;
          if (!parameterParens.has(leftParen) && !parameterParens.has(rightParen)) {
            const parenthesizedTokens = new Set(sourceCode.getTokensBetween(leftParen, rightParen));
            parenthesizedTokens.forEach((token) => {
              if (!parenthesizedTokens.has(offsets.getFirstDependency(token))) {
                offsets.setDesiredOffset(token, leftParen, 1);
              }
            });
          }
          offsets.setDesiredOffset(rightParen, leftParen, 0);
        });
      }
      function ignoreNode(node) {
        const unknownNodeTokens = new Set(sourceCode.getTokens(node, {includeComments: true}));
        unknownNodeTokens.forEach((token) => {
          if (!unknownNodeTokens.has(offsets.getFirstDependency(token))) {
            const firstTokenOfLine = tokenInfo.getFirstTokenOfLine(token);
            if (token === firstTokenOfLine) {
              offsets.ignoreToken(token);
            } else {
              offsets.setDesiredOffset(token, firstTokenOfLine, 0);
            }
          }
        });
      }
      function isOnFirstLineOfStatement(token, leafNode) {
        let node = leafNode;
        while (node.parent && !node.parent.type.endsWith("Statement") && !node.parent.type.endsWith("Declaration")) {
          node = node.parent;
        }
        node = node.parent;
        return !node || node.loc.start.line === token.loc.start.line;
      }
      function hasBlankLinesBetween(firstToken, secondToken) {
        const firstTokenLine = firstToken.loc.end.line;
        const secondTokenLine = secondToken.loc.start.line;
        if (firstTokenLine === secondTokenLine || firstTokenLine === secondTokenLine - 1) {
          return false;
        }
        for (let line = firstTokenLine + 1; line < secondTokenLine; ++line) {
          if (!tokenInfo.firstTokensByLineNumber.has(line)) {
            return true;
          }
        }
        return false;
      }
      const ignoredNodeFirstTokens = new Set();
      const baseOffsetListeners = {
        "ArrayExpression, ArrayPattern"(node) {
          const openingBracket = sourceCode.getFirstToken(node);
          const closingBracket = sourceCode.getTokenAfter(lodash.findLast(node.elements) || openingBracket, astUtils.isClosingBracketToken);
          addElementListIndent(node.elements, openingBracket, closingBracket, options.ArrayExpression);
        },
        "ObjectExpression, ObjectPattern"(node) {
          const openingCurly = sourceCode.getFirstToken(node);
          const closingCurly = sourceCode.getTokenAfter(node.properties.length ? node.properties[node.properties.length - 1] : openingCurly, astUtils.isClosingBraceToken);
          addElementListIndent(node.properties, openingCurly, closingCurly, options.ObjectExpression);
        },
        ArrowFunctionExpression(node) {
          const maybeOpeningParen = sourceCode.getFirstToken(node, {skip: node.async ? 1 : 0});
          if (astUtils.isOpeningParenToken(maybeOpeningParen)) {
            const openingParen = maybeOpeningParen;
            const closingParen = sourceCode.getTokenBefore(node.body, astUtils.isClosingParenToken);
            parameterParens.add(openingParen);
            parameterParens.add(closingParen);
            addElementListIndent(node.params, openingParen, closingParen, options.FunctionExpression.parameters);
          }
          addBlocklessNodeIndent(node.body);
        },
        AssignmentExpression(node) {
          const operator = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
          offsets.setDesiredOffsets([operator.range[0], node.range[1]], sourceCode.getLastToken(node.left), 1);
          offsets.ignoreToken(operator);
          offsets.ignoreToken(sourceCode.getTokenAfter(operator));
        },
        "BinaryExpression, LogicalExpression"(node) {
          const operator = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
          const tokenAfterOperator = sourceCode.getTokenAfter(operator);
          offsets.ignoreToken(operator);
          offsets.ignoreToken(tokenAfterOperator);
          offsets.setDesiredOffset(tokenAfterOperator, operator, 0);
        },
        "BlockStatement, ClassBody"(node) {
          let blockIndentLevel;
          if (node.parent && isOuterIIFE(node.parent)) {
            blockIndentLevel = options.outerIIFEBody;
          } else if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "ArrowFunctionExpression")) {
            blockIndentLevel = options.FunctionExpression.body;
          } else if (node.parent && node.parent.type === "FunctionDeclaration") {
            blockIndentLevel = options.FunctionDeclaration.body;
          } else {
            blockIndentLevel = 1;
          }
          if (!astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
            offsets.setDesiredOffset(sourceCode.getFirstToken(node), sourceCode.getFirstToken(node.parent), 0);
          }
          addElementListIndent(node.body, sourceCode.getFirstToken(node), sourceCode.getLastToken(node), blockIndentLevel);
        },
        CallExpression: addFunctionCallIndent,
        "ClassDeclaration[superClass], ClassExpression[superClass]"(node) {
          const classToken = sourceCode.getFirstToken(node);
          const extendsToken = sourceCode.getTokenBefore(node.superClass, astUtils.isNotOpeningParenToken);
          offsets.setDesiredOffsets([extendsToken.range[0], node.body.range[0]], classToken, 1);
        },
        ConditionalExpression(node) {
          const firstToken = sourceCode.getFirstToken(node);
          if (!options.flatTernaryExpressions || !astUtils.isTokenOnSameLine(node.test, node.consequent) || isOnFirstLineOfStatement(firstToken, node)) {
            const questionMarkToken = sourceCode.getFirstTokenBetween(node.test, node.consequent, (token) => token.type === "Punctuator" && token.value === "?");
            const colonToken = sourceCode.getFirstTokenBetween(node.consequent, node.alternate, (token) => token.type === "Punctuator" && token.value === ":");
            const firstConsequentToken = sourceCode.getTokenAfter(questionMarkToken);
            const lastConsequentToken = sourceCode.getTokenBefore(colonToken);
            const firstAlternateToken = sourceCode.getTokenAfter(colonToken);
            offsets.setDesiredOffset(questionMarkToken, firstToken, 1);
            offsets.setDesiredOffset(colonToken, firstToken, 1);
            offsets.setDesiredOffset(firstConsequentToken, firstToken, firstConsequentToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);
            if (lastConsequentToken.loc.end.line === firstAlternateToken.loc.start.line) {
              offsets.setDesiredOffset(firstAlternateToken, firstConsequentToken, 0);
            } else {
              offsets.setDesiredOffset(firstAlternateToken, firstToken, firstAlternateToken.type === "Punctuator" && options.offsetTernaryExpressions ? 2 : 1);
            }
          }
        },
        "DoWhileStatement, WhileStatement, ForInStatement, ForOfStatement": (node) => addBlocklessNodeIndent(node.body),
        ExportNamedDeclaration(node) {
          if (node.declaration === null) {
            const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
            addElementListIndent(node.specifiers, sourceCode.getFirstToken(node, {skip: 1}), closingCurly, 1);
            if (node.source) {
              offsets.setDesiredOffsets([closingCurly.range[1], node.range[1]], sourceCode.getFirstToken(node), 1);
            }
          }
        },
        ForStatement(node) {
          const forOpeningParen = sourceCode.getFirstToken(node, 1);
          if (node.init) {
            offsets.setDesiredOffsets(node.init.range, forOpeningParen, 1);
          }
          if (node.test) {
            offsets.setDesiredOffsets(node.test.range, forOpeningParen, 1);
          }
          if (node.update) {
            offsets.setDesiredOffsets(node.update.range, forOpeningParen, 1);
          }
          addBlocklessNodeIndent(node.body);
        },
        "FunctionDeclaration, FunctionExpression"(node) {
          const closingParen = sourceCode.getTokenBefore(node.body);
          const openingParen = sourceCode.getTokenBefore(node.params.length ? node.params[0] : closingParen);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          addElementListIndent(node.params, openingParen, closingParen, options[node.type].parameters);
        },
        IfStatement(node) {
          addBlocklessNodeIndent(node.consequent);
          if (node.alternate && node.alternate.type !== "IfStatement") {
            addBlocklessNodeIndent(node.alternate);
          }
        },
        ImportDeclaration(node) {
          if (node.specifiers.some((specifier) => specifier.type === "ImportSpecifier")) {
            const openingCurly = sourceCode.getFirstToken(node, astUtils.isOpeningBraceToken);
            const closingCurly = sourceCode.getLastToken(node, astUtils.isClosingBraceToken);
            addElementListIndent(node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier"), openingCurly, closingCurly, options.ImportDeclaration);
          }
          const fromToken = sourceCode.getLastToken(node, (token) => token.type === "Identifier" && token.value === "from");
          const sourceToken = sourceCode.getLastToken(node, (token) => token.type === "String");
          const semiToken = sourceCode.getLastToken(node, (token) => token.type === "Punctuator" && token.value === ";");
          if (fromToken) {
            const end = semiToken && semiToken.range[1] === sourceToken.range[1] ? node.range[1] : sourceToken.range[1];
            offsets.setDesiredOffsets([fromToken.range[0], end], sourceCode.getFirstToken(node), 1);
          }
        },
        ImportExpression(node) {
          const openingParen = sourceCode.getFirstToken(node, 1);
          const closingParen = sourceCode.getLastToken(node);
          parameterParens.add(openingParen);
          parameterParens.add(closingParen);
          offsets.setDesiredOffset(openingParen, sourceCode.getTokenBefore(openingParen), 0);
          addElementListIndent([node.source], openingParen, closingParen, options.CallExpression.arguments);
        },
        "MemberExpression, JSXMemberExpression, MetaProperty"(node) {
          const object = node.type === "MetaProperty" ? node.meta : node.object;
          const firstNonObjectToken = sourceCode.getFirstTokenBetween(object, node.property, astUtils.isNotClosingParenToken);
          const secondNonObjectToken = sourceCode.getTokenAfter(firstNonObjectToken);
          const objectParenCount = sourceCode.getTokensBetween(object, node.property, {filter: astUtils.isClosingParenToken}).length;
          const firstObjectToken = objectParenCount ? sourceCode.getTokenBefore(object, {skip: objectParenCount - 1}) : sourceCode.getFirstToken(object);
          const lastObjectToken = sourceCode.getTokenBefore(firstNonObjectToken);
          const firstPropertyToken = node.computed ? firstNonObjectToken : secondNonObjectToken;
          if (node.computed) {
            offsets.setDesiredOffset(sourceCode.getLastToken(node), firstNonObjectToken, 0);
            offsets.setDesiredOffsets(node.property.range, firstNonObjectToken, 1);
          }
          const offsetBase = lastObjectToken.loc.end.line === firstPropertyToken.loc.start.line ? lastObjectToken : firstObjectToken;
          if (typeof options.MemberExpression === "number") {
            offsets.setDesiredOffset(firstNonObjectToken, offsetBase, options.MemberExpression);
            offsets.setDesiredOffset(secondNonObjectToken, node.computed ? firstNonObjectToken : offsetBase, options.MemberExpression);
          } else {
            offsets.ignoreToken(firstNonObjectToken);
            offsets.ignoreToken(secondNonObjectToken);
            offsets.setDesiredOffset(firstNonObjectToken, offsetBase, 0);
            offsets.setDesiredOffset(secondNonObjectToken, firstNonObjectToken, 0);
          }
        },
        NewExpression(node) {
          if (node.arguments.length > 0 || astUtils.isClosingParenToken(sourceCode.getLastToken(node)) && astUtils.isOpeningParenToken(sourceCode.getLastToken(node, 1))) {
            addFunctionCallIndent(node);
          }
        },
        Property(node) {
          if (!node.shorthand && !node.method && node.kind === "init") {
            const colon = sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isColonToken);
            offsets.ignoreToken(sourceCode.getTokenAfter(colon));
          }
        },
        SwitchStatement(node) {
          const openingCurly = sourceCode.getTokenAfter(node.discriminant, astUtils.isOpeningBraceToken);
          const closingCurly = sourceCode.getLastToken(node);
          offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, options.SwitchCase);
          if (node.cases.length) {
            sourceCode.getTokensBetween(node.cases[node.cases.length - 1], closingCurly, {includeComments: true, filter: astUtils.isCommentToken}).forEach((token) => offsets.ignoreToken(token));
          }
        },
        SwitchCase(node) {
          if (!(node.consequent.length === 1 && node.consequent[0].type === "BlockStatement")) {
            const caseKeyword = sourceCode.getFirstToken(node);
            const tokenAfterCurrentCase = sourceCode.getTokenAfter(node);
            offsets.setDesiredOffsets([caseKeyword.range[1], tokenAfterCurrentCase.range[0]], caseKeyword, 1);
          }
        },
        TemplateLiteral(node) {
          node.expressions.forEach((expression, index) => {
            const previousQuasi = node.quasis[index];
            const nextQuasi = node.quasis[index + 1];
            const tokenToAlignFrom = previousQuasi.loc.start.line === previousQuasi.loc.end.line ? sourceCode.getFirstToken(previousQuasi) : null;
            offsets.setDesiredOffsets([previousQuasi.range[1], nextQuasi.range[0]], tokenToAlignFrom, 1);
            offsets.setDesiredOffset(sourceCode.getFirstToken(nextQuasi), tokenToAlignFrom, 0);
          });
        },
        VariableDeclaration(node) {
          let variableIndent = Object.prototype.hasOwnProperty.call(options.VariableDeclarator, node.kind) ? options.VariableDeclarator[node.kind] : DEFAULT_VARIABLE_INDENT;
          const firstToken = sourceCode.getFirstToken(node), lastToken = sourceCode.getLastToken(node);
          if (options.VariableDeclarator[node.kind] === "first") {
            if (node.declarations.length > 1) {
              addElementListIndent(node.declarations, firstToken, lastToken, "first");
              return;
            }
            variableIndent = DEFAULT_VARIABLE_INDENT;
          }
          if (node.declarations[node.declarations.length - 1].loc.start.line > node.loc.start.line) {
            offsets.setDesiredOffsets(node.range, firstToken, variableIndent, true);
          } else {
            offsets.setDesiredOffsets(node.range, firstToken, variableIndent);
          }
          if (astUtils.isSemicolonToken(lastToken)) {
            offsets.ignoreToken(lastToken);
          }
        },
        VariableDeclarator(node) {
          if (node.init) {
            const equalOperator = sourceCode.getTokenBefore(node.init, astUtils.isNotOpeningParenToken);
            const tokenAfterOperator = sourceCode.getTokenAfter(equalOperator);
            offsets.ignoreToken(equalOperator);
            offsets.ignoreToken(tokenAfterOperator);
            offsets.setDesiredOffsets([tokenAfterOperator.range[0], node.range[1]], equalOperator, 1);
            offsets.setDesiredOffset(equalOperator, sourceCode.getLastToken(node.id), 0);
          }
        },
        "JSXAttribute[value]"(node) {
          const equalsToken = sourceCode.getFirstTokenBetween(node.name, node.value, (token) => token.type === "Punctuator" && token.value === "=");
          offsets.setDesiredOffsets([equalsToken.range[0], node.value.range[1]], sourceCode.getFirstToken(node.name), 1);
        },
        JSXElement(node) {
          if (node.closingElement) {
            addElementListIndent(node.children, sourceCode.getFirstToken(node.openingElement), sourceCode.getFirstToken(node.closingElement), 1);
          }
        },
        JSXOpeningElement(node) {
          const firstToken = sourceCode.getFirstToken(node);
          let closingToken;
          if (node.selfClosing) {
            closingToken = sourceCode.getLastToken(node, {skip: 1});
            offsets.setDesiredOffset(sourceCode.getLastToken(node), closingToken, 0);
          } else {
            closingToken = sourceCode.getLastToken(node);
          }
          offsets.setDesiredOffsets(node.name.range, sourceCode.getFirstToken(node));
          addElementListIndent(node.attributes, firstToken, closingToken, 1);
        },
        JSXClosingElement(node) {
          const firstToken = sourceCode.getFirstToken(node);
          offsets.setDesiredOffsets(node.name.range, firstToken, 1);
        },
        JSXFragment(node) {
          const firstOpeningToken = sourceCode.getFirstToken(node.openingFragment);
          const firstClosingToken = sourceCode.getFirstToken(node.closingFragment);
          addElementListIndent(node.children, firstOpeningToken, firstClosingToken, 1);
        },
        JSXOpeningFragment(node) {
          const firstToken = sourceCode.getFirstToken(node);
          const closingToken = sourceCode.getLastToken(node);
          offsets.setDesiredOffsets(node.range, firstToken, 1);
          offsets.matchOffsetOf(firstToken, closingToken);
        },
        JSXClosingFragment(node) {
          const firstToken = sourceCode.getFirstToken(node);
          const slashToken = sourceCode.getLastToken(node, {skip: 1});
          const closingToken = sourceCode.getLastToken(node);
          const tokenToMatch = astUtils.isTokenOnSameLine(slashToken, closingToken) ? slashToken : closingToken;
          offsets.setDesiredOffsets(node.range, firstToken, 1);
          offsets.matchOffsetOf(firstToken, tokenToMatch);
        },
        JSXExpressionContainer(node) {
          const openingCurly = sourceCode.getFirstToken(node);
          const closingCurly = sourceCode.getLastToken(node);
          offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
        },
        JSXSpreadAttribute(node) {
          const openingCurly = sourceCode.getFirstToken(node);
          const closingCurly = sourceCode.getLastToken(node);
          offsets.setDesiredOffsets([openingCurly.range[1], closingCurly.range[0]], openingCurly, 1);
        },
        "*"(node) {
          const firstToken = sourceCode.getFirstToken(node);
          if (firstToken && !ignoredNodeFirstTokens.has(firstToken)) {
            offsets.setDesiredOffsets(node.range, firstToken, 0);
          }
        }
      };
      const listenerCallQueue = [];
      const offsetListeners = lodash.mapValues(baseOffsetListeners, (listener) => (node) => listenerCallQueue.push({listener, node}));
      const ignoredNodes = new Set();
      function addToIgnoredNodes(node) {
        ignoredNodes.add(node);
        ignoredNodeFirstTokens.add(sourceCode.getFirstToken(node));
      }
      const ignoredNodeListeners = options.ignoredNodes.reduce((listeners, ignoredSelector) => Object.assign(listeners, {[ignoredSelector]: addToIgnoredNodes}), {});
      return Object.assign(offsetListeners, ignoredNodeListeners, {
        "*:exit"(node) {
          if (!KNOWN_NODES.has(node.type)) {
            addToIgnoredNodes(node);
          }
        },
        "Program:exit"() {
          if (options.ignoreComments) {
            sourceCode.getAllComments().forEach((comment) => offsets.ignoreToken(comment));
          }
          listenerCallQueue.filter((nodeInfo) => !ignoredNodes.has(nodeInfo.node)).forEach((nodeInfo) => nodeInfo.listener(nodeInfo.node));
          ignoredNodes.forEach(ignoreNode);
          addParensIndent(sourceCode.ast.tokens);
          const precedingTokens = sourceCode.ast.comments.reduce((commentMap, comment) => {
            const tokenOrCommentBefore = sourceCode.getTokenBefore(comment, {includeComments: true});
            return commentMap.set(comment, commentMap.has(tokenOrCommentBefore) ? commentMap.get(tokenOrCommentBefore) : tokenOrCommentBefore);
          }, new WeakMap());
          sourceCode.lines.forEach((line, lineIndex) => {
            const lineNumber = lineIndex + 1;
            if (!tokenInfo.firstTokensByLineNumber.has(lineNumber)) {
              return;
            }
            const firstTokenOfLine = tokenInfo.firstTokensByLineNumber.get(lineNumber);
            if (firstTokenOfLine.loc.start.line !== lineNumber) {
              return;
            }
            if (astUtils.isCommentToken(firstTokenOfLine)) {
              const tokenBefore = precedingTokens.get(firstTokenOfLine);
              const tokenAfter = tokenBefore ? sourceCode.getTokenAfter(tokenBefore) : sourceCode.ast.tokens[0];
              const mayAlignWithBefore = tokenBefore && !hasBlankLinesBetween(tokenBefore, firstTokenOfLine);
              const mayAlignWithAfter = tokenAfter && !hasBlankLinesBetween(firstTokenOfLine, tokenAfter);
              if (tokenAfter && astUtils.isSemicolonToken(tokenAfter) && !astUtils.isTokenOnSameLine(firstTokenOfLine, tokenAfter)) {
                offsets.setDesiredOffset(firstTokenOfLine, tokenAfter, 0);
              }
              if (mayAlignWithBefore && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenBefore)) || mayAlignWithAfter && validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(tokenAfter))) {
                return;
              }
            }
            if (validateTokenIndent(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine))) {
              return;
            }
            report(firstTokenOfLine, offsets.getDesiredIndent(firstTokenOfLine));
          });
        }
      });
    }
  };
});

// node_modules/eslint/lib/rules/indent-legacy.js
var require_indent_legacy = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent indentation",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/indent-legacy"
      },
      deprecated: true,
      replacedBy: ["indent"],
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["tab"]
            },
            {
              type: "integer",
              minimum: 0
            }
          ]
        },
        {
          type: "object",
          properties: {
            SwitchCase: {
              type: "integer",
              minimum: 0
            },
            VariableDeclarator: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  type: "object",
                  properties: {
                    var: {
                      type: "integer",
                      minimum: 0
                    },
                    let: {
                      type: "integer",
                      minimum: 0
                    },
                    const: {
                      type: "integer",
                      minimum: 0
                    }
                  }
                }
              ]
            },
            outerIIFEBody: {
              type: "integer",
              minimum: 0
            },
            MemberExpression: {
              type: "integer",
              minimum: 0
            },
            FunctionDeclaration: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            FunctionExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                },
                body: {
                  type: "integer",
                  minimum: 0
                }
              }
            },
            CallExpression: {
              type: "object",
              properties: {
                parameters: {
                  oneOf: [
                    {
                      type: "integer",
                      minimum: 0
                    },
                    {
                      enum: ["first"]
                    }
                  ]
                }
              }
            },
            ArrayExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            },
            ObjectExpression: {
              oneOf: [
                {
                  type: "integer",
                  minimum: 0
                },
                {
                  enum: ["first"]
                }
              ]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expected: "Expected indentation of {{expected}} but found {{actual}}."
      }
    },
    create(context4) {
      const DEFAULT_VARIABLE_INDENT = 1;
      const DEFAULT_PARAMETER_INDENT = null;
      const DEFAULT_FUNCTION_BODY_INDENT = 1;
      let indentType = "space";
      let indentSize = 4;
      const options = {
        SwitchCase: 0,
        VariableDeclarator: {
          var: DEFAULT_VARIABLE_INDENT,
          let: DEFAULT_VARIABLE_INDENT,
          const: DEFAULT_VARIABLE_INDENT
        },
        outerIIFEBody: null,
        FunctionDeclaration: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        FunctionExpression: {
          parameters: DEFAULT_PARAMETER_INDENT,
          body: DEFAULT_FUNCTION_BODY_INDENT
        },
        CallExpression: {
          arguments: DEFAULT_PARAMETER_INDENT
        },
        ArrayExpression: 1,
        ObjectExpression: 1
      };
      const sourceCode = context4.getSourceCode();
      if (context4.options.length) {
        if (context4.options[0] === "tab") {
          indentSize = 1;
          indentType = "tab";
        } else if (typeof context4.options[0] === "number") {
          indentSize = context4.options[0];
          indentType = "space";
        }
        if (context4.options[1]) {
          const opts = context4.options[1];
          options.SwitchCase = opts.SwitchCase || 0;
          const variableDeclaratorRules = opts.VariableDeclarator;
          if (typeof variableDeclaratorRules === "number") {
            options.VariableDeclarator = {
              var: variableDeclaratorRules,
              let: variableDeclaratorRules,
              const: variableDeclaratorRules
            };
          } else if (typeof variableDeclaratorRules === "object") {
            Object.assign(options.VariableDeclarator, variableDeclaratorRules);
          }
          if (typeof opts.outerIIFEBody === "number") {
            options.outerIIFEBody = opts.outerIIFEBody;
          }
          if (typeof opts.MemberExpression === "number") {
            options.MemberExpression = opts.MemberExpression;
          }
          if (typeof opts.FunctionDeclaration === "object") {
            Object.assign(options.FunctionDeclaration, opts.FunctionDeclaration);
          }
          if (typeof opts.FunctionExpression === "object") {
            Object.assign(options.FunctionExpression, opts.FunctionExpression);
          }
          if (typeof opts.CallExpression === "object") {
            Object.assign(options.CallExpression, opts.CallExpression);
          }
          if (typeof opts.ArrayExpression === "number" || typeof opts.ArrayExpression === "string") {
            options.ArrayExpression = opts.ArrayExpression;
          }
          if (typeof opts.ObjectExpression === "number" || typeof opts.ObjectExpression === "string") {
            options.ObjectExpression = opts.ObjectExpression;
          }
        }
      }
      const caseIndentStore = {};
      function createErrorMessageData(expectedAmount, actualSpaces, actualTabs) {
        const expectedStatement = `${expectedAmount} ${indentType}${expectedAmount === 1 ? "" : "s"}`;
        const foundSpacesWord = `space${actualSpaces === 1 ? "" : "s"}`;
        const foundTabsWord = `tab${actualTabs === 1 ? "" : "s"}`;
        let foundStatement;
        if (actualSpaces > 0 && actualTabs > 0) {
          foundStatement = `${actualSpaces} ${foundSpacesWord} and ${actualTabs} ${foundTabsWord}`;
        } else if (actualSpaces > 0) {
          foundStatement = indentType === "space" ? actualSpaces : `${actualSpaces} ${foundSpacesWord}`;
        } else if (actualTabs > 0) {
          foundStatement = indentType === "tab" ? actualTabs : `${actualTabs} ${foundTabsWord}`;
        } else {
          foundStatement = "0";
        }
        return {
          expected: expectedStatement,
          actual: foundStatement
        };
      }
      function report(node, needed, gottenSpaces, gottenTabs, loc, isLastNodeCheck) {
        if (gottenSpaces && gottenTabs) {
          return;
        }
        const desiredIndent = (indentType === "space" ? " " : "	").repeat(needed);
        const textRange = isLastNodeCheck ? [node.range[1] - node.loc.end.column, node.range[1] - node.loc.end.column + gottenSpaces + gottenTabs] : [node.range[0] - node.loc.start.column, node.range[0] - node.loc.start.column + gottenSpaces + gottenTabs];
        context4.report({
          node,
          loc,
          messageId: "expected",
          data: createErrorMessageData(needed, gottenSpaces, gottenTabs),
          fix: (fixer) => fixer.replaceTextRange(textRange, desiredIndent)
        });
      }
      function getNodeIndent(node, byLastLine) {
        const token = byLastLine ? sourceCode.getLastToken(node) : sourceCode.getFirstToken(node);
        const srcCharsBeforeNode = sourceCode.getText(token, token.loc.start.column).split("");
        const indentChars = srcCharsBeforeNode.slice(0, srcCharsBeforeNode.findIndex((char) => char !== " " && char !== "	"));
        const spaces = indentChars.filter((char) => char === " ").length;
        const tabs = indentChars.filter((char) => char === "	").length;
        return {
          space: spaces,
          tab: tabs,
          goodChar: indentType === "space" ? spaces : tabs,
          badChar: indentType === "space" ? tabs : spaces
        };
      }
      function isNodeFirstInLine(node, byEndLocation) {
        const firstToken = byEndLocation === true ? sourceCode.getLastToken(node, 1) : sourceCode.getTokenBefore(node), startLine = byEndLocation === true ? node.loc.end.line : node.loc.start.line, endLine = firstToken ? firstToken.loc.end.line : -1;
        return startLine !== endLine;
      }
      function checkNodeIndent(node, neededIndent) {
        const actualIndent = getNodeIndent(node, false);
        if (node.type !== "ArrayExpression" && node.type !== "ObjectExpression" && (actualIndent.goodChar !== neededIndent || actualIndent.badChar !== 0) && isNodeFirstInLine(node)) {
          report(node, neededIndent, actualIndent.space, actualIndent.tab);
        }
        if (node.type === "IfStatement" && node.alternate) {
          const elseToken = sourceCode.getTokenBefore(node.alternate);
          checkNodeIndent(elseToken, neededIndent);
          if (!isNodeFirstInLine(node.alternate)) {
            checkNodeIndent(node.alternate, neededIndent);
          }
        }
        if (node.type === "TryStatement" && node.handler) {
          const catchToken = sourceCode.getFirstToken(node.handler);
          checkNodeIndent(catchToken, neededIndent);
        }
        if (node.type === "TryStatement" && node.finalizer) {
          const finallyToken = sourceCode.getTokenBefore(node.finalizer);
          checkNodeIndent(finallyToken, neededIndent);
        }
        if (node.type === "DoWhileStatement") {
          const whileToken = sourceCode.getTokenAfter(node.body);
          checkNodeIndent(whileToken, neededIndent);
        }
      }
      function checkNodesIndent(nodes, indent) {
        nodes.forEach((node) => checkNodeIndent(node, indent));
      }
      function checkLastNodeLineIndent(node, lastLineIndent) {
        const lastToken = sourceCode.getLastToken(node);
        const endIndent = getNodeIndent(lastToken, true);
        if ((endIndent.goodChar !== lastLineIndent || endIndent.badChar !== 0) && isNodeFirstInLine(node, true)) {
          report(node, lastLineIndent, endIndent.space, endIndent.tab, {line: lastToken.loc.start.line, column: lastToken.loc.start.column}, true);
        }
      }
      function checkLastReturnStatementLineIndent(node, firstLineIndent) {
        const lastToken = sourceCode.getLastToken(node, astUtils.isClosingParenToken);
        const textBeforeClosingParenthesis = sourceCode.getText(lastToken, lastToken.loc.start.column).slice(0, -1);
        if (textBeforeClosingParenthesis.trim()) {
          return;
        }
        const endIndent = getNodeIndent(lastToken, true);
        if (endIndent.goodChar !== firstLineIndent) {
          report(node, firstLineIndent, endIndent.space, endIndent.tab, {line: lastToken.loc.start.line, column: lastToken.loc.start.column}, true);
        }
      }
      function checkFirstNodeLineIndent(node, firstLineIndent) {
        const startIndent = getNodeIndent(node, false);
        if ((startIndent.goodChar !== firstLineIndent || startIndent.badChar !== 0) && isNodeFirstInLine(node)) {
          report(node, firstLineIndent, startIndent.space, startIndent.tab, {line: node.loc.start.line, column: node.loc.start.column});
        }
      }
      function getParentNodeByType(node, type, stopAtList) {
        let parent = node.parent;
        const stopAtSet = new Set(stopAtList || ["Program"]);
        while (parent.type !== type && !stopAtSet.has(parent.type) && parent.type !== "Program") {
          parent = parent.parent;
        }
        return parent.type === type ? parent : null;
      }
      function getVariableDeclaratorNode(node) {
        return getParentNodeByType(node, "VariableDeclarator");
      }
      function isNodeInVarOnTop(node, varNode) {
        return varNode && varNode.parent.loc.start.line === node.loc.start.line && varNode.parent.declarations.length > 1;
      }
      function isArgBeforeCalleeNodeMultiline(node) {
        const parent = node.parent;
        if (parent.arguments.length >= 2 && parent.arguments[1] === node) {
          return parent.arguments[0].loc.end.line > parent.arguments[0].loc.start.line;
        }
        return false;
      }
      function isOuterIIFE(node) {
        const parent = node.parent;
        let stmt = parent.parent;
        if (parent.type !== "CallExpression" || parent.callee !== node) {
          return false;
        }
        while (stmt.type === "UnaryExpression" && (stmt.operator === "!" || stmt.operator === "~" || stmt.operator === "+" || stmt.operator === "-") || stmt.type === "AssignmentExpression" || stmt.type === "LogicalExpression" || stmt.type === "SequenceExpression" || stmt.type === "VariableDeclarator") {
          stmt = stmt.parent;
        }
        return (stmt.type === "ExpressionStatement" || stmt.type === "VariableDeclaration") && stmt.parent && stmt.parent.type === "Program";
      }
      function checkIndentInFunctionBlock(node) {
        const calleeNode = node.parent;
        let indent;
        if (calleeNode.parent && (calleeNode.parent.type === "Property" || calleeNode.parent.type === "ArrayExpression")) {
          indent = getNodeIndent(calleeNode, false).goodChar;
        } else {
          indent = getNodeIndent(calleeNode).goodChar;
        }
        if (calleeNode.parent.type === "CallExpression") {
          const calleeParent = calleeNode.parent;
          if (calleeNode.type !== "FunctionExpression" && calleeNode.type !== "ArrowFunctionExpression") {
            if (calleeParent && calleeParent.loc.start.line < node.loc.start.line) {
              indent = getNodeIndent(calleeParent).goodChar;
            }
          } else {
            if (isArgBeforeCalleeNodeMultiline(calleeNode) && calleeParent.callee.loc.start.line === calleeParent.callee.loc.end.line && !isNodeFirstInLine(calleeNode)) {
              indent = getNodeIndent(calleeParent).goodChar;
            }
          }
        }
        let functionOffset = indentSize;
        if (options.outerIIFEBody !== null && isOuterIIFE(calleeNode)) {
          functionOffset = options.outerIIFEBody * indentSize;
        } else if (calleeNode.type === "FunctionExpression") {
          functionOffset = options.FunctionExpression.body * indentSize;
        } else if (calleeNode.type === "FunctionDeclaration") {
          functionOffset = options.FunctionDeclaration.body * indentSize;
        }
        indent += functionOffset;
        const parentVarNode = getVariableDeclaratorNode(node);
        if (parentVarNode && isNodeInVarOnTop(node, parentVarNode)) {
          indent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }
        if (node.body.length > 0) {
          checkNodesIndent(node.body, indent);
        }
        checkLastNodeLineIndent(node, indent - functionOffset);
      }
      function isSingleLineNode(node) {
        const lastToken = sourceCode.getLastToken(node), startLine = node.loc.start.line, endLine = lastToken.loc.end.line;
        return startLine === endLine;
      }
      function checkIndentInArrayOrObjectBlock(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        let elements = node.type === "ArrayExpression" ? node.elements : node.properties;
        elements = elements.filter((elem) => elem !== null);
        let nodeIndent;
        let elementsIndent;
        const parentVarNode = getVariableDeclaratorNode(node);
        if (isNodeFirstInLine(node)) {
          const parent = node.parent;
          nodeIndent = getNodeIndent(parent).goodChar;
          if (!parentVarNode || parentVarNode.loc.start.line !== node.loc.start.line) {
            if (parent.type !== "VariableDeclarator" || parentVarNode === parentVarNode.parent.declarations[0]) {
              if (parent.type === "VariableDeclarator" && parentVarNode.loc.start.line === parent.loc.start.line) {
                nodeIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
              } else if (parent.type === "ObjectExpression" || parent.type === "ArrayExpression") {
                const parentElements = node.parent.type === "ObjectExpression" ? node.parent.properties : node.parent.elements;
                if (parentElements[0] && parentElements[0].loc.start.line === parent.loc.start.line && parentElements[0].loc.end.line !== parent.loc.start.line) {
                } else if (typeof options[parent.type] === "number") {
                  nodeIndent += options[parent.type] * indentSize;
                } else {
                  nodeIndent = parentElements[0].loc.start.column;
                }
              } else if (parent.type === "CallExpression" || parent.type === "NewExpression") {
                if (typeof options.CallExpression.arguments === "number") {
                  nodeIndent += options.CallExpression.arguments * indentSize;
                } else if (options.CallExpression.arguments === "first") {
                  if (parent.arguments.indexOf(node) !== -1) {
                    nodeIndent = parent.arguments[0].loc.start.column;
                  }
                } else {
                  nodeIndent += indentSize;
                }
              } else if (parent.type === "LogicalExpression" || parent.type === "ArrowFunctionExpression") {
                nodeIndent += indentSize;
              }
            }
          }
          checkFirstNodeLineIndent(node, nodeIndent);
        } else {
          nodeIndent = getNodeIndent(node).goodChar;
        }
        if (options[node.type] === "first") {
          elementsIndent = elements.length ? elements[0].loc.start.column : 0;
        } else {
          elementsIndent = nodeIndent + indentSize * options[node.type];
        }
        if (isNodeInVarOnTop(node, parentVarNode)) {
          elementsIndent += indentSize * options.VariableDeclarator[parentVarNode.parent.kind];
        }
        checkNodesIndent(elements, elementsIndent);
        if (elements.length > 0) {
          if (elements[elements.length - 1].loc.end.line === node.loc.end.line) {
            return;
          }
        }
        checkLastNodeLineIndent(node, nodeIndent + (isNodeInVarOnTop(node, parentVarNode) ? options.VariableDeclarator[parentVarNode.parent.kind] * indentSize : 0));
      }
      function isNodeBodyBlock(node) {
        return node.type === "BlockStatement" || node.type === "ClassBody" || node.body && node.body.type === "BlockStatement" || node.consequent && node.consequent.type === "BlockStatement";
      }
      function blockIndentationCheck(node) {
        if (isSingleLineNode(node)) {
          return;
        }
        if (node.parent && (node.parent.type === "FunctionExpression" || node.parent.type === "FunctionDeclaration" || node.parent.type === "ArrowFunctionExpression")) {
          checkIndentInFunctionBlock(node);
          return;
        }
        let indent;
        let nodesToCheck = [];
        const statementsWithProperties = [
          "IfStatement",
          "WhileStatement",
          "ForStatement",
          "ForInStatement",
          "ForOfStatement",
          "DoWhileStatement",
          "ClassDeclaration",
          "TryStatement"
        ];
        if (node.parent && statementsWithProperties.indexOf(node.parent.type) !== -1 && isNodeBodyBlock(node)) {
          indent = getNodeIndent(node.parent).goodChar;
        } else if (node.parent && node.parent.type === "CatchClause") {
          indent = getNodeIndent(node.parent.parent).goodChar;
        } else {
          indent = getNodeIndent(node).goodChar;
        }
        if (node.type === "IfStatement" && node.consequent.type !== "BlockStatement") {
          nodesToCheck = [node.consequent];
        } else if (Array.isArray(node.body)) {
          nodesToCheck = node.body;
        } else {
          nodesToCheck = [node.body];
        }
        if (nodesToCheck.length > 0) {
          checkNodesIndent(nodesToCheck, indent + indentSize);
        }
        if (node.type === "BlockStatement") {
          checkLastNodeLineIndent(node, indent);
        }
      }
      function filterOutSameLineVars(node) {
        return node.declarations.reduce((finalCollection, elem) => {
          const lastElem = finalCollection[finalCollection.length - 1];
          if (elem.loc.start.line !== node.loc.start.line && !lastElem || lastElem && lastElem.loc.start.line !== elem.loc.start.line) {
            finalCollection.push(elem);
          }
          return finalCollection;
        }, []);
      }
      function checkIndentInVariableDeclarations(node) {
        const elements = filterOutSameLineVars(node);
        const nodeIndent = getNodeIndent(node).goodChar;
        const lastElement = elements[elements.length - 1];
        const elementsIndent = nodeIndent + indentSize * options.VariableDeclarator[node.kind];
        checkNodesIndent(elements, elementsIndent);
        if (sourceCode.getLastToken(node).loc.end.line <= lastElement.loc.end.line) {
          return;
        }
        const tokenBeforeLastElement = sourceCode.getTokenBefore(lastElement);
        if (tokenBeforeLastElement.value === ",") {
          checkLastNodeLineIndent(node, getNodeIndent(tokenBeforeLastElement).goodChar);
        } else {
          checkLastNodeLineIndent(node, elementsIndent - indentSize);
        }
      }
      function blockLessNodes(node) {
        if (node.body.type !== "BlockStatement") {
          blockIndentationCheck(node);
        }
      }
      function expectedCaseIndent(node, providedSwitchIndent) {
        const switchNode = node.type === "SwitchStatement" ? node : node.parent;
        const switchIndent = typeof providedSwitchIndent === "undefined" ? getNodeIndent(switchNode).goodChar : providedSwitchIndent;
        let caseIndent;
        if (caseIndentStore[switchNode.loc.start.line]) {
          return caseIndentStore[switchNode.loc.start.line];
        }
        if (switchNode.cases.length > 0 && options.SwitchCase === 0) {
          caseIndent = switchIndent;
        } else {
          caseIndent = switchIndent + indentSize * options.SwitchCase;
        }
        caseIndentStore[switchNode.loc.start.line] = caseIndent;
        return caseIndent;
      }
      function isWrappedInParenthesis(node) {
        const regex = /^return\s*?\(\s*?\);*?/u;
        const statementWithoutArgument = sourceCode.getText(node).replace(sourceCode.getText(node.argument), "");
        return regex.test(statementWithoutArgument);
      }
      return {
        Program(node) {
          if (node.body.length > 0) {
            checkNodesIndent(node.body, getNodeIndent(node).goodChar);
          }
        },
        ClassBody: blockIndentationCheck,
        BlockStatement: blockIndentationCheck,
        WhileStatement: blockLessNodes,
        ForStatement: blockLessNodes,
        ForInStatement: blockLessNodes,
        ForOfStatement: blockLessNodes,
        DoWhileStatement: blockLessNodes,
        IfStatement(node) {
          if (node.consequent.type !== "BlockStatement" && node.consequent.loc.start.line > node.loc.start.line) {
            blockIndentationCheck(node);
          }
        },
        VariableDeclaration(node) {
          if (node.declarations[node.declarations.length - 1].loc.start.line > node.declarations[0].loc.start.line) {
            checkIndentInVariableDeclarations(node);
          }
        },
        ObjectExpression(node) {
          checkIndentInArrayOrObjectBlock(node);
        },
        ArrayExpression(node) {
          checkIndentInArrayOrObjectBlock(node);
        },
        MemberExpression(node) {
          if (typeof options.MemberExpression === "undefined") {
            return;
          }
          if (isSingleLineNode(node)) {
            return;
          }
          if (getParentNodeByType(node, "VariableDeclarator", ["FunctionExpression", "ArrowFunctionExpression"])) {
            return;
          }
          if (getParentNodeByType(node, "AssignmentExpression", ["FunctionExpression"])) {
            return;
          }
          const propertyIndent = getNodeIndent(node).goodChar + indentSize * options.MemberExpression;
          const checkNodes = [node.property];
          const dot = sourceCode.getTokenBefore(node.property);
          if (dot.type === "Punctuator" && dot.value === ".") {
            checkNodes.push(dot);
          }
          checkNodesIndent(checkNodes, propertyIndent);
        },
        SwitchStatement(node) {
          const switchIndent = getNodeIndent(node).goodChar;
          const caseIndent = expectedCaseIndent(node, switchIndent);
          checkNodesIndent(node.cases, caseIndent);
          checkLastNodeLineIndent(node, switchIndent);
        },
        SwitchCase(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          const caseIndent = expectedCaseIndent(node);
          checkNodesIndent(node.consequent, caseIndent + indentSize);
        },
        FunctionDeclaration(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          if (options.FunctionDeclaration.parameters === "first" && node.params.length) {
            checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
          } else if (options.FunctionDeclaration.parameters !== null) {
            checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionDeclaration.parameters);
          }
        },
        FunctionExpression(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          if (options.FunctionExpression.parameters === "first" && node.params.length) {
            checkNodesIndent(node.params.slice(1), node.params[0].loc.start.column);
          } else if (options.FunctionExpression.parameters !== null) {
            checkNodesIndent(node.params, getNodeIndent(node).goodChar + indentSize * options.FunctionExpression.parameters);
          }
        },
        ReturnStatement(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          const firstLineIndent = getNodeIndent(node).goodChar;
          if (isWrappedInParenthesis(node)) {
            checkLastReturnStatementLineIndent(node, firstLineIndent);
          } else {
            checkNodeIndent(node, firstLineIndent);
          }
        },
        CallExpression(node) {
          if (isSingleLineNode(node)) {
            return;
          }
          if (options.CallExpression.arguments === "first" && node.arguments.length) {
            checkNodesIndent(node.arguments.slice(1), node.arguments[0].loc.start.column);
          } else if (options.CallExpression.arguments !== null) {
            checkNodesIndent(node.arguments, getNodeIndent(node).goodChar + indentSize * options.CallExpression.arguments);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/init-declarations.js
var require_init_declarations = __commonJS((exports2, module2) => {
  "use strict";
  function isForLoop(block) {
    return block.type === "ForInStatement" || block.type === "ForOfStatement" || block.type === "ForStatement";
  }
  function isInitialized(node) {
    const declaration = node.parent;
    const block = declaration.parent;
    if (isForLoop(block)) {
      if (block.type === "ForStatement") {
        return block.init === declaration;
      }
      return block.left === declaration;
    }
    return Boolean(node.init);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow initialization in variable declarations",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/init-declarations"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  ignoreForLoopInit: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        initialized: "Variable '{{idName}}' should be initialized on declaration.",
        notInitialized: "Variable '{{idName}}' should not be initialized on declaration."
      }
    },
    create(context4) {
      const MODE_ALWAYS = "always", MODE_NEVER = "never";
      const mode = context4.options[0] || MODE_ALWAYS;
      const params = context4.options[1] || {};
      return {
        "VariableDeclaration:exit"(node) {
          const kind = node.kind, declarations = node.declarations;
          for (let i = 0; i < declarations.length; ++i) {
            const declaration = declarations[i], id = declaration.id, initialized = isInitialized(declaration), isIgnoredForLoop = params.ignoreForLoopInit && isForLoop(node.parent);
            let messageId = "";
            if (mode === MODE_ALWAYS && !initialized) {
              messageId = "initialized";
            } else if (mode === MODE_NEVER && kind !== "const" && initialized && !isIgnoredForLoop) {
              messageId = "notInitialized";
            }
            if (id.type === "Identifier" && messageId) {
              context4.report({
                node: declaration,
                messageId,
                data: {
                  idName: id.name
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/jsx-quotes.js
var require_jsx_quotes = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var QUOTE_SETTINGS = {
    "prefer-double": {
      quote: '"',
      description: "singlequote",
      convert(str) {
        return str.replace(/'/gu, '"');
      }
    },
    "prefer-single": {
      quote: "'",
      description: "doublequote",
      convert(str) {
        return str.replace(/"/gu, "'");
      }
    }
  };
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce the consistent use of either double or single quotes in JSX attributes",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/jsx-quotes"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["prefer-single", "prefer-double"]
        }
      ],
      messages: {
        unexpected: "Unexpected usage of {{description}}."
      }
    },
    create(context4) {
      const quoteOption = context4.options[0] || "prefer-double", setting = QUOTE_SETTINGS[quoteOption];
      function usesExpectedQuotes(node) {
        return node.value.indexOf(setting.quote) !== -1 || astUtils.isSurroundedBy(node.raw, setting.quote);
      }
      return {
        JSXAttribute(node) {
          const attributeValue = node.value;
          if (attributeValue && astUtils.isStringLiteral(attributeValue) && !usesExpectedQuotes(attributeValue)) {
            context4.report({
              node: attributeValue,
              messageId: "unexpected",
              data: {
                description: setting.description
              },
              fix(fixer) {
                return fixer.replaceText(attributeValue, setting.convert(attributeValue.raw));
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/key-spacing.js
var require_key_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function containsLineTerminator(str) {
    return astUtils.LINEBREAK_MATCHER.test(str);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function isSingleLine(node) {
    return node.loc.end.line === node.loc.start.line;
  }
  function isSingleLineProperties(properties) {
    const [firstProp] = properties, lastProp = last(properties);
    return firstProp.loc.start.line === lastProp.loc.end.line;
  }
  function initOptionProperty(toOptions, fromOptions) {
    toOptions.mode = fromOptions.mode || "strict";
    if (typeof fromOptions.beforeColon !== "undefined") {
      toOptions.beforeColon = +fromOptions.beforeColon;
    } else {
      toOptions.beforeColon = 0;
    }
    if (typeof fromOptions.afterColon !== "undefined") {
      toOptions.afterColon = +fromOptions.afterColon;
    } else {
      toOptions.afterColon = 1;
    }
    if (typeof fromOptions.align !== "undefined") {
      if (typeof fromOptions.align === "object") {
        toOptions.align = fromOptions.align;
      } else {
        toOptions.align = {
          on: fromOptions.align,
          mode: toOptions.mode,
          beforeColon: toOptions.beforeColon,
          afterColon: toOptions.afterColon
        };
      }
    }
    return toOptions;
  }
  function initOptions(toOptions, fromOptions) {
    if (typeof fromOptions.align === "object") {
      toOptions.align = initOptionProperty({}, fromOptions.align);
      toOptions.align.on = fromOptions.align.on || "colon";
      toOptions.align.mode = fromOptions.align.mode || "strict";
      toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
      toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
    } else {
      toOptions.multiLine = initOptionProperty({}, fromOptions.multiLine || fromOptions);
      toOptions.singleLine = initOptionProperty({}, fromOptions.singleLine || fromOptions);
      if (toOptions.multiLine.align) {
        toOptions.align = {
          on: toOptions.multiLine.align.on,
          mode: toOptions.multiLine.align.mode || toOptions.multiLine.mode,
          beforeColon: toOptions.multiLine.align.beforeColon,
          afterColon: toOptions.multiLine.align.afterColon
        };
      }
    }
    return toOptions;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing between keys and values in object literal properties",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/key-spacing"
      },
      fixable: "whitespace",
      schema: [{
        anyOf: [
          {
            type: "object",
            properties: {
              align: {
                anyOf: [
                  {
                    enum: ["colon", "value"]
                  },
                  {
                    type: "object",
                    properties: {
                      mode: {
                        enum: ["strict", "minimum"]
                      },
                      on: {
                        enum: ["colon", "value"]
                      },
                      beforeColon: {
                        type: "boolean"
                      },
                      afterColon: {
                        type: "boolean"
                      }
                    },
                    additionalProperties: false
                  }
                ]
              },
              mode: {
                enum: ["strict", "minimum"]
              },
              beforeColon: {
                type: "boolean"
              },
              afterColon: {
                type: "boolean"
              }
            },
            additionalProperties: false
          },
          {
            type: "object",
            properties: {
              singleLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              },
              multiLine: {
                type: "object",
                properties: {
                  align: {
                    anyOf: [
                      {
                        enum: ["colon", "value"]
                      },
                      {
                        type: "object",
                        properties: {
                          mode: {
                            enum: ["strict", "minimum"]
                          },
                          on: {
                            enum: ["colon", "value"]
                          },
                          beforeColon: {
                            type: "boolean"
                          },
                          afterColon: {
                            type: "boolean"
                          }
                        },
                        additionalProperties: false
                      }
                    ]
                  },
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            },
            additionalProperties: false
          },
          {
            type: "object",
            properties: {
              singleLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              },
              multiLine: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              },
              align: {
                type: "object",
                properties: {
                  mode: {
                    enum: ["strict", "minimum"]
                  },
                  on: {
                    enum: ["colon", "value"]
                  },
                  beforeColon: {
                    type: "boolean"
                  },
                  afterColon: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            },
            additionalProperties: false
          }
        ]
      }],
      messages: {
        extraKey: "Extra space after {{computed}}key '{{key}}'.",
        extraValue: "Extra space before value for {{computed}}key '{{key}}'.",
        missingKey: "Missing space after {{computed}}key '{{key}}'.",
        missingValue: "Missing space before value for {{computed}}key '{{key}}'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {}, ruleOptions = initOptions({}, options), multiLineOptions = ruleOptions.multiLine, singleLineOptions = ruleOptions.singleLine, alignmentOptions = ruleOptions.align || null;
      const sourceCode = context4.getSourceCode();
      function continuesPropertyGroup(lastMember, candidate) {
        const groupEndLine = lastMember.loc.start.line, candidateStartLine = candidate.loc.start.line;
        if (candidateStartLine - groupEndLine <= 1) {
          return true;
        }
        const leadingComments = sourceCode.getCommentsBefore(candidate);
        if (leadingComments.length && leadingComments[0].loc.start.line - groupEndLine <= 1 && candidateStartLine - last(leadingComments).loc.end.line <= 1) {
          for (let i = 1; i < leadingComments.length; i++) {
            if (leadingComments[i].loc.start.line - leadingComments[i - 1].loc.end.line > 1) {
              return false;
            }
          }
          return true;
        }
        return false;
      }
      function isKeyValueProperty(property) {
        return !(property.method || property.shorthand || property.kind !== "init" || property.type !== "Property");
      }
      function getLastTokenBeforeColon(node) {
        const colonToken = sourceCode.getTokenAfter(node, astUtils.isColonToken);
        return sourceCode.getTokenBefore(colonToken);
      }
      function getNextColon(node) {
        return sourceCode.getTokenAfter(node, astUtils.isColonToken);
      }
      function getKey(property) {
        const key = property.key;
        if (property.computed) {
          return sourceCode.getText().slice(key.range[0], key.range[1]);
        }
        return astUtils.getStaticPropertyName(property);
      }
      function report(property, side, whitespace, expected, mode) {
        const diff = whitespace.length - expected, nextColon = getNextColon(property.key), tokenBeforeColon = sourceCode.getTokenBefore(nextColon, {includeComments: true}), tokenAfterColon = sourceCode.getTokenAfter(nextColon, {includeComments: true}), isKeySide = side === "key", isExtra = diff > 0, diffAbs = Math.abs(diff), spaces = Array(diffAbs + 1).join(" ");
        const locStart = isKeySide ? tokenBeforeColon.loc.end : nextColon.loc.start;
        const locEnd = isKeySide ? nextColon.loc.start : tokenAfterColon.loc.start;
        const missingLoc = isKeySide ? tokenBeforeColon.loc : tokenAfterColon.loc;
        const loc = isExtra ? {start: locStart, end: locEnd} : missingLoc;
        if ((diff && mode === "strict" || diff < 0 && mode === "minimum" || diff > 0 && !expected && mode === "minimum") && !(expected && containsLineTerminator(whitespace))) {
          let fix;
          if (isExtra) {
            let range;
            if (isKeySide) {
              range = [tokenBeforeColon.range[1], tokenBeforeColon.range[1] + diffAbs];
            } else {
              range = [tokenAfterColon.range[0] - diffAbs, tokenAfterColon.range[0]];
            }
            fix = function(fixer) {
              return fixer.removeRange(range);
            };
          } else {
            if (isKeySide) {
              fix = function(fixer) {
                return fixer.insertTextAfter(tokenBeforeColon, spaces);
              };
            } else {
              fix = function(fixer) {
                return fixer.insertTextBefore(tokenAfterColon, spaces);
              };
            }
          }
          let messageId = "";
          if (isExtra) {
            messageId = side === "key" ? "extraKey" : "extraValue";
          } else {
            messageId = side === "key" ? "missingKey" : "missingValue";
          }
          context4.report({
            node: property[side],
            loc,
            messageId,
            data: {
              computed: property.computed ? "computed " : "",
              key: getKey(property)
            },
            fix
          });
        }
      }
      function getKeyWidth(property) {
        const startToken = sourceCode.getFirstToken(property);
        const endToken = getLastTokenBeforeColon(property.key);
        return endToken.range[1] - startToken.range[0];
      }
      function getPropertyWhitespace(property) {
        const whitespace = /(\s*):(\s*)/u.exec(sourceCode.getText().slice(property.key.range[1], property.value.range[0]));
        if (whitespace) {
          return {
            beforeColon: whitespace[1],
            afterColon: whitespace[2]
          };
        }
        return null;
      }
      function createGroups(node) {
        if (node.properties.length === 1) {
          return [node.properties];
        }
        return node.properties.reduce((groups, property) => {
          const currentGroup = last(groups), prev = last(currentGroup);
          if (!prev || continuesPropertyGroup(prev, property)) {
            currentGroup.push(property);
          } else {
            groups.push([property]);
          }
          return groups;
        }, [
          []
        ]);
      }
      function verifyGroupAlignment(properties) {
        const length = properties.length, widths = properties.map(getKeyWidth), align = alignmentOptions.on;
        let targetWidth = Math.max(...widths), beforeColon, afterColon, mode;
        if (alignmentOptions && length > 1) {
          beforeColon = alignmentOptions.beforeColon;
          afterColon = alignmentOptions.afterColon;
          mode = alignmentOptions.mode;
        } else {
          beforeColon = multiLineOptions.beforeColon;
          afterColon = multiLineOptions.afterColon;
          mode = alignmentOptions.mode;
        }
        targetWidth += align === "colon" ? beforeColon : afterColon;
        for (let i = 0; i < length; i++) {
          const property = properties[i];
          const whitespace = getPropertyWhitespace(property);
          if (whitespace) {
            const width = widths[i];
            if (align === "value") {
              report(property, "key", whitespace.beforeColon, beforeColon, mode);
              report(property, "value", whitespace.afterColon, targetWidth - width, mode);
            } else {
              report(property, "key", whitespace.beforeColon, targetWidth - width, mode);
              report(property, "value", whitespace.afterColon, afterColon, mode);
            }
          }
        }
      }
      function verifySpacing(node, lineOptions) {
        const actual = getPropertyWhitespace(node);
        if (actual) {
          report(node, "key", actual.beforeColon, lineOptions.beforeColon, lineOptions.mode);
          report(node, "value", actual.afterColon, lineOptions.afterColon, lineOptions.mode);
        }
      }
      function verifyListSpacing(properties, lineOptions) {
        const length = properties.length;
        for (let i = 0; i < length; i++) {
          verifySpacing(properties[i], lineOptions);
        }
      }
      function verifyAlignment(node) {
        createGroups(node).forEach((group) => {
          const properties = group.filter(isKeyValueProperty);
          if (properties.length > 0 && isSingleLineProperties(properties)) {
            verifyListSpacing(properties, multiLineOptions);
          } else {
            verifyGroupAlignment(properties);
          }
        });
      }
      if (alignmentOptions) {
        return {
          ObjectExpression(node) {
            if (isSingleLine(node)) {
              verifyListSpacing(node.properties.filter(isKeyValueProperty), singleLineOptions);
            } else {
              verifyAlignment(node);
            }
          }
        };
      }
      return {
        Property(node) {
          verifySpacing(node, isSingleLine(node.parent) ? singleLineOptions : multiLineOptions);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/keyword-spacing.js
var require_keyword_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var keywords = require_keywords();
  var PREV_TOKEN = /^[)\]}>]$/u;
  var NEXT_TOKEN = /^(?:[([{<~!]|\+\+?|--?)$/u;
  var PREV_TOKEN_M = /^[)\]}>*]$/u;
  var NEXT_TOKEN_M = /^[{*]$/u;
  var TEMPLATE_OPEN_PAREN = /\$\{$/u;
  var TEMPLATE_CLOSE_PAREN = /^\}/u;
  var CHECK_TYPE = /^(?:JSXElement|RegularExpression|String|Template)$/u;
  var KEYS = keywords.concat(["as", "async", "await", "from", "get", "let", "of", "set", "yield"]);
  (function() {
    KEYS.sort();
    for (let i = 1; i < KEYS.length; ++i) {
      if (KEYS[i] === KEYS[i - 1]) {
        throw new Error(`Duplication was found in the keyword list: ${KEYS[i]}`);
      }
    }
  })();
  function isOpenParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_OPEN_PAREN.test(token.value);
  }
  function isCloseParenOfTemplate(token) {
    return token.type === "Template" && TEMPLATE_CLOSE_PAREN.test(token.value);
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before and after keywords",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/keyword-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {type: "boolean", default: true},
            after: {type: "boolean", default: true},
            overrides: {
              type: "object",
              properties: KEYS.reduce((retv, key) => {
                retv[key] = {
                  type: "object",
                  properties: {
                    before: {type: "boolean"},
                    after: {type: "boolean"}
                  },
                  additionalProperties: false
                };
                return retv;
              }, {}),
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectedBefore: 'Expected space(s) before "{{value}}".',
        expectedAfter: 'Expected space(s) after "{{value}}".',
        unexpectedBefore: 'Unexpected space(s) before "{{value}}".',
        unexpectedAfter: 'Unexpected space(s) after "{{value}}".'
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function expectSpaceBefore(token, pattern) {
        const prevToken = sourceCode.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && !sourceCode.isSpaceBetweenTokens(prevToken, token)) {
          context4.report({
            loc: token.loc,
            messageId: "expectedBefore",
            data: token,
            fix(fixer) {
              return fixer.insertTextBefore(token, " ");
            }
          });
        }
      }
      function unexpectSpaceBefore(token, pattern) {
        const prevToken = sourceCode.getTokenBefore(token);
        if (prevToken && (CHECK_TYPE.test(prevToken.type) || pattern.test(prevToken.value)) && !isOpenParenOfTemplate(prevToken) && astUtils.isTokenOnSameLine(prevToken, token) && sourceCode.isSpaceBetweenTokens(prevToken, token)) {
          context4.report({
            loc: {start: prevToken.loc.end, end: token.loc.start},
            messageId: "unexpectedBefore",
            data: token,
            fix(fixer) {
              return fixer.removeRange([prevToken.range[1], token.range[0]]);
            }
          });
        }
      }
      function expectSpaceAfter(token, pattern) {
        const nextToken = sourceCode.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && !sourceCode.isSpaceBetweenTokens(token, nextToken)) {
          context4.report({
            loc: token.loc,
            messageId: "expectedAfter",
            data: token,
            fix(fixer) {
              return fixer.insertTextAfter(token, " ");
            }
          });
        }
      }
      function unexpectSpaceAfter(token, pattern) {
        const nextToken = sourceCode.getTokenAfter(token);
        if (nextToken && (CHECK_TYPE.test(nextToken.type) || pattern.test(nextToken.value)) && !isCloseParenOfTemplate(nextToken) && astUtils.isTokenOnSameLine(token, nextToken) && sourceCode.isSpaceBetweenTokens(token, nextToken)) {
          context4.report({
            loc: {start: token.loc.end, end: nextToken.loc.start},
            messageId: "unexpectedAfter",
            data: token,
            fix(fixer) {
              return fixer.removeRange([token.range[1], nextToken.range[0]]);
            }
          });
        }
      }
      function parseOptions(options = {}) {
        const before = options.before !== false;
        const after = options.after !== false;
        const defaultValue = {
          before: before ? expectSpaceBefore : unexpectSpaceBefore,
          after: after ? expectSpaceAfter : unexpectSpaceAfter
        };
        const overrides = options && options.overrides || {};
        const retv = Object.create(null);
        for (let i = 0; i < KEYS.length; ++i) {
          const key = KEYS[i];
          const override = overrides[key];
          if (override) {
            const thisBefore = "before" in override ? override.before : before;
            const thisAfter = "after" in override ? override.after : after;
            retv[key] = {
              before: thisBefore ? expectSpaceBefore : unexpectSpaceBefore,
              after: thisAfter ? expectSpaceAfter : unexpectSpaceAfter
            };
          } else {
            retv[key] = defaultValue;
          }
        }
        return retv;
      }
      const checkMethodMap = parseOptions(context4.options[0]);
      function checkSpacingBefore(token, pattern) {
        checkMethodMap[token.value].before(token, pattern || PREV_TOKEN);
      }
      function checkSpacingAfter(token, pattern) {
        checkMethodMap[token.value].after(token, pattern || NEXT_TOKEN);
      }
      function checkSpacingAround(token) {
        checkSpacingBefore(token);
        checkSpacingAfter(token);
      }
      function checkSpacingAroundFirstToken(node) {
        const firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
          checkSpacingAround(firstToken);
        }
      }
      function checkSpacingBeforeFirstToken(node) {
        const firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && firstToken.type === "Keyword") {
          checkSpacingBefore(firstToken);
        }
      }
      function checkSpacingAroundTokenBefore(node) {
        if (node) {
          const token = sourceCode.getTokenBefore(node, astUtils.isKeywordToken);
          checkSpacingAround(token);
        }
      }
      function checkSpacingForFunction(node) {
        const firstToken = node && sourceCode.getFirstToken(node);
        if (firstToken && (firstToken.type === "Keyword" && firstToken.value === "function" || firstToken.value === "async")) {
          checkSpacingBefore(firstToken);
        }
      }
      function checkSpacingForClass(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.superClass);
      }
      function checkSpacingForIfStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.alternate);
      }
      function checkSpacingForTryStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundFirstToken(node.handler);
        checkSpacingAroundTokenBefore(node.finalizer);
      }
      function checkSpacingForDoWhileStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.test);
      }
      function checkSpacingForForInStatement(node) {
        checkSpacingAroundFirstToken(node);
        checkSpacingAroundTokenBefore(node.right);
      }
      function checkSpacingForForOfStatement(node) {
        if (node.await) {
          checkSpacingBefore(sourceCode.getFirstToken(node, 0));
          checkSpacingAfter(sourceCode.getFirstToken(node, 1));
        } else {
          checkSpacingAroundFirstToken(node);
        }
        checkSpacingAround(sourceCode.getTokenBefore(node.right, astUtils.isNotOpeningParenToken));
      }
      function checkSpacingForModuleDeclaration(node) {
        const firstToken = sourceCode.getFirstToken(node);
        checkSpacingBefore(firstToken, PREV_TOKEN_M);
        checkSpacingAfter(firstToken, NEXT_TOKEN_M);
        if (node.type === "ExportDefaultDeclaration") {
          checkSpacingAround(sourceCode.getTokenAfter(firstToken));
        }
        if (node.type === "ExportAllDeclaration" && node.exported) {
          const asToken = sourceCode.getTokenBefore(node.exported);
          checkSpacingBefore(asToken, PREV_TOKEN_M);
        }
        if (node.source) {
          const fromToken = sourceCode.getTokenBefore(node.source);
          checkSpacingBefore(fromToken, PREV_TOKEN_M);
          checkSpacingAfter(fromToken, NEXT_TOKEN_M);
        }
      }
      function checkSpacingForImportNamespaceSpecifier(node) {
        const asToken = sourceCode.getFirstToken(node, 1);
        checkSpacingBefore(asToken, PREV_TOKEN_M);
      }
      function checkSpacingForProperty(node) {
        if (node.static) {
          checkSpacingAroundFirstToken(node);
        }
        if (node.kind === "get" || node.kind === "set" || (node.method || node.type === "MethodDefinition") && node.value.async) {
          const token = sourceCode.getTokenBefore(node.key, (tok) => {
            switch (tok.value) {
              case "get":
              case "set":
              case "async":
                return true;
              default:
                return false;
            }
          });
          if (!token) {
            throw new Error("Failed to find token get, set, or async beside method name");
          }
          checkSpacingAround(token);
        }
      }
      function checkSpacingForAwaitExpression(node) {
        checkSpacingBefore(sourceCode.getFirstToken(node));
      }
      return {
        DebuggerStatement: checkSpacingAroundFirstToken,
        WithStatement: checkSpacingAroundFirstToken,
        BreakStatement: checkSpacingAroundFirstToken,
        ContinueStatement: checkSpacingAroundFirstToken,
        ReturnStatement: checkSpacingAroundFirstToken,
        ThrowStatement: checkSpacingAroundFirstToken,
        TryStatement: checkSpacingForTryStatement,
        IfStatement: checkSpacingForIfStatement,
        SwitchStatement: checkSpacingAroundFirstToken,
        SwitchCase: checkSpacingAroundFirstToken,
        DoWhileStatement: checkSpacingForDoWhileStatement,
        ForInStatement: checkSpacingForForInStatement,
        ForOfStatement: checkSpacingForForOfStatement,
        ForStatement: checkSpacingAroundFirstToken,
        WhileStatement: checkSpacingAroundFirstToken,
        ClassDeclaration: checkSpacingForClass,
        ExportNamedDeclaration: checkSpacingForModuleDeclaration,
        ExportDefaultDeclaration: checkSpacingForModuleDeclaration,
        ExportAllDeclaration: checkSpacingForModuleDeclaration,
        FunctionDeclaration: checkSpacingForFunction,
        ImportDeclaration: checkSpacingForModuleDeclaration,
        VariableDeclaration: checkSpacingAroundFirstToken,
        ArrowFunctionExpression: checkSpacingForFunction,
        AwaitExpression: checkSpacingForAwaitExpression,
        ClassExpression: checkSpacingForClass,
        FunctionExpression: checkSpacingForFunction,
        NewExpression: checkSpacingBeforeFirstToken,
        Super: checkSpacingBeforeFirstToken,
        ThisExpression: checkSpacingBeforeFirstToken,
        UnaryExpression: checkSpacingBeforeFirstToken,
        YieldExpression: checkSpacingBeforeFirstToken,
        ImportNamespaceSpecifier: checkSpacingForImportNamespaceSpecifier,
        MethodDefinition: checkSpacingForProperty,
        Property: checkSpacingForProperty
      };
    }
  };
});

// node_modules/eslint/lib/rules/line-comment-position.js
var require_line_comment_position = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce position of line comments",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/line-comment-position"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["above", "beside"]
            },
            {
              type: "object",
              properties: {
                position: {
                  enum: ["above", "beside"]
                },
                ignorePattern: {
                  type: "string"
                },
                applyDefaultPatterns: {
                  type: "boolean"
                },
                applyDefaultIgnorePatterns: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        above: "Expected comment to be above code.",
        beside: "Expected comment to be beside code."
      }
    },
    create(context4) {
      const options = context4.options[0];
      let above, ignorePattern, applyDefaultIgnorePatterns = true;
      if (!options || typeof options === "string") {
        above = !options || options === "above";
      } else {
        above = !options.position || options.position === "above";
        ignorePattern = options.ignorePattern;
        if (Object.prototype.hasOwnProperty.call(options, "applyDefaultIgnorePatterns")) {
          applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns;
        } else {
          applyDefaultIgnorePatterns = options.applyDefaultPatterns !== false;
        }
      }
      const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
      const fallThroughRegExp = /^\s*falls?\s?through/u;
      const customIgnoreRegExp = new RegExp(ignorePattern, "u");
      const sourceCode = context4.getSourceCode();
      return {
        Program() {
          const comments = sourceCode.getAllComments();
          comments.filter((token) => token.type === "Line").forEach((node) => {
            if (applyDefaultIgnorePatterns && (defaultIgnoreRegExp.test(node.value) || fallThroughRegExp.test(node.value))) {
              return;
            }
            if (ignorePattern && customIgnoreRegExp.test(node.value)) {
              return;
            }
            const previous = sourceCode.getTokenBefore(node, {includeComments: true});
            const isOnSameLine = previous && previous.loc.end.line === node.loc.start.line;
            if (above) {
              if (isOnSameLine) {
                context4.report({
                  node,
                  messageId: "above"
                });
              }
            } else {
              if (!isOnSameLine) {
                context4.report({
                  node,
                  messageId: "beside"
                });
              }
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/linebreak-style.js
var require_linebreak_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent linebreak style",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/linebreak-style"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["unix", "windows"]
        }
      ],
      messages: {
        expectedLF: "Expected linebreaks to be 'LF' but found 'CRLF'.",
        expectedCRLF: "Expected linebreaks to be 'CRLF' but found 'LF'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function createFix(range, text) {
        return function(fixer) {
          return fixer.replaceTextRange(range, text);
        };
      }
      return {
        Program: function checkForLinebreakStyle(node) {
          const linebreakStyle = context4.options[0] || "unix", expectedLF = linebreakStyle === "unix", expectedLFChars = expectedLF ? "\n" : "\r\n", source = sourceCode.getText(), pattern = astUtils.createGlobalLinebreakMatcher();
          let match;
          let i = 0;
          while ((match = pattern.exec(source)) !== null) {
            i++;
            if (match[0] === expectedLFChars) {
              continue;
            }
            const index = match.index;
            const range = [index, index + match[0].length];
            context4.report({
              node,
              loc: {
                start: {
                  line: i,
                  column: sourceCode.lines[i - 1].length
                },
                end: {
                  line: i + 1,
                  column: 0
                }
              },
              messageId: expectedLF ? "expectedLF" : "expectedCRLF",
              fix: createFix(range, expectedLFChars)
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/lines-around-comment.js
var require_lines_around_comment = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function getEmptyLineNums(lines) {
    const emptyLines = lines.map((line, i) => ({
      code: line.trim(),
      num: i + 1
    })).filter((line) => !line.code).map((line) => line.num);
    return emptyLines;
  }
  function getCommentLineNums(comments) {
    const lines = [];
    comments.forEach((token) => {
      const start = token.loc.start.line;
      const end = token.loc.end.line;
      lines.push(start, end);
    });
    return lines;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require empty lines around comments",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/lines-around-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            beforeBlockComment: {
              type: "boolean",
              default: true
            },
            afterBlockComment: {
              type: "boolean",
              default: false
            },
            beforeLineComment: {
              type: "boolean",
              default: false
            },
            afterLineComment: {
              type: "boolean",
              default: false
            },
            allowBlockStart: {
              type: "boolean",
              default: false
            },
            allowBlockEnd: {
              type: "boolean",
              default: false
            },
            allowClassStart: {
              type: "boolean"
            },
            allowClassEnd: {
              type: "boolean"
            },
            allowObjectStart: {
              type: "boolean"
            },
            allowObjectEnd: {
              type: "boolean"
            },
            allowArrayStart: {
              type: "boolean"
            },
            allowArrayEnd: {
              type: "boolean"
            },
            ignorePattern: {
              type: "string"
            },
            applyDefaultIgnorePatterns: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        after: "Expected line after comment.",
        before: "Expected line before comment."
      }
    },
    create(context4) {
      const options = Object.assign({}, context4.options[0]);
      const ignorePattern = options.ignorePattern;
      const defaultIgnoreRegExp = astUtils.COMMENTS_IGNORE_PATTERN;
      const customIgnoreRegExp = new RegExp(ignorePattern, "u");
      const applyDefaultIgnorePatterns = options.applyDefaultIgnorePatterns !== false;
      options.beforeBlockComment = typeof options.beforeBlockComment !== "undefined" ? options.beforeBlockComment : true;
      const sourceCode = context4.getSourceCode();
      const lines = sourceCode.lines, numLines = lines.length + 1, comments = sourceCode.getAllComments(), commentLines = getCommentLineNums(comments), emptyLines = getEmptyLineNums(lines), commentAndEmptyLines = commentLines.concat(emptyLines);
      function codeAroundComment(token) {
        let currentToken = token;
        do {
          currentToken = sourceCode.getTokenBefore(currentToken, {includeComments: true});
        } while (currentToken && astUtils.isCommentToken(currentToken));
        if (currentToken && astUtils.isTokenOnSameLine(currentToken, token)) {
          return true;
        }
        currentToken = token;
        do {
          currentToken = sourceCode.getTokenAfter(currentToken, {includeComments: true});
        } while (currentToken && astUtils.isCommentToken(currentToken));
        if (currentToken && astUtils.isTokenOnSameLine(token, currentToken)) {
          return true;
        }
        return false;
      }
      function isParentNodeType(parent, nodeType) {
        return parent.type === nodeType || parent.body && parent.body.type === nodeType || parent.consequent && parent.consequent.type === nodeType;
      }
      function getParentNodeOfToken(token) {
        return sourceCode.getNodeByRangeIndex(token.range[0]);
      }
      function isCommentAtParentStart(token, nodeType) {
        const parent = getParentNodeOfToken(token);
        return parent && isParentNodeType(parent, nodeType) && token.loc.start.line - parent.loc.start.line === 1;
      }
      function isCommentAtParentEnd(token, nodeType) {
        const parent = getParentNodeOfToken(token);
        return parent && isParentNodeType(parent, nodeType) && parent.loc.end.line - token.loc.end.line === 1;
      }
      function isCommentAtBlockStart(token) {
        return isCommentAtParentStart(token, "ClassBody") || isCommentAtParentStart(token, "BlockStatement") || isCommentAtParentStart(token, "SwitchCase");
      }
      function isCommentAtBlockEnd(token) {
        return isCommentAtParentEnd(token, "ClassBody") || isCommentAtParentEnd(token, "BlockStatement") || isCommentAtParentEnd(token, "SwitchCase") || isCommentAtParentEnd(token, "SwitchStatement");
      }
      function isCommentAtClassStart(token) {
        return isCommentAtParentStart(token, "ClassBody");
      }
      function isCommentAtClassEnd(token) {
        return isCommentAtParentEnd(token, "ClassBody");
      }
      function isCommentAtObjectStart(token) {
        return isCommentAtParentStart(token, "ObjectExpression") || isCommentAtParentStart(token, "ObjectPattern");
      }
      function isCommentAtObjectEnd(token) {
        return isCommentAtParentEnd(token, "ObjectExpression") || isCommentAtParentEnd(token, "ObjectPattern");
      }
      function isCommentAtArrayStart(token) {
        return isCommentAtParentStart(token, "ArrayExpression") || isCommentAtParentStart(token, "ArrayPattern");
      }
      function isCommentAtArrayEnd(token) {
        return isCommentAtParentEnd(token, "ArrayExpression") || isCommentAtParentEnd(token, "ArrayPattern");
      }
      function checkForEmptyLine(token, opts) {
        if (applyDefaultIgnorePatterns && defaultIgnoreRegExp.test(token.value)) {
          return;
        }
        if (ignorePattern && customIgnoreRegExp.test(token.value)) {
          return;
        }
        let after = opts.after, before = opts.before;
        const prevLineNum = token.loc.start.line - 1, nextLineNum = token.loc.end.line + 1, commentIsNotAlone = codeAroundComment(token);
        const blockStartAllowed = options.allowBlockStart && isCommentAtBlockStart(token) && !(options.allowClassStart === false && isCommentAtClassStart(token)), blockEndAllowed = options.allowBlockEnd && isCommentAtBlockEnd(token) && !(options.allowClassEnd === false && isCommentAtClassEnd(token)), classStartAllowed = options.allowClassStart && isCommentAtClassStart(token), classEndAllowed = options.allowClassEnd && isCommentAtClassEnd(token), objectStartAllowed = options.allowObjectStart && isCommentAtObjectStart(token), objectEndAllowed = options.allowObjectEnd && isCommentAtObjectEnd(token), arrayStartAllowed = options.allowArrayStart && isCommentAtArrayStart(token), arrayEndAllowed = options.allowArrayEnd && isCommentAtArrayEnd(token);
        const exceptionStartAllowed = blockStartAllowed || classStartAllowed || objectStartAllowed || arrayStartAllowed;
        const exceptionEndAllowed = blockEndAllowed || classEndAllowed || objectEndAllowed || arrayEndAllowed;
        if (prevLineNum < 1) {
          before = false;
        }
        if (nextLineNum >= numLines) {
          after = false;
        }
        if (commentIsNotAlone) {
          return;
        }
        const previousTokenOrComment = sourceCode.getTokenBefore(token, {includeComments: true});
        const nextTokenOrComment = sourceCode.getTokenAfter(token, {includeComments: true});
        if (!exceptionStartAllowed && before && !commentAndEmptyLines.includes(prevLineNum) && !(astUtils.isCommentToken(previousTokenOrComment) && astUtils.isTokenOnSameLine(previousTokenOrComment, token))) {
          const lineStart = token.range[0] - token.loc.start.column;
          const range = [lineStart, lineStart];
          context4.report({
            node: token,
            messageId: "before",
            fix(fixer) {
              return fixer.insertTextBeforeRange(range, "\n");
            }
          });
        }
        if (!exceptionEndAllowed && after && !commentAndEmptyLines.includes(nextLineNum) && !(astUtils.isCommentToken(nextTokenOrComment) && astUtils.isTokenOnSameLine(token, nextTokenOrComment))) {
          context4.report({
            node: token,
            messageId: "after",
            fix(fixer) {
              return fixer.insertTextAfter(token, "\n");
            }
          });
        }
      }
      return {
        Program() {
          comments.forEach((token) => {
            if (token.type === "Line") {
              if (options.beforeLineComment || options.afterLineComment) {
                checkForEmptyLine(token, {
                  after: options.afterLineComment,
                  before: options.beforeLineComment
                });
              }
            } else if (token.type === "Block") {
              if (options.beforeBlockComment || options.afterBlockComment) {
                checkForEmptyLine(token, {
                  after: options.afterBlockComment,
                  before: options.beforeBlockComment
                });
              }
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/lines-around-directive.js
var require_lines_around_directive = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow newlines around directives",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/lines-around-directive"
      },
      schema: [{
        oneOf: [
          {
            enum: ["always", "never"]
          },
          {
            type: "object",
            properties: {
              before: {
                enum: ["always", "never"]
              },
              after: {
                enum: ["always", "never"]
              }
            },
            additionalProperties: false,
            minProperties: 2
          }
        ]
      }],
      fixable: "whitespace",
      messages: {
        expected: 'Expected newline {{location}} "{{value}}" directive.',
        unexpected: 'Unexpected newline {{location}} "{{value}}" directive.'
      },
      deprecated: true,
      replacedBy: ["padding-line-between-statements"]
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const config = context4.options[0] || "always";
      const expectLineBefore = typeof config === "string" ? config : config.before;
      const expectLineAfter = typeof config === "string" ? config : config.after;
      function hasNewlineBefore(node) {
        const tokenBefore = sourceCode.getTokenBefore(node, {includeComments: true});
        const tokenLineBefore = tokenBefore ? tokenBefore.loc.end.line : 0;
        return node.loc.start.line - tokenLineBefore >= 2;
      }
      function getLastTokenOnLine(node) {
        const lastToken = sourceCode.getLastToken(node);
        const secondToLastToken = sourceCode.getTokenBefore(lastToken);
        return astUtils.isSemicolonToken(lastToken) && lastToken.loc.start.line > secondToLastToken.loc.end.line ? secondToLastToken : lastToken;
      }
      function hasNewlineAfter(node) {
        const lastToken = getLastTokenOnLine(node);
        const tokenAfter = sourceCode.getTokenAfter(lastToken, {includeComments: true});
        return tokenAfter.loc.start.line - lastToken.loc.end.line >= 2;
      }
      function reportError(node, location, expected) {
        context4.report({
          node,
          messageId: expected ? "expected" : "unexpected",
          data: {
            value: node.expression.value,
            location
          },
          fix(fixer) {
            const lastToken = getLastTokenOnLine(node);
            if (expected) {
              return location === "before" ? fixer.insertTextBefore(node, "\n") : fixer.insertTextAfter(lastToken, "\n");
            }
            return fixer.removeRange(location === "before" ? [node.range[0] - 1, node.range[0]] : [lastToken.range[1], lastToken.range[1] + 1]);
          }
        });
      }
      function checkDirectives(node) {
        const directives = astUtils.getDirectivePrologue(node);
        if (!directives.length) {
          return;
        }
        const firstDirective = directives[0];
        const leadingComments = sourceCode.getCommentsBefore(firstDirective);
        if (leadingComments.length) {
          if (expectLineBefore === "always" && !hasNewlineBefore(firstDirective)) {
            reportError(firstDirective, "before", true);
          }
          if (expectLineBefore === "never" && hasNewlineBefore(firstDirective)) {
            reportError(firstDirective, "before", false);
          }
        } else if (node.type === "Program" && expectLineBefore === "never" && !leadingComments.length && hasNewlineBefore(firstDirective)) {
          reportError(firstDirective, "before", false);
        }
        const lastDirective = directives[directives.length - 1];
        const statements = node.type === "Program" ? node.body : node.body.body;
        if (lastDirective === statements[statements.length - 1] && !lastDirective.trailingComments) {
          return;
        }
        if (expectLineAfter === "always" && !hasNewlineAfter(lastDirective)) {
          reportError(lastDirective, "after", true);
        }
        if (expectLineAfter === "never" && hasNewlineAfter(lastDirective)) {
          reportError(lastDirective, "after", false);
        }
      }
      return {
        Program: checkDirectives,
        FunctionDeclaration: checkDirectives,
        FunctionExpression: checkDirectives,
        ArrowFunctionExpression: checkDirectives
      };
    }
  };
});

// node_modules/eslint/lib/rules/lines-between-class-members.js
var require_lines_between_class_members = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow an empty line between class members",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/lines-between-class-members"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptAfterSingleLine: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        never: "Unexpected blank line between class members.",
        always: "Expected blank line between class members."
      }
    },
    create(context4) {
      const options = [];
      options[0] = context4.options[0] || "always";
      options[1] = context4.options[1] || {exceptAfterSingleLine: false};
      const sourceCode = context4.getSourceCode();
      function findLastConsecutiveTokenAfter(prevLastToken, nextFirstToken, maxLine) {
        const after = sourceCode.getTokenAfter(prevLastToken, {includeComments: true});
        if (after !== nextFirstToken && after.loc.start.line - prevLastToken.loc.end.line <= maxLine) {
          return findLastConsecutiveTokenAfter(after, nextFirstToken, maxLine);
        }
        return prevLastToken;
      }
      function findFirstConsecutiveTokenBefore(nextFirstToken, prevLastToken, maxLine) {
        const before = sourceCode.getTokenBefore(nextFirstToken, {includeComments: true});
        if (before !== prevLastToken && nextFirstToken.loc.start.line - before.loc.end.line <= maxLine) {
          return findFirstConsecutiveTokenBefore(before, prevLastToken, maxLine);
        }
        return nextFirstToken;
      }
      function hasTokenOrCommentBetween(before, after) {
        return sourceCode.getTokensBetween(before, after, {includeComments: true}).length !== 0;
      }
      return {
        ClassBody(node) {
          const body = node.body;
          for (let i = 0; i < body.length - 1; i++) {
            const curFirst = sourceCode.getFirstToken(body[i]);
            const curLast = sourceCode.getLastToken(body[i]);
            const nextFirst = sourceCode.getFirstToken(body[i + 1]);
            const isMulti = !astUtils.isTokenOnSameLine(curFirst, curLast);
            const skip = !isMulti && options[1].exceptAfterSingleLine;
            const beforePadding = findLastConsecutiveTokenAfter(curLast, nextFirst, 1);
            const afterPadding = findFirstConsecutiveTokenBefore(nextFirst, curLast, 1);
            const isPadded = afterPadding.loc.start.line - beforePadding.loc.end.line > 1;
            const hasTokenInPadding = hasTokenOrCommentBetween(beforePadding, afterPadding);
            const curLineLastToken = findLastConsecutiveTokenAfter(curLast, nextFirst, 0);
            if (options[0] === "always" && !skip && !isPadded || options[0] === "never" && isPadded) {
              context4.report({
                node: body[i + 1],
                messageId: isPadded ? "never" : "always",
                fix(fixer) {
                  if (hasTokenInPadding) {
                    return null;
                  }
                  return isPadded ? fixer.replaceTextRange([beforePadding.range[1], afterPadding.range[0]], "\n") : fixer.insertTextAfter(curLineLastToken, "\n");
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-classes-per-file.js
var require_max_classes_per_file = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum number of classes per file",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-classes-per-file"
      },
      schema: [
        {
          type: "integer",
          minimum: 1
        }
      ],
      messages: {
        maximumExceeded: "File has too many classes ({{ classCount }}). Maximum allowed is {{ max }}."
      }
    },
    create(context4) {
      const maxClasses = context4.options[0] || 1;
      let classCount = 0;
      return {
        Program() {
          classCount = 0;
        },
        "Program:exit"(node) {
          if (classCount > maxClasses) {
            context4.report({
              node,
              messageId: "maximumExceeded",
              data: {
                classCount,
                max: maxClasses
              }
            });
          }
        },
        "ClassDeclaration, ClassExpression"() {
          classCount++;
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-depth.js
var require_max_depth = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum depth that blocks can be nested",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-depth"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        tooDeeply: "Blocks are nested too deeply ({{depth}}). Maximum allowed is {{maxDepth}}."
      }
    },
    create(context4) {
      const functionStack = [], option = context4.options[0];
      let maxDepth = 4;
      if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
        maxDepth = option.maximum || option.max;
      }
      if (typeof option === "number") {
        maxDepth = option;
      }
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction() {
        functionStack.pop();
      }
      function pushBlock(node) {
        const len = ++functionStack[functionStack.length - 1];
        if (len > maxDepth) {
          context4.report({node, messageId: "tooDeeply", data: {depth: len, maxDepth}});
        }
      }
      function popBlock() {
        functionStack[functionStack.length - 1]--;
      }
      return {
        Program: startFunction,
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        IfStatement(node) {
          if (node.parent.type !== "IfStatement") {
            pushBlock(node);
          }
        },
        SwitchStatement: pushBlock,
        TryStatement: pushBlock,
        DoWhileStatement: pushBlock,
        WhileStatement: pushBlock,
        WithStatement: pushBlock,
        ForStatement: pushBlock,
        ForInStatement: pushBlock,
        ForOfStatement: pushBlock,
        "IfStatement:exit": popBlock,
        "SwitchStatement:exit": popBlock,
        "TryStatement:exit": popBlock,
        "DoWhileStatement:exit": popBlock,
        "WhileStatement:exit": popBlock,
        "WithStatement:exit": popBlock,
        "ForStatement:exit": popBlock,
        "ForInStatement:exit": popBlock,
        "ForOfStatement:exit": popBlock,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "Program:exit": endFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-len.js
var require_max_len = __commonJS((exports2, module2) => {
  "use strict";
  var OPTIONS_SCHEMA = {
    type: "object",
    properties: {
      code: {
        type: "integer",
        minimum: 0
      },
      comments: {
        type: "integer",
        minimum: 0
      },
      tabWidth: {
        type: "integer",
        minimum: 0
      },
      ignorePattern: {
        type: "string"
      },
      ignoreComments: {
        type: "boolean"
      },
      ignoreStrings: {
        type: "boolean"
      },
      ignoreUrls: {
        type: "boolean"
      },
      ignoreTemplateLiterals: {
        type: "boolean"
      },
      ignoreRegExpLiterals: {
        type: "boolean"
      },
      ignoreTrailingComments: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  var OPTIONS_OR_INTEGER_SCHEMA = {
    anyOf: [
      OPTIONS_SCHEMA,
      {
        type: "integer",
        minimum: 0
      }
    ]
  };
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce a maximum line length",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-len"
      },
      schema: [
        OPTIONS_OR_INTEGER_SCHEMA,
        OPTIONS_OR_INTEGER_SCHEMA,
        OPTIONS_SCHEMA
      ],
      messages: {
        max: "This line has a length of {{lineLength}}. Maximum allowed is {{maxLength}}.",
        maxComment: "This line has a comment length of {{lineLength}}. Maximum allowed is {{maxCommentLength}}."
      }
    },
    create(context4) {
      const URL_REGEXP = /[^:/?#]:\/\/[^?#]/u;
      const sourceCode = context4.getSourceCode();
      function computeLineLength(line, tabWidth2) {
        let extraCharacterCount = 0;
        line.replace(/\t/gu, (match, offset) => {
          const totalOffset = offset + extraCharacterCount, previousTabStopOffset = tabWidth2 ? totalOffset % tabWidth2 : 0, spaceCount = tabWidth2 - previousTabStopOffset;
          extraCharacterCount += spaceCount - 1;
        });
        return Array.from(line).length + extraCharacterCount;
      }
      const options = Object.assign({}, context4.options[context4.options.length - 1]);
      if (typeof context4.options[0] === "number") {
        options.code = context4.options[0];
      }
      if (typeof context4.options[1] === "number") {
        options.tabWidth = context4.options[1];
      }
      const maxLength = typeof options.code === "number" ? options.code : 80, tabWidth = typeof options.tabWidth === "number" ? options.tabWidth : 4, ignoreComments = !!options.ignoreComments, ignoreStrings = !!options.ignoreStrings, ignoreTemplateLiterals = !!options.ignoreTemplateLiterals, ignoreRegExpLiterals = !!options.ignoreRegExpLiterals, ignoreTrailingComments = !!options.ignoreTrailingComments || !!options.ignoreComments, ignoreUrls = !!options.ignoreUrls, maxCommentLength = options.comments;
      let ignorePattern = options.ignorePattern || null;
      if (ignorePattern) {
        ignorePattern = new RegExp(ignorePattern, "u");
      }
      function isTrailingComment(line, lineNumber, comment) {
        return comment && (comment.loc.start.line === lineNumber && lineNumber <= comment.loc.end.line) && (comment.loc.end.line > lineNumber || comment.loc.end.column === line.length);
      }
      function isFullLineComment(line, lineNumber, comment) {
        const start = comment.loc.start, end = comment.loc.end, isFirstTokenOnLine = !line.slice(0, comment.loc.start.column).trim();
        return comment && (start.line < lineNumber || start.line === lineNumber && isFirstTokenOnLine) && (end.line > lineNumber || end.line === lineNumber && end.column === line.length);
      }
      function isJSXEmptyExpressionInSingleLineContainer(node) {
        if (!node || !node.parent || node.type !== "JSXEmptyExpression" || node.parent.type !== "JSXExpressionContainer") {
          return false;
        }
        const parent = node.parent;
        return parent.loc.start.line === parent.loc.end.line;
      }
      function stripTrailingComment(line, comment) {
        return line.slice(0, comment.loc.start.column).replace(/\s+$/u, "");
      }
      function ensureArrayAndPush(object, key, value) {
        if (!Array.isArray(object[key])) {
          object[key] = [];
        }
        object[key].push(value);
      }
      function getAllStrings() {
        return sourceCode.ast.tokens.filter((token) => token.type === "String" || token.type === "JSXText" && sourceCode.getNodeByRangeIndex(token.range[0] - 1).type === "JSXAttribute");
      }
      function getAllTemplateLiterals() {
        return sourceCode.ast.tokens.filter((token) => token.type === "Template");
      }
      function getAllRegExpLiterals() {
        return sourceCode.ast.tokens.filter((token) => token.type === "RegularExpression");
      }
      function groupByLineNumber(acc, node) {
        for (let i = node.loc.start.line; i <= node.loc.end.line; ++i) {
          ensureArrayAndPush(acc, i, node);
        }
        return acc;
      }
      function getAllComments() {
        const comments = [];
        sourceCode.getAllComments().forEach((commentNode) => {
          const containingNode = sourceCode.getNodeByRangeIndex(commentNode.range[0]);
          if (isJSXEmptyExpressionInSingleLineContainer(containingNode)) {
            if (comments[comments.length - 1] !== containingNode.parent) {
              comments.push(containingNode.parent);
            }
          } else {
            comments.push(commentNode);
          }
        });
        return comments;
      }
      function checkProgramForMaxLength(node) {
        const lines = sourceCode.lines, comments = ignoreComments || maxCommentLength || ignoreTrailingComments ? getAllComments() : [];
        let commentsIndex = 0;
        const strings = getAllStrings();
        const stringsByLine = strings.reduce(groupByLineNumber, {});
        const templateLiterals = getAllTemplateLiterals();
        const templateLiteralsByLine = templateLiterals.reduce(groupByLineNumber, {});
        const regExpLiterals = getAllRegExpLiterals();
        const regExpLiteralsByLine = regExpLiterals.reduce(groupByLineNumber, {});
        lines.forEach((line, i) => {
          const lineNumber = i + 1;
          let lineIsComment = false;
          let textToMeasure;
          if (commentsIndex < comments.length) {
            let comment = null;
            do {
              comment = comments[++commentsIndex];
            } while (comment && comment.loc.start.line <= lineNumber);
            comment = comments[--commentsIndex];
            if (isFullLineComment(line, lineNumber, comment)) {
              lineIsComment = true;
              textToMeasure = line;
            } else if (ignoreTrailingComments && isTrailingComment(line, lineNumber, comment)) {
              textToMeasure = stripTrailingComment(line, comment);
              let lastIndex = commentsIndex;
              while (isTrailingComment(textToMeasure, lineNumber, comments[--lastIndex])) {
                textToMeasure = stripTrailingComment(textToMeasure, comments[lastIndex]);
              }
            } else {
              textToMeasure = line;
            }
          } else {
            textToMeasure = line;
          }
          if (ignorePattern && ignorePattern.test(textToMeasure) || ignoreUrls && URL_REGEXP.test(textToMeasure) || ignoreStrings && stringsByLine[lineNumber] || ignoreTemplateLiterals && templateLiteralsByLine[lineNumber] || ignoreRegExpLiterals && regExpLiteralsByLine[lineNumber]) {
            return;
          }
          const lineLength = computeLineLength(textToMeasure, tabWidth);
          const commentLengthApplies = lineIsComment && maxCommentLength;
          if (lineIsComment && ignoreComments) {
            return;
          }
          const loc = {
            start: {
              line: lineNumber,
              column: 0
            },
            end: {
              line: lineNumber,
              column: textToMeasure.length
            }
          };
          if (commentLengthApplies) {
            if (lineLength > maxCommentLength) {
              context4.report({
                node,
                loc,
                messageId: "maxComment",
                data: {
                  lineLength,
                  maxCommentLength
                }
              });
            }
          } else if (lineLength > maxLength) {
            context4.report({
              node,
              loc,
              messageId: "max",
              data: {
                lineLength,
                maxLength
              }
            });
          }
        });
      }
      return {
        Program: checkProgramForMaxLength
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-lines.js
var require_max_lines = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum number of lines per file",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-lines"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                max: {
                  type: "integer",
                  minimum: 0
                },
                skipComments: {
                  type: "boolean"
                },
                skipBlankLines: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "File has too many lines ({{actual}}). Maximum allowed is {{max}}."
      }
    },
    create(context4) {
      const option = context4.options[0];
      let max = 300;
      if (typeof option === "object" && Object.prototype.hasOwnProperty.call(option, "max")) {
        max = option.max;
      } else if (typeof option === "number") {
        max = option;
      }
      const skipComments = option && option.skipComments;
      const skipBlankLines = option && option.skipBlankLines;
      const sourceCode = context4.getSourceCode();
      function isCommentNodeType(token) {
        return token && (token.type === "Block" || token.type === "Line");
      }
      function getLinesWithoutCode(comment) {
        let start = comment.loc.start.line;
        let end = comment.loc.end.line;
        let token;
        token = comment;
        do {
          token = sourceCode.getTokenBefore(token, {
            includeComments: true
          });
        } while (isCommentNodeType(token));
        if (token && astUtils.isTokenOnSameLine(token, comment)) {
          start += 1;
        }
        token = comment;
        do {
          token = sourceCode.getTokenAfter(token, {
            includeComments: true
          });
        } while (isCommentNodeType(token));
        if (token && astUtils.isTokenOnSameLine(comment, token)) {
          end -= 1;
        }
        if (start <= end) {
          return lodash.range(start, end + 1);
        }
        return [];
      }
      return {
        "Program:exit"() {
          let lines = sourceCode.lines.map((text, i) => ({
            lineNumber: i + 1,
            text
          }));
          if (lines.length > 1 && lodash.last(lines).text === "") {
            lines.pop();
          }
          if (skipBlankLines) {
            lines = lines.filter((l) => l.text.trim() !== "");
          }
          if (skipComments) {
            const comments = sourceCode.getAllComments();
            const commentLines = lodash.flatten(comments.map((comment) => getLinesWithoutCode(comment)));
            lines = lines.filter((l) => !commentLines.includes(l.lineNumber));
          }
          if (lines.length > max) {
            const loc = {
              start: {
                line: lines[max].lineNumber,
                column: 0
              },
              end: {
                line: sourceCode.lines.length,
                column: lodash.last(sourceCode.lines).length
              }
            };
            context4.report({
              loc,
              messageId: "exceed",
              data: {
                max,
                actual: lines.length
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-lines-per-function.js
var require_max_lines_per_function = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var lodash = require_lodash();
  var OPTIONS_SCHEMA = {
    type: "object",
    properties: {
      max: {
        type: "integer",
        minimum: 0
      },
      skipComments: {
        type: "boolean"
      },
      skipBlankLines: {
        type: "boolean"
      },
      IIFEs: {
        type: "boolean"
      }
    },
    additionalProperties: false
  };
  var OPTIONS_OR_INTEGER_SCHEMA = {
    oneOf: [
      OPTIONS_SCHEMA,
      {
        type: "integer",
        minimum: 1
      }
    ]
  };
  function getCommentLineNumbers(comments) {
    const map = new Map();
    comments.forEach((comment) => {
      for (let i = comment.loc.start.line; i <= comment.loc.end.line; i++) {
        map.set(i, comment);
      }
    });
    return map;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum number of lines of code in a function",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-lines-per-function"
      },
      schema: [
        OPTIONS_OR_INTEGER_SCHEMA
      ],
      messages: {
        exceed: "{{name}} has too many lines ({{lineCount}}). Maximum allowed is {{maxLines}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const lines = sourceCode.lines;
      const option = context4.options[0];
      let maxLines = 50;
      let skipComments = false;
      let skipBlankLines = false;
      let IIFEs = false;
      if (typeof option === "object") {
        maxLines = typeof option.max === "number" ? option.max : 50;
        skipComments = !!option.skipComments;
        skipBlankLines = !!option.skipBlankLines;
        IIFEs = !!option.IIFEs;
      } else if (typeof option === "number") {
        maxLines = option;
      }
      const commentLineNumbers = getCommentLineNumbers(sourceCode.getAllComments());
      function isFullLineComment(line, lineNumber, comment) {
        const start = comment.loc.start, end = comment.loc.end, isFirstTokenOnLine = start.line === lineNumber && !line.slice(0, start.column).trim(), isLastTokenOnLine = end.line === lineNumber && !line.slice(end.column).trim();
        return comment && (start.line < lineNumber || isFirstTokenOnLine) && (end.line > lineNumber || isLastTokenOnLine);
      }
      function isIIFE(node) {
        return (node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression") && node.parent && node.parent.type === "CallExpression" && node.parent.callee === node;
      }
      function isEmbedded(node) {
        if (!node.parent) {
          return false;
        }
        if (node !== node.parent.value) {
          return false;
        }
        if (node.parent.type === "MethodDefinition") {
          return true;
        }
        if (node.parent.type === "Property") {
          return node.parent.method === true || node.parent.kind === "get" || node.parent.kind === "set";
        }
        return false;
      }
      function processFunction(funcNode) {
        const node = isEmbedded(funcNode) ? funcNode.parent : funcNode;
        if (!IIFEs && isIIFE(node)) {
          return;
        }
        let lineCount = 0;
        for (let i = node.loc.start.line - 1; i < node.loc.end.line; ++i) {
          const line = lines[i];
          if (skipComments) {
            if (commentLineNumbers.has(i + 1) && isFullLineComment(line, i + 1, commentLineNumbers.get(i + 1))) {
              continue;
            }
          }
          if (skipBlankLines) {
            if (line.match(/^\s*$/u)) {
              continue;
            }
          }
          lineCount++;
        }
        if (lineCount > maxLines) {
          const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(funcNode));
          context4.report({
            node,
            messageId: "exceed",
            data: {name, lineCount, maxLines}
          });
        }
      }
      return {
        FunctionDeclaration: processFunction,
        FunctionExpression: processFunction,
        ArrowFunctionExpression: processFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-nested-callbacks.js
var require_max_nested_callbacks = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum depth that callbacks can be nested",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-nested-callbacks"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "Too many nested callbacks ({{num}}). Maximum allowed is {{max}}."
      }
    },
    create(context4) {
      const option = context4.options[0];
      let THRESHOLD = 10;
      if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
        THRESHOLD = option.maximum || option.max;
      } else if (typeof option === "number") {
        THRESHOLD = option;
      }
      const callbackStack = [];
      function checkFunction(node) {
        const parent = node.parent;
        if (parent.type === "CallExpression") {
          callbackStack.push(node);
        }
        if (callbackStack.length > THRESHOLD) {
          const opts = {num: callbackStack.length, max: THRESHOLD};
          context4.report({node, messageId: "exceed", data: opts});
        }
      }
      function popStack() {
        callbackStack.pop();
      }
      return {
        ArrowFunctionExpression: checkFunction,
        "ArrowFunctionExpression:exit": popStack,
        FunctionExpression: checkFunction,
        "FunctionExpression:exit": popStack
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-params.js
var require_max_params = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum number of parameters in function definitions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-params"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        exceed: "{{name}} has too many parameters ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const option = context4.options[0];
      let numParams = 3;
      if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
        numParams = option.maximum || option.max;
      }
      if (typeof option === "number") {
        numParams = option;
      }
      function checkFunction(node) {
        if (node.params.length > numParams) {
          context4.report({
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            node,
            messageId: "exceed",
            data: {
              name: lodash.upperFirst(astUtils.getFunctionNameWithKind(node)),
              count: node.params.length,
              max: numParams
            }
          });
        }
      }
      return {
        FunctionDeclaration: checkFunction,
        ArrowFunctionExpression: checkFunction,
        FunctionExpression: checkFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-statements.js
var require_max_statements = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a maximum number of statements allowed in function blocks",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-statements"
      },
      schema: [
        {
          oneOf: [
            {
              type: "integer",
              minimum: 0
            },
            {
              type: "object",
              properties: {
                maximum: {
                  type: "integer",
                  minimum: 0
                },
                max: {
                  type: "integer",
                  minimum: 0
                }
              },
              additionalProperties: false
            }
          ]
        },
        {
          type: "object",
          properties: {
            ignoreTopLevelFunctions: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        exceed: "{{name}} has too many statements ({{count}}). Maximum allowed is {{max}}."
      }
    },
    create(context4) {
      const functionStack = [], option = context4.options[0], ignoreTopLevelFunctions = context4.options[1] && context4.options[1].ignoreTopLevelFunctions || false, topLevelFunctions = [];
      let maxStatements = 10;
      if (typeof option === "object" && (Object.prototype.hasOwnProperty.call(option, "maximum") || Object.prototype.hasOwnProperty.call(option, "max"))) {
        maxStatements = option.maximum || option.max;
      } else if (typeof option === "number") {
        maxStatements = option;
      }
      function reportIfTooManyStatements(node, count, max) {
        if (count > max) {
          const name = lodash.upperFirst(astUtils.getFunctionNameWithKind(node));
          context4.report({
            node,
            messageId: "exceed",
            data: {name, count, max}
          });
        }
      }
      function startFunction() {
        functionStack.push(0);
      }
      function endFunction(node) {
        const count = functionStack.pop();
        if (ignoreTopLevelFunctions && functionStack.length === 0) {
          topLevelFunctions.push({node, count});
        } else {
          reportIfTooManyStatements(node, count, maxStatements);
        }
      }
      function countStatements(node) {
        functionStack[functionStack.length - 1] += node.body.length;
      }
      return {
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        BlockStatement: countStatements,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction,
        "Program:exit"() {
          if (topLevelFunctions.length === 1) {
            return;
          }
          topLevelFunctions.forEach((element) => {
            const count = element.count;
            const node = element.node;
            reportIfTooManyStatements(node, count, maxStatements);
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/max-statements-per-line.js
var require_max_statements_per_line = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce a maximum number of statements allowed per line",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/max-statements-per-line"
      },
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 1,
              default: 1
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        exceed: "This line has {{numberOfStatementsOnThisLine}} {{statements}}. Maximum allowed is {{maxStatementsPerLine}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode(), options = context4.options[0] || {}, maxStatementsPerLine = typeof options.max !== "undefined" ? options.max : 1;
      let lastStatementLine = 0, numberOfStatementsOnThisLine = 0, firstExtraStatement;
      const SINGLE_CHILD_ALLOWED = /^(?:(?:DoWhile|For|ForIn|ForOf|If|Labeled|While)Statement|Export(?:Default|Named)Declaration)$/u;
      function reportFirstExtraStatementAndClear() {
        if (firstExtraStatement) {
          context4.report({
            node: firstExtraStatement,
            messageId: "exceed",
            data: {
              numberOfStatementsOnThisLine,
              maxStatementsPerLine,
              statements: numberOfStatementsOnThisLine === 1 ? "statement" : "statements"
            }
          });
        }
        firstExtraStatement = null;
      }
      function getActualLastToken(node) {
        return sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
      }
      function enterStatement(node) {
        const line = node.loc.start.line;
        if (SINGLE_CHILD_ALLOWED.test(node.parent.type) && node.parent.alternate !== node) {
          return;
        }
        if (line === lastStatementLine) {
          numberOfStatementsOnThisLine += 1;
        } else {
          reportFirstExtraStatementAndClear();
          numberOfStatementsOnThisLine = 1;
          lastStatementLine = line;
        }
        if (numberOfStatementsOnThisLine === maxStatementsPerLine + 1) {
          firstExtraStatement = firstExtraStatement || node;
        }
      }
      function leaveStatement(node) {
        const line = getActualLastToken(node).loc.end.line;
        if (line !== lastStatementLine) {
          reportFirstExtraStatementAndClear();
          numberOfStatementsOnThisLine = 1;
          lastStatementLine = line;
        }
      }
      return {
        BreakStatement: enterStatement,
        ClassDeclaration: enterStatement,
        ContinueStatement: enterStatement,
        DebuggerStatement: enterStatement,
        DoWhileStatement: enterStatement,
        ExpressionStatement: enterStatement,
        ForInStatement: enterStatement,
        ForOfStatement: enterStatement,
        ForStatement: enterStatement,
        FunctionDeclaration: enterStatement,
        IfStatement: enterStatement,
        ImportDeclaration: enterStatement,
        LabeledStatement: enterStatement,
        ReturnStatement: enterStatement,
        SwitchStatement: enterStatement,
        ThrowStatement: enterStatement,
        TryStatement: enterStatement,
        VariableDeclaration: enterStatement,
        WhileStatement: enterStatement,
        WithStatement: enterStatement,
        ExportNamedDeclaration: enterStatement,
        ExportDefaultDeclaration: enterStatement,
        ExportAllDeclaration: enterStatement,
        "BreakStatement:exit": leaveStatement,
        "ClassDeclaration:exit": leaveStatement,
        "ContinueStatement:exit": leaveStatement,
        "DebuggerStatement:exit": leaveStatement,
        "DoWhileStatement:exit": leaveStatement,
        "ExpressionStatement:exit": leaveStatement,
        "ForInStatement:exit": leaveStatement,
        "ForOfStatement:exit": leaveStatement,
        "ForStatement:exit": leaveStatement,
        "FunctionDeclaration:exit": leaveStatement,
        "IfStatement:exit": leaveStatement,
        "ImportDeclaration:exit": leaveStatement,
        "LabeledStatement:exit": leaveStatement,
        "ReturnStatement:exit": leaveStatement,
        "SwitchStatement:exit": leaveStatement,
        "ThrowStatement:exit": leaveStatement,
        "TryStatement:exit": leaveStatement,
        "VariableDeclaration:exit": leaveStatement,
        "WhileStatement:exit": leaveStatement,
        "WithStatement:exit": leaveStatement,
        "ExportNamedDeclaration:exit": leaveStatement,
        "ExportDefaultDeclaration:exit": leaveStatement,
        "ExportAllDeclaration:exit": leaveStatement,
        "Program:exit": reportFirstExtraStatementAndClear
      };
    }
  };
});

// node_modules/eslint/lib/rules/multiline-comment-style.js
var require_multiline_comment_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce a particular style for multiline comments",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/multiline-comment-style"
      },
      fixable: "whitespace",
      schema: [{enum: ["starred-block", "separate-lines", "bare-block"]}],
      messages: {
        expectedBlock: "Expected a block comment instead of consecutive line comments.",
        expectedBareBlock: "Expected a block comment without padding stars.",
        startNewline: "Expected a linebreak after '/*'.",
        endNewline: "Expected a linebreak before '*/'.",
        missingStar: "Expected a '*' at the start of this line.",
        alignment: "Expected this line to be aligned with the start of the comment.",
        expectedLines: "Expected multiple line comments instead of a block comment."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const option = context4.options[0] || "starred-block";
      function isStarredCommentLine(line) {
        return /^\s*\*/u.test(line);
      }
      function isStarredBlockComment([firstComment]) {
        if (firstComment.type !== "Block") {
          return false;
        }
        const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
        return lines.length > 0 && lines.every((line, i) => (i === 0 || i === lines.length - 1 ? /^\s*$/u : /^\s*\*/u).test(line));
      }
      function isJSDocComment([firstComment]) {
        if (firstComment.type !== "Block") {
          return false;
        }
        const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
        return /^\*\s*$/u.test(lines[0]) && lines.slice(1, -1).every((line) => /^\s* /u.test(line)) && /^\s*$/u.test(lines[lines.length - 1]);
      }
      function processSeparateLineComments(commentGroup) {
        const allLinesHaveLeadingSpace = commentGroup.map(({value}) => value).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
        return commentGroup.map(({value}) => allLinesHaveLeadingSpace ? value.replace(/^ /u, "") : value);
      }
      function processStarredBlockComment(comment) {
        const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).filter((line, i, linesArr) => !(i === 0 || i === linesArr.length - 1)).map((line) => line.replace(/^\s*$/u, ""));
        const allLinesHaveLeadingSpace = lines.map((line) => line.replace(/\s*\*/u, "")).filter((line) => line.trim().length).every((line) => line.startsWith(" "));
        return lines.map((line) => line.replace(allLinesHaveLeadingSpace ? /\s*\* ?/u : /\s*\*/u, ""));
      }
      function processBareBlockComment(comment) {
        const lines = comment.value.split(astUtils.LINEBREAK_MATCHER).map((line) => line.replace(/^\s*$/u, ""));
        const leadingWhitespace = `${sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0])}   `;
        let offset = "";
        for (const [i, line] of lines.entries()) {
          if (!line.trim().length || i === 0) {
            continue;
          }
          const [, lineOffset] = line.match(/^(\s*\*?\s*)/u);
          if (lineOffset.length < leadingWhitespace.length) {
            const newOffset = leadingWhitespace.slice(lineOffset.length - leadingWhitespace.length);
            if (newOffset.length > offset.length) {
              offset = newOffset;
            }
          }
        }
        return lines.map((line) => {
          const match = line.match(/^(\s*\*?\s*)(.*)/u);
          const [, lineOffset, lineContents] = match;
          if (lineOffset.length > leadingWhitespace.length) {
            return `${lineOffset.slice(leadingWhitespace.length - (offset.length + lineOffset.length))}${lineContents}`;
          }
          if (lineOffset.length < leadingWhitespace.length) {
            return `${lineOffset.slice(leadingWhitespace.length)}${lineContents}`;
          }
          return lineContents;
        });
      }
      function getCommentLines(commentGroup) {
        const [firstComment] = commentGroup;
        if (firstComment.type === "Line") {
          return processSeparateLineComments(commentGroup);
        }
        if (isStarredBlockComment(commentGroup)) {
          return processStarredBlockComment(firstComment);
        }
        return processBareBlockComment(firstComment);
      }
      function getInitialOffset(comment) {
        return sourceCode.text.slice(comment.range[0] - comment.loc.start.column, comment.range[0]);
      }
      function convertToStarredBlock(firstComment, commentLinesList) {
        const initialOffset = getInitialOffset(firstComment);
        return `/*
${commentLinesList.map((line) => `${initialOffset} * ${line}`).join("\n")}
${initialOffset} */`;
      }
      function convertToSeparateLines(firstComment, commentLinesList) {
        return commentLinesList.map((line) => `// ${line}`).join(`
${getInitialOffset(firstComment)}`);
      }
      function convertToBlock(firstComment, commentLinesList) {
        return `/* ${commentLinesList.join(`
${getInitialOffset(firstComment)}   `)} */`;
      }
      const commentGroupCheckers = {
        "starred-block"(commentGroup) {
          const [firstComment] = commentGroup;
          const commentLines = getCommentLines(commentGroup);
          if (commentLines.some((value) => value.includes("*/"))) {
            return;
          }
          if (commentGroup.length > 1) {
            context4.report({
              loc: {
                start: firstComment.loc.start,
                end: commentGroup[commentGroup.length - 1].loc.end
              },
              messageId: "expectedBlock",
              fix(fixer) {
                const range = [firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]];
                return commentLines.some((value) => value.startsWith("/")) ? null : fixer.replaceTextRange(range, convertToStarredBlock(firstComment, commentLines));
              }
            });
          } else {
            const lines = firstComment.value.split(astUtils.LINEBREAK_MATCHER);
            const expectedLeadingWhitespace = getInitialOffset(firstComment);
            const expectedLinePrefix = `${expectedLeadingWhitespace} *`;
            if (!/^\*?\s*$/u.test(lines[0])) {
              const start = firstComment.value.startsWith("*") ? firstComment.range[0] + 1 : firstComment.range[0];
              context4.report({
                loc: {
                  start: firstComment.loc.start,
                  end: {line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2}
                },
                messageId: "startNewline",
                fix: (fixer) => fixer.insertTextAfterRange([start, start + 2], `
${expectedLinePrefix}`)
              });
            }
            if (!/^\s*$/u.test(lines[lines.length - 1])) {
              context4.report({
                loc: {
                  start: {line: firstComment.loc.end.line, column: firstComment.loc.end.column - 2},
                  end: firstComment.loc.end
                },
                messageId: "endNewline",
                fix: (fixer) => fixer.replaceTextRange([firstComment.range[1] - 2, firstComment.range[1]], `
${expectedLinePrefix}/`)
              });
            }
            for (let lineNumber = firstComment.loc.start.line + 1; lineNumber <= firstComment.loc.end.line; lineNumber++) {
              const lineText = sourceCode.lines[lineNumber - 1];
              const errorType = isStarredCommentLine(lineText) ? "alignment" : "missingStar";
              if (!lineText.startsWith(expectedLinePrefix)) {
                context4.report({
                  loc: {
                    start: {line: lineNumber, column: 0},
                    end: {line: lineNumber, column: lineText.length}
                  },
                  messageId: errorType,
                  fix(fixer) {
                    const lineStartIndex = sourceCode.getIndexFromLoc({line: lineNumber, column: 0});
                    if (errorType === "alignment") {
                      const [, commentTextPrefix2 = ""] = lineText.match(/^(\s*\*)/u) || [];
                      const commentTextStartIndex2 = lineStartIndex + commentTextPrefix2.length;
                      return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex2], expectedLinePrefix);
                    }
                    const [, commentTextPrefix = ""] = lineText.match(/^(\s*)/u) || [];
                    const commentTextStartIndex = lineStartIndex + commentTextPrefix.length;
                    let offset;
                    for (const [idx, line] of lines.entries()) {
                      if (!/\S+/u.test(line)) {
                        continue;
                      }
                      const lineTextToAlignWith = sourceCode.lines[firstComment.loc.start.line - 1 + idx];
                      const [, prefix = "", initialOffset = ""] = lineTextToAlignWith.match(/^(\s*(?:\/?\*)?(\s*))/u) || [];
                      offset = `${commentTextPrefix.slice(prefix.length)}${initialOffset}`;
                      if (/^\s*\//u.test(lineText) && offset.length === 0) {
                        offset += " ";
                      }
                      break;
                    }
                    return fixer.replaceTextRange([lineStartIndex, commentTextStartIndex], `${expectedLinePrefix}${offset}`);
                  }
                });
              }
            }
          }
        },
        "separate-lines"(commentGroup) {
          const [firstComment] = commentGroup;
          if (firstComment.type !== "Block" || isJSDocComment(commentGroup)) {
            return;
          }
          const commentLines = getCommentLines(commentGroup);
          const tokenAfter = sourceCode.getTokenAfter(firstComment, {includeComments: true});
          if (tokenAfter && firstComment.loc.end.line === tokenAfter.loc.start.line) {
            return;
          }
          context4.report({
            loc: {
              start: firstComment.loc.start,
              end: {line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2}
            },
            messageId: "expectedLines",
            fix(fixer) {
              return fixer.replaceText(firstComment, convertToSeparateLines(firstComment, commentLines));
            }
          });
        },
        "bare-block"(commentGroup) {
          if (isJSDocComment(commentGroup)) {
            return;
          }
          const [firstComment] = commentGroup;
          const commentLines = getCommentLines(commentGroup);
          if (firstComment.type === "Line" && commentLines.length > 1 && !commentLines.some((value) => value.includes("*/"))) {
            context4.report({
              loc: {
                start: firstComment.loc.start,
                end: commentGroup[commentGroup.length - 1].loc.end
              },
              messageId: "expectedBlock",
              fix(fixer) {
                return fixer.replaceTextRange([firstComment.range[0], commentGroup[commentGroup.length - 1].range[1]], convertToBlock(firstComment, commentLines));
              }
            });
          }
          if (isStarredBlockComment(commentGroup)) {
            context4.report({
              loc: {
                start: firstComment.loc.start,
                end: {line: firstComment.loc.start.line, column: firstComment.loc.start.column + 2}
              },
              messageId: "expectedBareBlock",
              fix(fixer) {
                return fixer.replaceText(firstComment, convertToBlock(firstComment, commentLines));
              }
            });
          }
        }
      };
      return {
        Program() {
          return sourceCode.getAllComments().filter((comment) => comment.type !== "Shebang").filter((comment) => !astUtils.COMMENTS_IGNORE_PATTERN.test(comment.value)).filter((comment) => {
            const tokenBefore = sourceCode.getTokenBefore(comment, {includeComments: true});
            return !tokenBefore || tokenBefore.loc.end.line < comment.loc.start.line;
          }).reduce((commentGroups, comment, index, commentList) => {
            const tokenBefore = sourceCode.getTokenBefore(comment, {includeComments: true});
            if (comment.type === "Line" && index && commentList[index - 1].type === "Line" && tokenBefore && tokenBefore.loc.end.line === comment.loc.start.line - 1 && tokenBefore === commentList[index - 1]) {
              commentGroups[commentGroups.length - 1].push(comment);
            } else {
              commentGroups.push([comment]);
            }
            return commentGroups;
          }, []).filter((commentGroup) => !(commentGroup.length === 1 && commentGroup[0].loc.start.line === commentGroup[0].loc.end.line)).forEach(commentGroupCheckers[option]);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/multiline-ternary.js
var require_multiline_ternary = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce newlines between operands of ternary expressions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/multiline-ternary"
      },
      schema: [
        {
          enum: ["always", "always-multiline", "never"]
        }
      ],
      messages: {
        expectedTestCons: "Expected newline between test and consequent of ternary expression.",
        expectedConsAlt: "Expected newline between consequent and alternate of ternary expression.",
        unexpectedTestCons: "Unexpected newline between test and consequent of ternary expression.",
        unexpectedConsAlt: "Unexpected newline between consequent and alternate of ternary expression."
      },
      fixable: "whitespace"
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const option = context4.options[0];
      const multiline = option !== "never";
      const allowSingleLine = option === "always-multiline";
      return {
        ConditionalExpression(node) {
          const questionToken = sourceCode.getTokenAfter(node.test, astUtils.isNotClosingParenToken);
          const colonToken = sourceCode.getTokenAfter(node.consequent, astUtils.isNotClosingParenToken);
          const firstTokenOfTest = sourceCode.getFirstToken(node);
          const lastTokenOfTest = sourceCode.getTokenBefore(questionToken);
          const firstTokenOfConsequent = sourceCode.getTokenAfter(questionToken);
          const lastTokenOfConsequent = sourceCode.getTokenBefore(colonToken);
          const firstTokenOfAlternate = sourceCode.getTokenAfter(colonToken);
          const areTestAndConsequentOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, firstTokenOfConsequent);
          const areConsequentAndAlternateOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, firstTokenOfAlternate);
          const hasComments = !!sourceCode.getCommentsInside(node).length;
          if (!multiline) {
            if (!areTestAndConsequentOnSameLine) {
              context4.report({
                node: node.test,
                loc: {
                  start: firstTokenOfTest.loc.start,
                  end: lastTokenOfTest.loc.end
                },
                messageId: "unexpectedTestCons",
                fix: (fixer) => {
                  if (hasComments) {
                    return null;
                  }
                  const fixers = [];
                  const areTestAndQuestionOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfTest, questionToken);
                  const areQuestionAndConsOnSameLine = astUtils.isTokenOnSameLine(questionToken, firstTokenOfConsequent);
                  if (!areTestAndQuestionOnSameLine) {
                    fixers.push(fixer.removeRange([lastTokenOfTest.range[1], questionToken.range[0]]));
                  }
                  if (!areQuestionAndConsOnSameLine) {
                    fixers.push(fixer.removeRange([questionToken.range[1], firstTokenOfConsequent.range[0]]));
                  }
                  return fixers;
                }
              });
            }
            if (!areConsequentAndAlternateOnSameLine) {
              context4.report({
                node: node.consequent,
                loc: {
                  start: firstTokenOfConsequent.loc.start,
                  end: lastTokenOfConsequent.loc.end
                },
                messageId: "unexpectedConsAlt",
                fix: (fixer) => {
                  if (hasComments) {
                    return null;
                  }
                  const fixers = [];
                  const areConsAndColonOnSameLine = astUtils.isTokenOnSameLine(lastTokenOfConsequent, colonToken);
                  const areColonAndAltOnSameLine = astUtils.isTokenOnSameLine(colonToken, firstTokenOfAlternate);
                  if (!areConsAndColonOnSameLine) {
                    fixers.push(fixer.removeRange([lastTokenOfConsequent.range[1], colonToken.range[0]]));
                  }
                  if (!areColonAndAltOnSameLine) {
                    fixers.push(fixer.removeRange([colonToken.range[1], firstTokenOfAlternate.range[0]]));
                  }
                  return fixers;
                }
              });
            }
          } else {
            if (allowSingleLine && node.loc.start.line === node.loc.end.line) {
              return;
            }
            if (areTestAndConsequentOnSameLine) {
              context4.report({
                node: node.test,
                loc: {
                  start: firstTokenOfTest.loc.start,
                  end: lastTokenOfTest.loc.end
                },
                messageId: "expectedTestCons",
                fix: (fixer) => hasComments ? null : fixer.replaceTextRange([
                  lastTokenOfTest.range[1],
                  questionToken.range[0]
                ], "\n")
              });
            }
            if (areConsequentAndAlternateOnSameLine) {
              context4.report({
                node: node.consequent,
                loc: {
                  start: firstTokenOfConsequent.loc.start,
                  end: lastTokenOfConsequent.loc.end
                },
                messageId: "expectedConsAlt",
                fix: (fixer) => hasComments ? null : fixer.replaceTextRange([
                  lastTokenOfConsequent.range[1],
                  colonToken.range[0]
                ], "\n")
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/new-cap.js
var require_new_cap = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var CAPS_ALLOWED = [
    "Array",
    "Boolean",
    "Date",
    "Error",
    "Function",
    "Number",
    "Object",
    "RegExp",
    "String",
    "Symbol",
    "BigInt"
  ];
  function checkArray(obj, key, fallback) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && !Array.isArray(obj[key])) {
      throw new TypeError(`${key}, if provided, must be an Array`);
    }
    return obj[key] || fallback;
  }
  function invert(map, key) {
    map[key] = true;
    return map;
  }
  function calculateCapIsNewExceptions(config) {
    let capIsNewExceptions = checkArray(config, "capIsNewExceptions", CAPS_ALLOWED);
    if (capIsNewExceptions !== CAPS_ALLOWED) {
      capIsNewExceptions = capIsNewExceptions.concat(CAPS_ALLOWED);
    }
    return capIsNewExceptions.reduce(invert, {});
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require constructor names to begin with a capital letter",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/new-cap"
      },
      schema: [
        {
          type: "object",
          properties: {
            newIsCap: {
              type: "boolean",
              default: true
            },
            capIsNew: {
              type: "boolean",
              default: true
            },
            newIsCapExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            newIsCapExceptionPattern: {
              type: "string"
            },
            capIsNewExceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            capIsNewExceptionPattern: {
              type: "string"
            },
            properties: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        upper: "A function with a name starting with an uppercase letter should only be used as a constructor.",
        lower: "A constructor name should not start with a lowercase letter."
      }
    },
    create(context4) {
      const config = Object.assign({}, context4.options[0]);
      config.newIsCap = config.newIsCap !== false;
      config.capIsNew = config.capIsNew !== false;
      const skipProperties = config.properties === false;
      const newIsCapExceptions = checkArray(config, "newIsCapExceptions", []).reduce(invert, {});
      const newIsCapExceptionPattern = config.newIsCapExceptionPattern ? new RegExp(config.newIsCapExceptionPattern, "u") : null;
      const capIsNewExceptions = calculateCapIsNewExceptions(config);
      const capIsNewExceptionPattern = config.capIsNewExceptionPattern ? new RegExp(config.capIsNewExceptionPattern, "u") : null;
      const listeners = {};
      const sourceCode = context4.getSourceCode();
      function extractNameFromExpression(node) {
        return node.callee.type === "Identifier" ? node.callee.name : astUtils.getStaticPropertyName(node.callee) || "";
      }
      function getCap(str) {
        const firstChar = str.charAt(0);
        const firstCharLower = firstChar.toLowerCase();
        const firstCharUpper = firstChar.toUpperCase();
        if (firstCharLower === firstCharUpper) {
          return "non-alpha";
        }
        if (firstChar === firstCharLower) {
          return "lower";
        }
        return "upper";
      }
      function isCapAllowed(allowedMap, node, calleeName, pattern) {
        const sourceText = sourceCode.getText(node.callee);
        if (allowedMap[calleeName] || allowedMap[sourceText]) {
          return true;
        }
        if (pattern && pattern.test(sourceText)) {
          return true;
        }
        const callee = astUtils.skipChainExpression(node.callee);
        if (calleeName === "UTC" && callee.type === "MemberExpression") {
          return callee.object.type === "Identifier" && callee.object.name === "Date";
        }
        return skipProperties && callee.type === "MemberExpression";
      }
      function report(node, messageId) {
        let callee = astUtils.skipChainExpression(node.callee);
        if (callee.type === "MemberExpression") {
          callee = callee.property;
        }
        context4.report({node, loc: callee.loc, messageId});
      }
      if (config.newIsCap) {
        listeners.NewExpression = function(node) {
          const constructorName = extractNameFromExpression(node);
          if (constructorName) {
            const capitalization = getCap(constructorName);
            const isAllowed = capitalization !== "lower" || isCapAllowed(newIsCapExceptions, node, constructorName, newIsCapExceptionPattern);
            if (!isAllowed) {
              report(node, "lower");
            }
          }
        };
      }
      if (config.capIsNew) {
        listeners.CallExpression = function(node) {
          const calleeName = extractNameFromExpression(node);
          if (calleeName) {
            const capitalization = getCap(calleeName);
            const isAllowed = capitalization !== "upper" || isCapAllowed(capIsNewExceptions, node, calleeName, capIsNewExceptionPattern);
            if (!isAllowed) {
              report(node, "upper");
            }
          }
        };
      }
      return listeners;
    }
  };
});

// node_modules/eslint/lib/rules/new-parens.js
var require_new_parens = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce or disallow parentheses when invoking a constructor with no arguments",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/new-parens"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "never"]
              }
            ],
            minItems: 0,
            maxItems: 1
          }
        ]
      },
      messages: {
        missing: "Missing '()' invoking a constructor.",
        unnecessary: "Unnecessary '()' invoking a constructor with no arguments."
      }
    },
    create(context4) {
      const options = context4.options;
      const always = options[0] !== "never";
      const sourceCode = context4.getSourceCode();
      return {
        NewExpression(node) {
          if (node.arguments.length !== 0) {
            return;
          }
          const lastToken = sourceCode.getLastToken(node);
          const hasLastParen = lastToken && astUtils.isClosingParenToken(lastToken);
          const hasParens = hasLastParen && astUtils.isOpeningParenToken(sourceCode.getTokenBefore(lastToken)) && node.callee.range[1] < node.range[1];
          if (always) {
            if (!hasParens) {
              context4.report({
                node,
                messageId: "missing",
                fix: (fixer) => fixer.insertTextAfter(node, "()")
              });
            }
          } else {
            if (hasParens) {
              context4.report({
                node,
                messageId: "unnecessary",
                fix: (fixer) => [
                  fixer.remove(sourceCode.getTokenBefore(lastToken)),
                  fixer.remove(lastToken),
                  fixer.insertTextBefore(node, "("),
                  fixer.insertTextAfter(node, ")")
                ]
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/newline-after-var.js
var require_newline_after_var = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow an empty line after variable declarations",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/newline-after-var"
      },
      schema: [
        {
          enum: ["never", "always"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expected: "Expected blank line after variable declarations.",
        unexpected: "Unexpected blank line after variable declarations."
      },
      deprecated: true,
      replacedBy: ["padding-line-between-statements"]
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const mode = context4.options[0] === "never" ? "never" : "always";
      const commentEndLine = sourceCode.getAllComments().reduce((result, token) => {
        result[token.loc.start.line] = token.loc.end.line;
        return result;
      }, {});
      function getLastToken(node) {
        const lastToken = sourceCode.getLastToken(node);
        if (lastToken.type === "Punctuator" && lastToken.value === ";") {
          const prevToken = sourceCode.getTokenBefore(lastToken);
          if (prevToken.loc.end.line !== lastToken.loc.start.line) {
            return prevToken;
          }
        }
        return lastToken;
      }
      function isVar(keyword) {
        return keyword === "var" || keyword === "let" || keyword === "const";
      }
      function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
      }
      function isExportSpecifier(nodeType) {
        return nodeType === "ExportNamedDeclaration" || nodeType === "ExportSpecifier" || nodeType === "ExportDefaultDeclaration" || nodeType === "ExportAllDeclaration";
      }
      function isLastNode(node) {
        const token = sourceCode.getTokenAfter(node);
        return !token || token.type === "Punctuator" && token.value === "}";
      }
      function getLastCommentLineOfBlock(commentStartLine) {
        const currentCommentEnd = commentEndLine[commentStartLine];
        return commentEndLine[currentCommentEnd + 1] ? getLastCommentLineOfBlock(currentCommentEnd + 1) : currentCommentEnd;
      }
      function hasBlankLineAfterComment(token, commentStartLine) {
        return token.loc.start.line > getLastCommentLineOfBlock(commentStartLine) + 1;
      }
      function checkForBlankLine(node) {
        const lastToken = getLastToken(node), nextToken = lastToken === sourceCode.getLastToken(node) ? sourceCode.getTokenAfter(node) : sourceCode.getLastToken(node), nextLineNum = lastToken.loc.end.line + 1;
        if (!nextToken) {
          return;
        }
        if (isForTypeSpecifier(node.parent.type)) {
          return;
        }
        if (isExportSpecifier(node.parent.type)) {
          return;
        }
        if (nextToken.type === "Keyword" && isVar(nextToken.value)) {
          return;
        }
        if (isLastNode(node)) {
          return;
        }
        const noNextLineToken = nextToken.loc.start.line > nextLineNum;
        const hasNextLineComment = typeof commentEndLine[nextLineNum] !== "undefined";
        if (mode === "never" && noNextLineToken && !hasNextLineComment) {
          context4.report({
            node,
            messageId: "unexpected",
            data: {identifier: node.name},
            fix(fixer) {
              const linesBetween = sourceCode.getText().slice(lastToken.range[1], nextToken.range[0]).split(astUtils.LINEBREAK_MATCHER);
              return fixer.replaceTextRange([lastToken.range[1], nextToken.range[0]], `${linesBetween.slice(0, -1).join("")}
${linesBetween[linesBetween.length - 1]}`);
            }
          });
        }
        if (mode === "always" && (!noNextLineToken || hasNextLineComment && !hasBlankLineAfterComment(nextToken, nextLineNum))) {
          context4.report({
            node,
            messageId: "expected",
            data: {identifier: node.name},
            fix(fixer) {
              if ((noNextLineToken ? getLastCommentLineOfBlock(nextLineNum) : lastToken.loc.end.line) === nextToken.loc.start.line) {
                return fixer.insertTextBefore(nextToken, "\n\n");
              }
              return fixer.insertTextBeforeRange([nextToken.range[0] - nextToken.loc.start.column, nextToken.range[1]], "\n");
            }
          });
        }
      }
      return {
        VariableDeclaration: checkForBlankLine
      };
    }
  };
});

// node_modules/eslint/lib/rules/newline-before-return.js
var require_newline_before_return = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require an empty line before `return` statements",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/newline-before-return"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        expected: "Expected newline before return statement."
      },
      deprecated: true,
      replacedBy: ["padding-line-between-statements"]
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function isPrecededByTokens(node, testTokens) {
        const tokenBefore = sourceCode.getTokenBefore(node);
        return testTokens.some((token) => tokenBefore.value === token);
      }
      function isFirstNode(node) {
        const parentType = node.parent.type;
        if (node.parent.body) {
          return Array.isArray(node.parent.body) ? node.parent.body[0] === node : node.parent.body === node;
        }
        if (parentType === "IfStatement") {
          return isPrecededByTokens(node, ["else", ")"]);
        }
        if (parentType === "DoWhileStatement") {
          return isPrecededByTokens(node, ["do"]);
        }
        if (parentType === "SwitchCase") {
          return isPrecededByTokens(node, [":"]);
        }
        return isPrecededByTokens(node, [")"]);
      }
      function calcCommentLines(node, lineNumTokenBefore) {
        const comments = sourceCode.getCommentsBefore(node);
        let numLinesComments = 0;
        if (!comments.length) {
          return numLinesComments;
        }
        comments.forEach((comment) => {
          numLinesComments++;
          if (comment.type === "Block") {
            numLinesComments += comment.loc.end.line - comment.loc.start.line;
          }
          if (comment.loc.start.line === lineNumTokenBefore) {
            numLinesComments--;
          }
          if (comment.loc.end.line === node.loc.start.line) {
            numLinesComments--;
          }
        });
        return numLinesComments;
      }
      function getLineNumberOfTokenBefore(node) {
        const tokenBefore = sourceCode.getTokenBefore(node);
        let lineNumTokenBefore;
        if (tokenBefore) {
          lineNumTokenBefore = tokenBefore.loc.end.line;
        } else {
          lineNumTokenBefore = 0;
        }
        return lineNumTokenBefore;
      }
      function hasNewlineBefore(node) {
        const lineNumNode = node.loc.start.line;
        const lineNumTokenBefore = getLineNumberOfTokenBefore(node);
        const commentLines = calcCommentLines(node, lineNumTokenBefore);
        return lineNumNode - lineNumTokenBefore - commentLines > 1;
      }
      function canFix(node) {
        const leadingComments = sourceCode.getCommentsBefore(node);
        const lastLeadingComment = leadingComments[leadingComments.length - 1];
        const tokenBefore = sourceCode.getTokenBefore(node);
        if (leadingComments.length === 0) {
          return true;
        }
        if (lastLeadingComment.loc.end.line === tokenBefore.loc.end.line && lastLeadingComment.loc.end.line !== node.loc.start.line) {
          return true;
        }
        return false;
      }
      return {
        ReturnStatement(node) {
          if (!isFirstNode(node) && !hasNewlineBefore(node)) {
            context4.report({
              node,
              messageId: "expected",
              fix(fixer) {
                if (canFix(node)) {
                  const tokenBefore = sourceCode.getTokenBefore(node);
                  const newlines = node.loc.start.line === tokenBefore.loc.end.line ? "\n\n" : "\n";
                  return fixer.insertTextBefore(node, newlines);
                }
                return null;
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/newline-per-chained-call.js
var require_newline_per_chained_call = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require a newline after each call in a method chain",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/newline-per-chained-call"
      },
      fixable: "whitespace",
      schema: [{
        type: "object",
        properties: {
          ignoreChainWithDepth: {
            type: "integer",
            minimum: 1,
            maximum: 10,
            default: 2
          }
        },
        additionalProperties: false
      }],
      messages: {
        expected: "Expected line break before `{{callee}}`."
      }
    },
    create(context4) {
      const options = context4.options[0] || {}, ignoreChainWithDepth = options.ignoreChainWithDepth || 2;
      const sourceCode = context4.getSourceCode();
      function getPrefix(node) {
        if (node.computed) {
          if (node.optional) {
            return "?.[";
          }
          return "[";
        }
        if (node.optional) {
          return "?.";
        }
        return ".";
      }
      function getPropertyText(node) {
        const prefix = getPrefix(node);
        const lines = sourceCode.getText(node.property).split(astUtils.LINEBREAK_MATCHER);
        const suffix = node.computed && lines.length === 1 ? "]" : "";
        return prefix + lines[0] + suffix;
      }
      return {
        "CallExpression:exit"(node) {
          const callee = astUtils.skipChainExpression(node.callee);
          if (callee.type !== "MemberExpression") {
            return;
          }
          let parent = astUtils.skipChainExpression(callee.object);
          let depth = 1;
          while (parent && parent.callee) {
            depth += 1;
            parent = astUtils.skipChainExpression(astUtils.skipChainExpression(parent.callee).object);
          }
          if (depth > ignoreChainWithDepth && astUtils.isTokenOnSameLine(callee.object, callee.property)) {
            const firstTokenAfterObject = sourceCode.getTokenAfter(callee.object, astUtils.isNotClosingParenToken);
            context4.report({
              node: callee.property,
              loc: {
                start: firstTokenAfterObject.loc.start,
                end: callee.loc.end
              },
              messageId: "expected",
              data: {
                callee: getPropertyText(callee)
              },
              fix(fixer) {
                return fixer.insertTextBefore(firstTokenAfterObject, "\n");
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-alert.js
var require_no_alert = __commonJS((exports2, module2) => {
  "use strict";
  var {
    getStaticPropertyName: getPropertyName,
    getVariableByName,
    skipChainExpression
  } = require_ast_utils2();
  function isProhibitedIdentifier(name) {
    return /^(alert|confirm|prompt)$/u.test(name);
  }
  function findReference(scope, node) {
    const references = scope.references.filter((reference) => reference.identifier.range[0] === node.range[0] && reference.identifier.range[1] === node.range[1]);
    if (references.length === 1) {
      return references[0];
    }
    return null;
  }
  function isShadowed(scope, node) {
    const reference = findReference(scope, node);
    return reference && reference.resolved && reference.resolved.defs.length > 0;
  }
  function isGlobalThisReferenceOrGlobalWindow(scope, node) {
    if (scope.type === "global" && node.type === "ThisExpression") {
      return true;
    }
    if (node.type === "Identifier" && (node.name === "window" || node.name === "globalThis" && getVariableByName(scope, "globalThis"))) {
      return !isShadowed(scope, node);
    }
    return false;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `alert`, `confirm`, and `prompt`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-alert"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected {{name}}."
      }
    },
    create(context4) {
      return {
        CallExpression(node) {
          const callee = skipChainExpression(node.callee), currentScope = context4.getScope();
          if (callee.type === "Identifier") {
            const name = callee.name;
            if (!isShadowed(currentScope, callee) && isProhibitedIdentifier(callee.name)) {
              context4.report({
                node,
                messageId: "unexpected",
                data: {name}
              });
            }
          } else if (callee.type === "MemberExpression" && isGlobalThisReferenceOrGlobalWindow(currentScope, callee.object)) {
            const name = getPropertyName(callee);
            if (isProhibitedIdentifier(name)) {
              context4.report({
                node,
                messageId: "unexpected",
                data: {name}
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-array-constructor.js
var require_no_array_constructor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `Array` constructors",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-array-constructor"
      },
      schema: [],
      messages: {
        preferLiteral: "The array literal notation [] is preferable."
      }
    },
    create(context4) {
      function check(node) {
        if (node.arguments.length !== 1 && node.callee.type === "Identifier" && node.callee.name === "Array") {
          context4.report({node, messageId: "preferLiteral"});
        }
      }
      return {
        CallExpression: check,
        NewExpression: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-async-promise-executor.js
var require_no_async_promise_executor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow using an async function as a Promise executor",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-async-promise-executor"
      },
      fixable: null,
      schema: [],
      messages: {
        async: "Promise executor functions should not be async."
      }
    },
    create(context4) {
      return {
        "NewExpression[callee.name='Promise'][arguments.0.async=true]"(node) {
          context4.report({
            node: context4.getSourceCode().getFirstToken(node.arguments[0], (token) => token.value === "async"),
            messageId: "async"
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-await-in-loop.js
var require_no_await_in_loop = __commonJS((exports2, module2) => {
  "use strict";
  function isBoundary(node) {
    const t = node.type;
    return t === "FunctionDeclaration" || t === "FunctionExpression" || t === "ArrowFunctionExpression" || t === "ForOfStatement" && node.await === true;
  }
  function isLooped(node, parent) {
    switch (parent.type) {
      case "ForStatement":
        return node === parent.test || node === parent.update || node === parent.body;
      case "ForOfStatement":
      case "ForInStatement":
        return node === parent.body;
      case "WhileStatement":
      case "DoWhileStatement":
        return node === parent.test || node === parent.body;
      default:
        return false;
    }
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow `await` inside of loops",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-await-in-loop"
      },
      schema: [],
      messages: {
        unexpectedAwait: "Unexpected `await` inside a loop."
      }
    },
    create(context4) {
      function validate(awaitNode) {
        if (awaitNode.type === "ForOfStatement" && !awaitNode.await) {
          return;
        }
        let node = awaitNode;
        let parent = node.parent;
        while (parent && !isBoundary(parent)) {
          if (isLooped(node, parent)) {
            context4.report({
              node: awaitNode,
              messageId: "unexpectedAwait"
            });
            return;
          }
          node = parent;
          parent = parent.parent;
        }
      }
      return {
        AwaitExpression: validate,
        ForOfStatement: validate
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-bitwise.js
var require_no_bitwise = __commonJS((exports2, module2) => {
  "use strict";
  var BITWISE_OPERATORS = [
    "^",
    "|",
    "&",
    "<<",
    ">>",
    ">>>",
    "^=",
    "|=",
    "&=",
    "<<=",
    ">>=",
    ">>>=",
    "~"
  ];
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow bitwise operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-bitwise"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                enum: BITWISE_OPERATORS
              },
              uniqueItems: true
            },
            int32Hint: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected use of '{{operator}}'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const allowed = options.allow || [];
      const int32Hint = options.int32Hint === true;
      function report(node) {
        context4.report({node, messageId: "unexpected", data: {operator: node.operator}});
      }
      function hasBitwiseOperator(node) {
        return BITWISE_OPERATORS.indexOf(node.operator) !== -1;
      }
      function allowedOperator(node) {
        return allowed.indexOf(node.operator) !== -1;
      }
      function isInt32Hint(node) {
        return int32Hint && node.operator === "|" && node.right && node.right.type === "Literal" && node.right.value === 0;
      }
      function checkNodeForBitwiseOperator(node) {
        if (hasBitwiseOperator(node) && !allowedOperator(node) && !isInt32Hint(node)) {
          report(node);
        }
      }
      return {
        AssignmentExpression: checkNodeForBitwiseOperator,
        BinaryExpression: checkNodeForBitwiseOperator,
        UnaryExpression: checkNodeForBitwiseOperator
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-buffer-constructor.js
var require_no_buffer_constructor = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "problem",
      docs: {
        description: "disallow use of the `Buffer()` constructor",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-buffer-constructor"
      },
      schema: [],
      messages: {
        deprecated: "{{expr}} is deprecated. Use Buffer.from(), Buffer.alloc(), or Buffer.allocUnsafe() instead."
      }
    },
    create(context4) {
      return {
        "CallExpression[callee.name='Buffer'], NewExpression[callee.name='Buffer']"(node) {
          context4.report({
            node,
            messageId: "deprecated",
            data: {expr: node.type === "CallExpression" ? "Buffer()" : "new Buffer()"}
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-caller.js
var require_no_caller = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `arguments.caller` or `arguments.callee`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-caller"
      },
      schema: [],
      messages: {
        unexpected: "Avoid arguments.{{prop}}."
      }
    },
    create(context4) {
      return {
        MemberExpression(node) {
          const objectName = node.object.name, propertyName = node.property.name;
          if (objectName === "arguments" && !node.computed && propertyName && propertyName.match(/^calle[er]$/u)) {
            context4.report({node, messageId: "unexpected", data: {prop: propertyName}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-case-declarations.js
var require_no_case_declarations = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow lexical declarations in case clauses",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-case-declarations"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected lexical declaration in case block."
      }
    },
    create(context4) {
      function isLexicalDeclaration(node) {
        switch (node.type) {
          case "FunctionDeclaration":
          case "ClassDeclaration":
            return true;
          case "VariableDeclaration":
            return node.kind !== "var";
          default:
            return false;
        }
      }
      return {
        SwitchCase(node) {
          for (let i = 0; i < node.consequent.length; i++) {
            const statement = node.consequent[i];
            if (isLexicalDeclaration(statement)) {
              context4.report({
                node: statement,
                messageId: "unexpected"
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-catch-shadow.js
var require_no_catch_shadow = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `catch` clause parameters from shadowing variables in the outer scope",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-catch-shadow"
      },
      replacedBy: ["no-shadow"],
      deprecated: true,
      schema: [],
      messages: {
        mutable: "Value of '{{name}}' may be overwritten in IE 8 and earlier."
      }
    },
    create(context4) {
      function paramIsShadowing(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
      }
      return {
        "CatchClause[param!=null]"(node) {
          let scope = context4.getScope();
          if (scope.block === node) {
            scope = scope.upper;
          }
          if (paramIsShadowing(scope, node.param.name)) {
            context4.report({node, messageId: "mutable", data: {name: node.param.name}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-class-assign.js
var require_no_class_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow reassigning class members",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-class-assign"
      },
      schema: [],
      messages: {
        class: "'{{name}}' is a class."
      }
    },
    create(context4) {
      function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach((reference) => {
          context4.report({node: reference.identifier, messageId: "class", data: {name: reference.identifier.name}});
        });
      }
      function checkForClass(node) {
        context4.getDeclaredVariables(node).forEach(checkVariable);
      }
      return {
        ClassDeclaration: checkForClass,
        ClassExpression: checkForClass
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-compare-neg-zero.js
var require_no_compare_neg_zero = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow comparing against -0",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-compare-neg-zero"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Do not use the '{{operator}}' operator to compare against -0."
      }
    },
    create(context4) {
      function isNegZero(node) {
        return node.type === "UnaryExpression" && node.operator === "-" && node.argument.type === "Literal" && node.argument.value === 0;
      }
      const OPERATORS_TO_CHECK = new Set([">", ">=", "<", "<=", "==", "===", "!=", "!=="]);
      return {
        BinaryExpression(node) {
          if (OPERATORS_TO_CHECK.has(node.operator)) {
            if (isNegZero(node.left) || isNegZero(node.right)) {
              context4.report({
                node,
                messageId: "unexpected",
                data: {operator: node.operator}
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-cond-assign.js
var require_no_cond_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var TEST_CONDITION_PARENT_TYPES = new Set(["IfStatement", "WhileStatement", "DoWhileStatement", "ForStatement", "ConditionalExpression"]);
  var NODE_DESCRIPTIONS = {
    DoWhileStatement: "a 'do...while' statement",
    ForStatement: "a 'for' statement",
    IfStatement: "an 'if' statement",
    WhileStatement: "a 'while' statement"
  };
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow assignment operators in conditional expressions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-cond-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        unexpected: "Unexpected assignment within {{type}}.",
        missing: "Expected a conditional expression and instead saw an assignment."
      }
    },
    create(context4) {
      const prohibitAssign = context4.options[0] || "except-parens";
      const sourceCode = context4.getSourceCode();
      function isConditionalTestExpression(node) {
        return node.parent && TEST_CONDITION_PARENT_TYPES.has(node.parent.type) && node === node.parent.test;
      }
      function findConditionalAncestor(node) {
        let currentAncestor = node;
        do {
          if (isConditionalTestExpression(currentAncestor)) {
            return currentAncestor.parent;
          }
        } while ((currentAncestor = currentAncestor.parent) && !astUtils.isFunction(currentAncestor));
        return null;
      }
      function isParenthesisedTwice(node) {
        const previousToken = sourceCode.getTokenBefore(node, 1), nextToken = sourceCode.getTokenAfter(node, 1);
        return astUtils.isParenthesised(sourceCode, node) && previousToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
      }
      function testForAssign(node) {
        if (node.test && node.test.type === "AssignmentExpression" && (node.type === "ForStatement" ? !astUtils.isParenthesised(sourceCode, node.test) : !isParenthesisedTwice(node.test))) {
          context4.report({
            node: node.test,
            messageId: "missing"
          });
        }
      }
      function testForConditionalAncestor(node) {
        const ancestor = findConditionalAncestor(node);
        if (ancestor) {
          context4.report({
            node,
            messageId: "unexpected",
            data: {
              type: NODE_DESCRIPTIONS[ancestor.type] || ancestor.type
            }
          });
        }
      }
      if (prohibitAssign === "always") {
        return {
          AssignmentExpression: testForConditionalAncestor
        };
      }
      return {
        DoWhileStatement: testForAssign,
        ForStatement: testForAssign,
        IfStatement: testForAssign,
        WhileStatement: testForAssign,
        ConditionalExpression: testForAssign
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-confusing-arrow.js
var require_no_confusing_arrow = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isConditional(node) {
    return node && node.type === "ConditionalExpression";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow arrow functions where they could be confused with comparisons",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-confusing-arrow"
      },
      fixable: "code",
      schema: [{
        type: "object",
        properties: {
          allowParens: {type: "boolean", default: true}
        },
        additionalProperties: false
      }],
      messages: {
        confusing: "Arrow function used ambiguously with a conditional expression."
      }
    },
    create(context4) {
      const config = context4.options[0] || {};
      const allowParens = config.allowParens || config.allowParens === void 0;
      const sourceCode = context4.getSourceCode();
      function checkArrowFunc(node) {
        const body = node.body;
        if (isConditional(body) && !(allowParens && astUtils.isParenthesised(sourceCode, body))) {
          context4.report({
            node,
            messageId: "confusing",
            fix(fixer) {
              return allowParens && fixer.replaceText(node.body, `(${sourceCode.getText(node.body)})`);
            }
          });
        }
      }
      return {
        ArrowFunctionExpression: checkArrowFunc
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-console.js
var require_no_console = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `console`",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-console"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              },
              minItems: 1,
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected console statement."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const allowed = options.allow || [];
      function isConsole(reference) {
        const id = reference.identifier;
        return id && id.name === "console";
      }
      function isAllowed(node) {
        const propertyName = astUtils.getStaticPropertyName(node);
        return propertyName && allowed.indexOf(propertyName) !== -1;
      }
      function isMemberAccessExceptAllowed(reference) {
        const node = reference.identifier;
        const parent = node.parent;
        return parent.type === "MemberExpression" && parent.object === node && !isAllowed(parent);
      }
      function report(reference) {
        const node = reference.identifier.parent;
        context4.report({
          node,
          loc: node.loc,
          messageId: "unexpected"
        });
      }
      return {
        "Program:exit"() {
          const scope = context4.getScope();
          const consoleVar = astUtils.getVariableByName(scope, "console");
          const shadowed = consoleVar && consoleVar.defs.length > 0;
          const references = consoleVar ? consoleVar.references : scope.through.filter(isConsole);
          if (!shadowed) {
            references.filter(isMemberAccessExceptAllowed).forEach(report);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-const-assign.js
var require_no_const_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow reassigning `const` variables",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-const-assign"
      },
      schema: [],
      messages: {
        const: "'{{name}}' is constant."
      }
    },
    create(context4) {
      function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach((reference) => {
          context4.report({node: reference.identifier, messageId: "const", data: {name: reference.identifier.name}});
        });
      }
      return {
        VariableDeclaration(node) {
          if (node.kind === "const") {
            context4.getDeclaredVariables(node).forEach(checkVariable);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-constant-condition.js
var require_no_constant_condition = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow constant expressions in conditions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-constant-condition"
      },
      schema: [
        {
          type: "object",
          properties: {
            checkLoops: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected constant condition."
      }
    },
    create(context4) {
      const options = context4.options[0] || {}, checkLoops = options.checkLoops !== false, loopSetStack = [];
      let loopsInCurrentScope = new Set();
      function getBooleanValue(node) {
        if (node.value === null) {
          if (node.raw === "null") {
            return false;
          }
          if (typeof node.regex === "object") {
            return true;
          }
          return null;
        }
        return !!node.value;
      }
      function isLogicalIdentity(node, operator) {
        switch (node.type) {
          case "Literal":
            return operator === "||" && getBooleanValue(node) === true || operator === "&&" && getBooleanValue(node) === false;
          case "UnaryExpression":
            return operator === "&&" && node.operator === "void";
          case "LogicalExpression":
            return operator === node.operator && (isLogicalIdentity(node.left, operator) || isLogicalIdentity(node.right, operator));
          case "AssignmentExpression":
            return ["||=", "&&="].includes(node.operator) && operator === node.operator.slice(0, -1) && isLogicalIdentity(node.right, operator);
        }
        return false;
      }
      function isConstant(node, inBooleanPosition) {
        if (!node) {
          return true;
        }
        switch (node.type) {
          case "Literal":
          case "ArrowFunctionExpression":
          case "FunctionExpression":
          case "ObjectExpression":
            return true;
          case "TemplateLiteral":
            return inBooleanPosition && node.quasis.some((quasi) => quasi.value.cooked.length) || node.expressions.every((exp) => isConstant(exp, inBooleanPosition));
          case "ArrayExpression": {
            if (node.parent.type === "BinaryExpression" && node.parent.operator === "+") {
              return node.elements.every((element) => isConstant(element, false));
            }
            return true;
          }
          case "UnaryExpression":
            if (node.operator === "void" || node.operator === "typeof" && inBooleanPosition) {
              return true;
            }
            if (node.operator === "!") {
              return isConstant(node.argument, true);
            }
            return isConstant(node.argument, false);
          case "BinaryExpression":
            return isConstant(node.left, false) && isConstant(node.right, false) && node.operator !== "in";
          case "LogicalExpression": {
            const isLeftConstant = isConstant(node.left, inBooleanPosition);
            const isRightConstant = isConstant(node.right, inBooleanPosition);
            const isLeftShortCircuit = isLeftConstant && isLogicalIdentity(node.left, node.operator);
            const isRightShortCircuit = inBooleanPosition && isRightConstant && isLogicalIdentity(node.right, node.operator);
            return isLeftConstant && isRightConstant || isLeftShortCircuit || isRightShortCircuit;
          }
          case "AssignmentExpression":
            if (node.operator === "=") {
              return isConstant(node.right, inBooleanPosition);
            }
            if (["||=", "&&="].includes(node.operator) && inBooleanPosition) {
              return isLogicalIdentity(node.right, node.operator.slice(0, -1));
            }
            return false;
          case "SequenceExpression":
            return isConstant(node.expressions[node.expressions.length - 1], inBooleanPosition);
        }
        return false;
      }
      function trackConstantConditionLoop(node) {
        if (node.test && isConstant(node.test, true)) {
          loopsInCurrentScope.add(node);
        }
      }
      function checkConstantConditionLoopInSet(node) {
        if (loopsInCurrentScope.has(node)) {
          loopsInCurrentScope.delete(node);
          context4.report({node: node.test, messageId: "unexpected"});
        }
      }
      function reportIfConstant(node) {
        if (node.test && isConstant(node.test, true)) {
          context4.report({node: node.test, messageId: "unexpected"});
        }
      }
      function enterFunction() {
        loopSetStack.push(loopsInCurrentScope);
        loopsInCurrentScope = new Set();
      }
      function exitFunction() {
        loopsInCurrentScope = loopSetStack.pop();
      }
      function checkLoop(node) {
        if (checkLoops) {
          trackConstantConditionLoop(node);
        }
      }
      return {
        ConditionalExpression: reportIfConstant,
        IfStatement: reportIfConstant,
        WhileStatement: checkLoop,
        "WhileStatement:exit": checkConstantConditionLoopInSet,
        DoWhileStatement: checkLoop,
        "DoWhileStatement:exit": checkConstantConditionLoopInSet,
        ForStatement: checkLoop,
        "ForStatement > .test": (node) => checkLoop(node.parent),
        "ForStatement:exit": checkConstantConditionLoopInSet,
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        YieldExpression: () => loopsInCurrentScope.clear()
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-constructor-return.js
var require_no_constructor_return = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow returning value from constructor",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-constructor-return"
      },
      schema: {},
      fixable: null,
      messages: {
        unexpected: "Unexpected return statement in constructor."
      }
    },
    create(context4) {
      const stack = [];
      return {
        onCodePathStart(_, node) {
          stack.push(node);
        },
        onCodePathEnd() {
          stack.pop();
        },
        ReturnStatement(node) {
          const last = stack[stack.length - 1];
          if (!last.parent) {
            return;
          }
          if (last.parent.type === "MethodDefinition" && last.parent.kind === "constructor" && (node.parent.parent === last || node.argument)) {
            context4.report({
              node,
              messageId: "unexpected"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-continue.js
var require_no_continue = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `continue` statements",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-continue"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected use of continue statement."
      }
    },
    create(context4) {
      return {
        ContinueStatement(node) {
          context4.report({node, messageId: "unexpected"});
        }
      };
    }
  };
});

// node_modules/eslint/node_modules/regexpp/index.js
var require_regexpp = __commonJS((exports2) => {
  /*! @author Toru Nagashima <https://github.com/mysticatea> */
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var ast = /* @__PURE__ */ Object.freeze({});
  var largeIdStartRanges = void 0;
  var largeIdContinueRanges = void 0;
  function isIdStart(cp) {
    if (cp < 65)
      return false;
    if (cp < 91)
      return true;
    if (cp < 97)
      return false;
    if (cp < 123)
      return true;
    return isLargeIdStart(cp);
  }
  function isIdContinue(cp) {
    if (cp < 48)
      return false;
    if (cp < 58)
      return true;
    if (cp < 65)
      return false;
    if (cp < 91)
      return true;
    if (cp === 95)
      return true;
    if (cp < 97)
      return false;
    if (cp < 123)
      return true;
    return isLargeIdStart(cp) || isLargeIdContinue(cp);
  }
  function isLargeIdStart(cp) {
    return isInRange(cp, largeIdStartRanges || (largeIdStartRanges = initLargeIdStartRanges()));
  }
  function isLargeIdContinue(cp) {
    return isInRange(cp, largeIdContinueRanges || (largeIdContinueRanges = initLargeIdContinueRanges()));
  }
  function initLargeIdStartRanges() {
    return restoreRanges("170 0 11 0 5 0 6 22 2 30 2 457 5 11 15 4 8 0 2 0 130 4 2 1 3 3 2 0 7 0 2 2 2 0 2 19 2 82 2 138 9 165 2 37 3 0 7 40 72 26 5 3 46 42 36 1 2 98 2 0 16 1 8 1 11 2 3 0 17 0 2 29 30 88 12 0 25 32 10 1 5 0 6 21 5 0 10 0 4 0 24 24 8 10 54 20 2 17 61 53 4 0 19 0 8 9 16 15 5 7 3 1 3 21 2 6 2 0 4 3 4 0 17 0 14 1 2 2 15 1 11 0 9 5 5 1 3 21 2 6 2 1 2 1 2 1 32 3 2 0 20 2 17 8 2 2 2 21 2 6 2 1 2 4 4 0 19 0 16 1 24 0 12 7 3 1 3 21 2 6 2 1 2 4 4 0 31 1 2 2 16 0 18 0 2 5 4 2 2 3 4 1 2 0 2 1 4 1 4 2 4 11 23 0 53 7 2 2 2 22 2 15 4 0 27 2 6 1 31 0 5 7 2 2 2 22 2 9 2 4 4 0 33 0 2 1 16 1 18 8 2 2 2 40 3 0 17 0 6 2 9 2 25 5 6 17 4 23 2 8 2 0 3 6 59 47 2 1 13 6 59 1 2 0 2 4 2 23 2 0 2 9 2 1 10 0 3 4 2 0 22 3 33 0 64 7 2 35 28 4 116 42 21 0 17 5 5 3 4 0 4 1 8 2 5 12 13 0 18 37 2 0 6 0 3 42 2 332 2 3 3 6 2 0 2 3 3 40 2 3 3 32 2 3 3 6 2 0 2 3 3 14 2 56 2 3 3 66 38 15 17 85 3 5 4 619 3 16 2 25 6 74 4 10 8 12 2 3 15 17 15 17 15 12 2 2 16 51 36 0 5 0 68 88 8 40 2 0 6 69 11 30 50 29 3 4 12 43 5 25 55 22 10 52 83 0 94 46 18 6 56 29 14 1 11 43 27 35 42 2 11 35 3 8 8 42 3 2 42 3 2 5 2 1 4 0 6 191 65 277 3 5 3 37 3 5 3 7 2 0 2 0 2 0 2 30 3 52 2 6 2 0 4 2 2 6 4 3 3 5 5 12 6 2 2 6 117 0 14 0 17 12 102 0 5 0 3 9 2 0 3 5 7 0 2 0 2 0 2 15 3 3 6 4 5 0 18 40 2680 46 2 46 2 132 7 3 4 1 13 37 2 0 6 0 3 55 8 0 17 22 10 6 2 6 2 6 2 6 2 6 2 6 2 6 2 6 551 2 26 8 8 4 3 4 5 85 5 4 2 89 2 3 6 42 2 93 18 31 49 15 513 6591 65 20988 4 1164 68 45 3 268 4 15 11 1 21 46 17 30 3 79 40 8 3 102 3 52 3 8 43 12 2 2 2 3 2 22 30 51 15 49 63 5 4 0 2 1 12 27 11 22 26 28 8 46 29 0 17 4 2 9 11 4 2 40 24 2 2 7 21 22 4 0 4 49 2 0 4 1 3 4 3 0 2 0 25 2 3 10 8 2 13 5 3 5 3 5 10 6 2 6 2 42 2 13 7 114 30 11171 13 22 5 48 8453 365 3 105 39 6 13 4 6 0 2 9 2 12 2 4 2 0 2 1 2 1 2 107 34 362 19 63 3 53 41 11 117 4 2 134 37 25 7 25 12 88 4 5 3 5 3 5 3 2 36 11 2 25 2 18 2 1 2 14 3 13 35 122 70 52 268 28 4 48 48 31 14 29 6 37 11 29 3 35 5 7 2 4 43 157 19 35 5 35 5 39 9 51 157 310 10 21 11 7 153 5 3 0 2 43 2 1 4 0 3 22 11 22 10 30 66 18 2 1 11 21 11 25 71 55 7 1 65 0 16 3 2 2 2 28 43 28 4 28 36 7 2 27 28 53 11 21 11 18 14 17 111 72 56 50 14 50 14 35 349 41 7 1 79 28 11 0 9 21 107 20 28 22 13 52 76 44 33 24 27 35 30 0 3 0 9 34 4 0 13 47 15 3 22 0 2 0 36 17 2 24 85 6 2 0 2 3 2 14 2 9 8 46 39 7 3 1 3 21 2 6 2 1 2 4 4 0 19 0 13 4 159 52 19 3 21 2 31 47 21 1 2 0 185 46 42 3 37 47 21 0 60 42 14 0 72 26 230 43 117 63 32 7 3 0 3 7 2 1 2 23 16 0 2 0 95 7 3 38 17 0 2 0 29 0 11 39 8 0 22 0 12 45 20 0 35 56 264 8 2 36 18 0 50 29 113 6 2 1 2 37 22 0 26 5 2 1 2 31 15 0 328 18 190 0 80 921 103 110 18 195 2749 1070 4050 582 8634 568 8 30 114 29 19 47 17 3 32 20 6 18 689 63 129 74 6 0 67 12 65 1 2 0 29 6135 9 1237 43 8 8952 286 50 2 18 3 9 395 2309 106 6 12 4 8 8 9 5991 84 2 70 2 1 3 0 3 1 3 3 2 11 2 0 2 6 2 64 2 3 3 7 2 6 2 27 2 3 2 4 2 0 4 6 2 339 3 24 2 24 2 30 2 24 2 30 2 24 2 30 2 24 2 30 2 24 2 7 2357 44 11 6 17 0 370 43 1301 196 60 67 8 0 1205 3 2 26 2 1 2 0 3 0 2 9 2 3 2 0 2 0 7 0 5 0 2 0 2 0 2 2 2 1 2 0 3 0 2 0 2 0 2 0 2 0 2 1 2 0 3 3 2 6 2 3 2 3 2 0 2 9 2 16 6 2 2 4 2 16 4421 42717 35 4148 12 221 3 5761 15 7472 3104 541 1507 4938");
  }
  function initLargeIdContinueRanges() {
    return restoreRanges("183 0 585 111 24 0 252 4 266 44 2 0 2 1 2 1 2 0 73 10 49 30 7 0 102 6 3 5 3 1 2 3 3 9 24 0 31 26 92 10 16 9 34 8 10 0 25 3 2 8 2 2 2 4 44 2 120 14 2 32 55 2 2 17 2 6 11 1 3 9 18 2 57 0 2 6 3 1 3 2 10 0 11 1 3 9 15 0 3 2 57 0 2 4 5 1 3 2 4 0 21 11 4 0 12 2 57 0 2 7 2 2 2 2 21 1 3 9 11 5 2 2 57 0 2 6 3 1 3 2 8 2 11 1 3 9 19 0 60 4 4 2 2 3 10 0 15 9 17 4 58 6 2 2 2 3 8 1 12 1 3 9 18 2 57 0 2 6 2 2 2 3 8 1 12 1 3 9 17 3 56 1 2 6 2 2 2 3 10 0 11 1 3 9 18 2 71 0 5 5 2 0 2 7 7 9 3 1 62 0 3 6 13 7 2 9 88 0 3 8 12 5 3 9 63 1 7 9 12 0 2 0 2 0 5 1 50 19 2 1 6 10 2 35 10 0 101 19 2 9 13 3 5 2 2 2 3 6 4 3 14 11 2 14 704 2 10 8 929 2 30 2 30 1 31 1 65 31 10 0 3 9 34 2 3 9 144 0 119 11 5 11 11 9 129 10 61 4 58 9 2 28 3 10 7 9 23 13 2 1 64 4 48 16 12 9 18 8 13 2 31 12 3 9 45 13 49 19 9 9 7 9 119 2 2 20 5 0 7 0 3 2 199 57 2 4 576 1 20 0 124 12 5 0 4 11 3071 2 142 0 97 31 555 5 106 1 30086 9 70 0 5 9 33 1 81 1 273 0 4 0 5 0 24 4 5 0 84 1 51 17 11 9 7 17 14 10 29 7 26 12 45 3 48 13 16 9 12 0 11 9 48 13 13 0 9 1 3 9 34 2 51 0 2 2 3 1 6 1 2 0 42 4 6 1 237 7 2 1 3 9 20261 0 738 15 17 15 4 1 25 2 193 9 38 0 702 0 227 0 150 4 294 9 1368 2 2 1 6 3 41 2 5 0 166 1 574 3 9 9 370 1 154 10 176 2 54 14 32 9 16 3 46 10 54 9 7 2 37 13 2 9 6 1 45 0 13 2 49 13 9 3 2 11 83 11 7 0 161 11 6 9 7 3 56 1 2 6 3 1 3 2 10 0 11 1 3 6 4 4 193 17 10 9 5 0 82 19 13 9 214 6 3 8 28 1 83 16 16 9 82 12 9 9 84 14 5 9 243 14 166 9 71 5 2 1 3 3 2 0 2 1 13 9 120 6 3 6 4 0 29 9 41 6 2 3 9 0 10 10 47 15 406 7 2 7 17 9 57 21 2 13 123 5 4 0 2 1 2 6 2 0 9 9 49 4 2 1 2 4 9 9 330 3 19306 9 135 4 60 6 26 9 1014 0 2 54 8 3 82 0 12 1 19628 1 5319 4 4 5 9 7 3 6 31 3 149 2 1418 49 513 54 5 49 9 0 15 0 23 4 2 14 1361 6 2 16 3 6 2 1 2 4 262 6 10 9 419 13 1495 6 110 6 6 9 4759 9 787719 239");
  }
  function isInRange(cp, ranges) {
    let l = 0, r = ranges.length / 2 | 0, i = 0, min = 0, max = 0;
    while (l < r) {
      i = (l + r) / 2 | 0;
      min = ranges[2 * i];
      max = ranges[2 * i + 1];
      if (cp < min) {
        r = i;
      } else if (cp > max) {
        l = i + 1;
      } else {
        return true;
      }
    }
    return false;
  }
  function restoreRanges(data) {
    let last = 0;
    return data.split(" ").map((s) => last += parseInt(s, 10) | 0);
  }
  var DataSet = class {
    constructor(raw2018, raw2019, raw2020) {
      this._raw2018 = raw2018;
      this._raw2019 = raw2019;
      this._raw2020 = raw2020;
    }
    get es2018() {
      return this._set2018 || (this._set2018 = new Set(this._raw2018.split(" ")));
    }
    get es2019() {
      return this._set2019 || (this._set2019 = new Set(this._raw2019.split(" ")));
    }
    get es2020() {
      return this._set2020 || (this._set2020 = new Set(this._raw2020.split(" ")));
    }
  };
  var gcNameSet = new Set(["General_Category", "gc"]);
  var scNameSet = new Set(["Script", "Script_Extensions", "sc", "scx"]);
  var gcValueSets = new DataSet("C Cased_Letter Cc Cf Close_Punctuation Cn Co Combining_Mark Connector_Punctuation Control Cs Currency_Symbol Dash_Punctuation Decimal_Number Enclosing_Mark Final_Punctuation Format Initial_Punctuation L LC Letter Letter_Number Line_Separator Ll Lm Lo Lowercase_Letter Lt Lu M Mark Math_Symbol Mc Me Mn Modifier_Letter Modifier_Symbol N Nd Nl No Nonspacing_Mark Number Open_Punctuation Other Other_Letter Other_Number Other_Punctuation Other_Symbol P Paragraph_Separator Pc Pd Pe Pf Pi Po Private_Use Ps Punctuation S Sc Separator Sk Sm So Space_Separator Spacing_Mark Surrogate Symbol Titlecase_Letter Unassigned Uppercase_Letter Z Zl Zp Zs cntrl digit punct", "", "");
  var scValueSets = new DataSet("Adlam Adlm Aghb Ahom Anatolian_Hieroglyphs Arab Arabic Armenian Armi Armn Avestan Avst Bali Balinese Bamu Bamum Bass Bassa_Vah Batak Batk Beng Bengali Bhaiksuki Bhks Bopo Bopomofo Brah Brahmi Brai Braille Bugi Buginese Buhd Buhid Cakm Canadian_Aboriginal Cans Cari Carian Caucasian_Albanian Chakma Cham Cher Cherokee Common Copt Coptic Cprt Cuneiform Cypriot Cyrillic Cyrl Deseret Deva Devanagari Dsrt Dupl Duployan Egyp Egyptian_Hieroglyphs Elba Elbasan Ethi Ethiopic Geor Georgian Glag Glagolitic Gonm Goth Gothic Gran Grantha Greek Grek Gujarati Gujr Gurmukhi Guru Han Hang Hangul Hani Hano Hanunoo Hatr Hatran Hebr Hebrew Hira Hiragana Hluw Hmng Hung Imperial_Aramaic Inherited Inscriptional_Pahlavi Inscriptional_Parthian Ital Java Javanese Kaithi Kali Kana Kannada Katakana Kayah_Li Khar Kharoshthi Khmer Khmr Khoj Khojki Khudawadi Knda Kthi Lana Lao Laoo Latin Latn Lepc Lepcha Limb Limbu Lina Linb Linear_A Linear_B Lisu Lyci Lycian Lydi Lydian Mahajani Mahj Malayalam Mand Mandaic Mani Manichaean Marc Marchen Masaram_Gondi Meetei_Mayek Mend Mende_Kikakui Merc Mero Meroitic_Cursive Meroitic_Hieroglyphs Miao Mlym Modi Mong Mongolian Mro Mroo Mtei Mult Multani Myanmar Mymr Nabataean Narb Nbat New_Tai_Lue Newa Nko Nkoo Nshu Nushu Ogam Ogham Ol_Chiki Olck Old_Hungarian Old_Italic Old_North_Arabian Old_Permic Old_Persian Old_South_Arabian Old_Turkic Oriya Orkh Orya Osage Osge Osma Osmanya Pahawh_Hmong Palm Palmyrene Pau_Cin_Hau Pauc Perm Phag Phags_Pa Phli Phlp Phnx Phoenician Plrd Prti Psalter_Pahlavi Qaac Qaai Rejang Rjng Runic Runr Samaritan Samr Sarb Saur Saurashtra Sgnw Sharada Shavian Shaw Shrd Sidd Siddham SignWriting Sind Sinh Sinhala Sora Sora_Sompeng Soyo Soyombo Sund Sundanese Sylo Syloti_Nagri Syrc Syriac Tagalog Tagb Tagbanwa Tai_Le Tai_Tham Tai_Viet Takr Takri Tale Talu Tamil Taml Tang Tangut Tavt Telu Telugu Tfng Tglg Thaa Thaana Thai Tibetan Tibt Tifinagh Tirh Tirhuta Ugar Ugaritic Vai Vaii Wara Warang_Citi Xpeo Xsux Yi Yiii Zanabazar_Square Zanb Zinh Zyyy", "Dogr Dogra Gong Gunjala_Gondi Hanifi_Rohingya Maka Makasar Medefaidrin Medf Old_Sogdian Rohg Sogd Sogdian Sogo", "Elym Elymaic Hmnp Nand Nandinagari Nyiakeng_Puachue_Hmong Wancho Wcho");
  var binPropertySets = new DataSet("AHex ASCII ASCII_Hex_Digit Alpha Alphabetic Any Assigned Bidi_C Bidi_Control Bidi_M Bidi_Mirrored CI CWCF CWCM CWKCF CWL CWT CWU Case_Ignorable Cased Changes_When_Casefolded Changes_When_Casemapped Changes_When_Lowercased Changes_When_NFKC_Casefolded Changes_When_Titlecased Changes_When_Uppercased DI Dash Default_Ignorable_Code_Point Dep Deprecated Dia Diacritic Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Ext Extender Gr_Base Gr_Ext Grapheme_Base Grapheme_Extend Hex Hex_Digit IDC IDS IDSB IDST IDS_Binary_Operator IDS_Trinary_Operator ID_Continue ID_Start Ideo Ideographic Join_C Join_Control LOE Logical_Order_Exception Lower Lowercase Math NChar Noncharacter_Code_Point Pat_Syn Pat_WS Pattern_Syntax Pattern_White_Space QMark Quotation_Mark RI Radical Regional_Indicator SD STerm Sentence_Terminal Soft_Dotted Term Terminal_Punctuation UIdeo Unified_Ideograph Upper Uppercase VS Variation_Selector White_Space XIDC XIDS XID_Continue XID_Start space", "Extended_Pictographic", "");
  function isValidUnicodeProperty(version, name, value) {
    if (gcNameSet.has(name)) {
      return version >= 2018 && gcValueSets.es2018.has(value);
    }
    if (scNameSet.has(name)) {
      return version >= 2018 && scValueSets.es2018.has(value) || version >= 2019 && scValueSets.es2019.has(value) || version >= 2020 && scValueSets.es2020.has(value);
    }
    return false;
  }
  function isValidLoneUnicodeProperty(version, value) {
    return version >= 2018 && binPropertySets.es2018.has(value) || version >= 2019 && binPropertySets.es2019.has(value);
  }
  var Backspace = 8;
  var CharacterTabulation = 9;
  var LineFeed = 10;
  var LineTabulation = 11;
  var FormFeed = 12;
  var CarriageReturn = 13;
  var ExclamationMark = 33;
  var DollarSign = 36;
  var LeftParenthesis = 40;
  var RightParenthesis = 41;
  var Asterisk = 42;
  var PlusSign = 43;
  var Comma = 44;
  var HyphenMinus = 45;
  var FullStop = 46;
  var Solidus = 47;
  var DigitZero = 48;
  var DigitOne = 49;
  var DigitSeven = 55;
  var DigitNine = 57;
  var Colon = 58;
  var LessThanSign = 60;
  var EqualsSign = 61;
  var GreaterThanSign = 62;
  var QuestionMark = 63;
  var LatinCapitalLetterA = 65;
  var LatinCapitalLetterB = 66;
  var LatinCapitalLetterD = 68;
  var LatinCapitalLetterF = 70;
  var LatinCapitalLetterP = 80;
  var LatinCapitalLetterS = 83;
  var LatinCapitalLetterW = 87;
  var LatinCapitalLetterZ = 90;
  var LowLine = 95;
  var LatinSmallLetterA = 97;
  var LatinSmallLetterB = 98;
  var LatinSmallLetterC = 99;
  var LatinSmallLetterD = 100;
  var LatinSmallLetterF = 102;
  var LatinSmallLetterG = 103;
  var LatinSmallLetterI = 105;
  var LatinSmallLetterK = 107;
  var LatinSmallLetterM = 109;
  var LatinSmallLetterN = 110;
  var LatinSmallLetterP = 112;
  var LatinSmallLetterR = 114;
  var LatinSmallLetterS = 115;
  var LatinSmallLetterT = 116;
  var LatinSmallLetterU = 117;
  var LatinSmallLetterV = 118;
  var LatinSmallLetterW = 119;
  var LatinSmallLetterX = 120;
  var LatinSmallLetterY = 121;
  var LatinSmallLetterZ = 122;
  var LeftSquareBracket = 91;
  var ReverseSolidus = 92;
  var RightSquareBracket = 93;
  var CircumflexAccent = 94;
  var LeftCurlyBracket = 123;
  var VerticalLine = 124;
  var RightCurlyBracket = 125;
  var ZeroWidthNonJoiner = 8204;
  var ZeroWidthJoiner = 8205;
  var LineSeparator = 8232;
  var ParagraphSeparator = 8233;
  var MinCodePoint = 0;
  var MaxCodePoint = 1114111;
  function isLatinLetter(code) {
    return code >= LatinCapitalLetterA && code <= LatinCapitalLetterZ || code >= LatinSmallLetterA && code <= LatinSmallLetterZ;
  }
  function isDecimalDigit(code) {
    return code >= DigitZero && code <= DigitNine;
  }
  function isOctalDigit(code) {
    return code >= DigitZero && code <= DigitSeven;
  }
  function isHexDigit(code) {
    return code >= DigitZero && code <= DigitNine || code >= LatinCapitalLetterA && code <= LatinCapitalLetterF || code >= LatinSmallLetterA && code <= LatinSmallLetterF;
  }
  function isLineTerminator(code) {
    return code === LineFeed || code === CarriageReturn || code === LineSeparator || code === ParagraphSeparator;
  }
  function isValidUnicode(code) {
    return code >= MinCodePoint && code <= MaxCodePoint;
  }
  function digitToInt(code) {
    if (code >= LatinSmallLetterA && code <= LatinSmallLetterF) {
      return code - LatinSmallLetterA + 10;
    }
    if (code >= LatinCapitalLetterA && code <= LatinCapitalLetterF) {
      return code - LatinCapitalLetterA + 10;
    }
    return code - DigitZero;
  }
  function isLeadSurrogate(code) {
    return code >= 55296 && code <= 56319;
  }
  function isTrailSurrogate(code) {
    return code >= 56320 && code <= 57343;
  }
  function combineSurrogatePair(lead, trail) {
    return (lead - 55296) * 1024 + (trail - 56320) + 65536;
  }
  var legacyImpl = {
    at(s, end, i) {
      return i < end ? s.charCodeAt(i) : -1;
    },
    width(c) {
      return 1;
    }
  };
  var unicodeImpl = {
    at(s, end, i) {
      return i < end ? s.codePointAt(i) : -1;
    },
    width(c) {
      return c > 65535 ? 2 : 1;
    }
  };
  var Reader = class {
    constructor() {
      this._impl = legacyImpl;
      this._s = "";
      this._i = 0;
      this._end = 0;
      this._cp1 = -1;
      this._w1 = 1;
      this._cp2 = -1;
      this._w2 = 1;
      this._cp3 = -1;
      this._w3 = 1;
      this._cp4 = -1;
    }
    get source() {
      return this._s;
    }
    get index() {
      return this._i;
    }
    get currentCodePoint() {
      return this._cp1;
    }
    get nextCodePoint() {
      return this._cp2;
    }
    get nextCodePoint2() {
      return this._cp3;
    }
    get nextCodePoint3() {
      return this._cp4;
    }
    reset(source, start, end, uFlag) {
      this._impl = uFlag ? unicodeImpl : legacyImpl;
      this._s = source;
      this._end = end;
      this.rewind(start);
    }
    rewind(index) {
      const impl = this._impl;
      this._i = index;
      this._cp1 = impl.at(this._s, this._end, index);
      this._w1 = impl.width(this._cp1);
      this._cp2 = impl.at(this._s, this._end, index + this._w1);
      this._w2 = impl.width(this._cp2);
      this._cp3 = impl.at(this._s, this._end, index + this._w1 + this._w2);
      this._w3 = impl.width(this._cp3);
      this._cp4 = impl.at(this._s, this._end, index + this._w1 + this._w2 + this._w3);
    }
    advance() {
      if (this._cp1 !== -1) {
        const impl = this._impl;
        this._i += this._w1;
        this._cp1 = this._cp2;
        this._w1 = this._w2;
        this._cp2 = this._cp3;
        this._w2 = impl.width(this._cp2);
        this._cp3 = this._cp4;
        this._w3 = impl.width(this._cp3);
        this._cp4 = impl.at(this._s, this._end, this._i + this._w1 + this._w2 + this._w3);
      }
    }
    eat(cp) {
      if (this._cp1 === cp) {
        this.advance();
        return true;
      }
      return false;
    }
    eat2(cp1, cp2) {
      if (this._cp1 === cp1 && this._cp2 === cp2) {
        this.advance();
        this.advance();
        return true;
      }
      return false;
    }
    eat3(cp1, cp2, cp3) {
      if (this._cp1 === cp1 && this._cp2 === cp2 && this._cp3 === cp3) {
        this.advance();
        this.advance();
        this.advance();
        return true;
      }
      return false;
    }
  };
  var RegExpSyntaxError = class extends SyntaxError {
    constructor(source, uFlag, index, message) {
      if (source) {
        if (!source.startsWith("/")) {
          source = `/${source}/${uFlag ? "u" : ""}`;
        }
        source = `: ${source}`;
      }
      super(`Invalid regular expression${source}: ${message}`);
      this.index = index;
    }
  };
  function isSyntaxCharacter(cp) {
    return cp === CircumflexAccent || cp === DollarSign || cp === ReverseSolidus || cp === FullStop || cp === Asterisk || cp === PlusSign || cp === QuestionMark || cp === LeftParenthesis || cp === RightParenthesis || cp === LeftSquareBracket || cp === RightSquareBracket || cp === LeftCurlyBracket || cp === RightCurlyBracket || cp === VerticalLine;
  }
  function isRegExpIdentifierStart(cp) {
    return isIdStart(cp) || cp === DollarSign || cp === LowLine;
  }
  function isRegExpIdentifierPart(cp) {
    return isIdContinue(cp) || cp === DollarSign || cp === LowLine || cp === ZeroWidthNonJoiner || cp === ZeroWidthJoiner;
  }
  function isUnicodePropertyNameCharacter(cp) {
    return isLatinLetter(cp) || cp === LowLine;
  }
  function isUnicodePropertyValueCharacter(cp) {
    return isUnicodePropertyNameCharacter(cp) || isDecimalDigit(cp);
  }
  var RegExpValidator = class {
    constructor(options) {
      this._reader = new Reader();
      this._uFlag = false;
      this._nFlag = false;
      this._lastIntValue = 0;
      this._lastMinValue = 0;
      this._lastMaxValue = 0;
      this._lastStrValue = "";
      this._lastKeyValue = "";
      this._lastValValue = "";
      this._lastAssertionIsQuantifiable = false;
      this._numCapturingParens = 0;
      this._groupNames = new Set();
      this._backreferenceNames = new Set();
      this._options = options || {};
    }
    validateLiteral(source, start = 0, end = source.length) {
      this._uFlag = this._nFlag = false;
      this.reset(source, start, end);
      this.onLiteralEnter(start);
      if (this.eat(Solidus) && this.eatRegExpBody() && this.eat(Solidus)) {
        const flagStart = this.index;
        const uFlag = source.includes("u", flagStart);
        this.validateFlags(source, flagStart, end);
        this.validatePattern(source, start + 1, flagStart - 1, uFlag);
      } else if (start >= end) {
        this.raise("Empty");
      } else {
        const c = String.fromCodePoint(this.currentCodePoint);
        this.raise(`Unexpected character '${c}'`);
      }
      this.onLiteralLeave(start, end);
    }
    validateFlags(source, start = 0, end = source.length) {
      const existingFlags = new Set();
      let global2 = false;
      let ignoreCase = false;
      let multiline = false;
      let sticky = false;
      let unicode = false;
      let dotAll = false;
      for (let i = start; i < end; ++i) {
        const flag = source.charCodeAt(i);
        if (existingFlags.has(flag)) {
          this.raise(`Duplicated flag '${source[i]}'`);
        }
        existingFlags.add(flag);
        if (flag === LatinSmallLetterG) {
          global2 = true;
        } else if (flag === LatinSmallLetterI) {
          ignoreCase = true;
        } else if (flag === LatinSmallLetterM) {
          multiline = true;
        } else if (flag === LatinSmallLetterU && this.ecmaVersion >= 2015) {
          unicode = true;
        } else if (flag === LatinSmallLetterY && this.ecmaVersion >= 2015) {
          sticky = true;
        } else if (flag === LatinSmallLetterS && this.ecmaVersion >= 2018) {
          dotAll = true;
        } else {
          this.raise(`Invalid flag '${source[i]}'`);
        }
      }
      this.onFlags(start, end, global2, ignoreCase, multiline, unicode, sticky, dotAll);
    }
    validatePattern(source, start = 0, end = source.length, uFlag = false) {
      this._uFlag = uFlag && this.ecmaVersion >= 2015;
      this._nFlag = uFlag && this.ecmaVersion >= 2018;
      this.reset(source, start, end);
      this.consumePattern();
      if (!this._nFlag && this.ecmaVersion >= 2018 && this._groupNames.size > 0) {
        this._nFlag = true;
        this.rewind(start);
        this.consumePattern();
      }
    }
    get strict() {
      return Boolean(this._options.strict || this._uFlag);
    }
    get ecmaVersion() {
      return this._options.ecmaVersion || 2020;
    }
    onLiteralEnter(start) {
      if (this._options.onLiteralEnter) {
        this._options.onLiteralEnter(start);
      }
    }
    onLiteralLeave(start, end) {
      if (this._options.onLiteralLeave) {
        this._options.onLiteralLeave(start, end);
      }
    }
    onFlags(start, end, global2, ignoreCase, multiline, unicode, sticky, dotAll) {
      if (this._options.onFlags) {
        this._options.onFlags(start, end, global2, ignoreCase, multiline, unicode, sticky, dotAll);
      }
    }
    onPatternEnter(start) {
      if (this._options.onPatternEnter) {
        this._options.onPatternEnter(start);
      }
    }
    onPatternLeave(start, end) {
      if (this._options.onPatternLeave) {
        this._options.onPatternLeave(start, end);
      }
    }
    onDisjunctionEnter(start) {
      if (this._options.onDisjunctionEnter) {
        this._options.onDisjunctionEnter(start);
      }
    }
    onDisjunctionLeave(start, end) {
      if (this._options.onDisjunctionLeave) {
        this._options.onDisjunctionLeave(start, end);
      }
    }
    onAlternativeEnter(start, index) {
      if (this._options.onAlternativeEnter) {
        this._options.onAlternativeEnter(start, index);
      }
    }
    onAlternativeLeave(start, end, index) {
      if (this._options.onAlternativeLeave) {
        this._options.onAlternativeLeave(start, end, index);
      }
    }
    onGroupEnter(start) {
      if (this._options.onGroupEnter) {
        this._options.onGroupEnter(start);
      }
    }
    onGroupLeave(start, end) {
      if (this._options.onGroupLeave) {
        this._options.onGroupLeave(start, end);
      }
    }
    onCapturingGroupEnter(start, name) {
      if (this._options.onCapturingGroupEnter) {
        this._options.onCapturingGroupEnter(start, name);
      }
    }
    onCapturingGroupLeave(start, end, name) {
      if (this._options.onCapturingGroupLeave) {
        this._options.onCapturingGroupLeave(start, end, name);
      }
    }
    onQuantifier(start, end, min, max, greedy) {
      if (this._options.onQuantifier) {
        this._options.onQuantifier(start, end, min, max, greedy);
      }
    }
    onLookaroundAssertionEnter(start, kind, negate) {
      if (this._options.onLookaroundAssertionEnter) {
        this._options.onLookaroundAssertionEnter(start, kind, negate);
      }
    }
    onLookaroundAssertionLeave(start, end, kind, negate) {
      if (this._options.onLookaroundAssertionLeave) {
        this._options.onLookaroundAssertionLeave(start, end, kind, negate);
      }
    }
    onEdgeAssertion(start, end, kind) {
      if (this._options.onEdgeAssertion) {
        this._options.onEdgeAssertion(start, end, kind);
      }
    }
    onWordBoundaryAssertion(start, end, kind, negate) {
      if (this._options.onWordBoundaryAssertion) {
        this._options.onWordBoundaryAssertion(start, end, kind, negate);
      }
    }
    onAnyCharacterSet(start, end, kind) {
      if (this._options.onAnyCharacterSet) {
        this._options.onAnyCharacterSet(start, end, kind);
      }
    }
    onEscapeCharacterSet(start, end, kind, negate) {
      if (this._options.onEscapeCharacterSet) {
        this._options.onEscapeCharacterSet(start, end, kind, negate);
      }
    }
    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
      if (this._options.onUnicodePropertyCharacterSet) {
        this._options.onUnicodePropertyCharacterSet(start, end, kind, key, value, negate);
      }
    }
    onCharacter(start, end, value) {
      if (this._options.onCharacter) {
        this._options.onCharacter(start, end, value);
      }
    }
    onBackreference(start, end, ref) {
      if (this._options.onBackreference) {
        this._options.onBackreference(start, end, ref);
      }
    }
    onCharacterClassEnter(start, negate) {
      if (this._options.onCharacterClassEnter) {
        this._options.onCharacterClassEnter(start, negate);
      }
    }
    onCharacterClassLeave(start, end, negate) {
      if (this._options.onCharacterClassLeave) {
        this._options.onCharacterClassLeave(start, end, negate);
      }
    }
    onCharacterClassRange(start, end, min, max) {
      if (this._options.onCharacterClassRange) {
        this._options.onCharacterClassRange(start, end, min, max);
      }
    }
    get source() {
      return this._reader.source;
    }
    get index() {
      return this._reader.index;
    }
    get currentCodePoint() {
      return this._reader.currentCodePoint;
    }
    get nextCodePoint() {
      return this._reader.nextCodePoint;
    }
    get nextCodePoint2() {
      return this._reader.nextCodePoint2;
    }
    get nextCodePoint3() {
      return this._reader.nextCodePoint3;
    }
    reset(source, start, end) {
      this._reader.reset(source, start, end, this._uFlag);
    }
    rewind(index) {
      this._reader.rewind(index);
    }
    advance() {
      this._reader.advance();
    }
    eat(cp) {
      return this._reader.eat(cp);
    }
    eat2(cp1, cp2) {
      return this._reader.eat2(cp1, cp2);
    }
    eat3(cp1, cp2, cp3) {
      return this._reader.eat3(cp1, cp2, cp3);
    }
    raise(message) {
      throw new RegExpSyntaxError(this.source, this._uFlag, this.index, message);
    }
    eatRegExpBody() {
      const start = this.index;
      let inClass = false;
      let escaped = false;
      for (; ; ) {
        const cp = this.currentCodePoint;
        if (cp === -1 || isLineTerminator(cp)) {
          const kind = inClass ? "character class" : "regular expression";
          this.raise(`Unterminated ${kind}`);
        }
        if (escaped) {
          escaped = false;
        } else if (cp === ReverseSolidus) {
          escaped = true;
        } else if (cp === LeftSquareBracket) {
          inClass = true;
        } else if (cp === RightSquareBracket) {
          inClass = false;
        } else if (cp === Solidus && !inClass || cp === Asterisk && this.index === start) {
          break;
        }
        this.advance();
      }
      return this.index !== start;
    }
    consumePattern() {
      const start = this.index;
      this._numCapturingParens = this.countCapturingParens();
      this._groupNames.clear();
      this._backreferenceNames.clear();
      this.onPatternEnter(start);
      this.consumeDisjunction();
      const cp = this.currentCodePoint;
      if (this.currentCodePoint !== -1) {
        if (cp === RightParenthesis) {
          this.raise("Unmatched ')'");
        }
        if (cp === ReverseSolidus) {
          this.raise("\\ at end of pattern");
        }
        if (cp === RightSquareBracket || cp === RightCurlyBracket) {
          this.raise("Lone quantifier brackets");
        }
        const c = String.fromCodePoint(cp);
        this.raise(`Unexpected character '${c}'`);
      }
      for (const name of this._backreferenceNames) {
        if (!this._groupNames.has(name)) {
          this.raise("Invalid named capture referenced");
        }
      }
      this.onPatternLeave(start, this.index);
    }
    countCapturingParens() {
      const start = this.index;
      let inClass = false;
      let escaped = false;
      let count = 0;
      let cp = 0;
      while ((cp = this.currentCodePoint) !== -1) {
        if (escaped) {
          escaped = false;
        } else if (cp === ReverseSolidus) {
          escaped = true;
        } else if (cp === LeftSquareBracket) {
          inClass = true;
        } else if (cp === RightSquareBracket) {
          inClass = false;
        } else if (cp === LeftParenthesis && !inClass && (this.nextCodePoint !== QuestionMark || this.nextCodePoint2 === LessThanSign && this.nextCodePoint3 !== EqualsSign && this.nextCodePoint3 !== ExclamationMark)) {
          count += 1;
        }
        this.advance();
      }
      this.rewind(start);
      return count;
    }
    consumeDisjunction() {
      const start = this.index;
      let i = 0;
      this.onDisjunctionEnter(start);
      do {
        this.consumeAlternative(i++);
      } while (this.eat(VerticalLine));
      if (this.consumeQuantifier(true)) {
        this.raise("Nothing to repeat");
      }
      if (this.eat(LeftCurlyBracket)) {
        this.raise("Lone quantifier brackets");
      }
      this.onDisjunctionLeave(start, this.index);
    }
    consumeAlternative(i) {
      const start = this.index;
      this.onAlternativeEnter(start, i);
      while (this.currentCodePoint !== -1 && this.consumeTerm()) {
      }
      this.onAlternativeLeave(start, this.index, i);
    }
    consumeTerm() {
      if (this._uFlag || this.strict) {
        return this.consumeAssertion() || this.consumeAtom() && this.consumeOptionalQuantifier();
      }
      return this.consumeAssertion() && (!this._lastAssertionIsQuantifiable || this.consumeOptionalQuantifier()) || this.consumeExtendedAtom() && this.consumeOptionalQuantifier();
    }
    consumeOptionalQuantifier() {
      this.consumeQuantifier();
      return true;
    }
    consumeAssertion() {
      const start = this.index;
      this._lastAssertionIsQuantifiable = false;
      if (this.eat(CircumflexAccent)) {
        this.onEdgeAssertion(start, this.index, "start");
        return true;
      }
      if (this.eat(DollarSign)) {
        this.onEdgeAssertion(start, this.index, "end");
        return true;
      }
      if (this.eat2(ReverseSolidus, LatinCapitalLetterB)) {
        this.onWordBoundaryAssertion(start, this.index, "word", true);
        return true;
      }
      if (this.eat2(ReverseSolidus, LatinSmallLetterB)) {
        this.onWordBoundaryAssertion(start, this.index, "word", false);
        return true;
      }
      if (this.eat2(LeftParenthesis, QuestionMark)) {
        const lookbehind = this.ecmaVersion >= 2018 && this.eat(LessThanSign);
        let negate = false;
        if (this.eat(EqualsSign) || (negate = this.eat(ExclamationMark))) {
          const kind = lookbehind ? "lookbehind" : "lookahead";
          this.onLookaroundAssertionEnter(start, kind, negate);
          this.consumeDisjunction();
          if (!this.eat(RightParenthesis)) {
            this.raise("Unterminated group");
          }
          this._lastAssertionIsQuantifiable = !lookbehind && !this.strict;
          this.onLookaroundAssertionLeave(start, this.index, kind, negate);
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    consumeQuantifier(noConsume = false) {
      const start = this.index;
      let min = 0;
      let max = 0;
      let greedy = false;
      if (this.eat(Asterisk)) {
        min = 0;
        max = Number.POSITIVE_INFINITY;
      } else if (this.eat(PlusSign)) {
        min = 1;
        max = Number.POSITIVE_INFINITY;
      } else if (this.eat(QuestionMark)) {
        min = 0;
        max = 1;
      } else if (this.eatBracedQuantifier(noConsume)) {
        min = this._lastMinValue;
        max = this._lastMaxValue;
      } else {
        return false;
      }
      greedy = !this.eat(QuestionMark);
      if (!noConsume) {
        this.onQuantifier(start, this.index, min, max, greedy);
      }
      return true;
    }
    eatBracedQuantifier(noError) {
      const start = this.index;
      if (this.eat(LeftCurlyBracket)) {
        this._lastMinValue = 0;
        this._lastMaxValue = Number.POSITIVE_INFINITY;
        if (this.eatDecimalDigits()) {
          this._lastMinValue = this._lastMaxValue = this._lastIntValue;
          if (this.eat(Comma)) {
            this._lastMaxValue = this.eatDecimalDigits() ? this._lastIntValue : Number.POSITIVE_INFINITY;
          }
          if (this.eat(RightCurlyBracket)) {
            if (!noError && this._lastMaxValue < this._lastMinValue) {
              this.raise("numbers out of order in {} quantifier");
            }
            return true;
          }
        }
        if (!noError && (this._uFlag || this.strict)) {
          this.raise("Incomplete quantifier");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeAtom() {
      return this.consumePatternCharacter() || this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup();
    }
    consumeDot() {
      if (this.eat(FullStop)) {
        this.onAnyCharacterSet(this.index - 1, this.index, "any");
        return true;
      }
      return false;
    }
    consumeReverseSolidusAtomEscape() {
      const start = this.index;
      if (this.eat(ReverseSolidus)) {
        if (this.consumeAtomEscape()) {
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    consumeUncapturingGroup() {
      const start = this.index;
      if (this.eat3(LeftParenthesis, QuestionMark, Colon)) {
        this.onGroupEnter(start);
        this.consumeDisjunction();
        if (!this.eat(RightParenthesis)) {
          this.raise("Unterminated group");
        }
        this.onGroupLeave(start, this.index);
        return true;
      }
      return false;
    }
    consumeCapturingGroup() {
      const start = this.index;
      if (this.eat(LeftParenthesis)) {
        let name = null;
        if (this.ecmaVersion >= 2018) {
          if (this.consumeGroupSpecifier()) {
            name = this._lastStrValue;
          }
        } else if (this.currentCodePoint === QuestionMark) {
          this.raise("Invalid group");
        }
        this.onCapturingGroupEnter(start, name);
        this.consumeDisjunction();
        if (!this.eat(RightParenthesis)) {
          this.raise("Unterminated group");
        }
        this.onCapturingGroupLeave(start, this.index, name);
        return true;
      }
      return false;
    }
    consumeExtendedAtom() {
      return this.consumeDot() || this.consumeReverseSolidusAtomEscape() || this.consumeReverseSolidusFollowedByC() || this.consumeCharacterClass() || this.consumeUncapturingGroup() || this.consumeCapturingGroup() || this.consumeInvalidBracedQuantifier() || this.consumeExtendedPatternCharacter();
    }
    consumeReverseSolidusFollowedByC() {
      const start = this.index;
      if (this.currentCodePoint === ReverseSolidus && this.nextCodePoint === LatinSmallLetterC) {
        this._lastIntValue = this.currentCodePoint;
        this.advance();
        this.onCharacter(start, this.index, ReverseSolidus);
        return true;
      }
      return false;
    }
    consumeInvalidBracedQuantifier() {
      if (this.eatBracedQuantifier(true)) {
        this.raise("Nothing to repeat");
      }
      return false;
    }
    consumePatternCharacter() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && !isSyntaxCharacter(cp)) {
        this.advance();
        this.onCharacter(start, this.index, cp);
        return true;
      }
      return false;
    }
    consumeExtendedPatternCharacter() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && cp !== CircumflexAccent && cp !== DollarSign && cp !== ReverseSolidus && cp !== FullStop && cp !== Asterisk && cp !== PlusSign && cp !== QuestionMark && cp !== LeftParenthesis && cp !== RightParenthesis && cp !== LeftSquareBracket && cp !== VerticalLine) {
        this.advance();
        this.onCharacter(start, this.index, cp);
        return true;
      }
      return false;
    }
    consumeGroupSpecifier() {
      if (this.eat(QuestionMark)) {
        if (this.eatGroupName()) {
          if (!this._groupNames.has(this._lastStrValue)) {
            this._groupNames.add(this._lastStrValue);
            return true;
          }
          this.raise("Duplicate capture group name");
        }
        this.raise("Invalid group");
      }
      return false;
    }
    consumeAtomEscape() {
      if (this.consumeBackreference() || this.consumeCharacterClassEscape() || this.consumeCharacterEscape() || this._nFlag && this.consumeKGroupName()) {
        return true;
      }
      if (this.strict || this._uFlag) {
        this.raise("Invalid escape");
      }
      return false;
    }
    consumeBackreference() {
      const start = this.index;
      if (this.eatDecimalEscape()) {
        const n = this._lastIntValue;
        if (n <= this._numCapturingParens) {
          this.onBackreference(start - 1, this.index, n);
          return true;
        }
        if (this.strict || this._uFlag) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeCharacterClassEscape() {
      const start = this.index;
      if (this.eat(LatinSmallLetterD)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "digit", false);
        return true;
      }
      if (this.eat(LatinCapitalLetterD)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "digit", true);
        return true;
      }
      if (this.eat(LatinSmallLetterS)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "space", false);
        return true;
      }
      if (this.eat(LatinCapitalLetterS)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "space", true);
        return true;
      }
      if (this.eat(LatinSmallLetterW)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "word", false);
        return true;
      }
      if (this.eat(LatinCapitalLetterW)) {
        this._lastIntValue = -1;
        this.onEscapeCharacterSet(start - 1, this.index, "word", true);
        return true;
      }
      let negate = false;
      if (this._uFlag && this.ecmaVersion >= 2018 && (this.eat(LatinSmallLetterP) || (negate = this.eat(LatinCapitalLetterP)))) {
        this._lastIntValue = -1;
        if (this.eat(LeftCurlyBracket) && this.eatUnicodePropertyValueExpression() && this.eat(RightCurlyBracket)) {
          this.onUnicodePropertyCharacterSet(start - 1, this.index, "property", this._lastKeyValue, this._lastValValue || null, negate);
          return true;
        }
        this.raise("Invalid property name");
      }
      return false;
    }
    consumeCharacterEscape() {
      const start = this.index;
      if (this.eatControlEscape() || this.eatCControlLetter() || this.eatZero() || this.eatHexEscapeSequence() || this.eatRegExpUnicodeEscapeSequence() || !this.strict && !this._uFlag && this.eatLegacyOctalEscapeSequence() || this.eatIdentityEscape()) {
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      return false;
    }
    consumeKGroupName() {
      const start = this.index;
      if (this.eat(LatinSmallLetterK)) {
        if (this.eatGroupName()) {
          const groupName = this._lastStrValue;
          this._backreferenceNames.add(groupName);
          this.onBackreference(start - 1, this.index, groupName);
          return true;
        }
        this.raise("Invalid named reference");
      }
      return false;
    }
    consumeCharacterClass() {
      const start = this.index;
      if (this.eat(LeftSquareBracket)) {
        const negate = this.eat(CircumflexAccent);
        this.onCharacterClassEnter(start, negate);
        this.consumeClassRanges();
        if (!this.eat(RightSquareBracket)) {
          this.raise("Unterminated character class");
        }
        this.onCharacterClassLeave(start, this.index, negate);
        return true;
      }
      return false;
    }
    consumeClassRanges() {
      const strict = this.strict || this._uFlag;
      for (; ; ) {
        const rangeStart = this.index;
        if (!this.consumeClassAtom()) {
          break;
        }
        const min = this._lastIntValue;
        if (!this.eat(HyphenMinus)) {
          continue;
        }
        this.onCharacter(this.index - 1, this.index, HyphenMinus);
        if (!this.consumeClassAtom()) {
          break;
        }
        const max = this._lastIntValue;
        if (min === -1 || max === -1) {
          if (strict) {
            this.raise("Invalid character class");
          }
          continue;
        }
        if (min > max) {
          this.raise("Range out of order in character class");
        }
        this.onCharacterClassRange(rangeStart, this.index, min, max);
      }
    }
    consumeClassAtom() {
      const start = this.index;
      const cp = this.currentCodePoint;
      if (cp !== -1 && cp !== ReverseSolidus && cp !== RightSquareBracket) {
        this.advance();
        this._lastIntValue = cp;
        this.onCharacter(start, this.index, this._lastIntValue);
        return true;
      }
      if (this.eat(ReverseSolidus)) {
        if (this.consumeClassEscape()) {
          return true;
        }
        if (!this.strict && this.currentCodePoint === LatinSmallLetterC) {
          this._lastIntValue = ReverseSolidus;
          this.onCharacter(start, this.index, this._lastIntValue);
          return true;
        }
        if (this.strict || this._uFlag) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    consumeClassEscape() {
      const start = this.index;
      if (this.eat(LatinSmallLetterB)) {
        this._lastIntValue = Backspace;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      if (this._uFlag && this.eat(HyphenMinus)) {
        this._lastIntValue = HyphenMinus;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      let cp = 0;
      if (!this.strict && !this._uFlag && this.currentCodePoint === LatinSmallLetterC && (isDecimalDigit(cp = this.nextCodePoint) || cp === LowLine)) {
        this.advance();
        this.advance();
        this._lastIntValue = cp % 32;
        this.onCharacter(start - 1, this.index, this._lastIntValue);
        return true;
      }
      return this.consumeCharacterClassEscape() || this.consumeCharacterEscape();
    }
    eatGroupName() {
      if (this.eat(LessThanSign)) {
        if (this.eatRegExpIdentifierName() && this.eat(GreaterThanSign)) {
          return true;
        }
        this.raise("Invalid capture group name");
      }
      return false;
    }
    eatRegExpIdentifierName() {
      if (this.eatRegExpIdentifierStart()) {
        this._lastStrValue = String.fromCodePoint(this._lastIntValue);
        while (this.eatRegExpIdentifierPart()) {
          this._lastStrValue += String.fromCodePoint(this._lastIntValue);
        }
        return true;
      }
      return false;
    }
    eatRegExpIdentifierStart() {
      const start = this.index;
      const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
      let cp = this.currentCodePoint;
      this.advance();
      if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
        cp = this._lastIntValue;
      } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
        cp = combineSurrogatePair(cp, this.currentCodePoint);
        this.advance();
      }
      if (isRegExpIdentifierStart(cp)) {
        this._lastIntValue = cp;
        return true;
      }
      if (this.index !== start) {
        this.rewind(start);
      }
      return false;
    }
    eatRegExpIdentifierPart() {
      const start = this.index;
      const forceUFlag = !this._uFlag && this.ecmaVersion >= 2020;
      let cp = this.currentCodePoint;
      this.advance();
      if (cp === ReverseSolidus && this.eatRegExpUnicodeEscapeSequence(forceUFlag)) {
        cp = this._lastIntValue;
      } else if (forceUFlag && isLeadSurrogate(cp) && isTrailSurrogate(this.currentCodePoint)) {
        cp = combineSurrogatePair(cp, this.currentCodePoint);
        this.advance();
      }
      if (isRegExpIdentifierPart(cp)) {
        this._lastIntValue = cp;
        return true;
      }
      if (this.index !== start) {
        this.rewind(start);
      }
      return false;
    }
    eatCControlLetter() {
      const start = this.index;
      if (this.eat(LatinSmallLetterC)) {
        if (this.eatControlLetter()) {
          return true;
        }
        this.rewind(start);
      }
      return false;
    }
    eatZero() {
      if (this.currentCodePoint === DigitZero && !isDecimalDigit(this.nextCodePoint)) {
        this._lastIntValue = 0;
        this.advance();
        return true;
      }
      return false;
    }
    eatControlEscape() {
      if (this.eat(LatinSmallLetterF)) {
        this._lastIntValue = FormFeed;
        return true;
      }
      if (this.eat(LatinSmallLetterN)) {
        this._lastIntValue = LineFeed;
        return true;
      }
      if (this.eat(LatinSmallLetterR)) {
        this._lastIntValue = CarriageReturn;
        return true;
      }
      if (this.eat(LatinSmallLetterT)) {
        this._lastIntValue = CharacterTabulation;
        return true;
      }
      if (this.eat(LatinSmallLetterV)) {
        this._lastIntValue = LineTabulation;
        return true;
      }
      return false;
    }
    eatControlLetter() {
      const cp = this.currentCodePoint;
      if (isLatinLetter(cp)) {
        this.advance();
        this._lastIntValue = cp % 32;
        return true;
      }
      return false;
    }
    eatRegExpUnicodeEscapeSequence(forceUFlag = false) {
      const start = this.index;
      const uFlag = forceUFlag || this._uFlag;
      if (this.eat(LatinSmallLetterU)) {
        if (uFlag && this.eatRegExpUnicodeSurrogatePairEscape() || this.eatFixedHexDigits(4) || uFlag && this.eatRegExpUnicodeCodePointEscape()) {
          return true;
        }
        if (this.strict || uFlag) {
          this.raise("Invalid unicode escape");
        }
        this.rewind(start);
      }
      return false;
    }
    eatRegExpUnicodeSurrogatePairEscape() {
      const start = this.index;
      if (this.eatFixedHexDigits(4)) {
        const lead = this._lastIntValue;
        if (isLeadSurrogate(lead) && this.eat(ReverseSolidus) && this.eat(LatinSmallLetterU) && this.eatFixedHexDigits(4)) {
          const trail = this._lastIntValue;
          if (isTrailSurrogate(trail)) {
            this._lastIntValue = combineSurrogatePair(lead, trail);
            return true;
          }
        }
        this.rewind(start);
      }
      return false;
    }
    eatRegExpUnicodeCodePointEscape() {
      const start = this.index;
      if (this.eat(LeftCurlyBracket) && this.eatHexDigits() && this.eat(RightCurlyBracket) && isValidUnicode(this._lastIntValue)) {
        return true;
      }
      this.rewind(start);
      return false;
    }
    eatIdentityEscape() {
      const cp = this.currentCodePoint;
      if (this.isValidIdentityEscape(cp)) {
        this._lastIntValue = cp;
        this.advance();
        return true;
      }
      return false;
    }
    isValidIdentityEscape(cp) {
      if (cp === -1) {
        return false;
      }
      if (this._uFlag) {
        return isSyntaxCharacter(cp) || cp === Solidus;
      }
      if (this.strict) {
        return !isIdContinue(cp);
      }
      if (this._nFlag) {
        return !(cp === LatinSmallLetterC || cp === LatinSmallLetterK);
      }
      return cp !== LatinSmallLetterC;
    }
    eatDecimalEscape() {
      this._lastIntValue = 0;
      let cp = this.currentCodePoint;
      if (cp >= DigitOne && cp <= DigitNine) {
        do {
          this._lastIntValue = 10 * this._lastIntValue + (cp - DigitZero);
          this.advance();
        } while ((cp = this.currentCodePoint) >= DigitZero && cp <= DigitNine);
        return true;
      }
      return false;
    }
    eatUnicodePropertyValueExpression() {
      const start = this.index;
      if (this.eatUnicodePropertyName() && this.eat(EqualsSign)) {
        this._lastKeyValue = this._lastStrValue;
        if (this.eatUnicodePropertyValue()) {
          this._lastValValue = this._lastStrValue;
          if (isValidUnicodeProperty(this.ecmaVersion, this._lastKeyValue, this._lastValValue)) {
            return true;
          }
          this.raise("Invalid property name");
        }
      }
      this.rewind(start);
      if (this.eatLoneUnicodePropertyNameOrValue()) {
        const nameOrValue = this._lastStrValue;
        if (isValidUnicodeProperty(this.ecmaVersion, "General_Category", nameOrValue)) {
          this._lastKeyValue = "General_Category";
          this._lastValValue = nameOrValue;
          return true;
        }
        if (isValidLoneUnicodeProperty(this.ecmaVersion, nameOrValue)) {
          this._lastKeyValue = nameOrValue;
          this._lastValValue = "";
          return true;
        }
        this.raise("Invalid property name");
      }
      return false;
    }
    eatUnicodePropertyName() {
      this._lastStrValue = "";
      while (isUnicodePropertyNameCharacter(this.currentCodePoint)) {
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
        this.advance();
      }
      return this._lastStrValue !== "";
    }
    eatUnicodePropertyValue() {
      this._lastStrValue = "";
      while (isUnicodePropertyValueCharacter(this.currentCodePoint)) {
        this._lastStrValue += String.fromCodePoint(this.currentCodePoint);
        this.advance();
      }
      return this._lastStrValue !== "";
    }
    eatLoneUnicodePropertyNameOrValue() {
      return this.eatUnicodePropertyValue();
    }
    eatHexEscapeSequence() {
      const start = this.index;
      if (this.eat(LatinSmallLetterX)) {
        if (this.eatFixedHexDigits(2)) {
          return true;
        }
        if (this._uFlag || this.strict) {
          this.raise("Invalid escape");
        }
        this.rewind(start);
      }
      return false;
    }
    eatDecimalDigits() {
      const start = this.index;
      this._lastIntValue = 0;
      while (isDecimalDigit(this.currentCodePoint)) {
        this._lastIntValue = 10 * this._lastIntValue + digitToInt(this.currentCodePoint);
        this.advance();
      }
      return this.index !== start;
    }
    eatHexDigits() {
      const start = this.index;
      this._lastIntValue = 0;
      while (isHexDigit(this.currentCodePoint)) {
        this._lastIntValue = 16 * this._lastIntValue + digitToInt(this.currentCodePoint);
        this.advance();
      }
      return this.index !== start;
    }
    eatLegacyOctalEscapeSequence() {
      if (this.eatOctalDigit()) {
        const n1 = this._lastIntValue;
        if (this.eatOctalDigit()) {
          const n2 = this._lastIntValue;
          if (n1 <= 3 && this.eatOctalDigit()) {
            this._lastIntValue = n1 * 64 + n2 * 8 + this._lastIntValue;
          } else {
            this._lastIntValue = n1 * 8 + n2;
          }
        } else {
          this._lastIntValue = n1;
        }
        return true;
      }
      return false;
    }
    eatOctalDigit() {
      const cp = this.currentCodePoint;
      if (isOctalDigit(cp)) {
        this.advance();
        this._lastIntValue = cp - DigitZero;
        return true;
      }
      this._lastIntValue = 0;
      return false;
    }
    eatFixedHexDigits(length) {
      const start = this.index;
      this._lastIntValue = 0;
      for (let i = 0; i < length; ++i) {
        const cp = this.currentCodePoint;
        if (!isHexDigit(cp)) {
          this.rewind(start);
          return false;
        }
        this._lastIntValue = 16 * this._lastIntValue + digitToInt(cp);
        this.advance();
      }
      return true;
    }
  };
  var DummyPattern = {};
  var DummyFlags = {};
  var DummyCapturingGroup = {};
  var RegExpParserState = class {
    constructor(options) {
      this._node = DummyPattern;
      this._flags = DummyFlags;
      this._backreferences = [];
      this._capturingGroups = [];
      this.source = "";
      this.strict = Boolean(options && options.strict);
      this.ecmaVersion = options && options.ecmaVersion || 2020;
    }
    get pattern() {
      if (this._node.type !== "Pattern") {
        throw new Error("UnknownError");
      }
      return this._node;
    }
    get flags() {
      if (this._flags.type !== "Flags") {
        throw new Error("UnknownError");
      }
      return this._flags;
    }
    onFlags(start, end, global2, ignoreCase, multiline, unicode, sticky, dotAll) {
      this._flags = {
        type: "Flags",
        parent: null,
        start,
        end,
        raw: this.source.slice(start, end),
        global: global2,
        ignoreCase,
        multiline,
        unicode,
        sticky,
        dotAll
      };
    }
    onPatternEnter(start) {
      this._node = {
        type: "Pattern",
        parent: null,
        start,
        end: start,
        raw: "",
        alternatives: []
      };
      this._backreferences.length = 0;
      this._capturingGroups.length = 0;
    }
    onPatternLeave(start, end) {
      this._node.end = end;
      this._node.raw = this.source.slice(start, end);
      for (const reference of this._backreferences) {
        const ref = reference.ref;
        const group = typeof ref === "number" ? this._capturingGroups[ref - 1] : this._capturingGroups.find((g) => g.name === ref);
        reference.resolved = group;
        group.references.push(reference);
      }
    }
    onAlternativeEnter(start) {
      const parent = this._node;
      if (parent.type !== "Assertion" && parent.type !== "CapturingGroup" && parent.type !== "Group" && parent.type !== "Pattern") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "Alternative",
        parent,
        start,
        end: start,
        raw: "",
        elements: []
      };
      parent.alternatives.push(this._node);
    }
    onAlternativeLeave(start, end) {
      const node = this._node;
      if (node.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node.end = end;
      node.raw = this.source.slice(start, end);
      this._node = node.parent;
    }
    onGroupEnter(start) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "Group",
        parent,
        start,
        end: start,
        raw: "",
        alternatives: []
      };
      parent.elements.push(this._node);
    }
    onGroupLeave(start, end) {
      const node = this._node;
      if (node.type !== "Group" || node.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node.end = end;
      node.raw = this.source.slice(start, end);
      this._node = node.parent;
    }
    onCapturingGroupEnter(start, name) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "CapturingGroup",
        parent,
        start,
        end: start,
        raw: "",
        name,
        alternatives: [],
        references: []
      };
      parent.elements.push(this._node);
      this._capturingGroups.push(this._node);
    }
    onCapturingGroupLeave(start, end) {
      const node = this._node;
      if (node.type !== "CapturingGroup" || node.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node.end = end;
      node.raw = this.source.slice(start, end);
      this._node = node.parent;
    }
    onQuantifier(start, end, min, max, greedy) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const element = parent.elements.pop();
      if (element == null || element.type === "Quantifier" || element.type === "Assertion" && element.kind !== "lookahead") {
        throw new Error("UnknownError");
      }
      const node = {
        type: "Quantifier",
        parent,
        start: element.start,
        end,
        raw: this.source.slice(element.start, end),
        min,
        max,
        greedy,
        element
      };
      parent.elements.push(node);
      element.parent = node;
    }
    onLookaroundAssertionEnter(start, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const node = this._node = {
        type: "Assertion",
        parent,
        start,
        end: start,
        raw: "",
        kind,
        negate,
        alternatives: []
      };
      parent.elements.push(node);
    }
    onLookaroundAssertionLeave(start, end) {
      const node = this._node;
      if (node.type !== "Assertion" || node.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node.end = end;
      node.raw = this.source.slice(start, end);
      this._node = node.parent;
    }
    onEdgeAssertion(start, end, kind) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Assertion",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind
      });
    }
    onWordBoundaryAssertion(start, end, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Assertion",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        negate
      });
    }
    onAnyCharacterSet(start, end, kind) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "CharacterSet",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind
      });
    }
    onEscapeCharacterSet(start, end, kind, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "CharacterSet",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        negate
      });
    }
    onUnicodePropertyCharacterSet(start, end, kind, key, value, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "CharacterSet",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        kind,
        key,
        value,
        negate
      });
    }
    onCharacter(start, end, value) {
      const parent = this._node;
      if (parent.type !== "Alternative" && parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      parent.elements.push({
        type: "Character",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        value
      });
    }
    onBackreference(start, end, ref) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      const node = {
        type: "Backreference",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        ref,
        resolved: DummyCapturingGroup
      };
      parent.elements.push(node);
      this._backreferences.push(node);
    }
    onCharacterClassEnter(start, negate) {
      const parent = this._node;
      if (parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      this._node = {
        type: "CharacterClass",
        parent,
        start,
        end: start,
        raw: "",
        negate,
        elements: []
      };
      parent.elements.push(this._node);
    }
    onCharacterClassLeave(start, end) {
      const node = this._node;
      if (node.type !== "CharacterClass" || node.parent.type !== "Alternative") {
        throw new Error("UnknownError");
      }
      node.end = end;
      node.raw = this.source.slice(start, end);
      this._node = node.parent;
    }
    onCharacterClassRange(start, end) {
      const parent = this._node;
      if (parent.type !== "CharacterClass") {
        throw new Error("UnknownError");
      }
      const elements = parent.elements;
      const max = elements.pop();
      const hyphen = elements.pop();
      const min = elements.pop();
      if (!min || !max || !hyphen || min.type !== "Character" || max.type !== "Character" || hyphen.type !== "Character" || hyphen.value !== HyphenMinus) {
        throw new Error("UnknownError");
      }
      const node = {
        type: "CharacterClassRange",
        parent,
        start,
        end,
        raw: this.source.slice(start, end),
        min,
        max
      };
      min.parent = node;
      max.parent = node;
      elements.push(node);
    }
  };
  var RegExpParser = class {
    constructor(options) {
      this._state = new RegExpParserState(options);
      this._validator = new RegExpValidator(this._state);
    }
    parseLiteral(source, start = 0, end = source.length) {
      this._state.source = source;
      this._validator.validateLiteral(source, start, end);
      const pattern = this._state.pattern;
      const flags = this._state.flags;
      const literal = {
        type: "RegExpLiteral",
        parent: null,
        start,
        end,
        raw: source,
        pattern,
        flags
      };
      pattern.parent = literal;
      flags.parent = literal;
      return literal;
    }
    parseFlags(source, start = 0, end = source.length) {
      this._state.source = source;
      this._validator.validateFlags(source, start, end);
      return this._state.flags;
    }
    parsePattern(source, start = 0, end = source.length, uFlag = false) {
      this._state.source = source;
      this._validator.validatePattern(source, start, end, uFlag);
      return this._state.pattern;
    }
  };
  var RegExpVisitor = class {
    constructor(handlers) {
      this._handlers = handlers;
    }
    visit(node) {
      switch (node.type) {
        case "Alternative":
          this.visitAlternative(node);
          break;
        case "Assertion":
          this.visitAssertion(node);
          break;
        case "Backreference":
          this.visitBackreference(node);
          break;
        case "CapturingGroup":
          this.visitCapturingGroup(node);
          break;
        case "Character":
          this.visitCharacter(node);
          break;
        case "CharacterClass":
          this.visitCharacterClass(node);
          break;
        case "CharacterClassRange":
          this.visitCharacterClassRange(node);
          break;
        case "CharacterSet":
          this.visitCharacterSet(node);
          break;
        case "Flags":
          this.visitFlags(node);
          break;
        case "Group":
          this.visitGroup(node);
          break;
        case "Pattern":
          this.visitPattern(node);
          break;
        case "Quantifier":
          this.visitQuantifier(node);
          break;
        case "RegExpLiteral":
          this.visitRegExpLiteral(node);
          break;
        default:
          throw new Error(`Unknown type: ${node.type}`);
      }
    }
    visitAlternative(node) {
      if (this._handlers.onAlternativeEnter) {
        this._handlers.onAlternativeEnter(node);
      }
      node.elements.forEach(this.visit, this);
      if (this._handlers.onAlternativeLeave) {
        this._handlers.onAlternativeLeave(node);
      }
    }
    visitAssertion(node) {
      if (this._handlers.onAssertionEnter) {
        this._handlers.onAssertionEnter(node);
      }
      if (node.kind === "lookahead" || node.kind === "lookbehind") {
        node.alternatives.forEach(this.visit, this);
      }
      if (this._handlers.onAssertionLeave) {
        this._handlers.onAssertionLeave(node);
      }
    }
    visitBackreference(node) {
      if (this._handlers.onBackreferenceEnter) {
        this._handlers.onBackreferenceEnter(node);
      }
      if (this._handlers.onBackreferenceLeave) {
        this._handlers.onBackreferenceLeave(node);
      }
    }
    visitCapturingGroup(node) {
      if (this._handlers.onCapturingGroupEnter) {
        this._handlers.onCapturingGroupEnter(node);
      }
      node.alternatives.forEach(this.visit, this);
      if (this._handlers.onCapturingGroupLeave) {
        this._handlers.onCapturingGroupLeave(node);
      }
    }
    visitCharacter(node) {
      if (this._handlers.onCharacterEnter) {
        this._handlers.onCharacterEnter(node);
      }
      if (this._handlers.onCharacterLeave) {
        this._handlers.onCharacterLeave(node);
      }
    }
    visitCharacterClass(node) {
      if (this._handlers.onCharacterClassEnter) {
        this._handlers.onCharacterClassEnter(node);
      }
      node.elements.forEach(this.visit, this);
      if (this._handlers.onCharacterClassLeave) {
        this._handlers.onCharacterClassLeave(node);
      }
    }
    visitCharacterClassRange(node) {
      if (this._handlers.onCharacterClassRangeEnter) {
        this._handlers.onCharacterClassRangeEnter(node);
      }
      this.visitCharacter(node.min);
      this.visitCharacter(node.max);
      if (this._handlers.onCharacterClassRangeLeave) {
        this._handlers.onCharacterClassRangeLeave(node);
      }
    }
    visitCharacterSet(node) {
      if (this._handlers.onCharacterSetEnter) {
        this._handlers.onCharacterSetEnter(node);
      }
      if (this._handlers.onCharacterSetLeave) {
        this._handlers.onCharacterSetLeave(node);
      }
    }
    visitFlags(node) {
      if (this._handlers.onFlagsEnter) {
        this._handlers.onFlagsEnter(node);
      }
      if (this._handlers.onFlagsLeave) {
        this._handlers.onFlagsLeave(node);
      }
    }
    visitGroup(node) {
      if (this._handlers.onGroupEnter) {
        this._handlers.onGroupEnter(node);
      }
      node.alternatives.forEach(this.visit, this);
      if (this._handlers.onGroupLeave) {
        this._handlers.onGroupLeave(node);
      }
    }
    visitPattern(node) {
      if (this._handlers.onPatternEnter) {
        this._handlers.onPatternEnter(node);
      }
      node.alternatives.forEach(this.visit, this);
      if (this._handlers.onPatternLeave) {
        this._handlers.onPatternLeave(node);
      }
    }
    visitQuantifier(node) {
      if (this._handlers.onQuantifierEnter) {
        this._handlers.onQuantifierEnter(node);
      }
      this.visit(node.element);
      if (this._handlers.onQuantifierLeave) {
        this._handlers.onQuantifierLeave(node);
      }
    }
    visitRegExpLiteral(node) {
      if (this._handlers.onRegExpLiteralEnter) {
        this._handlers.onRegExpLiteralEnter(node);
      }
      this.visitPattern(node.pattern);
      this.visitFlags(node.flags);
      if (this._handlers.onRegExpLiteralLeave) {
        this._handlers.onRegExpLiteralLeave(node);
      }
    }
  };
  function parseRegExpLiteral(source, options) {
    return new RegExpParser(options).parseLiteral(String(source));
  }
  function validateRegExpLiteral(source, options) {
    return new RegExpValidator(options).validateLiteral(source);
  }
  function visitRegExpAST(node, handlers) {
    new RegExpVisitor(handlers).visit(node);
  }
  exports2.AST = ast;
  exports2.RegExpParser = RegExpParser;
  exports2.RegExpValidator = RegExpValidator;
  exports2.parseRegExpLiteral = parseRegExpLiteral;
  exports2.validateRegExpLiteral = validateRegExpLiteral;
  exports2.visitRegExpAST = visitRegExpAST;
});

// node_modules/eslint/lib/rules/no-control-regex.js
var require_no_control_regex = __commonJS((exports2, module2) => {
  "use strict";
  var RegExpValidator = require_regexpp().RegExpValidator;
  var collector = new class {
    constructor() {
      this._source = "";
      this._controlChars = [];
      this._validator = new RegExpValidator(this);
    }
    onPatternEnter() {
      this._controlChars = [];
    }
    onCharacter(start, end, cp) {
      if (cp >= 0 && cp <= 31 && (this._source.codePointAt(start) === cp || this._source.slice(start, end).startsWith("\\x") || this._source.slice(start, end).startsWith("\\u"))) {
        this._controlChars.push(`\\x${`0${cp.toString(16)}`.slice(-2)}`);
      }
    }
    collectControlChars(regexpStr) {
      try {
        this._source = regexpStr;
        this._validator.validatePattern(regexpStr);
      } catch (e) {
      }
      return this._controlChars;
    }
  }();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow control characters in regular expressions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-control-regex"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected control character(s) in regular expression: {{controlChars}}."
      }
    },
    create(context4) {
      function getRegExpPattern(node) {
        if (node.regex) {
          return node.regex.pattern;
        }
        if (typeof node.value === "string" && (node.parent.type === "NewExpression" || node.parent.type === "CallExpression") && node.parent.callee.type === "Identifier" && node.parent.callee.name === "RegExp" && node.parent.arguments[0] === node) {
          return node.value;
        }
        return null;
      }
      return {
        Literal(node) {
          const pattern = getRegExpPattern(node);
          if (pattern) {
            const controlCharacters = collector.collectControlChars(pattern);
            if (controlCharacters.length > 0) {
              context4.report({
                node,
                messageId: "unexpected",
                data: {
                  controlChars: controlCharacters.join(", ")
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-debugger.js
var require_no_debugger = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow the use of `debugger`",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-debugger"
      },
      fixable: null,
      schema: [],
      messages: {
        unexpected: "Unexpected 'debugger' statement."
      }
    },
    create(context4) {
      return {
        DebuggerStatement(node) {
          context4.report({
            node,
            messageId: "unexpected"
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-delete-var.js
var require_no_delete_var = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow deleting variables",
        category: "Variables",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-delete-var"
      },
      schema: [],
      messages: {
        unexpected: "Variables should not be deleted."
      }
    },
    create(context4) {
      return {
        UnaryExpression(node) {
          if (node.operator === "delete" && node.argument.type === "Identifier") {
            context4.report({node, messageId: "unexpected"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-div-regex.js
var require_no_div_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow division operators explicitly at the beginning of regular expressions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-div-regex"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "A regular expression literal can be confused with '/='."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        Literal(node) {
          const token = sourceCode.getFirstToken(node);
          if (token.type === "RegularExpression" && token.value[1] === "=") {
            context4.report({
              node,
              messageId: "unexpected",
              fix(fixer) {
                return fixer.replaceTextRange([token.range[0] + 1, token.range[0] + 2], "[=]");
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-dupe-args.js
var require_no_dupe_args = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate arguments in `function` definitions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-dupe-args"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate param '{{name}}'."
      }
    },
    create(context4) {
      function isParameter(def) {
        return def.type === "Parameter";
      }
      function checkParams(node) {
        const variables = context4.getDeclaredVariables(node);
        for (let i = 0; i < variables.length; ++i) {
          const variable = variables[i];
          const defs = variable.defs.filter(isParameter);
          if (defs.length >= 2) {
            context4.report({
              node,
              messageId: "unexpected",
              data: {name: variable.name}
            });
          }
        }
      }
      return {
        FunctionDeclaration: checkParams,
        FunctionExpression: checkParams
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-dupe-class-members.js
var require_no_dupe_class_members = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate class members",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-dupe-class-members"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate name '{{name}}'."
      }
    },
    create(context4) {
      let stack = [];
      function getState(name, isStatic) {
        const stateMap = stack[stack.length - 1];
        const key = `$${name}`;
        if (!stateMap[key]) {
          stateMap[key] = {
            nonStatic: {init: false, get: false, set: false},
            static: {init: false, get: false, set: false}
          };
        }
        return stateMap[key][isStatic ? "static" : "nonStatic"];
      }
      return {
        Program() {
          stack = [];
        },
        ClassBody() {
          stack.push(Object.create(null));
        },
        "ClassBody:exit"() {
          stack.pop();
        },
        MethodDefinition(node) {
          const name = astUtils.getStaticPropertyName(node);
          if (name === null || node.kind === "constructor") {
            return;
          }
          const state = getState(name, node.static);
          let isDuplicate = false;
          if (node.kind === "get") {
            isDuplicate = state.init || state.get;
            state.get = true;
          } else if (node.kind === "set") {
            isDuplicate = state.init || state.set;
            state.set = true;
          } else {
            isDuplicate = state.init || state.get || state.set;
            state.init = true;
          }
          if (isDuplicate) {
            context4.report({node, messageId: "unexpected", data: {name}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-dupe-else-if.js
var require_no_dupe_else_if = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isSubsetByComparator(comparator, arrA, arrB) {
    return arrA.every((a) => arrB.some((b) => comparator(a, b)));
  }
  function splitByLogicalOperator(operator, node) {
    if (node.type === "LogicalExpression" && node.operator === operator) {
      return [...splitByLogicalOperator(operator, node.left), ...splitByLogicalOperator(operator, node.right)];
    }
    return [node];
  }
  var splitByOr = splitByLogicalOperator.bind(null, "||");
  var splitByAnd = splitByLogicalOperator.bind(null, "&&");
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate conditions in if-else-if chains",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-dupe-else-if"
      },
      schema: [],
      messages: {
        unexpected: "This branch can never execute. Its condition is a duplicate or covered by previous conditions in the if-else-if chain."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function equal(a, b) {
        if (a.type !== b.type) {
          return false;
        }
        if (a.type === "LogicalExpression" && (a.operator === "||" || a.operator === "&&") && a.operator === b.operator) {
          return equal(a.left, b.left) && equal(a.right, b.right) || equal(a.left, b.right) && equal(a.right, b.left);
        }
        return astUtils.equalTokens(a, b, sourceCode);
      }
      const isSubset = isSubsetByComparator.bind(null, equal);
      return {
        IfStatement(node) {
          const test = node.test, conditionsToCheck = test.type === "LogicalExpression" && test.operator === "&&" ? [test, ...splitByAnd(test)] : [test];
          let current = node, listToCheck = conditionsToCheck.map((c) => splitByOr(c).map(splitByAnd));
          while (current.parent && current.parent.type === "IfStatement" && current.parent.alternate === current) {
            current = current.parent;
            const currentOrOperands = splitByOr(current.test).map(splitByAnd);
            listToCheck = listToCheck.map((orOperands) => orOperands.filter((orOperand) => !currentOrOperands.some((currentOrOperand) => isSubset(currentOrOperand, orOperand))));
            if (listToCheck.some((orOperands) => orOperands.length === 0)) {
              context4.report({node: test, messageId: "unexpected"});
              break;
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-dupe-keys.js
var require_no_dupe_keys = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var GET_KIND = /^(?:init|get)$/u;
  var SET_KIND = /^(?:init|set)$/u;
  var ObjectInfo = class {
    constructor(upper, node) {
      this.upper = upper;
      this.node = node;
      this.properties = new Map();
    }
    getPropertyInfo(node) {
      const name = astUtils.getStaticPropertyName(node);
      if (!this.properties.has(name)) {
        this.properties.set(name, {get: false, set: false});
      }
      return this.properties.get(name);
    }
    isPropertyDefined(node) {
      const entry = this.getPropertyInfo(node);
      return GET_KIND.test(node.kind) && entry.get || SET_KIND.test(node.kind) && entry.set;
    }
    defineProperty(node) {
      const entry = this.getPropertyInfo(node);
      if (GET_KIND.test(node.kind)) {
        entry.get = true;
      }
      if (SET_KIND.test(node.kind)) {
        entry.set = true;
      }
    }
  };
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate keys in object literals",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-dupe-keys"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate key '{{name}}'."
      }
    },
    create(context4) {
      let info3 = null;
      return {
        ObjectExpression(node) {
          info3 = new ObjectInfo(info3, node);
        },
        "ObjectExpression:exit"() {
          info3 = info3.upper;
        },
        Property(node) {
          const name = astUtils.getStaticPropertyName(node);
          if (node.parent.type !== "ObjectExpression") {
            return;
          }
          if (name === null) {
            return;
          }
          if (info3.isPropertyDefined(node)) {
            context4.report({
              node: info3.node,
              loc: node.key.loc,
              messageId: "unexpected",
              data: {name}
            });
          }
          info3.defineProperty(node);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-duplicate-case.js
var require_no_duplicate_case = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate case labels",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-duplicate-case"
      },
      schema: [],
      messages: {
        unexpected: "Duplicate case label."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function equal(a, b) {
        if (a.type !== b.type) {
          return false;
        }
        return astUtils.equalTokens(a, b, sourceCode);
      }
      return {
        SwitchStatement(node) {
          const previousTests = [];
          for (const switchCase of node.cases) {
            if (switchCase.test) {
              const test = switchCase.test;
              if (previousTests.some((previousTest) => equal(previousTest, test))) {
                context4.report({node: switchCase, messageId: "unexpected"});
              } else {
                previousTests.push(test);
              }
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-duplicate-imports.js
var require_no_duplicate_imports = __commonJS((exports2, module2) => {
  "use strict";
  function getValue(node) {
    if (node && node.source && node.source.value) {
      return node.source.value.trim();
    }
    return "";
  }
  function checkAndReport(context4, node, value, array, messageId) {
    if (array.indexOf(value) !== -1) {
      context4.report({
        node,
        messageId,
        data: {
          module: value
        }
      });
    }
  }
  function handleImports(context4, includeExports, importsInFile, exportsInFile) {
    return function(node) {
      const value = getValue(node);
      if (value) {
        checkAndReport(context4, node, value, importsInFile, "import");
        if (includeExports) {
          checkAndReport(context4, node, value, exportsInFile, "importAs");
        }
        importsInFile.push(value);
      }
    };
  }
  function handleExports(context4, importsInFile, exportsInFile) {
    return function(node) {
      const value = getValue(node);
      if (value) {
        checkAndReport(context4, node, value, exportsInFile, "export");
        checkAndReport(context4, node, value, importsInFile, "exportAs");
        exportsInFile.push(value);
      }
    };
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow duplicate module imports",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-duplicate-imports"
      },
      schema: [{
        type: "object",
        properties: {
          includeExports: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      messages: {
        import: "'{{module}}' import is duplicated.",
        importAs: "'{{module}}' import is duplicated as export.",
        export: "'{{module}}' export is duplicated.",
        exportAs: "'{{module}}' export is duplicated as import."
      }
    },
    create(context4) {
      const includeExports = (context4.options[0] || {}).includeExports, importsInFile = [], exportsInFile = [];
      const handlers = {
        ImportDeclaration: handleImports(context4, includeExports, importsInFile, exportsInFile)
      };
      if (includeExports) {
        handlers.ExportNamedDeclaration = handleExports(context4, importsInFile, exportsInFile);
        handlers.ExportAllDeclaration = handleExports(context4, importsInFile, exportsInFile);
      }
      return handlers;
    }
  };
});

// node_modules/eslint/lib/rules/utils/fix-tracker.js
var require_fix_tracker = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var FixTracker = class {
    constructor(fixer, sourceCode) {
      this.fixer = fixer;
      this.sourceCode = sourceCode;
      this.retainedRange = null;
    }
    retainRange(range) {
      this.retainedRange = range;
      return this;
    }
    retainEnclosingFunction(node) {
      const functionNode = astUtils.getUpperFunction(node);
      return this.retainRange(functionNode ? functionNode.range : this.sourceCode.ast.range);
    }
    retainSurroundingTokens(nodeOrToken) {
      const tokenBefore = this.sourceCode.getTokenBefore(nodeOrToken) || nodeOrToken;
      const tokenAfter = this.sourceCode.getTokenAfter(nodeOrToken) || nodeOrToken;
      return this.retainRange([tokenBefore.range[0], tokenAfter.range[1]]);
    }
    replaceTextRange(range, text) {
      let actualRange;
      if (this.retainedRange) {
        actualRange = [
          Math.min(this.retainedRange[0], range[0]),
          Math.max(this.retainedRange[1], range[1])
        ];
      } else {
        actualRange = range;
      }
      return this.fixer.replaceTextRange(actualRange, this.sourceCode.text.slice(actualRange[0], range[0]) + text + this.sourceCode.text.slice(range[1], actualRange[1]));
    }
    remove(nodeOrToken) {
      return this.replaceTextRange(nodeOrToken.range, "");
    }
  };
  module2.exports = FixTracker;
});

// node_modules/eslint/lib/rules/no-else-return.js
var require_no_else_return = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var FixTracker = require_fix_tracker();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `else` blocks after `return` statements in `if` statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-else-return"
      },
      schema: [{
        type: "object",
        properties: {
          allowElseIf: {
            type: "boolean",
            default: true
          }
        },
        additionalProperties: false
      }],
      fixable: "code",
      messages: {
        unexpected: "Unnecessary 'else' after 'return'."
      }
    },
    create(context4) {
      function isSafeToDeclare(names, scope) {
        if (names.length === 0) {
          return true;
        }
        const functionScope = scope.variableScope;
        const declaredVariables = scope.variables.filter(({defs}) => defs.length > 0);
        if (declaredVariables.some(({name}) => names.includes(name))) {
          return false;
        }
        if (scope !== functionScope && scope.upper.type === "catch") {
          if (scope.upper.variables.some(({name}) => names.includes(name))) {
            return false;
          }
        }
        const usedImplicitVariables = scope.variables.filter(({defs, references}) => defs.length === 0 && references.length > 0);
        if (usedImplicitVariables.some(({name}) => names.includes(name))) {
          return false;
        }
        if (scope.through.some((t) => names.includes(t.identifier.name))) {
          return false;
        }
        if (scope !== functionScope) {
          const scopeNodeRange = scope.block.range;
          const variablesToCheck = functionScope.variables.filter(({name}) => names.includes(name));
          if (variablesToCheck.some((v) => v.defs.some(({node: {range}}) => scopeNodeRange[0] <= range[0] && range[1] <= scopeNodeRange[1]))) {
            return false;
          }
        }
        return true;
      }
      function isSafeFromNameCollisions(node, scope) {
        if (node.type === "FunctionDeclaration") {
          return false;
        }
        if (node.type !== "BlockStatement") {
          return true;
        }
        const elseBlockScope = scope.childScopes.find(({block}) => block === node);
        if (!elseBlockScope) {
          return true;
        }
        const namesToCheck = elseBlockScope.variables.map(({name}) => name);
        return isSafeToDeclare(namesToCheck, scope);
      }
      function displayReport(node) {
        const currentScope = context4.getScope();
        context4.report({
          node,
          messageId: "unexpected",
          fix: (fixer) => {
            if (!isSafeFromNameCollisions(node, currentScope)) {
              return null;
            }
            const sourceCode = context4.getSourceCode();
            const startToken = sourceCode.getFirstToken(node);
            const elseToken = sourceCode.getTokenBefore(startToken);
            const source = sourceCode.getText(node);
            const lastIfToken = sourceCode.getTokenBefore(elseToken);
            let fixedSource, firstTokenOfElseBlock;
            if (startToken.type === "Punctuator" && startToken.value === "{") {
              firstTokenOfElseBlock = sourceCode.getTokenAfter(startToken);
            } else {
              firstTokenOfElseBlock = startToken;
            }
            const ifBlockMaybeUnsafe = node.parent.consequent.type !== "BlockStatement" && lastIfToken.value !== ";";
            const elseBlockUnsafe = /^[([/+`-]/u.test(firstTokenOfElseBlock.value);
            if (ifBlockMaybeUnsafe && elseBlockUnsafe) {
              return null;
            }
            const endToken = sourceCode.getLastToken(node);
            const lastTokenOfElseBlock = sourceCode.getTokenBefore(endToken);
            if (lastTokenOfElseBlock.value !== ";") {
              const nextToken = sourceCode.getTokenAfter(endToken);
              const nextTokenUnsafe = nextToken && /^[([/+`-]/u.test(nextToken.value);
              const nextTokenOnSameLine = nextToken && nextToken.loc.start.line === lastTokenOfElseBlock.loc.start.line;
              if (nextTokenUnsafe || nextTokenOnSameLine && nextToken.value !== "}") {
                return null;
              }
            }
            if (startToken.type === "Punctuator" && startToken.value === "{") {
              fixedSource = source.slice(1, -1);
            } else {
              fixedSource = source;
            }
            return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).replaceTextRange([elseToken.range[0], node.range[1]], fixedSource);
          }
        });
      }
      function checkForReturn(node) {
        return node.type === "ReturnStatement";
      }
      function naiveHasReturn(node) {
        if (node.type === "BlockStatement") {
          const body = node.body, lastChildNode = body[body.length - 1];
          return lastChildNode && checkForReturn(lastChildNode);
        }
        return checkForReturn(node);
      }
      function hasElse(node) {
        return node.alternate && node.consequent;
      }
      function checkForIf(node) {
        return node.type === "IfStatement" && hasElse(node) && naiveHasReturn(node.alternate) && naiveHasReturn(node.consequent);
      }
      function checkForReturnOrIf(node) {
        return checkForReturn(node) || checkForIf(node);
      }
      function alwaysReturns(node) {
        if (node.type === "BlockStatement") {
          return node.body.some(checkForReturnOrIf);
        }
        return checkForReturnOrIf(node);
      }
      function checkIfWithoutElse(node) {
        const parent = node.parent;
        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }
        const consequents = [];
        let alternate;
        for (let currentNode = node; currentNode.type === "IfStatement"; currentNode = currentNode.alternate) {
          if (!currentNode.alternate) {
            return;
          }
          consequents.push(currentNode.consequent);
          alternate = currentNode.alternate;
        }
        if (consequents.every(alwaysReturns)) {
          displayReport(alternate);
        }
      }
      function checkIfWithElse(node) {
        const parent = node.parent;
        if (!astUtils.STATEMENT_LIST_PARENTS.has(parent.type)) {
          return;
        }
        const alternate = node.alternate;
        if (alternate && alwaysReturns(node.consequent)) {
          displayReport(alternate);
        }
      }
      const allowElseIf = !(context4.options[0] && context4.options[0].allowElseIf === false);
      return {
        "IfStatement:exit": allowElseIf ? checkIfWithoutElse : checkIfWithElse
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-empty.js
var require_no_empty = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow empty block statements",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-empty"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyCatch: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Empty {{type}} statement."
      }
    },
    create(context4) {
      const options = context4.options[0] || {}, allowEmptyCatch = options.allowEmptyCatch || false;
      const sourceCode = context4.getSourceCode();
      return {
        BlockStatement(node) {
          if (node.body.length !== 0) {
            return;
          }
          if (astUtils.isFunction(node.parent)) {
            return;
          }
          if (allowEmptyCatch && node.parent.type === "CatchClause") {
            return;
          }
          if (sourceCode.getCommentsInside(node).length > 0) {
            return;
          }
          context4.report({node, messageId: "unexpected", data: {type: "block"}});
        },
        SwitchStatement(node) {
          if (typeof node.cases === "undefined" || node.cases.length === 0) {
            context4.report({node, messageId: "unexpected", data: {type: "switch"}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-empty-character-class.js
var require_no_empty_character_class = __commonJS((exports2, module2) => {
  "use strict";
  var regex = /^\/([^\\[]|\\.|\[([^\\\]]|\\.)+\])*\/[gimuys]*$/u;
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow empty character classes in regular expressions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-empty-character-class"
      },
      schema: [],
      messages: {
        unexpected: "Empty class."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        Literal(node) {
          const token = sourceCode.getFirstToken(node);
          if (token.type === "RegularExpression" && !regex.test(token.value)) {
            context4.report({node, messageId: "unexpected"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-empty-function.js
var require_no_empty_function = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var ALLOW_OPTIONS = Object.freeze([
    "functions",
    "arrowFunctions",
    "generatorFunctions",
    "methods",
    "generatorMethods",
    "getters",
    "setters",
    "constructors",
    "asyncFunctions",
    "asyncMethods"
  ]);
  function getKind(node) {
    const parent = node.parent;
    let kind = "";
    if (node.type === "ArrowFunctionExpression") {
      return "arrowFunctions";
    }
    if (parent.type === "Property") {
      if (parent.kind === "get") {
        return "getters";
      }
      if (parent.kind === "set") {
        return "setters";
      }
      kind = parent.method ? "methods" : "functions";
    } else if (parent.type === "MethodDefinition") {
      if (parent.kind === "get") {
        return "getters";
      }
      if (parent.kind === "set") {
        return "setters";
      }
      if (parent.kind === "constructor") {
        return "constructors";
      }
      kind = "methods";
    } else {
      kind = "functions";
    }
    let prefix = "";
    if (node.generator) {
      prefix = "generator";
    } else if (node.async) {
      prefix = "async";
    } else {
      return kind;
    }
    return prefix + kind[0].toUpperCase() + kind.slice(1);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow empty functions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-empty-function"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {enum: ALLOW_OPTIONS},
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "Unexpected empty {{name}}."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const allowed = options.allow || [];
      const sourceCode = context4.getSourceCode();
      function reportIfEmpty(node) {
        const kind = getKind(node);
        const name = astUtils.getFunctionNameWithKind(node);
        const innerComments = sourceCode.getTokens(node.body, {
          includeComments: true,
          filter: astUtils.isCommentToken
        });
        if (allowed.indexOf(kind) === -1 && node.body.type === "BlockStatement" && node.body.body.length === 0 && innerComments.length === 0) {
          context4.report({
            node,
            loc: node.body.loc,
            messageId: "unexpected",
            data: {name}
          });
        }
      }
      return {
        ArrowFunctionExpression: reportIfEmpty,
        FunctionDeclaration: reportIfEmpty,
        FunctionExpression: reportIfEmpty
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-empty-pattern.js
var require_no_empty_pattern = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow empty destructuring patterns",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-empty-pattern"
      },
      schema: [],
      messages: {
        unexpected: "Unexpected empty {{type}} pattern."
      }
    },
    create(context4) {
      return {
        ObjectPattern(node) {
          if (node.properties.length === 0) {
            context4.report({node, messageId: "unexpected", data: {type: "object"}});
          }
        },
        ArrayPattern(node) {
          if (node.elements.length === 0) {
            context4.report({node, messageId: "unexpected", data: {type: "array"}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-eq-null.js
var require_no_eq_null = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `null` comparisons without type-checking operators",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-eq-null"
      },
      schema: [],
      messages: {
        unexpected: "Use '===' to compare with null."
      }
    },
    create(context4) {
      return {
        BinaryExpression(node) {
          const badOperator = node.operator === "==" || node.operator === "!=";
          if (node.right.type === "Literal" && node.right.raw === "null" && badOperator || node.left.type === "Literal" && node.left.raw === "null" && badOperator) {
            context4.report({node, messageId: "unexpected"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-eval.js
var require_no_eval = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var candidatesOfGlobalObject = Object.freeze([
    "global",
    "window",
    "globalThis"
  ]);
  function isMember(node, name) {
    return astUtils.isSpecificMemberAccess(node, null, name);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `eval()`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-eval"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowIndirect: {type: "boolean", default: false}
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "eval can be harmful."
      }
    },
    create(context4) {
      const allowIndirect = Boolean(context4.options[0] && context4.options[0].allowIndirect);
      const sourceCode = context4.getSourceCode();
      let funcInfo = null;
      function enterVarScope(node) {
        const strict = context4.getScope().isStrict;
        funcInfo = {
          upper: funcInfo,
          node,
          strict,
          defaultThis: false,
          initialized: strict
        };
      }
      function exitVarScope() {
        funcInfo = funcInfo.upper;
      }
      function report(node) {
        const parent = node.parent;
        const locationNode = node.type === "MemberExpression" ? node.property : node;
        const reportNode = parent.type === "CallExpression" && parent.callee === node ? parent : node;
        context4.report({
          node: reportNode,
          loc: locationNode.loc,
          messageId: "unexpected"
        });
      }
      function reportAccessingEvalViaGlobalObject(globalScope) {
        for (let i = 0; i < candidatesOfGlobalObject.length; ++i) {
          const name = candidatesOfGlobalObject[i];
          const variable = astUtils.getVariableByName(globalScope, name);
          if (!variable) {
            continue;
          }
          const references = variable.references;
          for (let j = 0; j < references.length; ++j) {
            const identifier = references[j].identifier;
            let node = identifier.parent;
            while (isMember(node, name)) {
              node = node.parent;
            }
            if (isMember(node, "eval")) {
              report(node);
            }
          }
        }
      }
      function reportAccessingEval(globalScope) {
        const variable = astUtils.getVariableByName(globalScope, "eval");
        if (!variable) {
          return;
        }
        const references = variable.references;
        for (let i = 0; i < references.length; ++i) {
          const reference = references[i];
          const id = reference.identifier;
          if (id.name === "eval" && !astUtils.isCallee(id)) {
            report(id);
          }
        }
      }
      if (allowIndirect) {
        return {
          "CallExpression:exit"(node) {
            const callee = node.callee;
            if (!node.optional && astUtils.isSpecificId(callee, "eval")) {
              report(callee);
            }
          }
        };
      }
      return {
        "CallExpression:exit"(node) {
          const callee = node.callee;
          if (astUtils.isSpecificId(callee, "eval")) {
            report(callee);
          }
        },
        Program(node) {
          const scope = context4.getScope(), features = context4.parserOptions.ecmaFeatures || {}, strict = scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict;
          funcInfo = {
            upper: null,
            node,
            strict,
            defaultThis: true,
            initialized: true
          };
        },
        "Program:exit"() {
          const globalScope = context4.getScope();
          exitVarScope();
          reportAccessingEval(globalScope);
          reportAccessingEvalViaGlobalObject(globalScope);
        },
        FunctionDeclaration: enterVarScope,
        "FunctionDeclaration:exit": exitVarScope,
        FunctionExpression: enterVarScope,
        "FunctionExpression:exit": exitVarScope,
        ArrowFunctionExpression: enterVarScope,
        "ArrowFunctionExpression:exit": exitVarScope,
        ThisExpression(node) {
          if (!isMember(node.parent, "eval")) {
            return;
          }
          if (!funcInfo.initialized) {
            funcInfo.initialized = true;
            funcInfo.defaultThis = astUtils.isDefaultThisBinding(funcInfo.node, sourceCode);
          }
          if (!funcInfo.strict && funcInfo.defaultThis) {
            report(node.parent);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-ex-assign.js
var require_no_ex_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow reassigning exceptions in `catch` clauses",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-ex-assign"
      },
      schema: [],
      messages: {
        unexpected: "Do not assign to the exception parameter."
      }
    },
    create(context4) {
      function checkVariable(variable) {
        astUtils.getModifyingReferences(variable.references).forEach((reference) => {
          context4.report({node: reference.identifier, messageId: "unexpected"});
        });
      }
      return {
        CatchClause(node) {
          context4.getDeclaredVariables(node).forEach(checkVariable);
        }
      };
    }
  };
});

// node_modules/eslint/node_modules/globals/globals.json
var require_globals3 = __commonJS((exports2, module2) => {
  module2.exports = {
    builtin: {
      AggregateError: false,
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      FinalizationRegistry: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      globalThis: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakRef: false,
      WeakSet: false
    },
    es5: {
      Array: false,
      Boolean: false,
      constructor: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      propertyIsEnumerable: false,
      RangeError: false,
      ReferenceError: false,
      RegExp: false,
      String: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false
    },
    es2015: {
      Array: false,
      ArrayBuffer: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es2017: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es2020: {
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      globalThis: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakSet: false
    },
    es2021: {
      AggregateError: false,
      Array: false,
      ArrayBuffer: false,
      Atomics: false,
      BigInt: false,
      BigInt64Array: false,
      BigUint64Array: false,
      Boolean: false,
      constructor: false,
      DataView: false,
      Date: false,
      decodeURI: false,
      decodeURIComponent: false,
      encodeURI: false,
      encodeURIComponent: false,
      Error: false,
      escape: false,
      eval: false,
      EvalError: false,
      FinalizationRegistry: false,
      Float32Array: false,
      Float64Array: false,
      Function: false,
      globalThis: false,
      hasOwnProperty: false,
      Infinity: false,
      Int16Array: false,
      Int32Array: false,
      Int8Array: false,
      isFinite: false,
      isNaN: false,
      isPrototypeOf: false,
      JSON: false,
      Map: false,
      Math: false,
      NaN: false,
      Number: false,
      Object: false,
      parseFloat: false,
      parseInt: false,
      Promise: false,
      propertyIsEnumerable: false,
      Proxy: false,
      RangeError: false,
      ReferenceError: false,
      Reflect: false,
      RegExp: false,
      Set: false,
      SharedArrayBuffer: false,
      String: false,
      Symbol: false,
      SyntaxError: false,
      toLocaleString: false,
      toString: false,
      TypeError: false,
      Uint16Array: false,
      Uint32Array: false,
      Uint8Array: false,
      Uint8ClampedArray: false,
      undefined: false,
      unescape: false,
      URIError: false,
      valueOf: false,
      WeakMap: false,
      WeakRef: false,
      WeakSet: false
    },
    browser: {
      AbortController: false,
      AbortSignal: false,
      addEventListener: false,
      alert: false,
      AnalyserNode: false,
      Animation: false,
      AnimationEffectReadOnly: false,
      AnimationEffectTiming: false,
      AnimationEffectTimingReadOnly: false,
      AnimationEvent: false,
      AnimationPlaybackEvent: false,
      AnimationTimeline: false,
      applicationCache: false,
      ApplicationCache: false,
      ApplicationCacheErrorEvent: false,
      atob: false,
      Attr: false,
      Audio: false,
      AudioBuffer: false,
      AudioBufferSourceNode: false,
      AudioContext: false,
      AudioDestinationNode: false,
      AudioListener: false,
      AudioNode: false,
      AudioParam: false,
      AudioProcessingEvent: false,
      AudioScheduledSourceNode: false,
      "AudioWorkletGlobalScope ": false,
      AudioWorkletNode: false,
      AudioWorkletProcessor: false,
      BarProp: false,
      BaseAudioContext: false,
      BatteryManager: false,
      BeforeUnloadEvent: false,
      BiquadFilterNode: false,
      Blob: false,
      BlobEvent: false,
      blur: false,
      BroadcastChannel: false,
      btoa: false,
      BudgetService: false,
      ByteLengthQueuingStrategy: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      cancelAnimationFrame: false,
      cancelIdleCallback: false,
      CanvasCaptureMediaStreamTrack: false,
      CanvasGradient: false,
      CanvasPattern: false,
      CanvasRenderingContext2D: false,
      ChannelMergerNode: false,
      ChannelSplitterNode: false,
      CharacterData: false,
      clearInterval: false,
      clearTimeout: false,
      clientInformation: false,
      ClipboardEvent: false,
      close: false,
      closed: false,
      CloseEvent: false,
      Comment: false,
      CompositionEvent: false,
      confirm: false,
      console: false,
      ConstantSourceNode: false,
      ConvolverNode: false,
      CountQueuingStrategy: false,
      createImageBitmap: false,
      Credential: false,
      CredentialsContainer: false,
      crypto: false,
      Crypto: false,
      CryptoKey: false,
      CSS: false,
      CSSConditionRule: false,
      CSSFontFaceRule: false,
      CSSGroupingRule: false,
      CSSImportRule: false,
      CSSKeyframeRule: false,
      CSSKeyframesRule: false,
      CSSMediaRule: false,
      CSSNamespaceRule: false,
      CSSPageRule: false,
      CSSRule: false,
      CSSRuleList: false,
      CSSStyleDeclaration: false,
      CSSStyleRule: false,
      CSSStyleSheet: false,
      CSSSupportsRule: false,
      CustomElementRegistry: false,
      customElements: false,
      CustomEvent: false,
      DataTransfer: false,
      DataTransferItem: false,
      DataTransferItemList: false,
      defaultstatus: false,
      defaultStatus: false,
      DelayNode: false,
      DeviceMotionEvent: false,
      DeviceOrientationEvent: false,
      devicePixelRatio: false,
      dispatchEvent: false,
      document: false,
      Document: false,
      DocumentFragment: false,
      DocumentType: false,
      DOMError: false,
      DOMException: false,
      DOMImplementation: false,
      DOMMatrix: false,
      DOMMatrixReadOnly: false,
      DOMParser: false,
      DOMPoint: false,
      DOMPointReadOnly: false,
      DOMQuad: false,
      DOMRect: false,
      DOMRectReadOnly: false,
      DOMStringList: false,
      DOMStringMap: false,
      DOMTokenList: false,
      DragEvent: false,
      DynamicsCompressorNode: false,
      Element: false,
      ErrorEvent: false,
      event: false,
      Event: false,
      EventSource: false,
      EventTarget: false,
      external: false,
      fetch: false,
      File: false,
      FileList: false,
      FileReader: false,
      find: false,
      focus: false,
      FocusEvent: false,
      FontFace: false,
      FontFaceSetLoadEvent: false,
      FormData: false,
      frameElement: false,
      frames: false,
      GainNode: false,
      Gamepad: false,
      GamepadButton: false,
      GamepadEvent: false,
      getComputedStyle: false,
      getSelection: false,
      HashChangeEvent: false,
      Headers: false,
      history: false,
      History: false,
      HTMLAllCollection: false,
      HTMLAnchorElement: false,
      HTMLAreaElement: false,
      HTMLAudioElement: false,
      HTMLBaseElement: false,
      HTMLBodyElement: false,
      HTMLBRElement: false,
      HTMLButtonElement: false,
      HTMLCanvasElement: false,
      HTMLCollection: false,
      HTMLContentElement: false,
      HTMLDataElement: false,
      HTMLDataListElement: false,
      HTMLDetailsElement: false,
      HTMLDialogElement: false,
      HTMLDirectoryElement: false,
      HTMLDivElement: false,
      HTMLDListElement: false,
      HTMLDocument: false,
      HTMLElement: false,
      HTMLEmbedElement: false,
      HTMLFieldSetElement: false,
      HTMLFontElement: false,
      HTMLFormControlsCollection: false,
      HTMLFormElement: false,
      HTMLFrameElement: false,
      HTMLFrameSetElement: false,
      HTMLHeadElement: false,
      HTMLHeadingElement: false,
      HTMLHRElement: false,
      HTMLHtmlElement: false,
      HTMLIFrameElement: false,
      HTMLImageElement: false,
      HTMLInputElement: false,
      HTMLLabelElement: false,
      HTMLLegendElement: false,
      HTMLLIElement: false,
      HTMLLinkElement: false,
      HTMLMapElement: false,
      HTMLMarqueeElement: false,
      HTMLMediaElement: false,
      HTMLMenuElement: false,
      HTMLMetaElement: false,
      HTMLMeterElement: false,
      HTMLModElement: false,
      HTMLObjectElement: false,
      HTMLOListElement: false,
      HTMLOptGroupElement: false,
      HTMLOptionElement: false,
      HTMLOptionsCollection: false,
      HTMLOutputElement: false,
      HTMLParagraphElement: false,
      HTMLParamElement: false,
      HTMLPictureElement: false,
      HTMLPreElement: false,
      HTMLProgressElement: false,
      HTMLQuoteElement: false,
      HTMLScriptElement: false,
      HTMLSelectElement: false,
      HTMLShadowElement: false,
      HTMLSlotElement: false,
      HTMLSourceElement: false,
      HTMLSpanElement: false,
      HTMLStyleElement: false,
      HTMLTableCaptionElement: false,
      HTMLTableCellElement: false,
      HTMLTableColElement: false,
      HTMLTableElement: false,
      HTMLTableRowElement: false,
      HTMLTableSectionElement: false,
      HTMLTemplateElement: false,
      HTMLTextAreaElement: false,
      HTMLTimeElement: false,
      HTMLTitleElement: false,
      HTMLTrackElement: false,
      HTMLUListElement: false,
      HTMLUnknownElement: false,
      HTMLVideoElement: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      IdleDeadline: false,
      IIRFilterNode: false,
      Image: false,
      ImageBitmap: false,
      ImageBitmapRenderingContext: false,
      ImageCapture: false,
      ImageData: false,
      indexedDB: false,
      innerHeight: false,
      innerWidth: false,
      InputEvent: false,
      IntersectionObserver: false,
      IntersectionObserverEntry: false,
      Intl: false,
      isSecureContext: false,
      KeyboardEvent: false,
      KeyframeEffect: false,
      KeyframeEffectReadOnly: false,
      length: false,
      localStorage: false,
      location: true,
      Location: false,
      locationbar: false,
      matchMedia: false,
      MediaDeviceInfo: false,
      MediaDevices: false,
      MediaElementAudioSourceNode: false,
      MediaEncryptedEvent: false,
      MediaError: false,
      MediaKeyMessageEvent: false,
      MediaKeySession: false,
      MediaKeyStatusMap: false,
      MediaKeySystemAccess: false,
      MediaList: false,
      MediaQueryList: false,
      MediaQueryListEvent: false,
      MediaRecorder: false,
      MediaSettingsRange: false,
      MediaSource: false,
      MediaStream: false,
      MediaStreamAudioDestinationNode: false,
      MediaStreamAudioSourceNode: false,
      MediaStreamEvent: false,
      MediaStreamTrack: false,
      MediaStreamTrackEvent: false,
      menubar: false,
      MessageChannel: false,
      MessageEvent: false,
      MessagePort: false,
      MIDIAccess: false,
      MIDIConnectionEvent: false,
      MIDIInput: false,
      MIDIInputMap: false,
      MIDIMessageEvent: false,
      MIDIOutput: false,
      MIDIOutputMap: false,
      MIDIPort: false,
      MimeType: false,
      MimeTypeArray: false,
      MouseEvent: false,
      moveBy: false,
      moveTo: false,
      MutationEvent: false,
      MutationObserver: false,
      MutationRecord: false,
      name: false,
      NamedNodeMap: false,
      NavigationPreloadManager: false,
      navigator: false,
      Navigator: false,
      NetworkInformation: false,
      Node: false,
      NodeFilter: false,
      NodeIterator: false,
      NodeList: false,
      Notification: false,
      OfflineAudioCompletionEvent: false,
      OfflineAudioContext: false,
      offscreenBuffering: false,
      OffscreenCanvas: true,
      OffscreenCanvasRenderingContext2D: false,
      onabort: true,
      onafterprint: true,
      onanimationend: true,
      onanimationiteration: true,
      onanimationstart: true,
      onappinstalled: true,
      onauxclick: true,
      onbeforeinstallprompt: true,
      onbeforeprint: true,
      onbeforeunload: true,
      onblur: true,
      oncancel: true,
      oncanplay: true,
      oncanplaythrough: true,
      onchange: true,
      onclick: true,
      onclose: true,
      oncontextmenu: true,
      oncuechange: true,
      ondblclick: true,
      ondevicemotion: true,
      ondeviceorientation: true,
      ondeviceorientationabsolute: true,
      ondrag: true,
      ondragend: true,
      ondragenter: true,
      ondragleave: true,
      ondragover: true,
      ondragstart: true,
      ondrop: true,
      ondurationchange: true,
      onemptied: true,
      onended: true,
      onerror: true,
      onfocus: true,
      ongotpointercapture: true,
      onhashchange: true,
      oninput: true,
      oninvalid: true,
      onkeydown: true,
      onkeypress: true,
      onkeyup: true,
      onlanguagechange: true,
      onload: true,
      onloadeddata: true,
      onloadedmetadata: true,
      onloadstart: true,
      onlostpointercapture: true,
      onmessage: true,
      onmessageerror: true,
      onmousedown: true,
      onmouseenter: true,
      onmouseleave: true,
      onmousemove: true,
      onmouseout: true,
      onmouseover: true,
      onmouseup: true,
      onmousewheel: true,
      onoffline: true,
      ononline: true,
      onpagehide: true,
      onpageshow: true,
      onpause: true,
      onplay: true,
      onplaying: true,
      onpointercancel: true,
      onpointerdown: true,
      onpointerenter: true,
      onpointerleave: true,
      onpointermove: true,
      onpointerout: true,
      onpointerover: true,
      onpointerup: true,
      onpopstate: true,
      onprogress: true,
      onratechange: true,
      onrejectionhandled: true,
      onreset: true,
      onresize: true,
      onscroll: true,
      onsearch: true,
      onseeked: true,
      onseeking: true,
      onselect: true,
      onstalled: true,
      onstorage: true,
      onsubmit: true,
      onsuspend: true,
      ontimeupdate: true,
      ontoggle: true,
      ontransitionend: true,
      onunhandledrejection: true,
      onunload: true,
      onvolumechange: true,
      onwaiting: true,
      onwheel: true,
      open: false,
      openDatabase: false,
      opener: false,
      Option: false,
      origin: false,
      OscillatorNode: false,
      outerHeight: false,
      outerWidth: false,
      PageTransitionEvent: false,
      pageXOffset: false,
      pageYOffset: false,
      PannerNode: false,
      parent: false,
      Path2D: false,
      PaymentAddress: false,
      PaymentRequest: false,
      PaymentRequestUpdateEvent: false,
      PaymentResponse: false,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceLongTaskTiming: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceNavigationTiming: false,
      PerformanceObserver: false,
      PerformanceObserverEntryList: false,
      PerformancePaintTiming: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      PeriodicWave: false,
      Permissions: false,
      PermissionStatus: false,
      personalbar: false,
      PhotoCapabilities: false,
      Plugin: false,
      PluginArray: false,
      PointerEvent: false,
      PopStateEvent: false,
      postMessage: false,
      Presentation: false,
      PresentationAvailability: false,
      PresentationConnection: false,
      PresentationConnectionAvailableEvent: false,
      PresentationConnectionCloseEvent: false,
      PresentationConnectionList: false,
      PresentationReceiver: false,
      PresentationRequest: false,
      print: false,
      ProcessingInstruction: false,
      ProgressEvent: false,
      PromiseRejectionEvent: false,
      prompt: false,
      PushManager: false,
      PushSubscription: false,
      PushSubscriptionOptions: false,
      queueMicrotask: false,
      RadioNodeList: false,
      Range: false,
      ReadableStream: false,
      registerProcessor: false,
      RemotePlayback: false,
      removeEventListener: false,
      Request: false,
      requestAnimationFrame: false,
      requestIdleCallback: false,
      resizeBy: false,
      ResizeObserver: false,
      ResizeObserverEntry: false,
      resizeTo: false,
      Response: false,
      RTCCertificate: false,
      RTCDataChannel: false,
      RTCDataChannelEvent: false,
      RTCDtlsTransport: false,
      RTCIceCandidate: false,
      RTCIceGatherer: false,
      RTCIceTransport: false,
      RTCPeerConnection: false,
      RTCPeerConnectionIceEvent: false,
      RTCRtpContributingSource: false,
      RTCRtpReceiver: false,
      RTCRtpSender: false,
      RTCSctpTransport: false,
      RTCSessionDescription: false,
      RTCStatsReport: false,
      RTCTrackEvent: false,
      screen: false,
      Screen: false,
      screenLeft: false,
      ScreenOrientation: false,
      screenTop: false,
      screenX: false,
      screenY: false,
      ScriptProcessorNode: false,
      scroll: false,
      scrollbars: false,
      scrollBy: false,
      scrollTo: false,
      scrollX: false,
      scrollY: false,
      SecurityPolicyViolationEvent: false,
      Selection: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerRegistration: false,
      sessionStorage: false,
      setInterval: false,
      setTimeout: false,
      ShadowRoot: false,
      SharedWorker: false,
      SourceBuffer: false,
      SourceBufferList: false,
      speechSynthesis: false,
      SpeechSynthesisEvent: false,
      SpeechSynthesisUtterance: false,
      StaticRange: false,
      status: false,
      statusbar: false,
      StereoPannerNode: false,
      stop: false,
      Storage: false,
      StorageEvent: false,
      StorageManager: false,
      styleMedia: false,
      StyleSheet: false,
      StyleSheetList: false,
      SubtleCrypto: false,
      SVGAElement: false,
      SVGAngle: false,
      SVGAnimatedAngle: false,
      SVGAnimatedBoolean: false,
      SVGAnimatedEnumeration: false,
      SVGAnimatedInteger: false,
      SVGAnimatedLength: false,
      SVGAnimatedLengthList: false,
      SVGAnimatedNumber: false,
      SVGAnimatedNumberList: false,
      SVGAnimatedPreserveAspectRatio: false,
      SVGAnimatedRect: false,
      SVGAnimatedString: false,
      SVGAnimatedTransformList: false,
      SVGAnimateElement: false,
      SVGAnimateMotionElement: false,
      SVGAnimateTransformElement: false,
      SVGAnimationElement: false,
      SVGCircleElement: false,
      SVGClipPathElement: false,
      SVGComponentTransferFunctionElement: false,
      SVGDefsElement: false,
      SVGDescElement: false,
      SVGDiscardElement: false,
      SVGElement: false,
      SVGEllipseElement: false,
      SVGFEBlendElement: false,
      SVGFEColorMatrixElement: false,
      SVGFEComponentTransferElement: false,
      SVGFECompositeElement: false,
      SVGFEConvolveMatrixElement: false,
      SVGFEDiffuseLightingElement: false,
      SVGFEDisplacementMapElement: false,
      SVGFEDistantLightElement: false,
      SVGFEDropShadowElement: false,
      SVGFEFloodElement: false,
      SVGFEFuncAElement: false,
      SVGFEFuncBElement: false,
      SVGFEFuncGElement: false,
      SVGFEFuncRElement: false,
      SVGFEGaussianBlurElement: false,
      SVGFEImageElement: false,
      SVGFEMergeElement: false,
      SVGFEMergeNodeElement: false,
      SVGFEMorphologyElement: false,
      SVGFEOffsetElement: false,
      SVGFEPointLightElement: false,
      SVGFESpecularLightingElement: false,
      SVGFESpotLightElement: false,
      SVGFETileElement: false,
      SVGFETurbulenceElement: false,
      SVGFilterElement: false,
      SVGForeignObjectElement: false,
      SVGGElement: false,
      SVGGeometryElement: false,
      SVGGradientElement: false,
      SVGGraphicsElement: false,
      SVGImageElement: false,
      SVGLength: false,
      SVGLengthList: false,
      SVGLinearGradientElement: false,
      SVGLineElement: false,
      SVGMarkerElement: false,
      SVGMaskElement: false,
      SVGMatrix: false,
      SVGMetadataElement: false,
      SVGMPathElement: false,
      SVGNumber: false,
      SVGNumberList: false,
      SVGPathElement: false,
      SVGPatternElement: false,
      SVGPoint: false,
      SVGPointList: false,
      SVGPolygonElement: false,
      SVGPolylineElement: false,
      SVGPreserveAspectRatio: false,
      SVGRadialGradientElement: false,
      SVGRect: false,
      SVGRectElement: false,
      SVGScriptElement: false,
      SVGSetElement: false,
      SVGStopElement: false,
      SVGStringList: false,
      SVGStyleElement: false,
      SVGSVGElement: false,
      SVGSwitchElement: false,
      SVGSymbolElement: false,
      SVGTextContentElement: false,
      SVGTextElement: false,
      SVGTextPathElement: false,
      SVGTextPositioningElement: false,
      SVGTitleElement: false,
      SVGTransform: false,
      SVGTransformList: false,
      SVGTSpanElement: false,
      SVGUnitTypes: false,
      SVGUseElement: false,
      SVGViewElement: false,
      TaskAttributionTiming: false,
      Text: false,
      TextDecoder: false,
      TextEncoder: false,
      TextEvent: false,
      TextMetrics: false,
      TextTrack: false,
      TextTrackCue: false,
      TextTrackCueList: false,
      TextTrackList: false,
      TimeRanges: false,
      toolbar: false,
      top: false,
      Touch: false,
      TouchEvent: false,
      TouchList: false,
      TrackEvent: false,
      TransitionEvent: false,
      TreeWalker: false,
      UIEvent: false,
      URL: false,
      URLSearchParams: false,
      ValidityState: false,
      visualViewport: false,
      VisualViewport: false,
      VTTCue: false,
      WaveShaperNode: false,
      WebAssembly: false,
      WebGL2RenderingContext: false,
      WebGLActiveInfo: false,
      WebGLBuffer: false,
      WebGLContextEvent: false,
      WebGLFramebuffer: false,
      WebGLProgram: false,
      WebGLQuery: false,
      WebGLRenderbuffer: false,
      WebGLRenderingContext: false,
      WebGLSampler: false,
      WebGLShader: false,
      WebGLShaderPrecisionFormat: false,
      WebGLSync: false,
      WebGLTexture: false,
      WebGLTransformFeedback: false,
      WebGLUniformLocation: false,
      WebGLVertexArrayObject: false,
      WebSocket: false,
      WheelEvent: false,
      window: false,
      Window: false,
      Worker: false,
      WritableStream: false,
      XMLDocument: false,
      XMLHttpRequest: false,
      XMLHttpRequestEventTarget: false,
      XMLHttpRequestUpload: false,
      XMLSerializer: false,
      XPathEvaluator: false,
      XPathExpression: false,
      XPathResult: false,
      XSLTProcessor: false
    },
    worker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      clearInterval: false,
      clearTimeout: false,
      close: true,
      console: false,
      fetch: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: true,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onlanguagechange: true,
      onmessage: true,
      onoffline: true,
      ononline: true,
      onrejectionhandled: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: true,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    node: {
      __dirname: false,
      __filename: false,
      AbortController: false,
      Buffer: false,
      clearImmediate: false,
      clearInterval: false,
      clearTimeout: false,
      console: false,
      exports: true,
      global: false,
      Intl: false,
      module: false,
      process: false,
      queueMicrotask: false,
      require: false,
      setImmediate: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false
    },
    nodeBuiltin: {
      AbortController: false,
      Buffer: false,
      clearImmediate: false,
      clearInterval: false,
      clearTimeout: false,
      console: false,
      global: false,
      Intl: false,
      process: false,
      queueMicrotask: false,
      setImmediate: false,
      setInterval: false,
      setTimeout: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false
    },
    commonjs: {
      exports: true,
      global: false,
      module: false,
      require: false
    },
    amd: {
      define: false,
      require: false
    },
    mocha: {
      after: false,
      afterEach: false,
      before: false,
      beforeEach: false,
      context: false,
      describe: false,
      it: false,
      mocha: false,
      run: false,
      setup: false,
      specify: false,
      suite: false,
      suiteSetup: false,
      suiteTeardown: false,
      teardown: false,
      test: false,
      xcontext: false,
      xdescribe: false,
      xit: false,
      xspecify: false
    },
    jasmine: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      expectAsync: false,
      fail: false,
      fdescribe: false,
      fit: false,
      it: false,
      jasmine: false,
      pending: false,
      runs: false,
      spyOn: false,
      spyOnAllFunctions: false,
      spyOnProperty: false,
      waits: false,
      waitsFor: false,
      xdescribe: false,
      xit: false
    },
    jest: {
      afterAll: false,
      afterEach: false,
      beforeAll: false,
      beforeEach: false,
      describe: false,
      expect: false,
      fdescribe: false,
      fit: false,
      it: false,
      jest: false,
      pit: false,
      require: false,
      test: false,
      xdescribe: false,
      xit: false,
      xtest: false
    },
    qunit: {
      asyncTest: false,
      deepEqual: false,
      equal: false,
      expect: false,
      module: false,
      notDeepEqual: false,
      notEqual: false,
      notOk: false,
      notPropEqual: false,
      notStrictEqual: false,
      ok: false,
      propEqual: false,
      QUnit: false,
      raises: false,
      start: false,
      stop: false,
      strictEqual: false,
      test: false,
      throws: false
    },
    phantomjs: {
      console: true,
      exports: true,
      phantom: true,
      require: true,
      WebPage: true
    },
    couch: {
      emit: false,
      exports: false,
      getRow: false,
      log: false,
      module: false,
      provides: false,
      require: false,
      respond: false,
      send: false,
      start: false,
      sum: false
    },
    rhino: {
      defineClass: false,
      deserialize: false,
      gc: false,
      help: false,
      importClass: false,
      importPackage: false,
      java: false,
      load: false,
      loadClass: false,
      Packages: false,
      print: false,
      quit: false,
      readFile: false,
      readUrl: false,
      runCommand: false,
      seal: false,
      serialize: false,
      spawn: false,
      sync: false,
      toint32: false,
      version: false
    },
    nashorn: {
      __DIR__: false,
      __FILE__: false,
      __LINE__: false,
      com: false,
      edu: false,
      exit: false,
      java: false,
      Java: false,
      javafx: false,
      JavaImporter: false,
      javax: false,
      JSAdapter: false,
      load: false,
      loadWithNewGlobal: false,
      org: false,
      Packages: false,
      print: false,
      quit: false
    },
    wsh: {
      ActiveXObject: false,
      CollectGarbage: false,
      Debug: false,
      Enumerator: false,
      GetObject: false,
      RuntimeObject: false,
      ScriptEngine: false,
      ScriptEngineBuildVersion: false,
      ScriptEngineMajorVersion: false,
      ScriptEngineMinorVersion: false,
      VBArray: false,
      WScript: false,
      WSH: false
    },
    jquery: {
      $: false,
      jQuery: false
    },
    yui: {
      YAHOO: false,
      YAHOO_config: false,
      YUI: false,
      YUI_config: false
    },
    shelljs: {
      cat: false,
      cd: false,
      chmod: false,
      config: false,
      cp: false,
      dirs: false,
      echo: false,
      env: false,
      error: false,
      exec: false,
      exit: false,
      find: false,
      grep: false,
      ln: false,
      ls: false,
      mkdir: false,
      mv: false,
      popd: false,
      pushd: false,
      pwd: false,
      rm: false,
      sed: false,
      set: false,
      target: false,
      tempdir: false,
      test: false,
      touch: false,
      which: false
    },
    prototypejs: {
      $: false,
      $$: false,
      $A: false,
      $break: false,
      $continue: false,
      $F: false,
      $H: false,
      $R: false,
      $w: false,
      Abstract: false,
      Ajax: false,
      Autocompleter: false,
      Builder: false,
      Class: false,
      Control: false,
      Draggable: false,
      Draggables: false,
      Droppables: false,
      Effect: false,
      Element: false,
      Enumerable: false,
      Event: false,
      Field: false,
      Form: false,
      Hash: false,
      Insertion: false,
      ObjectRange: false,
      PeriodicalExecuter: false,
      Position: false,
      Prototype: false,
      Scriptaculous: false,
      Selector: false,
      Sortable: false,
      SortableObserver: false,
      Sound: false,
      Template: false,
      Toggle: false,
      Try: false
    },
    meteor: {
      $: false,
      Accounts: false,
      AccountsClient: false,
      AccountsCommon: false,
      AccountsServer: false,
      App: false,
      Assets: false,
      Blaze: false,
      check: false,
      Cordova: false,
      DDP: false,
      DDPRateLimiter: false,
      DDPServer: false,
      Deps: false,
      EJSON: false,
      Email: false,
      HTTP: false,
      Log: false,
      Match: false,
      Meteor: false,
      Mongo: false,
      MongoInternals: false,
      Npm: false,
      Package: false,
      Plugin: false,
      process: false,
      Random: false,
      ReactiveDict: false,
      ReactiveVar: false,
      Router: false,
      ServiceConfiguration: false,
      Session: false,
      share: false,
      Spacebars: false,
      Template: false,
      Tinytest: false,
      Tracker: false,
      UI: false,
      Utils: false,
      WebApp: false,
      WebAppInternals: false
    },
    mongo: {
      _isWindows: false,
      _rand: false,
      BulkWriteResult: false,
      cat: false,
      cd: false,
      connect: false,
      db: false,
      getHostName: false,
      getMemInfo: false,
      hostname: false,
      ISODate: false,
      listFiles: false,
      load: false,
      ls: false,
      md5sumFile: false,
      mkdir: false,
      Mongo: false,
      NumberInt: false,
      NumberLong: false,
      ObjectId: false,
      PlanCache: false,
      print: false,
      printjson: false,
      pwd: false,
      quit: false,
      removeFile: false,
      rs: false,
      sh: false,
      UUID: false,
      version: false,
      WriteResult: false
    },
    applescript: {
      $: false,
      Application: false,
      Automation: false,
      console: false,
      delay: false,
      Library: false,
      ObjC: false,
      ObjectSpecifier: false,
      Path: false,
      Progress: false,
      Ref: false
    },
    serviceworker: {
      addEventListener: false,
      applicationCache: false,
      atob: false,
      Blob: false,
      BroadcastChannel: false,
      btoa: false,
      Cache: false,
      caches: false,
      CacheStorage: false,
      clearInterval: false,
      clearTimeout: false,
      Client: false,
      clients: false,
      Clients: false,
      close: true,
      console: false,
      ExtendableEvent: false,
      ExtendableMessageEvent: false,
      fetch: false,
      FetchEvent: false,
      FileReaderSync: false,
      FormData: false,
      Headers: false,
      IDBCursor: false,
      IDBCursorWithValue: false,
      IDBDatabase: false,
      IDBFactory: false,
      IDBIndex: false,
      IDBKeyRange: false,
      IDBObjectStore: false,
      IDBOpenDBRequest: false,
      IDBRequest: false,
      IDBTransaction: false,
      IDBVersionChangeEvent: false,
      ImageData: false,
      importScripts: false,
      indexedDB: false,
      location: false,
      MessageChannel: false,
      MessagePort: false,
      name: false,
      navigator: false,
      Notification: false,
      onclose: true,
      onconnect: true,
      onerror: true,
      onfetch: true,
      oninstall: true,
      onlanguagechange: true,
      onmessage: true,
      onmessageerror: true,
      onnotificationclick: true,
      onnotificationclose: true,
      onoffline: true,
      ononline: true,
      onpush: true,
      onpushsubscriptionchange: true,
      onrejectionhandled: true,
      onsync: true,
      onunhandledrejection: true,
      performance: false,
      Performance: false,
      PerformanceEntry: false,
      PerformanceMark: false,
      PerformanceMeasure: false,
      PerformanceNavigation: false,
      PerformanceResourceTiming: false,
      PerformanceTiming: false,
      postMessage: true,
      Promise: false,
      queueMicrotask: false,
      registration: false,
      removeEventListener: false,
      Request: false,
      Response: false,
      self: false,
      ServiceWorker: false,
      ServiceWorkerContainer: false,
      ServiceWorkerGlobalScope: false,
      ServiceWorkerMessageEvent: false,
      ServiceWorkerRegistration: false,
      setInterval: false,
      setTimeout: false,
      skipWaiting: false,
      TextDecoder: false,
      TextEncoder: false,
      URL: false,
      URLSearchParams: false,
      WebSocket: false,
      WindowClient: false,
      Worker: false,
      WorkerGlobalScope: false,
      XMLHttpRequest: false
    },
    atomtest: {
      advanceClock: false,
      atom: false,
      fakeClearInterval: false,
      fakeClearTimeout: false,
      fakeSetInterval: false,
      fakeSetTimeout: false,
      resetTimeouts: false,
      waitsForPromise: false
    },
    embertest: {
      andThen: false,
      click: false,
      currentPath: false,
      currentRouteName: false,
      currentURL: false,
      fillIn: false,
      find: false,
      findAll: false,
      findWithAssert: false,
      keyEvent: false,
      pauseTest: false,
      resumeTest: false,
      triggerEvent: false,
      visit: false,
      wait: false
    },
    protractor: {
      $: false,
      $$: false,
      browser: false,
      by: false,
      By: false,
      DartObject: false,
      element: false,
      protractor: false
    },
    "shared-node-browser": {
      clearInterval: false,
      clearTimeout: false,
      console: false,
      setInterval: false,
      setTimeout: false,
      URL: false,
      URLSearchParams: false
    },
    webextensions: {
      browser: false,
      chrome: false,
      opr: false
    },
    greasemonkey: {
      cloneInto: false,
      createObjectIn: false,
      exportFunction: false,
      GM: false,
      GM_addStyle: false,
      GM_addValueChangeListener: false,
      GM_deleteValue: false,
      GM_download: false,
      GM_getResourceText: false,
      GM_getResourceURL: false,
      GM_getTab: false,
      GM_getTabs: false,
      GM_getValue: false,
      GM_info: false,
      GM_listValues: false,
      GM_log: false,
      GM_notification: false,
      GM_openInTab: false,
      GM_registerMenuCommand: false,
      GM_removeValueChangeListener: false,
      GM_saveTab: false,
      GM_setClipboard: false,
      GM_setValue: false,
      GM_unregisterMenuCommand: false,
      GM_xmlhttpRequest: false,
      unsafeWindow: false
    },
    devtools: {
      $: false,
      $_: false,
      $$: false,
      $0: false,
      $1: false,
      $2: false,
      $3: false,
      $4: false,
      $x: false,
      chrome: false,
      clear: false,
      copy: false,
      debug: false,
      dir: false,
      dirxml: false,
      getEventListeners: false,
      inspect: false,
      keys: false,
      monitor: false,
      monitorEvents: false,
      profile: false,
      profileEnd: false,
      queryObjects: false,
      table: false,
      undebug: false,
      unmonitor: false,
      unmonitorEvents: false,
      values: false
    }
  };
});

// node_modules/eslint/node_modules/globals/index.js
var require_globals4 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_globals3();
});

// node_modules/eslint/lib/rules/no-extend-native.js
var require_no_extend_native = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var globals = require_globals4();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow extending native types",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-extend-native"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpected: "{{builtin}} prototype is read only, properties should not be added."
      }
    },
    create(context4) {
      const config = context4.options[0] || {};
      const exceptions = new Set(config.exceptions || []);
      const modifiedBuiltins = new Set(Object.keys(globals.builtin).filter((builtin) => builtin[0].toUpperCase() === builtin[0]).filter((builtin) => !exceptions.has(builtin)));
      function reportNode(node, builtin) {
        context4.report({
          node,
          messageId: "unexpected",
          data: {
            builtin
          }
        });
      }
      function isPrototypePropertyAccessed(identifierNode) {
        return Boolean(identifierNode && identifierNode.parent && identifierNode.parent.type === "MemberExpression" && identifierNode.parent.object === identifierNode && astUtils.getStaticPropertyName(identifierNode.parent) === "prototype");
      }
      function isAssigningToPropertyOf(node) {
        return node.parent.type === "MemberExpression" && node.parent.object === node && node.parent.parent.type === "AssignmentExpression" && node.parent.parent.left === node.parent;
      }
      function isInDefinePropertyCall(node) {
        return node.parent.type === "CallExpression" && node.parent.arguments[0] === node && astUtils.isSpecificMemberAccess(node.parent.callee, "Object", /^definePropert(?:y|ies)$/u);
      }
      function checkAndReportPrototypeExtension(identifierNode) {
        if (!isPrototypePropertyAccessed(identifierNode)) {
          return;
        }
        const prototypeNode = identifierNode.parent.parent.type === "ChainExpression" ? identifierNode.parent.parent : identifierNode.parent;
        if (isAssigningToPropertyOf(prototypeNode)) {
          reportNode(prototypeNode.parent.parent, identifierNode.name);
        } else if (isInDefinePropertyCall(prototypeNode)) {
          reportNode(prototypeNode.parent, identifierNode.name);
        }
      }
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          modifiedBuiltins.forEach((builtin) => {
            const builtinVar = globalScope.set.get(builtin);
            if (builtinVar && builtinVar.references) {
              builtinVar.references.map((ref) => ref.identifier).forEach(checkAndReportPrototypeExtension);
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-extra-bind.js
var require_no_extra_bind = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var SIDE_EFFECT_FREE_NODE_TYPES = new Set(["Literal", "Identifier", "ThisExpression", "FunctionExpression"]);
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary calls to `.bind()`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-extra-bind"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "The function binding is unnecessary."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let scopeInfo = null;
      function isSideEffectFree(node) {
        return SIDE_EFFECT_FREE_NODE_TYPES.has(node.type);
      }
      function report(node) {
        const memberNode = node.parent;
        const callNode = memberNode.parent.type === "ChainExpression" ? memberNode.parent.parent : memberNode.parent;
        context4.report({
          node: callNode,
          messageId: "unexpected",
          loc: memberNode.property.loc,
          fix(fixer) {
            if (!isSideEffectFree(callNode.arguments[0])) {
              return null;
            }
            const tokenPairs = [
              [
                sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken),
                sourceCode.getLastToken(memberNode)
              ],
              [
                sourceCode.getTokenAfter(memberNode, astUtils.isNotClosingParenToken),
                sourceCode.getLastToken(callNode)
              ]
            ];
            const firstTokenToRemove = tokenPairs[0][0];
            const lastTokenToRemove = tokenPairs[1][1];
            if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
              return null;
            }
            return tokenPairs.map(([start, end]) => fixer.removeRange([start.range[0], end.range[1]]));
          }
        });
      }
      function isCalleeOfBindMethod(node) {
        if (!astUtils.isSpecificMemberAccess(node.parent, null, "bind")) {
          return false;
        }
        const bindNode = node.parent.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
        return bindNode.parent.type === "CallExpression" && bindNode.parent.callee === bindNode && bindNode.parent.arguments.length === 1 && bindNode.parent.arguments[0].type !== "SpreadElement";
      }
      function enterFunction(node) {
        scopeInfo = {
          isBound: isCalleeOfBindMethod(node),
          thisFound: false,
          upper: scopeInfo
        };
      }
      function exitFunction(node) {
        if (scopeInfo.isBound && !scopeInfo.thisFound) {
          report(node);
        }
        scopeInfo = scopeInfo.upper;
      }
      function exitArrowFunction(node) {
        if (isCalleeOfBindMethod(node)) {
          report(node);
        }
      }
      function markAsThisFound() {
        if (scopeInfo) {
          scopeInfo.thisFound = true;
        }
      }
      return {
        "ArrowFunctionExpression:exit": exitArrowFunction,
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        ThisExpression: markAsThisFound
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-extra-boolean-cast.js
var require_no_extra_boolean_cast = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var eslintUtils = require_eslint_utils();
  var precedence = astUtils.getPrecedence;
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary boolean casts",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-extra-boolean-cast"
      },
      schema: [{
        type: "object",
        properties: {
          enforceForLogicalOperands: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      fixable: "code",
      messages: {
        unexpectedCall: "Redundant Boolean call.",
        unexpectedNegation: "Redundant double negation."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const BOOLEAN_NODE_TYPES = [
        "IfStatement",
        "DoWhileStatement",
        "WhileStatement",
        "ConditionalExpression",
        "ForStatement"
      ];
      function isBooleanFunctionOrConstructorCall(node) {
        return (node.type === "CallExpression" || node.type === "NewExpression") && node.callee.type === "Identifier" && node.callee.name === "Boolean";
      }
      function isLogicalContext(node) {
        return node.type === "LogicalExpression" && (node.operator === "||" || node.operator === "&&") && (context4.options.length && context4.options[0].enforceForLogicalOperands === true);
      }
      function isInBooleanContext(node) {
        return isBooleanFunctionOrConstructorCall(node.parent) && node === node.parent.arguments[0] || BOOLEAN_NODE_TYPES.indexOf(node.parent.type) !== -1 && node === node.parent.test || node.parent.type === "UnaryExpression" && node.parent.operator === "!";
      }
      function isInFlaggedContext(node) {
        if (node.parent.type === "ChainExpression") {
          return isInFlaggedContext(node.parent);
        }
        return isInBooleanContext(node) || isLogicalContext(node.parent) && isInFlaggedContext(node.parent);
      }
      function hasCommentsInside(node) {
        return Boolean(sourceCode.getCommentsInside(node).length);
      }
      function isParenthesized(node) {
        return eslintUtils.isParenthesized(1, node, sourceCode);
      }
      function needsParens(previousNode, node) {
        if (previousNode.parent.type === "ChainExpression") {
          return needsParens(previousNode.parent, node);
        }
        if (isParenthesized(previousNode)) {
          return false;
        }
        const parent = previousNode.parent;
        switch (parent.type) {
          case "CallExpression":
          case "NewExpression":
            return node.type === "SequenceExpression";
          case "IfStatement":
          case "DoWhileStatement":
          case "WhileStatement":
          case "ForStatement":
            return false;
          case "ConditionalExpression":
            return precedence(node) <= precedence(parent);
          case "UnaryExpression":
            return precedence(node) < precedence(parent);
          case "LogicalExpression":
            if (astUtils.isMixedLogicalAndCoalesceExpressions(node, parent)) {
              return true;
            }
            if (previousNode === parent.left) {
              return precedence(node) < precedence(parent);
            }
            return precedence(node) <= precedence(parent);
          default:
            throw new Error(`Unexpected parent type: ${parent.type}`);
        }
      }
      return {
        UnaryExpression(node) {
          const parent = node.parent;
          if (node.operator !== "!" || parent.type !== "UnaryExpression" || parent.operator !== "!") {
            return;
          }
          if (isInFlaggedContext(parent)) {
            context4.report({
              node: parent,
              messageId: "unexpectedNegation",
              fix(fixer) {
                if (hasCommentsInside(parent)) {
                  return null;
                }
                if (needsParens(parent, node.argument)) {
                  return fixer.replaceText(parent, `(${sourceCode.getText(node.argument)})`);
                }
                let prefix = "";
                const tokenBefore = sourceCode.getTokenBefore(parent);
                const firstReplacementToken = sourceCode.getFirstToken(node.argument);
                if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                  prefix = " ";
                }
                return fixer.replaceText(parent, prefix + sourceCode.getText(node.argument));
              }
            });
          }
        },
        CallExpression(node) {
          if (node.callee.type !== "Identifier" || node.callee.name !== "Boolean") {
            return;
          }
          if (isInFlaggedContext(node)) {
            context4.report({
              node,
              messageId: "unexpectedCall",
              fix(fixer) {
                const parent = node.parent;
                if (node.arguments.length === 0) {
                  if (parent.type === "UnaryExpression" && parent.operator === "!") {
                    if (hasCommentsInside(parent)) {
                      return null;
                    }
                    const replacement = "true";
                    let prefix = "";
                    const tokenBefore = sourceCode.getTokenBefore(parent);
                    if (tokenBefore && tokenBefore.range[1] === parent.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                      prefix = " ";
                    }
                    return fixer.replaceText(parent, prefix + replacement);
                  }
                  if (hasCommentsInside(node)) {
                    return null;
                  }
                  return fixer.replaceText(node, "false");
                }
                if (node.arguments.length === 1) {
                  const argument = node.arguments[0];
                  if (argument.type === "SpreadElement" || hasCommentsInside(node)) {
                    return null;
                  }
                  if (needsParens(node, argument)) {
                    return fixer.replaceText(node, `(${sourceCode.getText(argument)})`);
                  }
                  return fixer.replaceText(node, sourceCode.getText(argument));
                }
                return null;
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-extra-label.js
var require_no_extra_label = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary labels",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-extra-label"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpected: "This label '{{name}}' is unnecessary."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let scopeInfo = null;
      function enterBreakableStatement(node) {
        scopeInfo = {
          label: node.parent.type === "LabeledStatement" ? node.parent.label : null,
          breakable: true,
          upper: scopeInfo
        };
      }
      function exitBreakableStatement() {
        scopeInfo = scopeInfo.upper;
      }
      function enterLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
          scopeInfo = {
            label: node.label,
            breakable: false,
            upper: scopeInfo
          };
        }
      }
      function exitLabeledStatement(node) {
        if (!astUtils.isBreakableStatement(node.body)) {
          scopeInfo = scopeInfo.upper;
        }
      }
      function reportIfUnnecessary(node) {
        if (!node.label) {
          return;
        }
        const labelNode = node.label;
        for (let info3 = scopeInfo; info3 !== null; info3 = info3.upper) {
          if (info3.breakable || info3.label && info3.label.name === labelNode.name) {
            if (info3.breakable && info3.label && info3.label.name === labelNode.name) {
              context4.report({
                node: labelNode,
                messageId: "unexpected",
                data: labelNode,
                fix(fixer) {
                  const breakOrContinueToken = sourceCode.getFirstToken(node);
                  if (sourceCode.commentsExistBetween(breakOrContinueToken, labelNode)) {
                    return null;
                  }
                  return fixer.removeRange([breakOrContinueToken.range[1], labelNode.range[1]]);
                }
              });
            }
            return;
          }
        }
      }
      return {
        WhileStatement: enterBreakableStatement,
        "WhileStatement:exit": exitBreakableStatement,
        DoWhileStatement: enterBreakableStatement,
        "DoWhileStatement:exit": exitBreakableStatement,
        ForStatement: enterBreakableStatement,
        "ForStatement:exit": exitBreakableStatement,
        ForInStatement: enterBreakableStatement,
        "ForInStatement:exit": exitBreakableStatement,
        ForOfStatement: enterBreakableStatement,
        "ForOfStatement:exit": exitBreakableStatement,
        SwitchStatement: enterBreakableStatement,
        "SwitchStatement:exit": exitBreakableStatement,
        LabeledStatement: enterLabeledStatement,
        "LabeledStatement:exit": exitLabeledStatement,
        BreakStatement: reportIfUnnecessary,
        ContinueStatement: reportIfUnnecessary
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-extra-parens.js
var require_no_extra_parens = __commonJS((exports2, module2) => {
  "use strict";
  var {isParenthesized: isParenthesizedRaw} = require_eslint_utils();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow unnecessary parentheses",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-extra-parens"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["functions"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["all"]
              },
              {
                type: "object",
                properties: {
                  conditionalAssign: {type: "boolean"},
                  nestedBinaryExpressions: {type: "boolean"},
                  returnAssign: {type: "boolean"},
                  ignoreJSX: {enum: ["none", "all", "single-line", "multi-line"]},
                  enforceForArrowConditionals: {type: "boolean"},
                  enforceForSequenceExpressions: {type: "boolean"},
                  enforceForNewInMemberExpressions: {type: "boolean"},
                  enforceForFunctionPrototypeMethods: {type: "boolean"}
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        unexpected: "Unnecessary parentheses around expression."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const tokensToIgnore = new WeakSet();
      const precedence = astUtils.getPrecedence;
      const ALL_NODES = context4.options[0] !== "functions";
      const EXCEPT_COND_ASSIGN = ALL_NODES && context4.options[1] && context4.options[1].conditionalAssign === false;
      const NESTED_BINARY = ALL_NODES && context4.options[1] && context4.options[1].nestedBinaryExpressions === false;
      const EXCEPT_RETURN_ASSIGN = ALL_NODES && context4.options[1] && context4.options[1].returnAssign === false;
      const IGNORE_JSX = ALL_NODES && context4.options[1] && context4.options[1].ignoreJSX;
      const IGNORE_ARROW_CONDITIONALS = ALL_NODES && context4.options[1] && context4.options[1].enforceForArrowConditionals === false;
      const IGNORE_SEQUENCE_EXPRESSIONS = ALL_NODES && context4.options[1] && context4.options[1].enforceForSequenceExpressions === false;
      const IGNORE_NEW_IN_MEMBER_EXPR = ALL_NODES && context4.options[1] && context4.options[1].enforceForNewInMemberExpressions === false;
      const IGNORE_FUNCTION_PROTOTYPE_METHODS = ALL_NODES && context4.options[1] && context4.options[1].enforceForFunctionPrototypeMethods === false;
      const PRECEDENCE_OF_ASSIGNMENT_EXPR = precedence({type: "AssignmentExpression"});
      const PRECEDENCE_OF_UPDATE_EXPR = precedence({type: "UpdateExpression"});
      let reportsBuffer;
      function isImmediateFunctionPrototypeMethodCall(node) {
        const callNode = astUtils.skipChainExpression(node);
        if (callNode.type !== "CallExpression") {
          return false;
        }
        const callee = astUtils.skipChainExpression(callNode.callee);
        return callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && ["call", "apply"].includes(astUtils.getStaticPropertyName(callee));
      }
      function ruleApplies(node) {
        if (node.type === "JSXElement" || node.type === "JSXFragment") {
          const isSingleLine = node.loc.start.line === node.loc.end.line;
          switch (IGNORE_JSX) {
            case "all":
              return false;
            case "multi-line":
              return isSingleLine;
            case "single-line":
              return !isSingleLine;
            case "none":
              break;
          }
        }
        if (node.type === "SequenceExpression" && IGNORE_SEQUENCE_EXPRESSIONS) {
          return false;
        }
        if (isImmediateFunctionPrototypeMethodCall(node) && IGNORE_FUNCTION_PROTOTYPE_METHODS) {
          return false;
        }
        return ALL_NODES || node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
      }
      function isParenthesised(node) {
        return isParenthesizedRaw(1, node, sourceCode);
      }
      function isParenthesisedTwice(node) {
        return isParenthesizedRaw(2, node, sourceCode);
      }
      function hasExcessParens(node) {
        return ruleApplies(node) && isParenthesised(node);
      }
      function hasDoubleExcessParens(node) {
        return ruleApplies(node) && isParenthesisedTwice(node);
      }
      function hasExcessParensWithPrecedence(node, precedenceLowerLimit) {
        if (ruleApplies(node) && isParenthesised(node)) {
          if (precedence(node) >= precedenceLowerLimit || isParenthesisedTwice(node)) {
            return true;
          }
        }
        return false;
      }
      function isCondAssignException(node) {
        return EXCEPT_COND_ASSIGN && node.test.type === "AssignmentExpression";
      }
      function isInReturnStatement(node) {
        for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
          if (currentNode.type === "ReturnStatement" || currentNode.type === "ArrowFunctionExpression" && currentNode.body.type !== "BlockStatement") {
            return true;
          }
        }
        return false;
      }
      function isNewExpressionWithParens(newExpression) {
        const lastToken = sourceCode.getLastToken(newExpression);
        const penultimateToken = sourceCode.getTokenBefore(lastToken);
        return newExpression.arguments.length > 0 || astUtils.isOpeningParenToken(penultimateToken) && astUtils.isClosingParenToken(lastToken) && newExpression.callee.range[1] < newExpression.range[1];
      }
      function containsAssignment(node) {
        if (node.type === "AssignmentExpression") {
          return true;
        }
        if (node.type === "ConditionalExpression" && (node.consequent.type === "AssignmentExpression" || node.alternate.type === "AssignmentExpression")) {
          return true;
        }
        if (node.left && node.left.type === "AssignmentExpression" || node.right && node.right.type === "AssignmentExpression") {
          return true;
        }
        return false;
      }
      function isReturnAssignException(node) {
        if (!EXCEPT_RETURN_ASSIGN || !isInReturnStatement(node)) {
          return false;
        }
        if (node.type === "ReturnStatement") {
          return node.argument && containsAssignment(node.argument);
        }
        if (node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement") {
          return containsAssignment(node.body);
        }
        return containsAssignment(node);
      }
      function hasExcessParensNoLineTerminator(token, node) {
        if (token.loc.end.line === node.loc.start.line) {
          return hasExcessParens(node);
        }
        return hasDoubleExcessParens(node);
      }
      function requiresLeadingSpace(node) {
        const leftParenToken = sourceCode.getTokenBefore(node);
        const tokenBeforeLeftParen = sourceCode.getTokenBefore(leftParenToken, {includeComments: true});
        const tokenAfterLeftParen = sourceCode.getTokenAfter(leftParenToken, {includeComments: true});
        return tokenBeforeLeftParen && tokenBeforeLeftParen.range[1] === leftParenToken.range[0] && leftParenToken.range[1] === tokenAfterLeftParen.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftParen, tokenAfterLeftParen);
      }
      function requiresTrailingSpace(node) {
        const nextTwoTokens = sourceCode.getTokensAfter(node, {count: 2});
        const rightParenToken = nextTwoTokens[0];
        const tokenAfterRightParen = nextTwoTokens[1];
        const tokenBeforeRightParen = sourceCode.getLastToken(node);
        return rightParenToken && tokenAfterRightParen && !sourceCode.isSpaceBetweenTokens(rightParenToken, tokenAfterRightParen) && !astUtils.canTokensBeAdjacent(tokenBeforeRightParen, tokenAfterRightParen);
      }
      function isIIFE(node) {
        const maybeCallNode = astUtils.skipChainExpression(node);
        return maybeCallNode.type === "CallExpression" && maybeCallNode.callee.type === "FunctionExpression";
      }
      function canBeAssignmentTarget(node) {
        return node && (node.type === "Identifier" || node.type === "MemberExpression");
      }
      function report(node) {
        const leftParenToken = sourceCode.getTokenBefore(node);
        const rightParenToken = sourceCode.getTokenAfter(node);
        if (!isParenthesisedTwice(node)) {
          if (tokensToIgnore.has(sourceCode.getFirstToken(node))) {
            return;
          }
          if (isIIFE(node) && !isParenthesised(node.callee)) {
            return;
          }
        }
        function finishReport() {
          context4.report({
            node,
            loc: leftParenToken.loc,
            messageId: "unexpected",
            fix(fixer) {
              const parenthesizedSource = sourceCode.text.slice(leftParenToken.range[1], rightParenToken.range[0]);
              return fixer.replaceTextRange([
                leftParenToken.range[0],
                rightParenToken.range[1]
              ], (requiresLeadingSpace(node) ? " " : "") + parenthesizedSource + (requiresTrailingSpace(node) ? " " : ""));
            }
          });
        }
        if (reportsBuffer) {
          reportsBuffer.reports.push({node, finishReport});
          return;
        }
        finishReport();
      }
      function checkArgumentWithPrecedence(node) {
        if (hasExcessParensWithPrecedence(node.argument, precedence(node))) {
          report(node.argument);
        }
      }
      function doesMemberExpressionContainCallExpression(node) {
        let currentNode = node.object;
        let currentNodeType = node.object.type;
        while (currentNodeType === "MemberExpression") {
          currentNode = currentNode.object;
          currentNodeType = currentNode.type;
        }
        return currentNodeType === "CallExpression";
      }
      function checkCallNew(node) {
        const callee = node.callee;
        if (hasExcessParensWithPrecedence(callee, precedence(node))) {
          if (hasDoubleExcessParens(callee) || !(isIIFE(node) || callee.type === "NewExpression" && !isNewExpressionWithParens(callee) && !(node.type === "NewExpression" && !isNewExpressionWithParens(node)) || node.type === "NewExpression" && callee.type === "MemberExpression" && doesMemberExpressionContainCallExpression(callee) || !node.optional && callee.type === "ChainExpression")) {
            report(node.callee);
          }
        }
        node.arguments.filter((arg) => hasExcessParensWithPrecedence(arg, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
      }
      function checkBinaryLogical(node) {
        const prec = precedence(node);
        const leftPrecedence = precedence(node.left);
        const rightPrecedence = precedence(node.right);
        const isExponentiation = node.operator === "**";
        const shouldSkipLeft = NESTED_BINARY && (node.left.type === "BinaryExpression" || node.left.type === "LogicalExpression");
        const shouldSkipRight = NESTED_BINARY && (node.right.type === "BinaryExpression" || node.right.type === "LogicalExpression");
        if (!shouldSkipLeft && hasExcessParens(node.left)) {
          if (!(["AwaitExpression", "UnaryExpression"].includes(node.left.type) && isExponentiation) && !astUtils.isMixedLogicalAndCoalesceExpressions(node.left, node) && (leftPrecedence > prec || leftPrecedence === prec && !isExponentiation) || isParenthesisedTwice(node.left)) {
            report(node.left);
          }
        }
        if (!shouldSkipRight && hasExcessParens(node.right)) {
          if (!astUtils.isMixedLogicalAndCoalesceExpressions(node.right, node) && (rightPrecedence > prec || rightPrecedence === prec && isExponentiation) || isParenthesisedTwice(node.right)) {
            report(node.right);
          }
        }
      }
      function checkClass(node) {
        if (!node.superClass) {
          return;
        }
        const hasExtraParens = precedence(node.superClass) > PRECEDENCE_OF_UPDATE_EXPR ? hasExcessParens(node.superClass) : hasDoubleExcessParens(node.superClass);
        if (hasExtraParens) {
          report(node.superClass);
        }
      }
      function checkSpreadOperator(node) {
        if (hasExcessParensWithPrecedence(node.argument, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
          report(node.argument);
        }
      }
      function checkExpressionOrExportStatement(node) {
        const firstToken = isParenthesised(node) ? sourceCode.getTokenBefore(node) : sourceCode.getFirstToken(node);
        const secondToken = sourceCode.getTokenAfter(firstToken, astUtils.isNotOpeningParenToken);
        const thirdToken = secondToken ? sourceCode.getTokenAfter(secondToken) : null;
        const tokenAfterClosingParens = secondToken ? sourceCode.getTokenAfter(secondToken, astUtils.isNotClosingParenToken) : null;
        if (astUtils.isOpeningParenToken(firstToken) && (astUtils.isOpeningBraceToken(secondToken) || secondToken.type === "Keyword" && (secondToken.value === "function" || secondToken.value === "class" || secondToken.value === "let" && tokenAfterClosingParens && (astUtils.isOpeningBracketToken(tokenAfterClosingParens) || tokenAfterClosingParens.type === "Identifier")) || secondToken && secondToken.type === "Identifier" && secondToken.value === "async" && thirdToken && thirdToken.type === "Keyword" && thirdToken.value === "function")) {
          tokensToIgnore.add(secondToken);
        }
        const hasExtraParens = node.parent.type === "ExportDefaultDeclaration" ? hasExcessParensWithPrecedence(node, PRECEDENCE_OF_ASSIGNMENT_EXPR) : hasExcessParens(node);
        if (hasExtraParens) {
          report(node);
        }
      }
      function pathToAncestor(node, ancestor) {
        const path3 = [node];
        let currentNode = node;
        while (currentNode !== ancestor) {
          currentNode = currentNode.parent;
          if (currentNode === null) {
            throw new Error("Nodes are not in the ancestor-descendant relationship.");
          }
          path3.push(currentNode);
        }
        return path3;
      }
      function pathToDescendant(node, descendant) {
        return pathToAncestor(descendant, node).reverse();
      }
      function isSafelyEnclosingInExpression(node, child) {
        switch (node.type) {
          case "ArrayExpression":
          case "ArrayPattern":
          case "BlockStatement":
          case "ObjectExpression":
          case "ObjectPattern":
          case "TemplateLiteral":
            return true;
          case "ArrowFunctionExpression":
          case "FunctionExpression":
            return node.params.includes(child);
          case "CallExpression":
          case "NewExpression":
            return node.arguments.includes(child);
          case "MemberExpression":
            return node.computed && node.property === child;
          case "ConditionalExpression":
            return node.consequent === child;
          default:
            return false;
        }
      }
      function startNewReportsBuffering() {
        reportsBuffer = {
          upper: reportsBuffer,
          inExpressionNodes: [],
          reports: []
        };
      }
      function endCurrentReportsBuffering() {
        const {upper, inExpressionNodes, reports} = reportsBuffer;
        if (upper) {
          upper.inExpressionNodes.push(...inExpressionNodes);
          upper.reports.push(...reports);
        } else {
          reports.forEach(({finishReport}) => finishReport());
        }
        reportsBuffer = upper;
      }
      function isInCurrentReportsBuffer(node) {
        return reportsBuffer.reports.some((r) => r.node === node);
      }
      function removeFromCurrentReportsBuffer(node) {
        reportsBuffer.reports = reportsBuffer.reports.filter((r) => r.node !== node);
      }
      function isMemberExpInNewCallee(node) {
        if (node.type === "MemberExpression") {
          return node.parent.type === "NewExpression" && node.parent.callee === node ? true : node.parent.object === node && isMemberExpInNewCallee(node.parent);
        }
        return false;
      }
      return {
        ArrayExpression(node) {
          node.elements.filter((e) => e && hasExcessParensWithPrecedence(e, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach(report);
        },
        ArrayPattern(node) {
          node.elements.filter((e) => canBeAssignmentTarget(e) && hasExcessParens(e)).forEach(report);
        },
        ArrowFunctionExpression(node) {
          if (isReturnAssignException(node)) {
            return;
          }
          if (node.body.type === "ConditionalExpression" && IGNORE_ARROW_CONDITIONALS) {
            return;
          }
          if (node.body.type !== "BlockStatement") {
            const firstBodyToken = sourceCode.getFirstToken(node.body, astUtils.isNotOpeningParenToken);
            const tokenBeforeFirst = sourceCode.getTokenBefore(firstBodyToken);
            if (astUtils.isOpeningParenToken(tokenBeforeFirst) && astUtils.isOpeningBraceToken(firstBodyToken)) {
              tokensToIgnore.add(firstBodyToken);
            }
            if (hasExcessParensWithPrecedence(node.body, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(node.body);
            }
          }
        },
        AssignmentExpression(node) {
          if (canBeAssignmentTarget(node.left) && hasExcessParens(node.left)) {
            report(node.left);
          }
          if (!isReturnAssignException(node) && hasExcessParensWithPrecedence(node.right, precedence(node))) {
            report(node.right);
          }
        },
        BinaryExpression(node) {
          if (reportsBuffer && node.operator === "in") {
            reportsBuffer.inExpressionNodes.push(node);
          }
          checkBinaryLogical(node);
        },
        CallExpression: checkCallNew,
        ClassBody(node) {
          node.body.filter((member) => member.type === "MethodDefinition" && member.computed && member.key).filter((member) => hasExcessParensWithPrecedence(member.key, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach((member) => report(member.key));
        },
        ConditionalExpression(node) {
          if (isReturnAssignException(node)) {
            return;
          }
          if (!isCondAssignException(node) && hasExcessParensWithPrecedence(node.test, precedence({type: "LogicalExpression", operator: "||"}))) {
            report(node.test);
          }
          if (hasExcessParensWithPrecedence(node.consequent, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(node.consequent);
          }
          if (hasExcessParensWithPrecedence(node.alternate, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(node.alternate);
          }
        },
        DoWhileStatement(node) {
          if (hasExcessParens(node.test) && !isCondAssignException(node)) {
            report(node.test);
          }
        },
        ExportDefaultDeclaration: (node) => checkExpressionOrExportStatement(node.declaration),
        ExpressionStatement: (node) => checkExpressionOrExportStatement(node.expression),
        ForInStatement(node) {
          if (node.left.type !== "VariableDeclaration") {
            const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
            if (firstLeftToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstLeftToken, astUtils.isNotClosingParenToken))) {
              tokensToIgnore.add(firstLeftToken);
            }
          }
          if (hasExcessParens(node.left)) {
            report(node.left);
          }
          if (hasExcessParens(node.right)) {
            report(node.right);
          }
        },
        ForOfStatement(node) {
          if (node.left.type !== "VariableDeclaration") {
            const firstLeftToken = sourceCode.getFirstToken(node.left, astUtils.isNotOpeningParenToken);
            if (firstLeftToken.value === "let") {
              tokensToIgnore.add(firstLeftToken);
            }
          }
          if (hasExcessParens(node.left)) {
            report(node.left);
          }
          if (hasExcessParensWithPrecedence(node.right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(node.right);
          }
        },
        ForStatement(node) {
          if (node.test && hasExcessParens(node.test) && !isCondAssignException(node)) {
            report(node.test);
          }
          if (node.update && hasExcessParens(node.update)) {
            report(node.update);
          }
          if (node.init) {
            if (node.init.type !== "VariableDeclaration") {
              const firstToken = sourceCode.getFirstToken(node.init, astUtils.isNotOpeningParenToken);
              if (firstToken.value === "let" && astUtils.isOpeningBracketToken(sourceCode.getTokenAfter(firstToken, astUtils.isNotClosingParenToken))) {
                tokensToIgnore.add(firstToken);
              }
            }
            startNewReportsBuffering();
            if (hasExcessParens(node.init)) {
              report(node.init);
            }
          }
        },
        "ForStatement > *.init:exit"(node) {
          if (reportsBuffer.reports.length) {
            reportsBuffer.inExpressionNodes.forEach((inExpressionNode) => {
              const path3 = pathToDescendant(node, inExpressionNode);
              let nodeToExclude;
              for (let i = 0; i < path3.length; i++) {
                const pathNode = path3[i];
                if (i < path3.length - 1) {
                  const nextPathNode = path3[i + 1];
                  if (isSafelyEnclosingInExpression(pathNode, nextPathNode)) {
                    return;
                  }
                }
                if (isParenthesised(pathNode)) {
                  if (isInCurrentReportsBuffer(pathNode)) {
                    if (isParenthesisedTwice(pathNode)) {
                      return;
                    }
                    if (!nodeToExclude) {
                      nodeToExclude = pathNode;
                    }
                  } else {
                    return;
                  }
                }
              }
              removeFromCurrentReportsBuffer(nodeToExclude);
            });
          }
          endCurrentReportsBuffering();
        },
        IfStatement(node) {
          if (hasExcessParens(node.test) && !isCondAssignException(node)) {
            report(node.test);
          }
        },
        ImportExpression(node) {
          const {source} = node;
          if (source.type === "SequenceExpression") {
            if (hasDoubleExcessParens(source)) {
              report(source);
            }
          } else if (hasExcessParens(source)) {
            report(source);
          }
        },
        LogicalExpression: checkBinaryLogical,
        MemberExpression(node) {
          const shouldAllowWrapOnce = isMemberExpInNewCallee(node) && doesMemberExpressionContainCallExpression(node);
          const nodeObjHasExcessParens = shouldAllowWrapOnce ? hasDoubleExcessParens(node.object) : hasExcessParens(node.object) && !(isImmediateFunctionPrototypeMethodCall(node.parent) && node.parent.callee === node && IGNORE_FUNCTION_PROTOTYPE_METHODS);
          if (nodeObjHasExcessParens && precedence(node.object) >= precedence(node) && (node.computed || !(astUtils.isDecimalInteger(node.object) || node.object.type === "Literal" && node.object.regex))) {
            report(node.object);
          }
          if (nodeObjHasExcessParens && node.object.type === "CallExpression") {
            report(node.object);
          }
          if (nodeObjHasExcessParens && !IGNORE_NEW_IN_MEMBER_EXPR && node.object.type === "NewExpression" && isNewExpressionWithParens(node.object)) {
            report(node.object);
          }
          if (nodeObjHasExcessParens && node.optional && node.object.type === "ChainExpression") {
            report(node.object);
          }
          if (node.computed && hasExcessParens(node.property)) {
            report(node.property);
          }
        },
        NewExpression: checkCallNew,
        ObjectExpression(node) {
          node.properties.filter((property) => property.value && hasExcessParensWithPrecedence(property.value, PRECEDENCE_OF_ASSIGNMENT_EXPR)).forEach((property) => report(property.value));
        },
        ObjectPattern(node) {
          node.properties.filter((property) => {
            const value = property.value;
            return canBeAssignmentTarget(value) && hasExcessParens(value);
          }).forEach((property) => report(property.value));
        },
        Property(node) {
          if (node.computed) {
            const {key} = node;
            if (key && hasExcessParensWithPrecedence(key, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
              report(key);
            }
          }
        },
        RestElement(node) {
          const argument = node.argument;
          if (canBeAssignmentTarget(argument) && hasExcessParens(argument)) {
            report(argument);
          }
        },
        ReturnStatement(node) {
          const returnToken = sourceCode.getFirstToken(node);
          if (isReturnAssignException(node)) {
            return;
          }
          if (node.argument && hasExcessParensNoLineTerminator(returnToken, node.argument) && !(node.argument.type === "Literal" && node.argument.regex)) {
            report(node.argument);
          }
        },
        SequenceExpression(node) {
          const precedenceOfNode = precedence(node);
          node.expressions.filter((e) => hasExcessParensWithPrecedence(e, precedenceOfNode)).forEach(report);
        },
        SwitchCase(node) {
          if (node.test && hasExcessParens(node.test)) {
            report(node.test);
          }
        },
        SwitchStatement(node) {
          if (hasExcessParens(node.discriminant)) {
            report(node.discriminant);
          }
        },
        ThrowStatement(node) {
          const throwToken = sourceCode.getFirstToken(node);
          if (hasExcessParensNoLineTerminator(throwToken, node.argument)) {
            report(node.argument);
          }
        },
        UnaryExpression: checkArgumentWithPrecedence,
        UpdateExpression(node) {
          if (node.prefix) {
            checkArgumentWithPrecedence(node);
          } else {
            const {argument} = node;
            const operatorToken = sourceCode.getLastToken(node);
            if (argument.loc.end.line === operatorToken.loc.start.line) {
              checkArgumentWithPrecedence(node);
            } else {
              if (hasDoubleExcessParens(argument)) {
                report(argument);
              }
            }
          }
        },
        AwaitExpression: checkArgumentWithPrecedence,
        VariableDeclarator(node) {
          if (node.init && hasExcessParensWithPrecedence(node.init, PRECEDENCE_OF_ASSIGNMENT_EXPR) && !(node.init.type === "Literal" && node.init.regex)) {
            report(node.init);
          }
        },
        WhileStatement(node) {
          if (hasExcessParens(node.test) && !isCondAssignException(node)) {
            report(node.test);
          }
        },
        WithStatement(node) {
          if (hasExcessParens(node.object)) {
            report(node.object);
          }
        },
        YieldExpression(node) {
          if (node.argument) {
            const yieldToken = sourceCode.getFirstToken(node);
            if (precedence(node.argument) >= precedence(node) && hasExcessParensNoLineTerminator(yieldToken, node.argument) || hasDoubleExcessParens(node.argument)) {
              report(node.argument);
            }
          }
        },
        ClassDeclaration: checkClass,
        ClassExpression: checkClass,
        SpreadElement: checkSpreadOperator,
        SpreadProperty: checkSpreadOperator,
        ExperimentalSpreadProperty: checkSpreadOperator,
        TemplateLiteral(node) {
          node.expressions.filter((e) => e && hasExcessParens(e)).forEach(report);
        },
        AssignmentPattern(node) {
          const {left, right} = node;
          if (canBeAssignmentTarget(left) && hasExcessParens(left)) {
            report(left);
          }
          if (right && hasExcessParensWithPrecedence(right, PRECEDENCE_OF_ASSIGNMENT_EXPR)) {
            report(right);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-extra-semi.js
var require_no_extra_semi = __commonJS((exports2, module2) => {
  "use strict";
  var FixTracker = require_fix_tracker();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary semicolons",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-extra-semi"
      },
      fixable: "code",
      schema: [],
      messages: {
        unexpected: "Unnecessary semicolon."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function report(nodeOrToken) {
        context4.report({
          node: nodeOrToken,
          messageId: "unexpected",
          fix(fixer) {
            return new FixTracker(fixer, context4.getSourceCode()).retainSurroundingTokens(nodeOrToken).remove(nodeOrToken);
          }
        });
      }
      function checkForPartOfClassBody(firstToken) {
        for (let token = firstToken; token.type === "Punctuator" && !astUtils.isClosingBraceToken(token); token = sourceCode.getTokenAfter(token)) {
          if (astUtils.isSemicolonToken(token)) {
            report(token);
          }
        }
      }
      return {
        EmptyStatement(node) {
          const parent = node.parent, allowedParentTypes = [
            "ForStatement",
            "ForInStatement",
            "ForOfStatement",
            "WhileStatement",
            "DoWhileStatement",
            "IfStatement",
            "LabeledStatement",
            "WithStatement"
          ];
          if (allowedParentTypes.indexOf(parent.type) === -1) {
            report(node);
          }
        },
        ClassBody(node) {
          checkForPartOfClassBody(sourceCode.getFirstToken(node, 1));
        },
        MethodDefinition(node) {
          checkForPartOfClassBody(sourceCode.getTokenAfter(node));
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-fallthrough.js
var require_no_fallthrough = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var DEFAULT_FALLTHROUGH_COMMENT = /falls?\s?through/iu;
  function hasFallthroughComment(node, context4, fallthroughCommentPattern) {
    const sourceCode = context4.getSourceCode();
    const comment = lodash.last(sourceCode.getCommentsBefore(node));
    return Boolean(comment && fallthroughCommentPattern.test(comment.value));
  }
  function isReachable(segment) {
    return segment.reachable;
  }
  function hasBlankLinesBetween(node, token) {
    return token.loc.start.line > node.loc.end.line + 1;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow fallthrough of `case` statements",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-fallthrough"
      },
      schema: [
        {
          type: "object",
          properties: {
            commentPattern: {
              type: "string",
              default: ""
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        case: "Expected a 'break' statement before 'case'.",
        default: "Expected a 'break' statement before 'default'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      let currentCodePath = null;
      const sourceCode = context4.getSourceCode();
      let fallthroughCase = null;
      let fallthroughCommentPattern = null;
      if (options.commentPattern) {
        fallthroughCommentPattern = new RegExp(options.commentPattern, "u");
      } else {
        fallthroughCommentPattern = DEFAULT_FALLTHROUGH_COMMENT;
      }
      return {
        onCodePathStart(codePath) {
          currentCodePath = codePath;
        },
        onCodePathEnd() {
          currentCodePath = currentCodePath.upper;
        },
        SwitchCase(node) {
          if (fallthroughCase && !hasFallthroughComment(node, context4, fallthroughCommentPattern)) {
            context4.report({
              messageId: node.test ? "case" : "default",
              node
            });
          }
          fallthroughCase = null;
        },
        "SwitchCase:exit"(node) {
          const nextToken = sourceCode.getTokenAfter(node);
          if (currentCodePath.currentSegments.some(isReachable) && (node.consequent.length > 0 || hasBlankLinesBetween(node, nextToken)) && lodash.last(node.parent.cases) !== node) {
            fallthroughCase = node;
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-floating-decimal.js
var require_no_floating_decimal = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow leading or trailing decimal points in numeric literals",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-floating-decimal"
      },
      schema: [],
      fixable: "code",
      messages: {
        leading: "A leading decimal point can be confused with a dot.",
        trailing: "A trailing decimal point can be confused with a dot."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        Literal(node) {
          if (typeof node.value === "number") {
            if (node.raw.startsWith(".")) {
              context4.report({
                node,
                messageId: "leading",
                fix(fixer) {
                  const tokenBefore = sourceCode.getTokenBefore(node);
                  const needsSpaceBefore = tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, `0${node.raw}`);
                  return fixer.insertTextBefore(node, needsSpaceBefore ? " 0" : "0");
                }
              });
            }
            if (node.raw.indexOf(".") === node.raw.length - 1) {
              context4.report({
                node,
                messageId: "trailing",
                fix: (fixer) => fixer.insertTextAfter(node, "0")
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-func-assign.js
var require_no_func_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow reassigning `function` declarations",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-func-assign"
      },
      schema: [],
      messages: {
        isAFunction: "'{{name}}' is a function."
      }
    },
    create(context4) {
      function checkReference(references) {
        astUtils.getModifyingReferences(references).forEach((reference) => {
          context4.report({
            node: reference.identifier,
            messageId: "isAFunction",
            data: {
              name: reference.identifier.name
            }
          });
        });
      }
      function checkVariable(variable) {
        if (variable.defs[0].type === "FunctionName") {
          checkReference(variable.references);
        }
      }
      function checkForFunction(node) {
        context4.getDeclaredVariables(node).forEach(checkVariable);
      }
      return {
        FunctionDeclaration: checkForFunction,
        FunctionExpression: checkForFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-global-assign.js
var require_no_global_assign = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow assignments to native objects or read-only global variables",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-global-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {type: "string"},
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        globalShouldNotBeModified: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(context4) {
      const config = context4.options[0];
      const exceptions = config && config.exceptions || [];
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {
          context4.report({
            node: identifier,
            messageId: "globalShouldNotBeModified",
            data: {
              name: identifier.name
            }
          });
        }
      }
      function checkVariable(variable) {
        if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
          variable.references.forEach(checkReference);
        }
      }
      return {
        Program() {
          const globalScope = context4.getScope();
          globalScope.variables.forEach(checkVariable);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-implicit-coercion.js
var require_no_implicit_coercion = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var INDEX_OF_PATTERN = /^(?:i|lastI)ndexOf$/u;
  var ALLOWABLE_OPERATORS = ["~", "!!", "+", "*"];
  function parseOptions(options) {
    return {
      boolean: "boolean" in options ? options.boolean : true,
      number: "number" in options ? options.number : true,
      string: "string" in options ? options.string : true,
      allow: options.allow || []
    };
  }
  function isDoubleLogicalNegating(node) {
    return node.operator === "!" && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
  }
  function isBinaryNegatingOfIndexOf(node) {
    if (node.operator !== "~") {
      return false;
    }
    const callNode = astUtils.skipChainExpression(node.argument);
    return callNode.type === "CallExpression" && astUtils.isSpecificMemberAccess(callNode.callee, null, INDEX_OF_PATTERN);
  }
  function isMultiplyByOne(node) {
    return node.operator === "*" && (node.left.type === "Literal" && node.left.value === 1 || node.right.type === "Literal" && node.right.value === 1);
  }
  function isNumeric(node) {
    return node.type === "Literal" && typeof node.value === "number" || node.type === "CallExpression" && (node.callee.name === "Number" || node.callee.name === "parseInt" || node.callee.name === "parseFloat");
  }
  function getNonNumericOperand(node) {
    const left = node.left, right = node.right;
    if (right.type !== "BinaryExpression" && !isNumeric(right)) {
      return right;
    }
    if (left.type !== "BinaryExpression" && !isNumeric(left)) {
      return left;
    }
    return null;
  }
  function isEmptyString(node) {
    return astUtils.isStringLiteral(node) && (node.value === "" || node.type === "TemplateLiteral" && node.quasis.length === 1 && node.quasis[0].value.cooked === "");
  }
  function isConcatWithEmptyString(node) {
    return node.operator === "+" && (isEmptyString(node.left) && !astUtils.isStringLiteral(node.right) || isEmptyString(node.right) && !astUtils.isStringLiteral(node.left));
  }
  function isAppendEmptyString(node) {
    return node.operator === "+=" && isEmptyString(node.right);
  }
  function getNonEmptyOperand(node) {
    return isEmptyString(node.left) ? node.right : node.left;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow shorthand type conversions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-implicit-coercion"
      },
      fixable: "code",
      schema: [{
        type: "object",
        properties: {
          boolean: {
            type: "boolean",
            default: true
          },
          number: {
            type: "boolean",
            default: true
          },
          string: {
            type: "boolean",
            default: true
          },
          allow: {
            type: "array",
            items: {
              enum: ALLOWABLE_OPERATORS
            },
            uniqueItems: true
          }
        },
        additionalProperties: false
      }],
      messages: {
        useRecommendation: "use `{{recommendation}}` instead."
      }
    },
    create(context4) {
      const options = parseOptions(context4.options[0] || {});
      const sourceCode = context4.getSourceCode();
      function report(node, recommendation, shouldFix) {
        context4.report({
          node,
          messageId: "useRecommendation",
          data: {
            recommendation
          },
          fix(fixer) {
            if (!shouldFix) {
              return null;
            }
            const tokenBefore = sourceCode.getTokenBefore(node);
            if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, recommendation)) {
              return fixer.replaceText(node, ` ${recommendation}`);
            }
            return fixer.replaceText(node, recommendation);
          }
        });
      }
      return {
        UnaryExpression(node) {
          let operatorAllowed;
          operatorAllowed = options.allow.indexOf("!!") >= 0;
          if (!operatorAllowed && options.boolean && isDoubleLogicalNegating(node)) {
            const recommendation = `Boolean(${sourceCode.getText(node.argument.argument)})`;
            report(node, recommendation, true);
          }
          operatorAllowed = options.allow.indexOf("~") >= 0;
          if (!operatorAllowed && options.boolean && isBinaryNegatingOfIndexOf(node)) {
            const comparison = node.argument.type === "ChainExpression" ? ">= 0" : "!== -1";
            const recommendation = `${sourceCode.getText(node.argument)} ${comparison}`;
            report(node, recommendation, false);
          }
          operatorAllowed = options.allow.indexOf("+") >= 0;
          if (!operatorAllowed && options.number && node.operator === "+" && !isNumeric(node.argument)) {
            const recommendation = `Number(${sourceCode.getText(node.argument)})`;
            report(node, recommendation, true);
          }
        },
        "BinaryExpression:exit"(node) {
          let operatorAllowed;
          operatorAllowed = options.allow.indexOf("*") >= 0;
          const nonNumericOperand = !operatorAllowed && options.number && isMultiplyByOne(node) && getNonNumericOperand(node);
          if (nonNumericOperand) {
            const recommendation = `Number(${sourceCode.getText(nonNumericOperand)})`;
            report(node, recommendation, true);
          }
          operatorAllowed = options.allow.indexOf("+") >= 0;
          if (!operatorAllowed && options.string && isConcatWithEmptyString(node)) {
            const recommendation = `String(${sourceCode.getText(getNonEmptyOperand(node))})`;
            report(node, recommendation, true);
          }
        },
        AssignmentExpression(node) {
          const operatorAllowed = options.allow.indexOf("+") >= 0;
          if (!operatorAllowed && options.string && isAppendEmptyString(node)) {
            const code = sourceCode.getText(getNonEmptyOperand(node));
            const recommendation = `${code} = String(${code})`;
            report(node, recommendation, true);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-implicit-globals.js
var require_no_implicit_globals = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow declarations in the global scope",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-implicit-globals"
      },
      schema: [{
        type: "object",
        properties: {
          lexicalBindings: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      messages: {
        globalNonLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in an IIFE for a local variable, assign as global property for a global variable.",
        globalLexicalBinding: "Unexpected {{kind}} declaration in the global scope, wrap in a block or in an IIFE.",
        globalVariableLeak: "Global variable leak, declare the variable if it is intended to be local.",
        assignmentToReadonlyGlobal: "Unexpected assignment to read-only global variable.",
        redeclarationOfReadonlyGlobal: "Unexpected redeclaration of read-only global variable."
      }
    },
    create(context4) {
      const checkLexicalBindings = context4.options[0] && context4.options[0].lexicalBindings === true;
      function report(node, messageId, kind) {
        context4.report({
          node,
          messageId,
          data: {
            kind
          }
        });
      }
      return {
        Program() {
          const scope = context4.getScope();
          scope.variables.forEach((variable) => {
            const isReadonlyEslintGlobalVariable = variable.writeable === false;
            const isWritableEslintGlobalVariable = variable.writeable === true;
            if (isWritableEslintGlobalVariable) {
              return;
            }
            variable.defs.forEach((def) => {
              const defNode = def.node;
              if (def.type === "FunctionName" || def.type === "Variable" && def.parent.kind === "var") {
                if (isReadonlyEslintGlobalVariable) {
                  report(defNode, "redeclarationOfReadonlyGlobal");
                } else {
                  report(defNode, "globalNonLexicalBinding", def.type === "FunctionName" ? "function" : `'${def.parent.kind}'`);
                }
              }
              if (checkLexicalBindings) {
                if (def.type === "ClassName" || def.type === "Variable" && (def.parent.kind === "let" || def.parent.kind === "const")) {
                  if (isReadonlyEslintGlobalVariable) {
                    report(defNode, "redeclarationOfReadonlyGlobal");
                  } else {
                    report(defNode, "globalLexicalBinding", def.type === "ClassName" ? "class" : `'${def.parent.kind}'`);
                  }
                }
              }
            });
          });
          scope.implicit.variables.forEach((variable) => {
            const scopeVariable = scope.set.get(variable.name);
            let messageId;
            if (scopeVariable) {
              if (scopeVariable.writeable) {
                return;
              }
              messageId = "assignmentToReadonlyGlobal";
            } else {
              messageId = "globalVariableLeak";
            }
            variable.defs.forEach((def) => {
              report(def.node, messageId);
            });
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-implied-eval.js
var require_no_implied_eval = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var {getStaticValue} = require_eslint_utils();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `eval()`-like methods",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-implied-eval"
      },
      schema: [],
      messages: {
        impliedEval: "Implied eval. Consider passing a function instead of a string."
      }
    },
    create(context4) {
      const GLOBAL_CANDIDATES = Object.freeze(["global", "window", "globalThis"]);
      const EVAL_LIKE_FUNC_PATTERN = /^(?:set(?:Interval|Timeout)|execScript)$/u;
      function isEvaluatedString(node) {
        if (node.type === "Literal" && typeof node.value === "string" || node.type === "TemplateLiteral") {
          return true;
        }
        if (node.type === "BinaryExpression" && node.operator === "+") {
          return isEvaluatedString(node.left) || isEvaluatedString(node.right);
        }
        return false;
      }
      function reportImpliedEvalCallExpression(node) {
        const [firstArgument] = node.arguments;
        if (firstArgument) {
          const staticValue = getStaticValue(firstArgument, context4.getScope());
          const isStaticString = staticValue && typeof staticValue.value === "string";
          const isString = isStaticString || isEvaluatedString(firstArgument);
          if (isString) {
            context4.report({
              node,
              messageId: "impliedEval"
            });
          }
        }
      }
      function reportImpliedEvalViaGlobal(globalVar) {
        const {references, name} = globalVar;
        references.forEach((ref) => {
          const identifier = ref.identifier;
          let node = identifier.parent;
          while (astUtils.isSpecificMemberAccess(node, null, name)) {
            node = node.parent;
          }
          if (astUtils.isSpecificMemberAccess(node, null, EVAL_LIKE_FUNC_PATTERN)) {
            const calleeNode = node.parent.type === "ChainExpression" ? node.parent : node;
            const parent = calleeNode.parent;
            if (parent.type === "CallExpression" && parent.callee === calleeNode) {
              reportImpliedEvalCallExpression(parent);
            }
          }
        });
      }
      return {
        CallExpression(node) {
          if (astUtils.isSpecificId(node.callee, EVAL_LIKE_FUNC_PATTERN)) {
            reportImpliedEvalCallExpression(node);
          }
        },
        "Program:exit"() {
          const globalScope = context4.getScope();
          GLOBAL_CANDIDATES.map((candidate) => astUtils.getVariableByName(globalScope, candidate)).filter((globalVar) => !!globalVar && globalVar.defs.length === 0).forEach(reportImpliedEvalViaGlobal);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-import-assign.js
var require_no_import_assign = __commonJS((exports2, module2) => {
  "use strict";
  var {findVariable} = require_eslint_utils();
  var astUtils = require_ast_utils2();
  var WellKnownMutationFunctions = {
    Object: /^(?:assign|definePropert(?:y|ies)|freeze|setPrototypeOf)$/u,
    Reflect: /^(?:(?:define|delete)Property|set(?:PrototypeOf)?)$/u
  };
  function isAssignmentLeft(node) {
    const {parent} = node;
    return parent.type === "AssignmentExpression" && parent.left === node || parent.type === "ArrayPattern" || parent.type === "Property" && parent.value === node && parent.parent.type === "ObjectPattern" || parent.type === "RestElement" || parent.type === "AssignmentPattern" && parent.left === node;
  }
  function isOperandOfMutationUnaryOperator(node) {
    const argumentNode = node.parent.type === "ChainExpression" ? node.parent : node;
    const {parent} = argumentNode;
    return parent.type === "UpdateExpression" && parent.argument === argumentNode || parent.type === "UnaryExpression" && parent.operator === "delete" && parent.argument === argumentNode;
  }
  function isIterationVariable(node) {
    const {parent} = node;
    return parent.type === "ForInStatement" && parent.left === node || parent.type === "ForOfStatement" && parent.left === node;
  }
  function isArgumentOfWellKnownMutationFunction(node, scope) {
    const {parent} = node;
    if (parent.type !== "CallExpression" || parent.arguments[0] !== node) {
      return false;
    }
    const callee = astUtils.skipChainExpression(parent.callee);
    if (!astUtils.isSpecificMemberAccess(callee, "Object", WellKnownMutationFunctions.Object) && !astUtils.isSpecificMemberAccess(callee, "Reflect", WellKnownMutationFunctions.Reflect)) {
      return false;
    }
    const variable = findVariable(scope, callee.object);
    return variable !== null && variable.scope.type === "global";
  }
  function isMemberWrite(id, scope) {
    const {parent} = id;
    return parent.type === "MemberExpression" && parent.object === id && (isAssignmentLeft(parent) || isOperandOfMutationUnaryOperator(parent) || isIterationVariable(parent)) || isArgumentOfWellKnownMutationFunction(id, scope);
  }
  function getWriteNode(id) {
    let node = id.parent;
    while (node && node.type !== "AssignmentExpression" && node.type !== "UpdateExpression" && node.type !== "UnaryExpression" && node.type !== "CallExpression" && node.type !== "ForInStatement" && node.type !== "ForOfStatement") {
      node = node.parent;
    }
    return node || id;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow assigning to imported bindings",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-import-assign"
      },
      schema: [],
      messages: {
        readonly: "'{{name}}' is read-only.",
        readonlyMember: "The members of '{{name}}' are read-only."
      }
    },
    create(context4) {
      return {
        ImportDeclaration(node) {
          const scope = context4.getScope();
          for (const variable of context4.getDeclaredVariables(node)) {
            const shouldCheckMembers = variable.defs.some((d) => d.node.type === "ImportNamespaceSpecifier");
            let prevIdNode = null;
            for (const reference of variable.references) {
              const idNode = reference.identifier;
              if (idNode === prevIdNode) {
                continue;
              }
              prevIdNode = idNode;
              if (reference.isWrite()) {
                context4.report({
                  node: getWriteNode(idNode),
                  messageId: "readonly",
                  data: {name: idNode.name}
                });
              } else if (shouldCheckMembers && isMemberWrite(idNode, scope)) {
                context4.report({
                  node: getWriteNode(idNode),
                  messageId: "readonlyMember",
                  data: {name: idNode.name}
                });
              }
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-inline-comments.js
var require_no_inline_comments = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow inline comments after code",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-inline-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignorePattern: {
              type: "string"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedInlineComment: "Unexpected comment inline with code."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = context4.options[0];
      let customIgnoreRegExp;
      if (options && options.ignorePattern) {
        customIgnoreRegExp = new RegExp(options.ignorePattern, "u");
      }
      function testCodeAroundComment(node) {
        const startLine = String(sourceCode.lines[node.loc.start.line - 1]), endLine = String(sourceCode.lines[node.loc.end.line - 1]), preamble = startLine.slice(0, node.loc.start.column).trim(), postamble = endLine.slice(node.loc.end.column).trim(), isPreambleEmpty = !preamble, isPostambleEmpty = !postamble;
        if (isPreambleEmpty && isPostambleEmpty) {
          return;
        }
        if (customIgnoreRegExp && customIgnoreRegExp.test(node.value)) {
          return;
        }
        if ((isPreambleEmpty || preamble === "{") && (isPostambleEmpty || postamble === "}")) {
          const enclosingNode = sourceCode.getNodeByRangeIndex(node.range[0]);
          if (enclosingNode && enclosingNode.type === "JSXEmptyExpression") {
            return;
          }
        }
        if (astUtils.isDirectiveComment(node)) {
          return;
        }
        context4.report({
          node,
          messageId: "unexpectedInlineComment"
        });
      }
      return {
        Program() {
          sourceCode.getAllComments().filter((token) => token.type !== "Shebang").forEach(testCodeAroundComment);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-inner-declarations.js
var require_no_inner_declarations = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var validParent = new Set(["Program", "ExportNamedDeclaration", "ExportDefaultDeclaration"]);
  var validBlockStatementParent = new Set(["FunctionDeclaration", "FunctionExpression", "ArrowFunctionExpression"]);
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow variable or `function` declarations in nested blocks",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-inner-declarations"
      },
      schema: [
        {
          enum: ["functions", "both"]
        }
      ],
      messages: {
        moveDeclToRoot: "Move {{type}} declaration to {{body}} root."
      }
    },
    create(context4) {
      function check(node) {
        const parent = node.parent;
        if (parent.type === "BlockStatement" && validBlockStatementParent.has(parent.parent.type)) {
          return;
        }
        if (validParent.has(parent.type)) {
          return;
        }
        const upperFunction = astUtils.getUpperFunction(parent);
        context4.report({
          node,
          messageId: "moveDeclToRoot",
          data: {
            type: node.type === "FunctionDeclaration" ? "function" : "variable",
            body: upperFunction === null ? "program" : "function body"
          }
        });
      }
      return {
        FunctionDeclaration: check,
        VariableDeclaration(node) {
          if (context4.options[0] === "both" && node.kind === "var") {
            check(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-invalid-regexp.js
var require_no_invalid_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var RegExpValidator = require_regexpp().RegExpValidator;
  var validator = new RegExpValidator();
  var validFlags = /[gimuys]/gu;
  var undefined1 = void 0;
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow invalid regular expression strings in `RegExp` constructors",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-invalid-regexp"
      },
      schema: [{
        type: "object",
        properties: {
          allowConstructorFlags: {
            type: "array",
            items: {
              type: "string"
            }
          }
        },
        additionalProperties: false
      }],
      messages: {
        regexMessage: "{{message}}."
      }
    },
    create(context4) {
      const options = context4.options[0];
      let allowedFlags = null;
      if (options && options.allowConstructorFlags) {
        const temp = options.allowConstructorFlags.join("").replace(validFlags, "");
        if (temp) {
          allowedFlags = new RegExp(`[${temp}]`, "giu");
        }
      }
      function isString(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
      }
      function getFlags(node) {
        if (node.arguments.length < 2) {
          return "";
        }
        if (isString(node.arguments[1])) {
          return node.arguments[1].value;
        }
        return null;
      }
      function validateRegExpPattern(pattern, uFlag) {
        try {
          validator.validatePattern(pattern, undefined1, undefined1, uFlag);
          return null;
        } catch (err) {
          return err.message;
        }
      }
      function validateRegExpFlags(flags) {
        try {
          validator.validateFlags(flags);
          return null;
        } catch (e) {
          return `Invalid flags supplied to RegExp constructor '${flags}'`;
        }
      }
      return {
        "CallExpression, NewExpression"(node) {
          if (node.callee.type !== "Identifier" || node.callee.name !== "RegExp" || !isString(node.arguments[0])) {
            return;
          }
          const pattern = node.arguments[0].value;
          let flags = getFlags(node);
          if (flags && allowedFlags) {
            flags = flags.replace(allowedFlags, "");
          }
          const message = flags && validateRegExpFlags(flags) || (flags === null ? validateRegExpPattern(pattern, true) && validateRegExpPattern(pattern, false) : validateRegExpPattern(pattern, flags.includes("u")));
          if (message) {
            context4.report({
              node,
              messageId: "regexMessage",
              data: {message}
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-invalid-this.js
var require_no_invalid_this = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `this` keywords outside of classes or class-like objects",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-invalid-this"
      },
      schema: [
        {
          type: "object",
          properties: {
            capIsConstructor: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedThis: "Unexpected 'this'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const capIsConstructor = options.capIsConstructor !== false;
      const stack = [], sourceCode = context4.getSourceCode();
      stack.getCurrent = function() {
        const current = this[this.length - 1];
        if (!current.init) {
          current.init = true;
          current.valid = !astUtils.isDefaultThisBinding(current.node, sourceCode, {capIsConstructor});
        }
        return current;
      };
      function enterFunction(node) {
        stack.push({
          init: !context4.getScope().isStrict,
          node,
          valid: true
        });
      }
      function exitFunction() {
        stack.pop();
      }
      return {
        Program(node) {
          const scope = context4.getScope(), features = context4.parserOptions.ecmaFeatures || {};
          stack.push({
            init: true,
            node,
            valid: !(scope.isStrict || node.sourceType === "module" || features.globalReturn && scope.childScopes[0].isStrict)
          });
        },
        "Program:exit"() {
          stack.pop();
        },
        FunctionDeclaration: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        FunctionExpression: enterFunction,
        "FunctionExpression:exit": exitFunction,
        ThisExpression(node) {
          const current = stack.getCurrent();
          if (current && !current.valid) {
            context4.report({
              node,
              messageId: "unexpectedThis"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-irregular-whitespace.js
var require_no_irregular_whitespace = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var ALL_IRREGULARS = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000\u2028\u2029]/u;
  var IRREGULAR_WHITESPACE = /[\f\v\u0085\ufeff\u00a0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u200b\u202f\u205f\u3000]+/mgu;
  var IRREGULAR_LINE_TERMINATORS = /[\u2028\u2029]/mgu;
  var LINE_BREAK = astUtils.createGlobalLinebreakMatcher();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow irregular whitespace",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-irregular-whitespace"
      },
      schema: [
        {
          type: "object",
          properties: {
            skipComments: {
              type: "boolean",
              default: false
            },
            skipStrings: {
              type: "boolean",
              default: true
            },
            skipTemplates: {
              type: "boolean",
              default: false
            },
            skipRegExps: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noIrregularWhitespace: "Irregular whitespace not allowed."
      }
    },
    create(context4) {
      let errors = [];
      const options = context4.options[0] || {};
      const skipComments = !!options.skipComments;
      const skipStrings = options.skipStrings !== false;
      const skipRegExps = !!options.skipRegExps;
      const skipTemplates = !!options.skipTemplates;
      const sourceCode = context4.getSourceCode();
      const commentNodes = sourceCode.getAllComments();
      function removeWhitespaceError(node) {
        const locStart = node.loc.start;
        const locEnd = node.loc.end;
        errors = errors.filter(({loc: {start: errorLocStart}}) => errorLocStart.line < locStart.line || errorLocStart.line === locStart.line && errorLocStart.column < locStart.column || errorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column || errorLocStart.line > locEnd.line);
      }
      function removeInvalidNodeErrorsInIdentifierOrLiteral(node) {
        const shouldCheckStrings = skipStrings && typeof node.value === "string";
        const shouldCheckRegExps = skipRegExps && Boolean(node.regex);
        if (shouldCheckStrings || shouldCheckRegExps) {
          if (ALL_IRREGULARS.test(node.raw)) {
            removeWhitespaceError(node);
          }
        }
      }
      function removeInvalidNodeErrorsInTemplateLiteral(node) {
        if (typeof node.value.raw === "string") {
          if (ALL_IRREGULARS.test(node.value.raw)) {
            removeWhitespaceError(node);
          }
        }
      }
      function removeInvalidNodeErrorsInComment(node) {
        if (ALL_IRREGULARS.test(node.value)) {
          removeWhitespaceError(node);
        }
      }
      function checkForIrregularWhitespace(node) {
        const sourceLines = sourceCode.lines;
        sourceLines.forEach((sourceLine, lineIndex) => {
          const lineNumber = lineIndex + 1;
          let match;
          while ((match = IRREGULAR_WHITESPACE.exec(sourceLine)) !== null) {
            errors.push({
              node,
              messageId: "noIrregularWhitespace",
              loc: {
                start: {
                  line: lineNumber,
                  column: match.index
                },
                end: {
                  line: lineNumber,
                  column: match.index + match[0].length
                }
              }
            });
          }
        });
      }
      function checkForIrregularLineTerminators(node) {
        const source = sourceCode.getText(), sourceLines = sourceCode.lines, linebreaks = source.match(LINE_BREAK);
        let lastLineIndex = -1, match;
        while ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null) {
          const lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;
          errors.push({
            node,
            messageId: "noIrregularWhitespace",
            loc: {
              start: {
                line: lineIndex + 1,
                column: sourceLines[lineIndex].length
              },
              end: {
                line: lineIndex + 2,
                column: 0
              }
            }
          });
          lastLineIndex = lineIndex;
        }
      }
      function noop() {
      }
      const nodes = {};
      if (ALL_IRREGULARS.test(sourceCode.getText())) {
        nodes.Program = function(node) {
          checkForIrregularWhitespace(node);
          checkForIrregularLineTerminators(node);
        };
        nodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;
        nodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;
        nodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;
        nodes["Program:exit"] = function() {
          if (skipComments) {
            commentNodes.forEach(removeInvalidNodeErrorsInComment);
          }
          errors.forEach((error5) => context4.report(error5));
        };
      } else {
        nodes.Program = noop;
      }
      return nodes;
    }
  };
});

// node_modules/eslint/lib/rules/no-iterator.js
var require_no_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var {getStaticPropertyName} = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of the `__iterator__` property",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-iterator"
      },
      schema: [],
      messages: {
        noIterator: "Reserved name '__iterator__'."
      }
    },
    create(context4) {
      return {
        MemberExpression(node) {
          if (getStaticPropertyName(node) === "__iterator__") {
            context4.report({
              node,
              messageId: "noIterator"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-label-var.js
var require_no_label_var = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow labels that share a name with a variable",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-label-var"
      },
      schema: [],
      messages: {
        identifierClashWithLabel: "Found identifier with same name as label."
      }
    },
    create(context4) {
      function findIdentifier(scope, name) {
        return astUtils.getVariableByName(scope, name) !== null;
      }
      return {
        LabeledStatement(node) {
          const scope = context4.getScope();
          if (findIdentifier(scope, node.label.name)) {
            context4.report({
              node,
              messageId: "identifierClashWithLabel"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-labels.js
var require_no_labels = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow labeled statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-labels"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowLoop: {
              type: "boolean",
              default: false
            },
            allowSwitch: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedLabel: "Unexpected labeled statement.",
        unexpectedLabelInBreak: "Unexpected label in break statement.",
        unexpectedLabelInContinue: "Unexpected label in continue statement."
      }
    },
    create(context4) {
      const options = context4.options[0];
      const allowLoop = options && options.allowLoop;
      const allowSwitch = options && options.allowSwitch;
      let scopeInfo = null;
      function getBodyKind(node) {
        if (astUtils.isLoop(node)) {
          return "loop";
        }
        if (node.type === "SwitchStatement") {
          return "switch";
        }
        return "other";
      }
      function isAllowed(kind) {
        switch (kind) {
          case "loop":
            return allowLoop;
          case "switch":
            return allowSwitch;
          default:
            return false;
        }
      }
      function getKind(label) {
        let info3 = scopeInfo;
        while (info3) {
          if (info3.label === label) {
            return info3.kind;
          }
          info3 = info3.upper;
        }
        return "other";
      }
      return {
        LabeledStatement(node) {
          scopeInfo = {
            label: node.label.name,
            kind: getBodyKind(node.body),
            upper: scopeInfo
          };
        },
        "LabeledStatement:exit"(node) {
          if (!isAllowed(scopeInfo.kind)) {
            context4.report({
              node,
              messageId: "unexpectedLabel"
            });
          }
          scopeInfo = scopeInfo.upper;
        },
        BreakStatement(node) {
          if (node.label && !isAllowed(getKind(node.label.name))) {
            context4.report({
              node,
              messageId: "unexpectedLabelInBreak"
            });
          }
        },
        ContinueStatement(node) {
          if (node.label && !isAllowed(getKind(node.label.name))) {
            context4.report({
              node,
              messageId: "unexpectedLabelInContinue"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-lone-blocks.js
var require_no_lone_blocks = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary nested blocks",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-lone-blocks"
      },
      schema: [],
      messages: {
        redundantBlock: "Block is redundant.",
        redundantNestedBlock: "Nested block is redundant."
      }
    },
    create(context4) {
      const loneBlocks = [];
      let ruleDef;
      function report(node) {
        const messageId = node.parent.type === "BlockStatement" ? "redundantNestedBlock" : "redundantBlock";
        context4.report({
          node,
          messageId
        });
      }
      function isLoneBlock(node) {
        return node.parent.type === "BlockStatement" || node.parent.type === "Program" || node.parent.type === "SwitchCase" && !(node.parent.consequent[0] === node && node.parent.consequent.length === 1);
      }
      function markLoneBlock() {
        if (loneBlocks.length === 0) {
          return;
        }
        const block = context4.getAncestors().pop();
        if (loneBlocks[loneBlocks.length - 1] === block) {
          loneBlocks.pop();
        }
      }
      ruleDef = {
        BlockStatement(node) {
          if (isLoneBlock(node)) {
            report(node);
          }
        }
      };
      if (context4.parserOptions.ecmaVersion >= 6) {
        ruleDef = {
          BlockStatement(node) {
            if (isLoneBlock(node)) {
              loneBlocks.push(node);
            }
          },
          "BlockStatement:exit"(node) {
            if (loneBlocks.length > 0 && loneBlocks[loneBlocks.length - 1] === node) {
              loneBlocks.pop();
              report(node);
            } else if (node.parent.type === "BlockStatement" && node.parent.body.length === 1) {
              report(node);
            }
          }
        };
        ruleDef.VariableDeclaration = function(node) {
          if (node.kind === "let" || node.kind === "const") {
            markLoneBlock();
          }
        };
        ruleDef.FunctionDeclaration = function() {
          if (context4.getScope().isStrict) {
            markLoneBlock();
          }
        };
        ruleDef.ClassDeclaration = markLoneBlock;
      }
      return ruleDef;
    }
  };
});

// node_modules/eslint/lib/rules/no-lonely-if.js
var require_no_lonely_if = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `if` statements as the only statement in `else` blocks",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-lonely-if"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedLonelyIf: "Unexpected if as the only statement in an else block."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        IfStatement(node) {
          const ancestors = context4.getAncestors(), parent = ancestors.pop(), grandparent = ancestors.pop();
          if (parent && parent.type === "BlockStatement" && parent.body.length === 1 && grandparent && grandparent.type === "IfStatement" && parent === grandparent.alternate) {
            context4.report({
              node,
              messageId: "unexpectedLonelyIf",
              fix(fixer) {
                const openingElseCurly = sourceCode.getFirstToken(parent);
                const closingElseCurly = sourceCode.getLastToken(parent);
                const elseKeyword = sourceCode.getTokenBefore(openingElseCurly);
                const tokenAfterElseBlock = sourceCode.getTokenAfter(closingElseCurly);
                const lastIfToken = sourceCode.getLastToken(node.consequent);
                const sourceText = sourceCode.getText();
                if (sourceText.slice(openingElseCurly.range[1], node.range[0]).trim() || sourceText.slice(node.range[1], closingElseCurly.range[0]).trim()) {
                  return null;
                }
                if (node.consequent.type !== "BlockStatement" && lastIfToken.value !== ";" && tokenAfterElseBlock && (node.consequent.loc.end.line === tokenAfterElseBlock.loc.start.line || /^[([/+`-]/u.test(tokenAfterElseBlock.value) || lastIfToken.value === "++" || lastIfToken.value === "--")) {
                  return null;
                }
                return fixer.replaceTextRange([openingElseCurly.range[0], closingElseCurly.range[1]], (elseKeyword.range[1] === openingElseCurly.range[0] ? " " : "") + sourceCode.getText(node));
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-loop-func.js
var require_no_loop_func = __commonJS((exports2, module2) => {
  "use strict";
  function getContainingLoopNode(node) {
    for (let currentNode = node; currentNode.parent; currentNode = currentNode.parent) {
      const parent = currentNode.parent;
      switch (parent.type) {
        case "WhileStatement":
        case "DoWhileStatement":
          return parent;
        case "ForStatement":
          if (parent.init !== currentNode) {
            return parent;
          }
          break;
        case "ForInStatement":
        case "ForOfStatement":
          if (parent.right !== currentNode) {
            return parent;
          }
          break;
        case "ArrowFunctionExpression":
        case "FunctionExpression":
        case "FunctionDeclaration":
          return null;
        default:
          break;
      }
    }
    return null;
  }
  function getTopLoopNode(node, excludedNode) {
    const border = excludedNode ? excludedNode.range[1] : 0;
    let retv = node;
    let containingLoopNode = node;
    while (containingLoopNode && containingLoopNode.range[0] >= border) {
      retv = containingLoopNode;
      containingLoopNode = getContainingLoopNode(containingLoopNode);
    }
    return retv;
  }
  function isSafe(loopNode, reference) {
    const variable = reference.resolved;
    const definition = variable && variable.defs[0];
    const declaration = definition && definition.parent;
    const kind = declaration && declaration.type === "VariableDeclaration" ? declaration.kind : "";
    if (kind === "const") {
      return true;
    }
    if (kind === "let" && declaration.range[0] > loopNode.range[0] && declaration.range[1] < loopNode.range[1]) {
      return true;
    }
    const border = getTopLoopNode(loopNode, kind === "let" ? declaration : null).range[0];
    function isSafeReference(upperRef) {
      const id = upperRef.identifier;
      return !upperRef.isWrite() || variable.scope.variableScope === upperRef.from.variableScope && id.range[0] < border;
    }
    return Boolean(variable) && variable.references.every(isSafeReference);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow function declarations that contain unsafe references inside loop statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-loop-func"
      },
      schema: [],
      messages: {
        unsafeRefs: "Function declared in a loop contains unsafe references to variable(s) {{ varNames }}."
      }
    },
    create(context4) {
      function checkForLoops(node) {
        const loopNode = getContainingLoopNode(node);
        if (!loopNode) {
          return;
        }
        const references = context4.getScope().through;
        const unsafeRefs = references.filter((r) => !isSafe(loopNode, r)).map((r) => r.identifier.name);
        if (unsafeRefs.length > 0) {
          context4.report({
            node,
            messageId: "unsafeRefs",
            data: {varNames: `'${unsafeRefs.join("', '")}'`}
          });
        }
      }
      return {
        ArrowFunctionExpression: checkForLoops,
        FunctionExpression: checkForLoops,
        FunctionDeclaration: checkForLoops
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-loss-of-precision.js
var require_no_loss_of_precision = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow literal numbers that lose precision",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-loss-of-precision"
      },
      schema: [],
      messages: {
        noLossOfPrecision: "This number literal will lose precision at runtime."
      }
    },
    create(context4) {
      function isNumber(node) {
        return typeof node.value === "number";
      }
      function getRaw(node) {
        return node.raw.replace(/_/gu, "");
      }
      function isBaseTen(node) {
        const prefixes = ["0x", "0X", "0b", "0B", "0o", "0O"];
        return prefixes.every((prefix) => !node.raw.startsWith(prefix)) && !/^0[0-7]+$/u.test(node.raw);
      }
      function notBaseTenLosesPrecision(node) {
        const rawString = getRaw(node).toUpperCase();
        let base = 0;
        if (rawString.startsWith("0B")) {
          base = 2;
        } else if (rawString.startsWith("0X")) {
          base = 16;
        } else {
          base = 8;
        }
        return !rawString.endsWith(node.value.toString(base).toUpperCase());
      }
      function addDecimalPointToNumber(stringNumber) {
        return `${stringNumber.slice(0, 1)}.${stringNumber.slice(1)}`;
      }
      function removeLeadingZeros(numberAsString) {
        return numberAsString.replace(/^0*/u, "");
      }
      function removeTrailingZeros(numberAsString) {
        return numberAsString.replace(/0*$/u, "");
      }
      function normalizeInteger(stringInteger) {
        const significantDigits = removeTrailingZeros(removeLeadingZeros(stringInteger));
        return {
          magnitude: stringInteger.startsWith("0") ? stringInteger.length - 2 : stringInteger.length - 1,
          coefficient: addDecimalPointToNumber(significantDigits)
        };
      }
      function normalizeFloat(stringFloat) {
        const trimmedFloat = removeLeadingZeros(stringFloat);
        if (trimmedFloat.startsWith(".")) {
          const decimalDigits = trimmedFloat.split(".").pop();
          const significantDigits = removeLeadingZeros(decimalDigits);
          return {
            magnitude: significantDigits.length - decimalDigits.length - 1,
            coefficient: addDecimalPointToNumber(significantDigits)
          };
        }
        return {
          magnitude: trimmedFloat.indexOf(".") - 1,
          coefficient: addDecimalPointToNumber(trimmedFloat.replace(".", ""))
        };
      }
      function convertNumberToScientificNotation(stringNumber) {
        const splitNumber = stringNumber.replace("E", "e").split("e");
        const originalCoefficient = splitNumber[0];
        const normalizedNumber = stringNumber.includes(".") ? normalizeFloat(originalCoefficient) : normalizeInteger(originalCoefficient);
        const normalizedCoefficient = normalizedNumber.coefficient;
        const magnitude = splitNumber.length > 1 ? parseInt(splitNumber[1], 10) + normalizedNumber.magnitude : normalizedNumber.magnitude;
        return `${normalizedCoefficient}e${magnitude}`;
      }
      function baseTenLosesPrecision(node) {
        const normalizedRawNumber = convertNumberToScientificNotation(getRaw(node));
        const requestedPrecision = normalizedRawNumber.split("e")[0].replace(".", "").length;
        if (requestedPrecision > 100) {
          return true;
        }
        const storedNumber = node.value.toPrecision(requestedPrecision);
        const normalizedStoredNumber = convertNumberToScientificNotation(storedNumber);
        return normalizedRawNumber !== normalizedStoredNumber;
      }
      function losesPrecision(node) {
        return isBaseTen(node) ? baseTenLosesPrecision(node) : notBaseTenLosesPrecision(node);
      }
      return {
        Literal(node) {
          if (node.value && isNumber(node) && losesPrecision(node)) {
            context4.report({
              messageId: "noLossOfPrecision",
              node
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-magic-numbers.js
var require_no_magic_numbers = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var MAX_ARRAY_LENGTH = __pow(2, 32) - 1;
  function normalizeIgnoreValue(x) {
    if (typeof x === "string") {
      return BigInt(x.slice(0, -1));
    }
    return x;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow magic numbers",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-magic-numbers"
      },
      schema: [{
        type: "object",
        properties: {
          detectObjects: {
            type: "boolean",
            default: false
          },
          enforceConst: {
            type: "boolean",
            default: false
          },
          ignore: {
            type: "array",
            items: {
              anyOf: [
                {type: "number"},
                {type: "string", pattern: "^[+-]?(?:0|[1-9][0-9]*)n$"}
              ]
            },
            uniqueItems: true
          },
          ignoreArrayIndexes: {
            type: "boolean",
            default: false
          },
          ignoreDefaultValues: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      messages: {
        useConst: "Number constants declarations must use 'const'.",
        noMagic: "No magic number: {{raw}}."
      }
    },
    create(context4) {
      const config = context4.options[0] || {}, detectObjects = !!config.detectObjects, enforceConst = !!config.enforceConst, ignore = (config.ignore || []).map(normalizeIgnoreValue), ignoreArrayIndexes = !!config.ignoreArrayIndexes, ignoreDefaultValues = !!config.ignoreDefaultValues;
      const okTypes = detectObjects ? [] : ["ObjectExpression", "Property", "AssignmentExpression"];
      function isIgnoredValue(value) {
        return ignore.indexOf(value) !== -1;
      }
      function isDefaultValue(fullNumberNode) {
        const parent = fullNumberNode.parent;
        return parent.type === "AssignmentPattern" && parent.right === fullNumberNode;
      }
      function isParseIntRadix(fullNumberNode) {
        const parent = fullNumberNode.parent;
        return parent.type === "CallExpression" && fullNumberNode === parent.arguments[1] && (astUtils.isSpecificId(parent.callee, "parseInt") || astUtils.isSpecificMemberAccess(parent.callee, "Number", "parseInt"));
      }
      function isJSXNumber(fullNumberNode) {
        return fullNumberNode.parent.type.indexOf("JSX") === 0;
      }
      function isArrayIndex(fullNumberNode, value) {
        const parent = fullNumberNode.parent;
        return parent.type === "MemberExpression" && parent.property === fullNumberNode && (Number.isInteger(value) || typeof value === "bigint") && value >= 0 && value < MAX_ARRAY_LENGTH;
      }
      return {
        Literal(node) {
          if (!astUtils.isNumericLiteral(node)) {
            return;
          }
          let fullNumberNode;
          let value;
          let raw;
          if (node.parent.type === "UnaryExpression" && node.parent.operator === "-") {
            fullNumberNode = node.parent;
            value = -node.value;
            raw = `-${node.raw}`;
          } else {
            fullNumberNode = node;
            value = node.value;
            raw = node.raw;
          }
          const parent = fullNumberNode.parent;
          if (isIgnoredValue(value) || ignoreDefaultValues && isDefaultValue(fullNumberNode) || isParseIntRadix(fullNumberNode) || isJSXNumber(fullNumberNode) || ignoreArrayIndexes && isArrayIndex(fullNumberNode, value)) {
            return;
          }
          if (parent.type === "VariableDeclarator") {
            if (enforceConst && parent.parent.kind !== "const") {
              context4.report({
                node: fullNumberNode,
                messageId: "useConst"
              });
            }
          } else if (okTypes.indexOf(parent.type) === -1 || parent.type === "AssignmentExpression" && parent.left.type === "Identifier") {
            context4.report({
              node: fullNumberNode,
              messageId: "noMagic",
              data: {
                raw
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/utils/unicode/is-combining-character.js
var require_is_combining_character = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isCombiningCharacter(codePoint) {
    return /^[\p{Mc}\p{Me}\p{Mn}]$/u.test(String.fromCodePoint(codePoint));
  };
});

// node_modules/eslint/lib/rules/utils/unicode/is-emoji-modifier.js
var require_is_emoji_modifier = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isEmojiModifier(code) {
    return code >= 127995 && code <= 127999;
  };
});

// node_modules/eslint/lib/rules/utils/unicode/is-regional-indicator-symbol.js
var require_is_regional_indicator_symbol = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isRegionalIndicatorSymbol(code) {
    return code >= 127462 && code <= 127487;
  };
});

// node_modules/eslint/lib/rules/utils/unicode/is-surrogate-pair.js
var require_is_surrogate_pair = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isSurrogatePair(lead, tail) {
    return lead >= 55296 && lead < 56320 && tail >= 56320 && tail < 57344;
  };
});

// node_modules/eslint/lib/rules/utils/unicode/index.js
var require_unicode = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    isCombiningCharacter: require_is_combining_character(),
    isEmojiModifier: require_is_emoji_modifier(),
    isRegionalIndicatorSymbol: require_is_regional_indicator_symbol(),
    isSurrogatePair: require_is_surrogate_pair()
  };
});

// node_modules/eslint/lib/rules/no-misleading-character-class.js
var require_no_misleading_character_class = __commonJS((exports2, module2) => {
  "use strict";
  var {CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant} = require_eslint_utils();
  var {RegExpParser, visitRegExpAST} = require_regexpp();
  var {isCombiningCharacter, isEmojiModifier, isRegionalIndicatorSymbol, isSurrogatePair} = require_unicode();
  function* iterateCharacterSequence(nodes) {
    let seq = [];
    for (const node of nodes) {
      switch (node.type) {
        case "Character":
          seq.push(node.value);
          break;
        case "CharacterClassRange":
          seq.push(node.min.value);
          yield seq;
          seq = [node.max.value];
          break;
        case "CharacterSet":
          if (seq.length > 0) {
            yield seq;
            seq = [];
          }
          break;
      }
    }
    if (seq.length > 0) {
      yield seq;
    }
  }
  var hasCharacterSequence = {
    surrogatePairWithoutUFlag(chars) {
      return chars.some((c, i) => i !== 0 && isSurrogatePair(chars[i - 1], c));
    },
    combiningClass(chars) {
      return chars.some((c, i) => i !== 0 && isCombiningCharacter(c) && !isCombiningCharacter(chars[i - 1]));
    },
    emojiModifier(chars) {
      return chars.some((c, i) => i !== 0 && isEmojiModifier(c) && !isEmojiModifier(chars[i - 1]));
    },
    regionalIndicatorSymbol(chars) {
      return chars.some((c, i) => i !== 0 && isRegionalIndicatorSymbol(c) && isRegionalIndicatorSymbol(chars[i - 1]));
    },
    zwj(chars) {
      const lastIndex = chars.length - 1;
      return chars.some((c, i) => i !== 0 && i !== lastIndex && c === 8205 && chars[i - 1] !== 8205 && chars[i + 1] !== 8205);
    }
  };
  var kinds = Object.keys(hasCharacterSequence);
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow characters which are made with multiple code points in character class syntax",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-misleading-character-class"
      },
      schema: [],
      messages: {
        surrogatePairWithoutUFlag: "Unexpected surrogate pair in character class. Use 'u' flag.",
        combiningClass: "Unexpected combined character in character class.",
        emojiModifier: "Unexpected modified Emoji in character class.",
        regionalIndicatorSymbol: "Unexpected national flag in character class.",
        zwj: "Unexpected joined character sequence in character class."
      }
    },
    create(context4) {
      const parser = new RegExpParser();
      function verify(node, pattern, flags) {
        const has = {
          surrogatePairWithoutUFlag: false,
          combiningClass: false,
          variationSelector: false,
          emojiModifier: false,
          regionalIndicatorSymbol: false,
          zwj: false
        };
        let patternNode;
        try {
          patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
        } catch (e) {
          return;
        }
        visitRegExpAST(patternNode, {
          onCharacterClassEnter(ccNode) {
            for (const chars of iterateCharacterSequence(ccNode.elements)) {
              for (const kind of kinds) {
                has[kind] = has[kind] || hasCharacterSequence[kind](chars);
              }
            }
          }
        });
        for (const kind of kinds) {
          if (has[kind]) {
            context4.report({node, messageId: kind});
          }
        }
      }
      return {
        "Literal[regex]"(node) {
          verify(node, node.regex.pattern, node.regex.flags);
        },
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          for (const {node} of tracker.iterateGlobalReferences({
            RegExp: {[CALL]: true, [CONSTRUCT]: true}
          })) {
            const [patternNode, flagsNode] = node.arguments;
            const pattern = getStringIfConstant(patternNode, scope);
            const flags = getStringIfConstant(flagsNode, scope);
            if (typeof pattern === "string") {
              verify(node, pattern, flags || "");
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-mixed-operators.js
var require_no_mixed_operators = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var ARITHMETIC_OPERATORS = ["+", "-", "*", "/", "%", "**"];
  var BITWISE_OPERATORS = ["&", "|", "^", "~", "<<", ">>", ">>>"];
  var COMPARISON_OPERATORS = ["==", "!=", "===", "!==", ">", ">=", "<", "<="];
  var LOGICAL_OPERATORS = ["&&", "||"];
  var RELATIONAL_OPERATORS = ["in", "instanceof"];
  var TERNARY_OPERATOR = ["?:"];
  var COALESCE_OPERATOR = ["??"];
  var ALL_OPERATORS = [].concat(ARITHMETIC_OPERATORS, BITWISE_OPERATORS, COMPARISON_OPERATORS, LOGICAL_OPERATORS, RELATIONAL_OPERATORS, TERNARY_OPERATOR, COALESCE_OPERATOR);
  var DEFAULT_GROUPS = [
    ARITHMETIC_OPERATORS,
    BITWISE_OPERATORS,
    COMPARISON_OPERATORS,
    LOGICAL_OPERATORS,
    RELATIONAL_OPERATORS
  ];
  var TARGET_NODE_TYPE = /^(?:Binary|Logical|Conditional)Expression$/u;
  function normalizeOptions(options = {}) {
    const hasGroups = options.groups && options.groups.length > 0;
    const groups = hasGroups ? options.groups : DEFAULT_GROUPS;
    const allowSamePrecedence = options.allowSamePrecedence !== false;
    return {
      groups,
      allowSamePrecedence
    };
  }
  function includesBothInAGroup(groups, left, right) {
    return groups.some((group) => group.indexOf(left) !== -1 && group.indexOf(right) !== -1);
  }
  function getChildNode(node) {
    return node.type === "ConditionalExpression" ? node.test : node.left;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow mixed binary operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-mixed-operators"
      },
      schema: [
        {
          type: "object",
          properties: {
            groups: {
              type: "array",
              items: {
                type: "array",
                items: {enum: ALL_OPERATORS},
                minItems: 2,
                uniqueItems: true
              },
              uniqueItems: true
            },
            allowSamePrecedence: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedMixedOperator: "Unexpected mix of '{{leftOperator}}' and '{{rightOperator}}'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = normalizeOptions(context4.options[0]);
      function shouldIgnore(node) {
        const a = node;
        const b = node.parent;
        return !includesBothInAGroup(options.groups, a.operator, b.type === "ConditionalExpression" ? "?:" : b.operator) || options.allowSamePrecedence && astUtils.getPrecedence(a) === astUtils.getPrecedence(b);
      }
      function isMixedWithParent(node) {
        return node.operator !== node.parent.operator && !astUtils.isParenthesised(sourceCode, node);
      }
      function getOperatorToken(node) {
        return sourceCode.getTokenAfter(getChildNode(node), astUtils.isNotClosingParenToken);
      }
      function reportBothOperators(node) {
        const parent = node.parent;
        const left = getChildNode(parent) === node ? node : parent;
        const right = getChildNode(parent) !== node ? node : parent;
        const data = {
          leftOperator: left.operator || "?:",
          rightOperator: right.operator || "?:"
        };
        context4.report({
          node: left,
          loc: getOperatorToken(left).loc,
          messageId: "unexpectedMixedOperator",
          data
        });
        context4.report({
          node: right,
          loc: getOperatorToken(right).loc,
          messageId: "unexpectedMixedOperator",
          data
        });
      }
      function check(node) {
        if (TARGET_NODE_TYPE.test(node.parent.type) && isMixedWithParent(node) && !shouldIgnore(node)) {
          reportBothOperators(node);
        }
      }
      return {
        BinaryExpression: check,
        LogicalExpression: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-mixed-requires.js
var require_no_mixed_requires = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow `require` calls to be mixed with regular variable declarations",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-mixed-requires"
      },
      schema: [
        {
          oneOf: [
            {
              type: "boolean"
            },
            {
              type: "object",
              properties: {
                grouping: {
                  type: "boolean"
                },
                allowCall: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        noMixRequire: "Do not mix 'require' and other declarations.",
        noMixCoreModuleFileComputed: "Do not mix core, module, file and computed requires."
      }
    },
    create(context4) {
      const options = context4.options[0];
      let grouping = false, allowCall = false;
      if (typeof options === "object") {
        grouping = options.grouping;
        allowCall = options.allowCall;
      } else {
        grouping = !!options;
      }
      function getBuiltinModules() {
        return [
          "assert",
          "buffer",
          "child_process",
          "cluster",
          "crypto",
          "dgram",
          "dns",
          "domain",
          "events",
          "fs",
          "http",
          "https",
          "net",
          "os",
          "path",
          "punycode",
          "querystring",
          "readline",
          "repl",
          "smalloc",
          "stream",
          "string_decoder",
          "tls",
          "tty",
          "url",
          "util",
          "v8",
          "vm",
          "zlib"
        ];
      }
      const BUILTIN_MODULES = getBuiltinModules();
      const DECL_REQUIRE = "require", DECL_UNINITIALIZED = "uninitialized", DECL_OTHER = "other";
      const REQ_CORE = "core", REQ_FILE = "file", REQ_MODULE = "module", REQ_COMPUTED = "computed";
      function getDeclarationType(initExpression) {
        if (!initExpression) {
          return DECL_UNINITIALIZED;
        }
        if (initExpression.type === "CallExpression" && initExpression.callee.type === "Identifier" && initExpression.callee.name === "require") {
          return DECL_REQUIRE;
        }
        if (allowCall && initExpression.type === "CallExpression" && initExpression.callee.type === "CallExpression") {
          return getDeclarationType(initExpression.callee);
        }
        if (initExpression.type === "MemberExpression") {
          return getDeclarationType(initExpression.object);
        }
        return DECL_OTHER;
      }
      function inferModuleType(initExpression) {
        if (initExpression.type === "MemberExpression") {
          return inferModuleType(initExpression.object);
        }
        if (initExpression.arguments.length === 0) {
          return REQ_COMPUTED;
        }
        const arg = initExpression.arguments[0];
        if (arg.type !== "Literal" || typeof arg.value !== "string") {
          return REQ_COMPUTED;
        }
        if (BUILTIN_MODULES.indexOf(arg.value) !== -1) {
          return REQ_CORE;
        }
        if (/^\.{0,2}\//u.test(arg.value)) {
          return REQ_FILE;
        }
        return REQ_MODULE;
      }
      function isMixed(declarations) {
        const contains = {};
        declarations.forEach((declaration) => {
          const type = getDeclarationType(declaration.init);
          contains[type] = true;
        });
        return !!(contains[DECL_REQUIRE] && (contains[DECL_UNINITIALIZED] || contains[DECL_OTHER]));
      }
      function isGrouped(declarations) {
        const found = {};
        declarations.forEach((declaration) => {
          if (getDeclarationType(declaration.init) === DECL_REQUIRE) {
            found[inferModuleType(declaration.init)] = true;
          }
        });
        return Object.keys(found).length <= 1;
      }
      return {
        VariableDeclaration(node) {
          if (isMixed(node.declarations)) {
            context4.report({
              node,
              messageId: "noMixRequire"
            });
          } else if (grouping && !isGrouped(node.declarations)) {
            context4.report({
              node,
              messageId: "noMixCoreModuleFileComputed"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-mixed-spaces-and-tabs.js
var require_no_mixed_spaces_and_tabs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow mixed spaces and tabs for indentation",
        category: "Stylistic Issues",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-mixed-spaces-and-tabs"
      },
      schema: [
        {
          enum: ["smart-tabs", true, false]
        }
      ],
      messages: {
        mixedSpacesAndTabs: "Mixed spaces and tabs."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let smartTabs;
      switch (context4.options[0]) {
        case true:
        case "smart-tabs":
          smartTabs = true;
          break;
        default:
          smartTabs = false;
      }
      return {
        "Program:exit"(node) {
          const lines = sourceCode.lines, comments = sourceCode.getAllComments(), ignoredCommentLines = new Set();
          comments.forEach((comment) => {
            for (let i = comment.loc.start.line + 1; i <= comment.loc.end.line; i++) {
              ignoredCommentLines.add(i);
            }
          });
          let regex = /^(?=( +|\t+))\1(?:\t| )/u;
          if (smartTabs) {
            regex = /^(?=(\t*))\1(?=( +))\2\t/u;
          }
          lines.forEach((line, i) => {
            const match = regex.exec(line);
            if (match) {
              const lineNumber = i + 1;
              const loc = {
                start: {
                  line: lineNumber,
                  column: match[0].length - 2
                },
                end: {
                  line: lineNumber,
                  column: match[0].length
                }
              };
              if (!ignoredCommentLines.has(lineNumber)) {
                const containingNode = sourceCode.getNodeByRangeIndex(sourceCode.getIndexFromLoc(loc.start));
                if (!(containingNode && ["Literal", "TemplateElement"].includes(containingNode.type))) {
                  context4.report({
                    node,
                    loc,
                    messageId: "mixedSpacesAndTabs"
                  });
                }
              }
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-multi-assign.js
var require_no_multi_assign = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow use of chained assignment expressions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-multi-assign"
      },
      schema: [],
      messages: {
        unexpectedChain: "Unexpected chained assignment."
      }
    },
    create(context4) {
      return {
        AssignmentExpression(node) {
          if (["AssignmentExpression", "VariableDeclarator"].indexOf(node.parent.type) !== -1) {
            context4.report({
              node,
              messageId: "unexpectedChain"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-multi-spaces.js
var require_no_multi_spaces = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow multiple spaces",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-multi-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "object",
              patternProperties: {
                "^([A-Z][a-z]*)+$": {
                  type: "boolean"
                }
              },
              additionalProperties: false
            },
            ignoreEOLComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        multipleSpaces: "Multiple spaces found before '{{displayValue}}'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = context4.options[0] || {};
      const ignoreEOLComments = options.ignoreEOLComments;
      const exceptions = Object.assign({Property: true}, options.exceptions);
      const hasExceptions = Object.keys(exceptions).filter((key) => exceptions[key]).length > 0;
      function formatReportedCommentValue(token) {
        const valueLines = token.value.split("\n");
        const value = valueLines[0];
        const formattedValue = `${value.slice(0, 12)}...`;
        return valueLines.length === 1 && value.length <= 12 ? value : formattedValue;
      }
      return {
        Program() {
          sourceCode.tokensAndComments.forEach((leftToken, leftIndex, tokensAndComments) => {
            if (leftIndex === tokensAndComments.length - 1) {
              return;
            }
            const rightToken = tokensAndComments[leftIndex + 1];
            if (!sourceCode.text.slice(leftToken.range[1], rightToken.range[0]).includes("  ") || leftToken.loc.end.line < rightToken.loc.start.line) {
              return;
            }
            if (ignoreEOLComments && astUtils.isCommentToken(rightToken) && (leftIndex === tokensAndComments.length - 2 || rightToken.loc.end.line < tokensAndComments[leftIndex + 2].loc.start.line)) {
              return;
            }
            if (hasExceptions) {
              const parentNode = sourceCode.getNodeByRangeIndex(rightToken.range[0] - 1);
              if (parentNode && exceptions[parentNode.type]) {
                return;
              }
            }
            let displayValue;
            if (rightToken.type === "Block") {
              displayValue = `/*${formatReportedCommentValue(rightToken)}*/`;
            } else if (rightToken.type === "Line") {
              displayValue = `//${formatReportedCommentValue(rightToken)}`;
            } else {
              displayValue = rightToken.value;
            }
            context4.report({
              node: rightToken,
              loc: {start: leftToken.loc.end, end: rightToken.loc.start},
              messageId: "multipleSpaces",
              data: {displayValue},
              fix: (fixer) => fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], " ")
            });
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-multi-str.js
var require_no_multi_str = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow multiline strings",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-multi-str"
      },
      schema: [],
      messages: {
        multilineString: "Multiline support is limited to browsers supporting ES5 only."
      }
    },
    create(context4) {
      function isJSXElement(node) {
        return node.type.indexOf("JSX") === 0;
      }
      return {
        Literal(node) {
          if (astUtils.LINEBREAK_MATCHER.test(node.raw) && !isJSXElement(node.parent)) {
            context4.report({
              node,
              messageId: "multilineString"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-multiple-empty-lines.js
var require_no_multiple_empty_lines = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow multiple empty lines",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-multiple-empty-lines"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            max: {
              type: "integer",
              minimum: 0
            },
            maxEOF: {
              type: "integer",
              minimum: 0
            },
            maxBOF: {
              type: "integer",
              minimum: 0
            }
          },
          required: ["max"],
          additionalProperties: false
        }
      ],
      messages: {
        blankBeginningOfFile: "Too many blank lines at the beginning of file. Max of {{max}} allowed.",
        blankEndOfFile: "Too many blank lines at the end of file. Max of {{max}} allowed.",
        consecutiveBlank: "More than {{max}} blank {{pluralizedLines}} not allowed."
      }
    },
    create(context4) {
      let max = 2, maxEOF = max, maxBOF = max;
      if (context4.options.length) {
        max = context4.options[0].max;
        maxEOF = typeof context4.options[0].maxEOF !== "undefined" ? context4.options[0].maxEOF : max;
        maxBOF = typeof context4.options[0].maxBOF !== "undefined" ? context4.options[0].maxBOF : max;
      }
      const sourceCode = context4.getSourceCode();
      const allLines = sourceCode.lines[sourceCode.lines.length - 1] === "" ? sourceCode.lines.slice(0, -1) : sourceCode.lines;
      const templateLiteralLines = new Set();
      return {
        TemplateLiteral(node) {
          node.quasis.forEach((literalPart) => {
            for (let ignoredLine = literalPart.loc.start.line; ignoredLine < literalPart.loc.end.line; ignoredLine++) {
              templateLiteralLines.add(ignoredLine);
            }
          });
        },
        "Program:exit"(node) {
          return allLines.reduce((nonEmptyLineNumbers, line, index) => {
            if (line.trim() || templateLiteralLines.has(index + 1)) {
              nonEmptyLineNumbers.push(index + 1);
            }
            return nonEmptyLineNumbers;
          }, []).concat(allLines.length + 1).reduce((lastLineNumber, lineNumber) => {
            let messageId, maxAllowed;
            if (lastLineNumber === 0) {
              messageId = "blankBeginningOfFile";
              maxAllowed = maxBOF;
            } else if (lineNumber === allLines.length + 1) {
              messageId = "blankEndOfFile";
              maxAllowed = maxEOF;
            } else {
              messageId = "consecutiveBlank";
              maxAllowed = max;
            }
            if (lineNumber - lastLineNumber - 1 > maxAllowed) {
              context4.report({
                node,
                loc: {
                  start: {line: lastLineNumber + maxAllowed + 1, column: 0},
                  end: {line: lineNumber, column: 0}
                },
                messageId,
                data: {
                  max: maxAllowed,
                  pluralizedLines: maxAllowed === 1 ? "line" : "lines"
                },
                fix(fixer) {
                  const rangeStart = sourceCode.getIndexFromLoc({line: lastLineNumber + 1, column: 0});
                  const lineNumberAfterRemovedLines = lineNumber - maxAllowed;
                  const rangeEnd = lineNumberAfterRemovedLines <= allLines.length ? sourceCode.getIndexFromLoc({line: lineNumberAfterRemovedLines, column: 0}) : sourceCode.text.length;
                  return fixer.removeRange([rangeStart, rangeEnd]);
                }
              });
            }
            return lineNumber;
          }, 0);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-native-reassign.js
var require_no_native_reassign = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow assignments to native objects or read-only global variables",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-native-reassign"
      },
      deprecated: true,
      replacedBy: ["no-global-assign"],
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {type: "string"},
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        nativeReassign: "Read-only global '{{name}}' should not be modified."
      }
    },
    create(context4) {
      const config = context4.options[0];
      const exceptions = config && config.exceptions || [];
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (reference.init === false && reference.isWrite() && (index === 0 || references[index - 1].identifier !== identifier)) {
          context4.report({
            node: identifier,
            messageId: "nativeReassign",
            data: identifier
          });
        }
      }
      function checkVariable(variable) {
        if (variable.writeable === false && exceptions.indexOf(variable.name) === -1) {
          variable.references.forEach(checkReference);
        }
      }
      return {
        Program() {
          const globalScope = context4.getScope();
          globalScope.variables.forEach(checkVariable);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-negated-condition.js
var require_no_negated_condition = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow negated conditions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-negated-condition"
      },
      schema: [],
      messages: {
        unexpectedNegated: "Unexpected negated condition."
      }
    },
    create(context4) {
      function hasElseWithoutCondition(node) {
        return node.alternate && node.alternate.type !== "IfStatement";
      }
      function isNegatedUnaryExpression(test) {
        return test.type === "UnaryExpression" && test.operator === "!";
      }
      function isNegatedBinaryExpression(test) {
        return test.type === "BinaryExpression" && (test.operator === "!=" || test.operator === "!==");
      }
      function isNegatedIf(node) {
        return isNegatedUnaryExpression(node.test) || isNegatedBinaryExpression(node.test);
      }
      return {
        IfStatement(node) {
          if (!hasElseWithoutCondition(node)) {
            return;
          }
          if (isNegatedIf(node)) {
            context4.report({
              node,
              messageId: "unexpectedNegated"
            });
          }
        },
        ConditionalExpression(node) {
          if (isNegatedIf(node)) {
            context4.report({
              node,
              messageId: "unexpectedNegated"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-negated-in-lhs.js
var require_no_negated_in_lhs = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow negating the left operand in `in` expressions",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-negated-in-lhs"
      },
      replacedBy: ["no-unsafe-negation"],
      deprecated: true,
      schema: [],
      messages: {
        negatedLHS: "The 'in' expression's left operand is negated."
      }
    },
    create(context4) {
      return {
        BinaryExpression(node) {
          if (node.operator === "in" && node.left.type === "UnaryExpression" && node.left.operator === "!") {
            context4.report({node, messageId: "negatedLHS"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-nested-ternary.js
var require_no_nested_ternary = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow nested ternary expressions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-nested-ternary"
      },
      schema: [],
      messages: {
        noNestedTernary: "Do not nest ternary expressions."
      }
    },
    create(context4) {
      return {
        ConditionalExpression(node) {
          if (node.alternate.type === "ConditionalExpression" || node.consequent.type === "ConditionalExpression") {
            context4.report({
              node,
              messageId: "noNestedTernary"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new.js
var require_no_new = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `new` operators outside of assignments or comparisons",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-new"
      },
      schema: [],
      messages: {
        noNewStatement: "Do not use 'new' for side effects."
      }
    },
    create(context4) {
      return {
        "ExpressionStatement > NewExpression"(node) {
          context4.report({
            node: node.parent,
            messageId: "noNewStatement"
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new-func.js
var require_no_new_func = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `new` operators with the `Function` object",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-new-func"
      },
      schema: [],
      messages: {
        noFunctionConstructor: "The Function constructor is eval."
      }
    },
    create(context4) {
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          const variable = globalScope.set.get("Function");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((ref) => {
              const node = ref.identifier;
              const {parent} = node;
              if (parent && (parent.type === "NewExpression" || parent.type === "CallExpression") && node === parent.callee) {
                context4.report({
                  node: parent,
                  messageId: "noFunctionConstructor"
                });
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new-object.js
var require_no_new_object = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `Object` constructors",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-new-object"
      },
      schema: [],
      messages: {
        preferLiteral: "The object literal notation {} is preferrable."
      }
    },
    create(context4) {
      return {
        NewExpression(node) {
          const variable = astUtils.getVariableByName(context4.getScope(), node.callee.name);
          if (variable && variable.identifiers.length > 0) {
            return;
          }
          if (node.callee.name === "Object") {
            context4.report({
              node,
              messageId: "preferLiteral"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new-require.js
var require_no_new_require = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow `new` operators with calls to `require`",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-new-require"
      },
      schema: [],
      messages: {
        noNewRequire: "Unexpected use of new with require."
      }
    },
    create(context4) {
      return {
        NewExpression(node) {
          if (node.callee.type === "Identifier" && node.callee.name === "require") {
            context4.report({
              node,
              messageId: "noNewRequire"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new-symbol.js
var require_no_new_symbol = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow `new` operators with the `Symbol` object",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-new-symbol"
      },
      schema: [],
      messages: {
        noNewSymbol: "`Symbol` cannot be called as a constructor."
      }
    },
    create(context4) {
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          const variable = globalScope.set.get("Symbol");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((ref) => {
              const node = ref.identifier;
              const parent = node.parent;
              if (parent && parent.type === "NewExpression" && parent.callee === node) {
                context4.report({
                  node,
                  messageId: "noNewSymbol"
                });
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-new-wrappers.js
var require_no_new_wrappers = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `new` operators with the `String`, `Number`, and `Boolean` objects",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-new-wrappers"
      },
      schema: [],
      messages: {
        noConstructor: "Do not use {{fn}} as a constructor."
      }
    },
    create(context4) {
      return {
        NewExpression(node) {
          const wrapperObjects = ["String", "Number", "Boolean"];
          if (wrapperObjects.indexOf(node.callee.name) > -1) {
            context4.report({
              node,
              messageId: "noConstructor",
              data: {fn: node.callee.name}
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-nonoctal-decimal-escape.js
var require_no_nonoctal_decimal_escape = __commonJS((exports2, module2) => {
  "use strict";
  var QUICK_TEST_REGEX = /\\[89]/u;
  function getUnicodeEscape(character) {
    return `\\u${character.charCodeAt(0).toString(16).padStart(4, "0")}`;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `\\8` and `\\9` escape sequences in string literals",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-nonoctal-decimal-escape",
        suggestion: true
      },
      schema: [],
      messages: {
        decimalEscape: "Don't use '{{decimalEscape}}' escape sequence.",
        refactor: "Replace '{{original}}' with '{{replacement}}'. This maintains the current functionality.",
        escapeBackslash: "Replace '{{original}}' with '{{replacement}}' to include the actual backslash character."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function createSuggestion(messageId, range, replacement) {
        return {
          messageId,
          data: {
            original: sourceCode.getText().slice(...range),
            replacement
          },
          fix(fixer) {
            return fixer.replaceTextRange(range, replacement);
          }
        };
      }
      return {
        Literal(node) {
          if (typeof node.value !== "string") {
            return;
          }
          if (!QUICK_TEST_REGEX.test(node.raw)) {
            return;
          }
          const regex = /(?:[^\\]|(?<previousEscape>\\.))*?(?<decimalEscape>\\[89])/suy;
          let match;
          while (match = regex.exec(node.raw)) {
            const {previousEscape, decimalEscape} = match.groups;
            const decimalEscapeRangeEnd = node.range[0] + match.index + match[0].length;
            const decimalEscapeRangeStart = decimalEscapeRangeEnd - decimalEscape.length;
            const decimalEscapeRange = [decimalEscapeRangeStart, decimalEscapeRangeEnd];
            const suggest = [];
            if (previousEscape === "\\0") {
              suggest.push(createSuggestion("refactor", [decimalEscapeRangeStart - previousEscape.length, decimalEscapeRangeEnd], `${getUnicodeEscape("\0")}${decimalEscape[1]}`), createSuggestion("refactor", decimalEscapeRange, getUnicodeEscape(decimalEscape[1])));
            } else {
              suggest.push(createSuggestion("refactor", decimalEscapeRange, decimalEscape[1]));
            }
            suggest.push(createSuggestion("escapeBackslash", decimalEscapeRange, `\\${decimalEscape}`));
            context4.report({
              node,
              loc: {
                start: sourceCode.getLocFromIndex(decimalEscapeRangeStart),
                end: sourceCode.getLocFromIndex(decimalEscapeRangeEnd)
              },
              messageId: "decimalEscape",
              data: {
                decimalEscape
              },
              suggest
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-obj-calls.js
var require_no_obj_calls = __commonJS((exports2, module2) => {
  "use strict";
  var {CALL, CONSTRUCT, ReferenceTracker} = require_eslint_utils();
  var getPropertyName = require_ast_utils2().getStaticPropertyName;
  var nonCallableGlobals = ["Atomics", "JSON", "Math", "Reflect"];
  function getReportNodeName(node) {
    if (node.type === "ChainExpression") {
      return getReportNodeName(node.expression);
    }
    if (node.type === "MemberExpression") {
      return getPropertyName(node);
    }
    return node.name;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow calling global object properties as functions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-obj-calls"
      },
      schema: [],
      messages: {
        unexpectedCall: "'{{name}}' is not a function.",
        unexpectedRefCall: "'{{name}}' is reference to '{{ref}}', which is not a function."
      }
    },
    create(context4) {
      return {
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const traceMap = {};
          for (const g of nonCallableGlobals) {
            traceMap[g] = {
              [CALL]: true,
              [CONSTRUCT]: true
            };
          }
          for (const {node, path: path3} of tracker.iterateGlobalReferences(traceMap)) {
            const name = getReportNodeName(node.callee);
            const ref = path3[0];
            const messageId = name === ref ? "unexpectedCall" : "unexpectedRefCall";
            context4.report({node, messageId, data: {name, ref}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-octal.js
var require_no_octal = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow octal literals",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-octal"
      },
      schema: [],
      messages: {
        noOcatal: "Octal literals should not be used."
      }
    },
    create(context4) {
      return {
        Literal(node) {
          if (typeof node.value === "number" && /^0[0-9]/u.test(node.raw)) {
            context4.report({
              node,
              messageId: "noOcatal"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-octal-escape.js
var require_no_octal_escape = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow octal escape sequences in string literals",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-octal-escape"
      },
      schema: [],
      messages: {
        octalEscapeSequence: "Don't use octal: '\\{{sequence}}'. Use '\\u....' instead."
      }
    },
    create(context4) {
      return {
        Literal(node) {
          if (typeof node.value !== "string") {
            return;
          }
          const match = node.raw.match(/^(?:[^\\]|\\.)*?\\([0-3][0-7]{1,2}|[4-7][0-7]|0(?=[89])|[1-7])/su);
          if (match) {
            context4.report({
              node,
              messageId: "octalEscapeSequence",
              data: {sequence: match[1]}
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-param-reassign.js
var require_no_param_reassign = __commonJS((exports2, module2) => {
  "use strict";
  var stopNodePattern = /(?:Statement|Declaration|Function(?:Expression)?|Program)$/u;
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow reassigning `function` parameters",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-param-reassign"
      },
      schema: [
        {
          oneOf: [
            {
              type: "object",
              properties: {
                props: {
                  enum: [false]
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                props: {
                  enum: [true]
                },
                ignorePropertyModificationsFor: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                },
                ignorePropertyModificationsForRegex: {
                  type: "array",
                  items: {
                    type: "string"
                  },
                  uniqueItems: true
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        assignmentToFunctionParam: "Assignment to function parameter '{{name}}'.",
        assignmentToFunctionParamProp: "Assignment to property of function parameter '{{name}}'."
      }
    },
    create(context4) {
      const props = context4.options[0] && context4.options[0].props;
      const ignoredPropertyAssignmentsFor = context4.options[0] && context4.options[0].ignorePropertyModificationsFor || [];
      const ignoredPropertyAssignmentsForRegex = context4.options[0] && context4.options[0].ignorePropertyModificationsForRegex || [];
      function isModifyingProp(reference) {
        let node = reference.identifier;
        let parent = node.parent;
        while (parent && (!stopNodePattern.test(parent.type) || parent.type === "ForInStatement" || parent.type === "ForOfStatement")) {
          switch (parent.type) {
            case "AssignmentExpression":
              return parent.left === node;
            case "UpdateExpression":
              return true;
            case "UnaryExpression":
              if (parent.operator === "delete") {
                return true;
              }
              break;
            case "ForInStatement":
            case "ForOfStatement":
              if (parent.left === node) {
                return true;
              }
              return false;
            case "CallExpression":
              if (parent.callee !== node) {
                return false;
              }
              break;
            case "MemberExpression":
              if (parent.property === node) {
                return false;
              }
              break;
            case "Property":
              if (parent.key === node) {
                return false;
              }
              break;
            case "ConditionalExpression":
              if (parent.test === node) {
                return false;
              }
              break;
          }
          node = parent;
          parent = node.parent;
        }
        return false;
      }
      function isIgnoredPropertyAssignment(identifierName) {
        return ignoredPropertyAssignmentsFor.includes(identifierName) || ignoredPropertyAssignmentsForRegex.some((ignored) => new RegExp(ignored, "u").test(identifierName));
      }
      function checkReference(reference, index, references) {
        const identifier = reference.identifier;
        if (identifier && !reference.init && (index === 0 || references[index - 1].identifier !== identifier)) {
          if (reference.isWrite()) {
            context4.report({
              node: identifier,
              messageId: "assignmentToFunctionParam",
              data: {name: identifier.name}
            });
          } else if (props && isModifyingProp(reference) && !isIgnoredPropertyAssignment(identifier.name)) {
            context4.report({
              node: identifier,
              messageId: "assignmentToFunctionParamProp",
              data: {name: identifier.name}
            });
          }
        }
      }
      function checkVariable(variable) {
        if (variable.defs[0].type === "Parameter") {
          variable.references.forEach(checkReference);
        }
      }
      function checkForFunction(node) {
        context4.getDeclaredVariables(node).forEach(checkVariable);
      }
      return {
        "FunctionDeclaration:exit": checkForFunction,
        "FunctionExpression:exit": checkForFunction,
        "ArrowFunctionExpression:exit": checkForFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-path-concat.js
var require_no_path_concat = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow string concatenation with `__dirname` and `__filename`",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-path-concat"
      },
      schema: [],
      messages: {
        usePathFunctions: "Use path.join() or path.resolve() instead of + to create paths."
      }
    },
    create(context4) {
      const MATCHER = /^__(?:dir|file)name$/u;
      return {
        BinaryExpression(node) {
          const left = node.left, right = node.right;
          if (node.operator === "+" && (left.type === "Identifier" && MATCHER.test(left.name) || right.type === "Identifier" && MATCHER.test(right.name))) {
            context4.report({
              node,
              messageId: "usePathFunctions"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-plusplus.js
var require_no_plusplus = __commonJS((exports2, module2) => {
  "use strict";
  function isForStatementUpdate(node) {
    const parent = node.parent;
    return parent.type === "ForStatement" && parent.update === node;
  }
  function isForLoopAfterthought(node) {
    const parent = node.parent;
    if (parent.type === "SequenceExpression") {
      return isForLoopAfterthought(parent);
    }
    return isForStatementUpdate(node);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the unary operators `++` and `--`",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-plusplus"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowForLoopAfterthoughts: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedUnaryOp: "Unary operator '{{operator}}' used."
      }
    },
    create(context4) {
      const config = context4.options[0];
      let allowForLoopAfterthoughts = false;
      if (typeof config === "object") {
        allowForLoopAfterthoughts = config.allowForLoopAfterthoughts === true;
      }
      return {
        UpdateExpression(node) {
          if (allowForLoopAfterthoughts && isForLoopAfterthought(node)) {
            return;
          }
          context4.report({
            node,
            messageId: "unexpectedUnaryOp",
            data: {
              operator: node.operator
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-process-env.js
var require_no_process_env = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow the use of `process.env`",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-process-env"
      },
      schema: [],
      messages: {
        unexpectedProcessEnv: "Unexpected use of process.env."
      }
    },
    create(context4) {
      return {
        MemberExpression(node) {
          const objectName = node.object.name, propertyName = node.property.name;
          if (objectName === "process" && !node.computed && propertyName && propertyName === "env") {
            context4.report({node, messageId: "unexpectedProcessEnv"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-process-exit.js
var require_no_process_exit = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow the use of `process.exit()`",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-process-exit"
      },
      schema: [],
      messages: {
        noProcessExit: "Don't use process.exit(); throw an error instead."
      }
    },
    create(context4) {
      return {
        "CallExpression > MemberExpression.callee[object.name = 'process'][property.name = 'exit']"(node) {
          context4.report({node: node.parent, messageId: "noProcessExit"});
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-promise-executor-return.js
var require_no_promise_executor_return = __commonJS((exports2, module2) => {
  "use strict";
  var {findVariable} = require_eslint_utils();
  var functionTypesToCheck = new Set(["ArrowFunctionExpression", "FunctionExpression"]);
  function isGlobalReference(node, scope) {
    const variable = findVariable(scope, node);
    return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
  }
  function getOuterScope(scope) {
    const upper = scope.upper;
    if (upper.type === "function-expression-name") {
      return upper.upper;
    }
    return upper;
  }
  function isPromiseExecutor(node, scope) {
    const parent = node.parent;
    return parent.type === "NewExpression" && parent.arguments[0] === node && parent.callee.type === "Identifier" && parent.callee.name === "Promise" && isGlobalReference(parent.callee, getOuterScope(scope));
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow returning values from Promise executor functions",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-promise-executor-return"
      },
      schema: [],
      messages: {
        returnsValue: "Return values from promise executor functions cannot be read."
      }
    },
    create(context4) {
      let funcInfo = null;
      function report(node) {
        context4.report({node, messageId: "returnsValue"});
      }
      return {
        onCodePathStart(_, node) {
          funcInfo = {
            upper: funcInfo,
            shouldCheck: functionTypesToCheck.has(node.type) && isPromiseExecutor(node, context4.getScope())
          };
          if (funcInfo.shouldCheck && node.type === "ArrowFunctionExpression" && node.expression) {
            report(node.body);
          }
        },
        onCodePathEnd() {
          funcInfo = funcInfo.upper;
        },
        ReturnStatement(node) {
          if (funcInfo.shouldCheck && node.argument) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-proto.js
var require_no_proto = __commonJS((exports2, module2) => {
  "use strict";
  var {getStaticPropertyName} = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of the `__proto__` property",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-proto"
      },
      schema: [],
      messages: {
        unexpectedProto: "The '__proto__' property is deprecated."
      }
    },
    create(context4) {
      return {
        MemberExpression(node) {
          if (getStaticPropertyName(node) === "__proto__") {
            context4.report({node, messageId: "unexpectedProto"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-prototype-builtins.js
var require_no_prototype_builtins = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow calling some `Object.prototype` methods directly on objects",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-prototype-builtins"
      },
      schema: [],
      messages: {
        prototypeBuildIn: "Do not access Object.prototype method '{{prop}}' from target object."
      }
    },
    create(context4) {
      const DISALLOWED_PROPS = [
        "hasOwnProperty",
        "isPrototypeOf",
        "propertyIsEnumerable"
      ];
      function disallowBuiltIns(node) {
        const callee = astUtils.skipChainExpression(node.callee);
        if (callee.type !== "MemberExpression") {
          return;
        }
        const propName = astUtils.getStaticPropertyName(callee);
        if (propName !== null && DISALLOWED_PROPS.indexOf(propName) > -1) {
          context4.report({
            messageId: "prototypeBuildIn",
            loc: callee.property.loc,
            data: {prop: propName},
            node
          });
        }
      }
      return {
        CallExpression: disallowBuiltIns
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-redeclare.js
var require_no_redeclare = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow variable redeclaration",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-redeclare"
      },
      messages: {
        redeclared: "'{{id}}' is already defined.",
        redeclaredAsBuiltin: "'{{id}}' is already defined as a built-in global variable.",
        redeclaredBySyntax: "'{{id}}' is already defined by a variable declaration."
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: {type: "boolean", default: true}
          },
          additionalProperties: false
        }
      ]
    },
    create(context4) {
      const options = {
        builtinGlobals: Boolean(context4.options.length === 0 || context4.options[0].builtinGlobals)
      };
      const sourceCode = context4.getSourceCode();
      function* iterateDeclarations(variable) {
        if (options.builtinGlobals && (variable.eslintImplicitGlobalSetting === "readonly" || variable.eslintImplicitGlobalSetting === "writable")) {
          yield {type: "builtin"};
        }
        for (const id of variable.identifiers) {
          yield {type: "syntax", node: id, loc: id.loc};
        }
        if (variable.eslintExplicitGlobalComments) {
          for (const comment of variable.eslintExplicitGlobalComments) {
            yield {
              type: "comment",
              node: comment,
              loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, comment, variable.name)
            };
          }
        }
      }
      function findVariablesInScope(scope) {
        for (const variable of scope.variables) {
          const [
            declaration,
            ...extraDeclarations
          ] = iterateDeclarations(variable);
          if (extraDeclarations.length === 0) {
            continue;
          }
          const detailMessageId = declaration.type === "builtin" ? "redeclaredAsBuiltin" : "redeclaredBySyntax";
          const data = {id: variable.name};
          for (const {type, node, loc} of extraDeclarations) {
            const messageId = type === declaration.type ? "redeclared" : detailMessageId;
            context4.report({node, loc, messageId, data});
          }
        }
      }
      function checkForBlock(node) {
        const scope = context4.getScope();
        if (scope.block === node) {
          findVariablesInScope(scope);
        }
      }
      return {
        Program() {
          const scope = context4.getScope();
          findVariablesInScope(scope);
          if (scope.type === "global" && scope.childScopes[0] && scope.block === scope.childScopes[0].block) {
            findVariablesInScope(scope.childScopes[0]);
          }
        },
        FunctionDeclaration: checkForBlock,
        FunctionExpression: checkForBlock,
        ArrowFunctionExpression: checkForBlock,
        BlockStatement: checkForBlock,
        ForStatement: checkForBlock,
        ForInStatement: checkForBlock,
        ForOfStatement: checkForBlock,
        SwitchStatement: checkForBlock
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-regex-spaces.js
var require_no_regex_spaces = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var regexpp = require_regexpp();
  var regExpParser = new regexpp.RegExpParser();
  var DOUBLE_SPACE = / {2}/u;
  function isString(node) {
    return node && node.type === "Literal" && typeof node.value === "string";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow multiple spaces in regular expressions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-regex-spaces"
      },
      schema: [],
      fixable: "code",
      messages: {
        multipleSpaces: "Spaces are hard to count. Use {{{length}}}."
      }
    },
    create(context4) {
      function checkRegex(nodeToReport, pattern, rawPattern, rawPatternStartRange, flags) {
        if (!DOUBLE_SPACE.test(rawPattern)) {
          return;
        }
        const characterClassNodes = [];
        let regExpAST;
        try {
          regExpAST = regExpParser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
        } catch (e) {
          return;
        }
        regexpp.visitRegExpAST(regExpAST, {
          onCharacterClassEnter(ccNode) {
            characterClassNodes.push(ccNode);
          }
        });
        const spacesPattern = /( {2,})(?: [+*{?]|[^+*{?]|$)/gu;
        let match;
        while (match = spacesPattern.exec(pattern)) {
          const {1: {length}, index} = match;
          if (characterClassNodes.every(({start, end}) => index < start || end <= index)) {
            context4.report({
              node: nodeToReport,
              messageId: "multipleSpaces",
              data: {length},
              fix(fixer) {
                if (pattern !== rawPattern) {
                  return null;
                }
                return fixer.replaceTextRange([rawPatternStartRange + index, rawPatternStartRange + index + length], ` {${length}}`);
              }
            });
            return;
          }
        }
      }
      function checkLiteral(node) {
        if (node.regex) {
          const pattern = node.regex.pattern;
          const rawPattern = node.raw.slice(1, node.raw.lastIndexOf("/"));
          const rawPatternStartRange = node.range[0] + 1;
          const flags = node.regex.flags;
          checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
        }
      }
      function checkFunction(node) {
        const scope = context4.getScope();
        const regExpVar = astUtils.getVariableByName(scope, "RegExp");
        const shadowed = regExpVar && regExpVar.defs.length > 0;
        const patternNode = node.arguments[0];
        const flagsNode = node.arguments[1];
        if (node.callee.type === "Identifier" && node.callee.name === "RegExp" && isString(patternNode) && !shadowed) {
          const pattern = patternNode.value;
          const rawPattern = patternNode.raw.slice(1, -1);
          const rawPatternStartRange = patternNode.range[0] + 1;
          const flags = isString(flagsNode) ? flagsNode.value : "";
          checkRegex(node, pattern, rawPattern, rawPatternStartRange, flags);
        }
      }
      return {
        Literal: checkLiteral,
        CallExpression: checkFunction,
        NewExpression: checkFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-exports.js
var require_no_restricted_exports = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified names in exports",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-exports"
      },
      schema: [{
        type: "object",
        properties: {
          restrictedNamedExports: {
            type: "array",
            items: {
              type: "string"
            },
            uniqueItems: true
          }
        },
        additionalProperties: false
      }],
      messages: {
        restrictedNamed: "'{{name}}' is restricted from being used as an exported name."
      }
    },
    create(context4) {
      const restrictedNames = new Set(context4.options[0] && context4.options[0].restrictedNamedExports);
      function checkExportedName(node) {
        const name = node.name;
        if (restrictedNames.has(name)) {
          context4.report({
            node,
            messageId: "restrictedNamed",
            data: {name}
          });
        }
      }
      return {
        ExportAllDeclaration(node) {
          if (node.exported) {
            checkExportedName(node.exported);
          }
        },
        ExportNamedDeclaration(node) {
          const declaration = node.declaration;
          if (declaration) {
            if (declaration.type === "FunctionDeclaration" || declaration.type === "ClassDeclaration") {
              checkExportedName(declaration.id);
            } else if (declaration.type === "VariableDeclaration") {
              context4.getDeclaredVariables(declaration).map((v) => v.defs.find((d) => d.parent === declaration)).map((d) => d.name).forEach(checkExportedName);
            }
          } else {
            node.specifiers.map((s) => s.exported).forEach(checkExportedName);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-globals.js
var require_no_restricted_globals = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified global variables",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-globals"
      },
      schema: {
        type: "array",
        items: {
          oneOf: [
            {
              type: "string"
            },
            {
              type: "object",
              properties: {
                name: {type: "string"},
                message: {type: "string"}
              },
              required: ["name"],
              additionalProperties: false
            }
          ]
        },
        uniqueItems: true,
        minItems: 0
      },
      messages: {
        defaultMessage: "Unexpected use of '{{name}}'.",
        customMessage: "Unexpected use of '{{name}}'. {{customMessage}}"
      }
    },
    create(context4) {
      if (context4.options.length === 0) {
        return {};
      }
      const restrictedGlobalMessages = context4.options.reduce((memo, option) => {
        if (typeof option === "string") {
          memo[option] = null;
        } else {
          memo[option.name] = option.message;
        }
        return memo;
      }, {});
      function reportReference(reference) {
        const name = reference.identifier.name, customMessage = restrictedGlobalMessages[name], messageId = customMessage ? "customMessage" : "defaultMessage";
        context4.report({
          node: reference.identifier,
          messageId,
          data: {
            name,
            customMessage
          }
        });
      }
      function isRestricted(name) {
        return Object.prototype.hasOwnProperty.call(restrictedGlobalMessages, name);
      }
      return {
        Program() {
          const scope = context4.getScope();
          scope.variables.forEach((variable) => {
            if (!variable.defs.length && isRestricted(variable.name)) {
              variable.references.forEach(reportReference);
            }
          });
          scope.through.forEach((reference) => {
            if (isRestricted(reference.identifier.name)) {
              reportReference(reference);
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-imports.js
var require_no_restricted_imports = __commonJS((exports2, module2) => {
  "use strict";
  var ignore = require_ignore();
  var arrayOfStrings = {
    type: "array",
    items: {type: "string"},
    uniqueItems: true
  };
  var arrayOfStringsOrObjects = {
    type: "array",
    items: {
      anyOf: [
        {type: "string"},
        {
          type: "object",
          properties: {
            name: {type: "string"},
            message: {
              type: "string",
              minLength: 1
            },
            importNames: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false,
          required: ["name"]
        }
      ]
    },
    uniqueItems: true
  };
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified modules when loaded by `import`",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-imports"
      },
      messages: {
        path: "'{{importSource}}' import is restricted from being used.",
        pathWithCustomMessage: "'{{importSource}}' import is restricted from being used. {{customMessage}}",
        patterns: "'{{importSource}}' import is restricted from being used by a pattern.",
        everything: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted.",
        everythingWithCustomMessage: "* import is invalid because '{{importNames}}' from '{{importSource}}' is restricted. {{customMessage}}",
        importName: "'{{importName}}' import from '{{importSource}}' is restricted.",
        importNameWithCustomMessage: "'{{importName}}' import from '{{importSource}}' is restricted. {{customMessage}}"
      },
      schema: {
        anyOf: [
          arrayOfStringsOrObjects,
          {
            type: "array",
            items: [{
              type: "object",
              properties: {
                paths: arrayOfStringsOrObjects,
                patterns: arrayOfStrings
              },
              additionalProperties: false
            }],
            additionalItems: false
          }
        ]
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = Array.isArray(context4.options) ? context4.options : [];
      const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
      const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context4.options) || [];
      const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
      if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
        return {};
      }
      const restrictedPathMessages = restrictedPaths.reduce((memo, importSource) => {
        if (typeof importSource === "string") {
          memo[importSource] = {message: null};
        } else {
          memo[importSource.name] = {
            message: importSource.message,
            importNames: importSource.importNames
          };
        }
        return memo;
      }, {});
      const restrictedPatternsMatcher = ignore().add(restrictedPatterns);
      function checkRestrictedPathAndReport(importSource, importNames, node) {
        if (!Object.prototype.hasOwnProperty.call(restrictedPathMessages, importSource)) {
          return;
        }
        const customMessage = restrictedPathMessages[importSource].message;
        const restrictedImportNames = restrictedPathMessages[importSource].importNames;
        if (restrictedImportNames) {
          if (importNames.has("*")) {
            const specifierData = importNames.get("*")[0];
            context4.report({
              node,
              messageId: customMessage ? "everythingWithCustomMessage" : "everything",
              loc: specifierData.loc,
              data: {
                importSource,
                importNames: restrictedImportNames,
                customMessage
              }
            });
          }
          restrictedImportNames.forEach((importName) => {
            if (importNames.has(importName)) {
              const specifiers = importNames.get(importName);
              specifiers.forEach((specifier) => {
                context4.report({
                  node,
                  messageId: customMessage ? "importNameWithCustomMessage" : "importName",
                  loc: specifier.loc,
                  data: {
                    importSource,
                    customMessage,
                    importName
                  }
                });
              });
            }
          });
        } else {
          context4.report({
            node,
            messageId: customMessage ? "pathWithCustomMessage" : "path",
            data: {
              importSource,
              customMessage
            }
          });
        }
      }
      function reportPathForPatterns(node) {
        const importSource = node.source.value.trim();
        context4.report({
          node,
          messageId: "patterns",
          data: {
            importSource
          }
        });
      }
      function isRestrictedPattern(importSource) {
        return restrictedPatterns.length > 0 && restrictedPatternsMatcher.ignores(importSource);
      }
      function checkNode(node) {
        const importSource = node.source.value.trim();
        const importNames = new Map();
        if (node.type === "ExportAllDeclaration") {
          const starToken = sourceCode.getFirstToken(node, 1);
          importNames.set("*", [{loc: starToken.loc}]);
        } else if (node.specifiers) {
          for (const specifier of node.specifiers) {
            let name;
            const specifierData = {loc: specifier.loc};
            if (specifier.type === "ImportDefaultSpecifier") {
              name = "default";
            } else if (specifier.type === "ImportNamespaceSpecifier") {
              name = "*";
            } else if (specifier.imported) {
              name = specifier.imported.name;
            } else if (specifier.local) {
              name = specifier.local.name;
            }
            if (name) {
              if (importNames.has(name)) {
                importNames.get(name).push(specifierData);
              } else {
                importNames.set(name, [specifierData]);
              }
            }
          }
        }
        checkRestrictedPathAndReport(importSource, importNames, node);
        if (isRestrictedPattern(importSource)) {
          reportPathForPatterns(node);
        }
      }
      return {
        ImportDeclaration: checkNode,
        ExportNamedDeclaration(node) {
          if (node.source) {
            checkNode(node);
          }
        },
        ExportAllDeclaration: checkNode
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-modules.js
var require_no_restricted_modules = __commonJS((exports2, module2) => {
  "use strict";
  var ignore = require_ignore();
  var arrayOfStrings = {
    type: "array",
    items: {type: "string"},
    uniqueItems: true
  };
  var arrayOfStringsOrObjects = {
    type: "array",
    items: {
      anyOf: [
        {type: "string"},
        {
          type: "object",
          properties: {
            name: {type: "string"},
            message: {
              type: "string",
              minLength: 1
            }
          },
          additionalProperties: false,
          required: ["name"]
        }
      ]
    },
    uniqueItems: true
  };
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow specified modules when loaded by `require`",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-modules"
      },
      schema: {
        anyOf: [
          arrayOfStringsOrObjects,
          {
            type: "array",
            items: {
              type: "object",
              properties: {
                paths: arrayOfStringsOrObjects,
                patterns: arrayOfStrings
              },
              additionalProperties: false
            },
            additionalItems: false
          }
        ]
      },
      messages: {
        defaultMessage: "'{{name}}' module is restricted from being used.",
        customMessage: "'{{name}}' module is restricted from being used. {{customMessage}}",
        patternMessage: "'{{name}}' module is restricted from being used by a pattern."
      }
    },
    create(context4) {
      const options = Array.isArray(context4.options) ? context4.options : [];
      const isPathAndPatternsObject = typeof options[0] === "object" && (Object.prototype.hasOwnProperty.call(options[0], "paths") || Object.prototype.hasOwnProperty.call(options[0], "patterns"));
      const restrictedPaths = (isPathAndPatternsObject ? options[0].paths : context4.options) || [];
      const restrictedPatterns = (isPathAndPatternsObject ? options[0].patterns : []) || [];
      const restrictedPathMessages = restrictedPaths.reduce((memo, importName) => {
        if (typeof importName === "string") {
          memo[importName] = null;
        } else {
          memo[importName.name] = importName.message;
        }
        return memo;
      }, {});
      if (Object.keys(restrictedPaths).length === 0 && restrictedPatterns.length === 0) {
        return {};
      }
      const ig = ignore().add(restrictedPatterns);
      function isStringLiteral(node) {
        return node && node.type === "Literal" && typeof node.value === "string";
      }
      function isStaticTemplateLiteral(node) {
        return node && node.type === "TemplateLiteral" && node.expressions.length === 0;
      }
      function isRequireCall(node) {
        return node.callee.type === "Identifier" && node.callee.name === "require";
      }
      function getFirstArgumentString(node) {
        if (isStringLiteral(node)) {
          return node.value.trim();
        }
        if (isStaticTemplateLiteral(node)) {
          return node.quasis[0].value.cooked.trim();
        }
        return null;
      }
      function reportPath(node, name) {
        const customMessage = restrictedPathMessages[name];
        const messageId = customMessage ? "customMessage" : "defaultMessage";
        context4.report({
          node,
          messageId,
          data: {
            name,
            customMessage
          }
        });
      }
      function isRestrictedPath(name) {
        return Object.prototype.hasOwnProperty.call(restrictedPathMessages, name);
      }
      return {
        CallExpression(node) {
          if (isRequireCall(node)) {
            if (node.arguments.length) {
              const name = getFirstArgumentString(node.arguments[0]);
              if (name) {
                if (isRestrictedPath(name)) {
                  reportPath(node, name);
                }
                if (restrictedPatterns.length > 0 && ig.ignores(name)) {
                  context4.report({
                    node,
                    messageId: "patternMessage",
                    data: {name}
                  });
                }
              }
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-properties.js
var require_no_restricted_properties = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow certain properties on certain objects",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-properties"
      },
      schema: {
        type: "array",
        items: {
          anyOf: [
            {
              type: "object",
              properties: {
                object: {
                  type: "string"
                },
                property: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              },
              additionalProperties: false,
              required: ["object"]
            },
            {
              type: "object",
              properties: {
                object: {
                  type: "string"
                },
                property: {
                  type: "string"
                },
                message: {
                  type: "string"
                }
              },
              additionalProperties: false,
              required: ["property"]
            }
          ]
        },
        uniqueItems: true
      },
      messages: {
        restrictedObjectProperty: "'{{objectName}}.{{propertyName}}' is restricted from being used.{{message}}",
        restrictedProperty: "'{{propertyName}}' is restricted from being used.{{message}}"
      }
    },
    create(context4) {
      const restrictedCalls = context4.options;
      if (restrictedCalls.length === 0) {
        return {};
      }
      const restrictedProperties = new Map();
      const globallyRestrictedObjects = new Map();
      const globallyRestrictedProperties = new Map();
      restrictedCalls.forEach((option) => {
        const objectName = option.object;
        const propertyName = option.property;
        if (typeof objectName === "undefined") {
          globallyRestrictedProperties.set(propertyName, {message: option.message});
        } else if (typeof propertyName === "undefined") {
          globallyRestrictedObjects.set(objectName, {message: option.message});
        } else {
          if (!restrictedProperties.has(objectName)) {
            restrictedProperties.set(objectName, new Map());
          }
          restrictedProperties.get(objectName).set(propertyName, {
            message: option.message
          });
        }
      });
      function checkPropertyAccess(node, objectName, propertyName) {
        if (propertyName === null) {
          return;
        }
        const matchedObject = restrictedProperties.get(objectName);
        const matchedObjectProperty = matchedObject ? matchedObject.get(propertyName) : globallyRestrictedObjects.get(objectName);
        const globalMatchedProperty = globallyRestrictedProperties.get(propertyName);
        if (matchedObjectProperty) {
          const message = matchedObjectProperty.message ? ` ${matchedObjectProperty.message}` : "";
          context4.report({
            node,
            messageId: "restrictedObjectProperty",
            data: {
              objectName,
              propertyName,
              message
            }
          });
        } else if (globalMatchedProperty) {
          const message = globalMatchedProperty.message ? ` ${globalMatchedProperty.message}` : "";
          context4.report({
            node,
            messageId: "restrictedProperty",
            data: {
              propertyName,
              message
            }
          });
        }
      }
      function checkDestructuringAssignment(node) {
        if (node.right.type === "Identifier") {
          const objectName = node.right.name;
          if (node.left.type === "ObjectPattern") {
            node.left.properties.forEach((property) => {
              checkPropertyAccess(node.left, objectName, astUtils.getStaticPropertyName(property));
            });
          }
        }
      }
      return {
        MemberExpression(node) {
          checkPropertyAccess(node, node.object && node.object.name, astUtils.getStaticPropertyName(node));
        },
        VariableDeclarator(node) {
          if (node.init && node.init.type === "Identifier") {
            const objectName = node.init.name;
            if (node.id.type === "ObjectPattern") {
              node.id.properties.forEach((property) => {
                checkPropertyAccess(node.id, objectName, astUtils.getStaticPropertyName(property));
              });
            }
          }
        },
        AssignmentExpression: checkDestructuringAssignment,
        AssignmentPattern: checkDestructuringAssignment
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-restricted-syntax.js
var require_no_restricted_syntax = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified syntax",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-restricted-syntax"
      },
      schema: {
        type: "array",
        items: {
          oneOf: [
            {
              type: "string"
            },
            {
              type: "object",
              properties: {
                selector: {type: "string"},
                message: {type: "string"}
              },
              required: ["selector"],
              additionalProperties: false
            }
          ]
        },
        uniqueItems: true,
        minItems: 0
      },
      messages: {
        restrictedSyntax: "{{message}}"
      }
    },
    create(context4) {
      return context4.options.reduce((result, selectorOrObject) => {
        const isStringFormat = typeof selectorOrObject === "string";
        const hasCustomMessage = !isStringFormat && Boolean(selectorOrObject.message);
        const selector = isStringFormat ? selectorOrObject : selectorOrObject.selector;
        const message = hasCustomMessage ? selectorOrObject.message : `Using '${selector}' is not allowed.`;
        return Object.assign(result, {
          [selector](node) {
            context4.report({
              node,
              messageId: "restrictedSyntax",
              data: {message}
            });
          }
        });
      }, {});
    }
  };
});

// node_modules/eslint/lib/rules/no-return-assign.js
var require_no_return_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var SENTINEL_TYPE = /^(?:[a-zA-Z]+?Statement|ArrowFunctionExpression|FunctionExpression|ClassExpression)$/u;
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow assignment operators in `return` statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-return-assign"
      },
      schema: [
        {
          enum: ["except-parens", "always"]
        }
      ],
      messages: {
        returnAssignment: "Return statement should not contain assignment.",
        arrowAssignment: "Arrow function should not return assignment."
      }
    },
    create(context4) {
      const always = (context4.options[0] || "except-parens") !== "except-parens";
      const sourceCode = context4.getSourceCode();
      return {
        AssignmentExpression(node) {
          if (!always && astUtils.isParenthesised(sourceCode, node)) {
            return;
          }
          let currentChild = node;
          let parent = currentChild.parent;
          while (parent && !SENTINEL_TYPE.test(parent.type)) {
            currentChild = parent;
            parent = parent.parent;
          }
          if (parent && parent.type === "ReturnStatement") {
            context4.report({
              node: parent,
              messageId: "returnAssignment"
            });
          } else if (parent && parent.type === "ArrowFunctionExpression" && parent.body === currentChild) {
            context4.report({
              node: parent,
              messageId: "arrowAssignment"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-return-await.js
var require_no_return_await = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary `return await`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-return-await"
      },
      fixable: null,
      schema: [],
      messages: {
        redundantUseOfAwait: "Redundant use of `await` on a return value."
      }
    },
    create(context4) {
      function reportUnnecessaryAwait(node) {
        context4.report({
          node: context4.getSourceCode().getFirstToken(node),
          loc: node.loc,
          messageId: "redundantUseOfAwait"
        });
      }
      function hasErrorHandler(node) {
        let ancestor = node;
        while (!astUtils.isFunction(ancestor) && ancestor.type !== "Program") {
          if (ancestor.parent.type === "TryStatement" && (ancestor === ancestor.parent.block || ancestor === ancestor.parent.handler && ancestor.parent.finalizer)) {
            return true;
          }
          ancestor = ancestor.parent;
        }
        return false;
      }
      function isInTailCallPosition(node) {
        if (node.parent.type === "ArrowFunctionExpression") {
          return true;
        }
        if (node.parent.type === "ReturnStatement") {
          return !hasErrorHandler(node.parent);
        }
        if (node.parent.type === "ConditionalExpression" && (node === node.parent.consequent || node === node.parent.alternate)) {
          return isInTailCallPosition(node.parent);
        }
        if (node.parent.type === "LogicalExpression" && node === node.parent.right) {
          return isInTailCallPosition(node.parent);
        }
        if (node.parent.type === "SequenceExpression" && node === node.parent.expressions[node.parent.expressions.length - 1]) {
          return isInTailCallPosition(node.parent);
        }
        return false;
      }
      return {
        AwaitExpression(node) {
          if (isInTailCallPosition(node) && !hasErrorHandler(node)) {
            reportUnnecessaryAwait(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-script-url.js
var require_no_script_url = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `javascript:` urls",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-script-url"
      },
      schema: [],
      messages: {
        unexpectedScriptURL: "Script URL is a form of eval."
      }
    },
    create(context4) {
      function check(node) {
        const value = astUtils.getStaticStringValue(node);
        if (typeof value === "string" && value.toLowerCase().indexOf("javascript:") === 0) {
          context4.report({node, messageId: "unexpectedScriptURL"});
        }
      }
      return {
        Literal(node) {
          if (node.value && typeof node.value === "string") {
            check(node);
          }
        },
        TemplateLiteral(node) {
          if (!(node.parent && node.parent.type === "TaggedTemplateExpression")) {
            check(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-self-assign.js
var require_no_self_assign = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var SPACES = /\s+/gu;
  function eachSelfAssignment(left, right, props, report) {
    if (!left || !right) {
    } else if (left.type === "Identifier" && right.type === "Identifier" && left.name === right.name) {
      report(right);
    } else if (left.type === "ArrayPattern" && right.type === "ArrayExpression") {
      const end = Math.min(left.elements.length, right.elements.length);
      for (let i = 0; i < end; ++i) {
        const leftElement = left.elements[i];
        const rightElement = right.elements[i];
        if (leftElement && leftElement.type === "RestElement" && i < right.elements.length - 1) {
          break;
        }
        eachSelfAssignment(leftElement, rightElement, props, report);
        if (rightElement && rightElement.type === "SpreadElement") {
          break;
        }
      }
    } else if (left.type === "RestElement" && right.type === "SpreadElement") {
      eachSelfAssignment(left.argument, right.argument, props, report);
    } else if (left.type === "ObjectPattern" && right.type === "ObjectExpression" && right.properties.length >= 1) {
      let startJ = 0;
      for (let i = right.properties.length - 1; i >= 0; --i) {
        const propType = right.properties[i].type;
        if (propType === "SpreadElement" || propType === "ExperimentalSpreadProperty") {
          startJ = i + 1;
          break;
        }
      }
      for (let i = 0; i < left.properties.length; ++i) {
        for (let j = startJ; j < right.properties.length; ++j) {
          eachSelfAssignment(left.properties[i], right.properties[j], props, report);
        }
      }
    } else if (left.type === "Property" && right.type === "Property" && right.kind === "init" && !right.method) {
      const leftName = astUtils.getStaticPropertyName(left);
      if (leftName !== null && leftName === astUtils.getStaticPropertyName(right)) {
        eachSelfAssignment(left.value, right.value, props, report);
      }
    } else if (props && astUtils.skipChainExpression(left).type === "MemberExpression" && astUtils.skipChainExpression(right).type === "MemberExpression" && astUtils.isSameReference(left, right)) {
      report(right);
    }
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow assignments where both sides are exactly the same",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-self-assign"
      },
      schema: [
        {
          type: "object",
          properties: {
            props: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        selfAssignment: "'{{name}}' is assigned to itself."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const [{props = true} = {}] = context4.options;
      function report(node) {
        context4.report({
          node,
          messageId: "selfAssignment",
          data: {
            name: sourceCode.getText(node).replace(SPACES, "")
          }
        });
      }
      return {
        AssignmentExpression(node) {
          if (node.operator === "=") {
            eachSelfAssignment(node.left, node.right, props, report);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-self-compare.js
var require_no_self_compare = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow comparisons where both sides are exactly the same",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-self-compare"
      },
      schema: [],
      messages: {
        comparingToSelf: "Comparing to itself is potentially pointless."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function hasSameTokens(nodeA, nodeB) {
        const tokensA = sourceCode.getTokens(nodeA);
        const tokensB = sourceCode.getTokens(nodeB);
        return tokensA.length === tokensB.length && tokensA.every((token, index) => token.type === tokensB[index].type && token.value === tokensB[index].value);
      }
      return {
        BinaryExpression(node) {
          const operators = new Set(["===", "==", "!==", "!=", ">", "<", ">=", "<="]);
          if (operators.has(node.operator) && hasSameTokens(node.left, node.right)) {
            context4.report({node, messageId: "comparingToSelf"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-sequences.js
var require_no_sequences = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var DEFAULT_OPTIONS = {
    allowInParentheses: true
  };
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow comma operators",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-sequences"
      },
      schema: [{
        properties: {
          allowInParentheses: {
            type: "boolean",
            default: true
          }
        },
        additionalProperties: false
      }],
      messages: {
        unexpectedCommaExpression: "Unexpected use of comma operator."
      }
    },
    create(context4) {
      const options = Object.assign({}, DEFAULT_OPTIONS, context4.options[0]);
      const sourceCode = context4.getSourceCode();
      const parenthesized = {
        DoWhileStatement: "test",
        IfStatement: "test",
        SwitchStatement: "discriminant",
        WhileStatement: "test",
        WithStatement: "object",
        ArrowFunctionExpression: "body"
      };
      function requiresExtraParens(node) {
        return node.parent && parenthesized[node.parent.type] && node === node.parent[parenthesized[node.parent.type]];
      }
      function isParenthesised(node) {
        return astUtils.isParenthesised(sourceCode, node);
      }
      function isParenthesisedTwice(node) {
        const previousToken = sourceCode.getTokenBefore(node, 1), nextToken = sourceCode.getTokenAfter(node, 1);
        return isParenthesised(node) && previousToken && nextToken && astUtils.isOpeningParenToken(previousToken) && previousToken.range[1] <= node.range[0] && astUtils.isClosingParenToken(nextToken) && nextToken.range[0] >= node.range[1];
      }
      return {
        SequenceExpression(node) {
          if (node.parent.type === "ForStatement" && (node === node.parent.init || node === node.parent.update)) {
            return;
          }
          if (options.allowInParentheses) {
            if (requiresExtraParens(node)) {
              if (isParenthesisedTwice(node)) {
                return;
              }
            } else {
              if (isParenthesised(node)) {
                return;
              }
            }
          }
          const firstCommaToken = sourceCode.getTokenAfter(node.expressions[0], astUtils.isCommaToken);
          context4.report({node, loc: firstCommaToken.loc, messageId: "unexpectedCommaExpression"});
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-setter-return.js
var require_no_setter_return = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var {findVariable} = require_eslint_utils();
  function isGlobalReference(node, scope) {
    const variable = findVariable(scope, node);
    return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
  }
  function isArgumentOfGlobalMethodCall(node, scope, objectName, methodName, index) {
    const callNode = node.parent;
    return callNode.type === "CallExpression" && callNode.arguments[index] === node && astUtils.isSpecificMemberAccess(callNode.callee, objectName, methodName) && isGlobalReference(astUtils.skipChainExpression(callNode.callee).object, scope);
  }
  function isPropertyDescriptor(node, scope) {
    if (isArgumentOfGlobalMethodCall(node, scope, "Object", "defineProperty", 2) || isArgumentOfGlobalMethodCall(node, scope, "Reflect", "defineProperty", 2)) {
      return true;
    }
    const parent = node.parent;
    if (parent.type === "Property" && parent.value === node) {
      const grandparent = parent.parent;
      if (grandparent.type === "ObjectExpression" && (isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "create", 1) || isArgumentOfGlobalMethodCall(grandparent, scope, "Object", "defineProperties", 1))) {
        return true;
      }
    }
    return false;
  }
  function isSetter(node, scope) {
    const parent = node.parent;
    if (parent.kind === "set" && parent.value === node) {
      return true;
    }
    if (parent.type === "Property" && parent.value === node && astUtils.getStaticPropertyName(parent) === "set" && parent.parent.type === "ObjectExpression" && isPropertyDescriptor(parent.parent, scope)) {
      return true;
    }
    return false;
  }
  function getOuterScope(scope) {
    const upper = scope.upper;
    if (upper.type === "function-expression-name") {
      return upper.upper;
    }
    return upper;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow returning values from setters",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-setter-return"
      },
      schema: [],
      messages: {
        returnsValue: "Setter cannot return a value."
      }
    },
    create(context4) {
      let funcInfo = null;
      function enterFunction(node) {
        const outerScope = getOuterScope(context4.getScope());
        funcInfo = {
          upper: funcInfo,
          isSetter: isSetter(node, outerScope)
        };
      }
      function exitFunction() {
        funcInfo = funcInfo.upper;
      }
      function report(node) {
        context4.report({node, messageId: "returnsValue"});
      }
      return {
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression(node) {
          enterFunction(node);
          if (funcInfo.isSetter && node.expression) {
            report(node.body);
          }
        },
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        "ArrowFunctionExpression:exit": exitFunction,
        ReturnStatement(node) {
          if (funcInfo && funcInfo.isSetter && node.argument) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-shadow.js
var require_no_shadow = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow variable declarations from shadowing variables declared in the outer scope",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-shadow"
      },
      schema: [
        {
          type: "object",
          properties: {
            builtinGlobals: {type: "boolean", default: false},
            hoist: {enum: ["all", "functions", "never"], default: "functions"},
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noShadow: "'{{name}}' is already declared in the upper scope on line {{shadowedLine}} column {{shadowedColumn}}.",
        noShadowGlobal: "'{{name}}' is already a global variable."
      }
    },
    create(context4) {
      const options = {
        builtinGlobals: context4.options[0] && context4.options[0].builtinGlobals,
        hoist: context4.options[0] && context4.options[0].hoist || "functions",
        allow: context4.options[0] && context4.options[0].allow || []
      };
      function isAllowed(variable) {
        return options.allow.indexOf(variable.name) !== -1;
      }
      function isDuplicatedClassNameVariable(variable) {
        const block = variable.scope.block;
        return block.type === "ClassDeclaration" && block.id === variable.identifiers[0];
      }
      function isOnInitializer(variable, scopeVar) {
        const outerScope = scopeVar.scope;
        const outerDef = scopeVar.defs[0];
        const outer = outerDef && outerDef.parent && outerDef.parent.range;
        const innerScope = variable.scope;
        const innerDef = variable.defs[0];
        const inner = innerDef && innerDef.name.range;
        return outer && inner && outer[0] < inner[0] && inner[1] < outer[1] && (innerDef.type === "FunctionName" && innerDef.node.type === "FunctionExpression" || innerDef.node.type === "ClassExpression") && outerScope === innerScope.upper;
      }
      function getNameRange(variable) {
        const def = variable.defs[0];
        return def && def.name.range;
      }
      function getDeclaredLocation(variable) {
        const identifier = variable.identifiers[0];
        let obj;
        if (identifier) {
          obj = {
            global: false,
            line: identifier.loc.start.line,
            column: identifier.loc.start.column + 1
          };
        } else {
          obj = {
            global: true
          };
        }
        return obj;
      }
      function isInTdz(variable, scopeVar) {
        const outerDef = scopeVar.defs[0];
        const inner = getNameRange(variable);
        const outer = getNameRange(scopeVar);
        return inner && outer && inner[1] < outer[0] && (options.hoist !== "functions" || !outerDef || outerDef.node.type !== "FunctionDeclaration");
      }
      function checkForShadows(scope) {
        const variables = scope.variables;
        for (let i = 0; i < variables.length; ++i) {
          const variable = variables[i];
          if (variable.identifiers.length === 0 || isDuplicatedClassNameVariable(variable) || isAllowed(variable)) {
            continue;
          }
          const shadowed = astUtils.getVariableByName(scope.upper, variable.name);
          if (shadowed && (shadowed.identifiers.length > 0 || options.builtinGlobals && "writeable" in shadowed) && !isOnInitializer(variable, shadowed) && !(options.hoist !== "all" && isInTdz(variable, shadowed))) {
            const location = getDeclaredLocation(shadowed);
            const messageId = location.global ? "noShadowGlobal" : "noShadow";
            const data = {name: variable.name};
            if (!location.global) {
              data.shadowedLine = location.line;
              data.shadowedColumn = location.column;
            }
            context4.report({
              node: variable.identifiers[0],
              messageId,
              data
            });
          }
        }
      }
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          const stack = globalScope.childScopes.slice();
          while (stack.length) {
            const scope = stack.pop();
            stack.push(...scope.childScopes);
            checkForShadows(scope);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-shadow-restricted-names.js
var require_no_shadow_restricted_names = __commonJS((exports2, module2) => {
  "use strict";
  function safelyShadowsUndefined(variable) {
    return variable.name === "undefined" && variable.references.every((ref) => !ref.isWrite()) && variable.defs.every((def) => def.node.type === "VariableDeclarator" && def.node.init === null);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow identifiers from shadowing restricted names",
        category: "Variables",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-shadow-restricted-names"
      },
      schema: [],
      messages: {
        shadowingRestrictedName: "Shadowing of global property '{{name}}'."
      }
    },
    create(context4) {
      const RESTRICTED = new Set(["undefined", "NaN", "Infinity", "arguments", "eval"]);
      return {
        "VariableDeclaration, :function, CatchClause"(node) {
          for (const variable of context4.getDeclaredVariables(node)) {
            if (variable.defs.length > 0 && RESTRICTED.has(variable.name) && !safelyShadowsUndefined(variable)) {
              context4.report({
                node: variable.defs[0].name,
                messageId: "shadowingRestrictedName",
                data: {
                  name: variable.name
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-spaced-func.js
var require_no_spaced_func = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow spacing between function identifiers and their applications (deprecated)",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-spaced-func"
      },
      deprecated: true,
      replacedBy: ["func-call-spacing"],
      fixable: "whitespace",
      schema: [],
      messages: {
        noSpacedFunction: "Unexpected space between function name and paren."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function detectOpenSpaces(node) {
        const lastCalleeToken = sourceCode.getLastToken(node.callee);
        let prevToken = lastCalleeToken, parenToken = sourceCode.getTokenAfter(lastCalleeToken);
        while (parenToken && parenToken.range[1] < node.range[1] && parenToken.value !== "(") {
          prevToken = parenToken;
          parenToken = sourceCode.getTokenAfter(parenToken);
        }
        if (parenToken && parenToken.range[1] < node.range[1] && sourceCode.isSpaceBetweenTokens(prevToken, parenToken)) {
          context4.report({
            node,
            loc: lastCalleeToken.loc.start,
            messageId: "noSpacedFunction",
            fix(fixer) {
              return fixer.removeRange([prevToken.range[1], parenToken.range[0]]);
            }
          });
        }
      }
      return {
        CallExpression: detectOpenSpaces,
        NewExpression: detectOpenSpaces
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-sparse-arrays.js
var require_no_sparse_arrays = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow sparse arrays",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-sparse-arrays"
      },
      schema: [],
      messages: {
        unexpectedSparseArray: "Unexpected comma in middle of array."
      }
    },
    create(context4) {
      return {
        ArrayExpression(node) {
          const emptySpot = node.elements.indexOf(null) > -1;
          if (emptySpot) {
            context4.report({node, messageId: "unexpectedSparseArray"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-sync.js
var require_no_sync = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      deprecated: true,
      replacedBy: [],
      type: "suggestion",
      docs: {
        description: "disallow synchronous methods",
        category: "Node.js and CommonJS",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-sync"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAtRootLevel: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        noSync: "Unexpected sync method: '{{propertyName}}'."
      }
    },
    create(context4) {
      const selector = context4.options[0] && context4.options[0].allowAtRootLevel ? ":function MemberExpression[property.name=/.*Sync$/]" : "MemberExpression[property.name=/.*Sync$/]";
      return {
        [selector](node) {
          context4.report({
            node,
            messageId: "noSync",
            data: {
              propertyName: node.property.name
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-tabs.js
var require_no_tabs = __commonJS((exports2, module2) => {
  "use strict";
  var tabRegex = /\t+/gu;
  var anyNonWhitespaceRegex = /\S/u;
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow all tabs",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-tabs"
      },
      schema: [{
        type: "object",
        properties: {
          allowIndentationTabs: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      messages: {
        unexpectedTab: "Unexpected tab character."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const allowIndentationTabs = context4.options && context4.options[0] && context4.options[0].allowIndentationTabs;
      return {
        Program(node) {
          sourceCode.getLines().forEach((line, index) => {
            let match;
            while ((match = tabRegex.exec(line)) !== null) {
              if (allowIndentationTabs && !anyNonWhitespaceRegex.test(line.slice(0, match.index))) {
                continue;
              }
              context4.report({
                node,
                loc: {
                  start: {
                    line: index + 1,
                    column: match.index
                  },
                  end: {
                    line: index + 1,
                    column: match.index + match[0].length
                  }
                },
                messageId: "unexpectedTab"
              });
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-template-curly-in-string.js
var require_no_template_curly_in_string = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow template literal placeholder syntax in regular strings",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-template-curly-in-string"
      },
      schema: [],
      messages: {
        unexpectedTemplateExpression: "Unexpected template string expression."
      }
    },
    create(context4) {
      const regex = /\$\{[^}]+\}/u;
      return {
        Literal(node) {
          if (typeof node.value === "string" && regex.test(node.value)) {
            context4.report({
              node,
              messageId: "unexpectedTemplateExpression"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-ternary.js
var require_no_ternary = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow ternary operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-ternary"
      },
      schema: [],
      messages: {
        noTernaryOperator: "Ternary operator used."
      }
    },
    create(context4) {
      return {
        ConditionalExpression(node) {
          context4.report({node, messageId: "noTernaryOperator"});
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-this-before-super.js
var require_no_this_before_super = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isConstructorFunction(node) {
    return node.type === "FunctionExpression" && node.parent.type === "MethodDefinition" && node.parent.kind === "constructor";
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow `this`/`super` before calling `super()` in constructors",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-this-before-super"
      },
      schema: [],
      messages: {
        noBeforeSuper: "'{{kind}}' is not allowed before 'super()'."
      }
    },
    create(context4) {
      let funcInfo = null;
      let segInfoMap = Object.create(null);
      function isCalled(segment) {
        return !segment.reachable || segInfoMap[segment.id].superCalled;
      }
      function isInConstructorOfDerivedClass() {
        return Boolean(funcInfo && funcInfo.isConstructor && funcInfo.hasExtends);
      }
      function isBeforeCallOfSuper() {
        return isInConstructorOfDerivedClass() && !funcInfo.codePath.currentSegments.every(isCalled);
      }
      function setInvalid(node) {
        const segments = funcInfo.codePath.currentSegments;
        for (let i = 0; i < segments.length; ++i) {
          const segment = segments[i];
          if (segment.reachable) {
            segInfoMap[segment.id].invalidNodes.push(node);
          }
        }
      }
      function setSuperCalled() {
        const segments = funcInfo.codePath.currentSegments;
        for (let i = 0; i < segments.length; ++i) {
          const segment = segments[i];
          if (segment.reachable) {
            segInfoMap[segment.id].superCalled = true;
          }
        }
      }
      return {
        onCodePathStart(codePath, node) {
          if (isConstructorFunction(node)) {
            const classNode = node.parent.parent.parent;
            funcInfo = {
              upper: funcInfo,
              isConstructor: true,
              hasExtends: Boolean(classNode.superClass && !astUtils.isNullOrUndefined(classNode.superClass)),
              codePath
            };
          } else {
            funcInfo = {
              upper: funcInfo,
              isConstructor: false,
              hasExtends: false,
              codePath
            };
          }
        },
        onCodePathEnd(codePath) {
          const isDerivedClass = funcInfo.hasExtends;
          funcInfo = funcInfo.upper;
          if (!isDerivedClass) {
            return;
          }
          codePath.traverseSegments((segment, controller) => {
            const info3 = segInfoMap[segment.id];
            for (let i = 0; i < info3.invalidNodes.length; ++i) {
              const invalidNode = info3.invalidNodes[i];
              context4.report({
                messageId: "noBeforeSuper",
                node: invalidNode,
                data: {
                  kind: invalidNode.type === "Super" ? "super" : "this"
                }
              });
            }
            if (info3.superCalled) {
              controller.skip();
            }
          });
        },
        onCodePathSegmentStart(segment) {
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          segInfoMap[segment.id] = {
            superCalled: segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled),
            invalidNodes: []
          };
        },
        onCodePathSegmentLoop(fromSegment, toSegment) {
          if (!isInConstructorOfDerivedClass()) {
            return;
          }
          funcInfo.codePath.traverseSegments({first: toSegment, last: fromSegment}, (segment, controller) => {
            const info3 = segInfoMap[segment.id];
            if (info3.superCalled) {
              info3.invalidNodes = [];
              controller.skip();
            } else if (segment.prevSegments.length > 0 && segment.prevSegments.every(isCalled)) {
              info3.superCalled = true;
              info3.invalidNodes = [];
            }
          });
        },
        ThisExpression(node) {
          if (isBeforeCallOfSuper()) {
            setInvalid(node);
          }
        },
        Super(node) {
          if (!astUtils.isCallee(node) && isBeforeCallOfSuper()) {
            setInvalid(node);
          }
        },
        "CallExpression:exit"(node) {
          if (node.callee.type === "Super" && isBeforeCallOfSuper()) {
            setSuperCalled();
          }
        },
        "Program:exit"() {
          segInfoMap = Object.create(null);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-throw-literal.js
var require_no_throw_literal = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow throwing literals as exceptions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-throw-literal"
      },
      schema: [],
      messages: {
        object: "Expected an error object to be thrown.",
        undef: "Do not throw undefined."
      }
    },
    create(context4) {
      return {
        ThrowStatement(node) {
          if (!astUtils.couldBeError(node.argument)) {
            context4.report({node, messageId: "object"});
          } else if (node.argument.type === "Identifier") {
            if (node.argument.name === "undefined") {
              context4.report({node, messageId: "undef"});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-trailing-spaces.js
var require_no_trailing_spaces = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow trailing whitespace at the end of lines",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-trailing-spaces"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            skipBlankLines: {
              type: "boolean",
              default: false
            },
            ignoreComments: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        trailingSpace: "Trailing spaces not allowed."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const BLANK_CLASS = "[ 	\xA0\u2000-\u200B\u3000]", SKIP_BLANK = `^${BLANK_CLASS}*$`, NONBLANK = `${BLANK_CLASS}+$`;
      const options = context4.options[0] || {}, skipBlankLines = options.skipBlankLines || false, ignoreComments = options.ignoreComments || false;
      function report(node, location, fixRange) {
        context4.report({
          node,
          loc: location,
          messageId: "trailingSpace",
          fix(fixer) {
            return fixer.removeRange(fixRange);
          }
        });
      }
      function getCommentLineNumbers(comments) {
        const lines = new Set();
        comments.forEach((comment) => {
          const endLine = comment.type === "Block" ? comment.loc.end.line - 1 : comment.loc.end.line;
          for (let i = comment.loc.start.line; i <= endLine; i++) {
            lines.add(i);
          }
        });
        return lines;
      }
      return {
        Program: function checkTrailingSpaces(node) {
          const re = new RegExp(NONBLANK, "u"), skipMatch = new RegExp(SKIP_BLANK, "u"), lines = sourceCode.lines, linebreaks = sourceCode.getText().match(astUtils.createGlobalLinebreakMatcher()), comments = sourceCode.getAllComments(), commentLineNumbers = getCommentLineNumbers(comments);
          let totalLength = 0, fixRange = [];
          for (let i = 0, ii = lines.length; i < ii; i++) {
            const lineNumber = i + 1;
            const linebreakLength = linebreaks && linebreaks[i] ? linebreaks[i].length : 1;
            const lineLength = lines[i].length + linebreakLength;
            const matches = re.exec(lines[i]);
            if (matches) {
              const location = {
                start: {
                  line: lineNumber,
                  column: matches.index
                },
                end: {
                  line: lineNumber,
                  column: lineLength - linebreakLength
                }
              };
              const rangeStart = totalLength + location.start.column;
              const rangeEnd = totalLength + location.end.column;
              const containingNode = sourceCode.getNodeByRangeIndex(rangeStart);
              if (containingNode && containingNode.type === "TemplateElement" && rangeStart > containingNode.parent.range[0] && rangeEnd < containingNode.parent.range[1]) {
                totalLength += lineLength;
                continue;
              }
              if (skipBlankLines && skipMatch.test(lines[i])) {
                totalLength += lineLength;
                continue;
              }
              fixRange = [rangeStart, rangeEnd];
              if (!ignoreComments || !commentLineNumbers.has(lineNumber)) {
                report(node, location, fixRange);
              }
            }
            totalLength += lineLength;
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-undef.js
var require_no_undef = __commonJS((exports2, module2) => {
  "use strict";
  function hasTypeOfOperator(node) {
    const parent = node.parent;
    return parent.type === "UnaryExpression" && parent.operator === "typeof";
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow the use of undeclared variables unless mentioned in `/*global */` comments",
        category: "Variables",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-undef"
      },
      schema: [
        {
          type: "object",
          properties: {
            typeof: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        undef: "'{{name}}' is not defined."
      }
    },
    create(context4) {
      const options = context4.options[0];
      const considerTypeOf = options && options.typeof === true || false;
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          globalScope.through.forEach((ref) => {
            const identifier = ref.identifier;
            if (!considerTypeOf && hasTypeOfOperator(identifier)) {
              return;
            }
            context4.report({
              node: identifier,
              messageId: "undef",
              data: identifier
            });
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-undef-init.js
var require_no_undef_init = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow initializing variables to `undefined`",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-undef-init"
      },
      schema: [],
      fixable: "code",
      messages: {
        unnecessaryUndefinedInit: "It's not necessary to initialize '{{name}}' to undefined."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        VariableDeclarator(node) {
          const name = sourceCode.getText(node.id), init = node.init && node.init.name, scope = context4.getScope(), undefinedVar = astUtils.getVariableByName(scope, "undefined"), shadowed = undefinedVar && undefinedVar.defs.length > 0, lastToken = sourceCode.getLastToken(node);
          if (init === "undefined" && node.parent.kind !== "const" && !shadowed) {
            context4.report({
              node,
              messageId: "unnecessaryUndefinedInit",
              data: {name},
              fix(fixer) {
                if (node.parent.kind === "var") {
                  return null;
                }
                if (node.id.type === "ArrayPattern" || node.id.type === "ObjectPattern") {
                  return null;
                }
                if (sourceCode.commentsExistBetween(node.id, lastToken)) {
                  return null;
                }
                return fixer.removeRange([node.id.range[1], node.range[1]]);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-undefined.js
var require_no_undefined = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `undefined` as an identifier",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-undefined"
      },
      schema: [],
      messages: {
        unexpectedUndefined: "Unexpected use of undefined."
      }
    },
    create(context4) {
      function report(node) {
        context4.report({
          node,
          messageId: "unexpectedUndefined"
        });
      }
      function checkScope(scope) {
        const undefinedVar = scope.set.get("undefined");
        if (!undefinedVar) {
          return;
        }
        const references = undefinedVar.references;
        const defs = undefinedVar.defs;
        references.filter((ref) => !ref.init).forEach((ref) => report(ref.identifier));
        defs.forEach((def) => report(def.name));
      }
      return {
        "Program:exit"() {
          const globalScope = context4.getScope();
          const stack = [globalScope];
          while (stack.length) {
            const scope = stack.pop();
            stack.push(...scope.childScopes);
            checkScope(scope);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-underscore-dangle.js
var require_no_underscore_dangle = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow dangling underscores in identifiers",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-underscore-dangle"
      },
      schema: [
        {
          type: "object",
          properties: {
            allow: {
              type: "array",
              items: {
                type: "string"
              }
            },
            allowAfterThis: {
              type: "boolean",
              default: false
            },
            allowAfterSuper: {
              type: "boolean",
              default: false
            },
            allowAfterThisConstructor: {
              type: "boolean",
              default: false
            },
            enforceInMethodNames: {
              type: "boolean",
              default: false
            },
            allowFunctionParams: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedUnderscore: "Unexpected dangling '_' in '{{identifier}}'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const ALLOWED_VARIABLES = options.allow ? options.allow : [];
      const allowAfterThis = typeof options.allowAfterThis !== "undefined" ? options.allowAfterThis : false;
      const allowAfterSuper = typeof options.allowAfterSuper !== "undefined" ? options.allowAfterSuper : false;
      const allowAfterThisConstructor = typeof options.allowAfterThisConstructor !== "undefined" ? options.allowAfterThisConstructor : false;
      const enforceInMethodNames = typeof options.enforceInMethodNames !== "undefined" ? options.enforceInMethodNames : false;
      const allowFunctionParams = typeof options.allowFunctionParams !== "undefined" ? options.allowFunctionParams : true;
      function isAllowed(identifier) {
        return ALLOWED_VARIABLES.some((ident) => ident === identifier);
      }
      function hasDanglingUnderscore(identifier) {
        const len = identifier.length;
        return identifier !== "_" && (identifier[0] === "_" || identifier[len - 1] === "_");
      }
      function isSpecialCaseIdentifierForMemberExpression(identifier) {
        return identifier === "__proto__";
      }
      function isSpecialCaseIdentifierInVariableExpression(identifier) {
        return identifier === "_";
      }
      function isThisConstructorReference(node) {
        return node.object.type === "MemberExpression" && node.object.property.name === "constructor" && node.object.object.type === "ThisExpression";
      }
      function checkForDanglingUnderscoreInFunctionParameters(node) {
        if (!allowFunctionParams) {
          node.params.forEach((param) => {
            const {type} = param;
            let nodeToCheck;
            if (type === "RestElement") {
              nodeToCheck = param.argument;
            } else if (type === "AssignmentPattern") {
              nodeToCheck = param.left;
            } else {
              nodeToCheck = param;
            }
            if (nodeToCheck.type === "Identifier") {
              const identifier = nodeToCheck.name;
              if (hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
                context4.report({
                  node: param,
                  messageId: "unexpectedUnderscore",
                  data: {
                    identifier
                  }
                });
              }
            }
          });
        }
      }
      function checkForDanglingUnderscoreInFunction(node) {
        if (node.type === "FunctionDeclaration" && node.id) {
          const identifier = node.id.name;
          if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
            context4.report({
              node,
              messageId: "unexpectedUnderscore",
              data: {
                identifier
              }
            });
          }
        }
        checkForDanglingUnderscoreInFunctionParameters(node);
      }
      function checkForDanglingUnderscoreInVariableExpression(node) {
        const identifier = node.id.name;
        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !isSpecialCaseIdentifierInVariableExpression(identifier) && !isAllowed(identifier)) {
          context4.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      }
      function checkForDanglingUnderscoreInMemberExpression(node) {
        const identifier = node.property.name, isMemberOfThis = node.object.type === "ThisExpression", isMemberOfSuper = node.object.type === "Super", isMemberOfThisConstructor = isThisConstructorReference(node);
        if (typeof identifier !== "undefined" && hasDanglingUnderscore(identifier) && !(isMemberOfThis && allowAfterThis) && !(isMemberOfSuper && allowAfterSuper) && !(isMemberOfThisConstructor && allowAfterThisConstructor) && !isSpecialCaseIdentifierForMemberExpression(identifier) && !isAllowed(identifier)) {
          context4.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      }
      function checkForDanglingUnderscoreInMethod(node) {
        const identifier = node.key.name;
        const isMethod = node.type === "MethodDefinition" || node.type === "Property" && node.method;
        if (typeof identifier !== "undefined" && enforceInMethodNames && isMethod && hasDanglingUnderscore(identifier) && !isAllowed(identifier)) {
          context4.report({
            node,
            messageId: "unexpectedUnderscore",
            data: {
              identifier
            }
          });
        }
      }
      return {
        FunctionDeclaration: checkForDanglingUnderscoreInFunction,
        VariableDeclarator: checkForDanglingUnderscoreInVariableExpression,
        MemberExpression: checkForDanglingUnderscoreInMemberExpression,
        MethodDefinition: checkForDanglingUnderscoreInMethod,
        Property: checkForDanglingUnderscoreInMethod,
        FunctionExpression: checkForDanglingUnderscoreInFunction,
        ArrowFunctionExpression: checkForDanglingUnderscoreInFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unexpected-multiline.js
var require_no_unexpected_multiline = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow confusing multiline expressions",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unexpected-multiline"
      },
      schema: [],
      messages: {
        function: "Unexpected newline between function and ( of function call.",
        property: "Unexpected newline between object and [ of property access.",
        taggedTemplate: "Unexpected newline between template tag and template literal.",
        division: "Unexpected newline between numerator and division operator."
      }
    },
    create(context4) {
      const REGEX_FLAG_MATCHER = /^[gimsuy]+$/u;
      const sourceCode = context4.getSourceCode();
      function checkForBreakAfter(node, messageId) {
        const openParen = sourceCode.getTokenAfter(node, astUtils.isNotClosingParenToken);
        const nodeExpressionEnd = sourceCode.getTokenBefore(openParen);
        if (openParen.loc.start.line !== nodeExpressionEnd.loc.end.line) {
          context4.report({
            node,
            loc: openParen.loc,
            messageId
          });
        }
      }
      return {
        MemberExpression(node) {
          if (!node.computed || node.optional) {
            return;
          }
          checkForBreakAfter(node.object, "property");
        },
        TaggedTemplateExpression(node) {
          const {quasi} = node;
          const tokenBefore = sourceCode.getTokenBefore(quasi);
          if (tokenBefore.loc.end.line !== quasi.loc.start.line) {
            context4.report({
              node,
              loc: {
                start: quasi.loc.start,
                end: {
                  line: quasi.loc.start.line,
                  column: quasi.loc.start.column + 1
                }
              },
              messageId: "taggedTemplate"
            });
          }
        },
        CallExpression(node) {
          if (node.arguments.length === 0 || node.optional) {
            return;
          }
          checkForBreakAfter(node.callee, "function");
        },
        "BinaryExpression[operator='/'] > BinaryExpression[operator='/'].left"(node) {
          const secondSlash = sourceCode.getTokenAfter(node, (token) => token.value === "/");
          const tokenAfterOperator = sourceCode.getTokenAfter(secondSlash);
          if (tokenAfterOperator.type === "Identifier" && REGEX_FLAG_MATCHER.test(tokenAfterOperator.value) && secondSlash.range[1] === tokenAfterOperator.range[0]) {
            checkForBreakAfter(node.left, "division");
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unmodified-loop-condition.js
var require_no_unmodified_loop_condition = __commonJS((exports2, module2) => {
  "use strict";
  var Traverser = require_traverser();
  var astUtils = require_ast_utils2();
  var SENTINEL_PATTERN = /(?:(?:Call|Class|Function|Member|New|Yield)Expression|Statement|Declaration)$/u;
  var LOOP_PATTERN = /^(?:DoWhile|For|While)Statement$/u;
  var GROUP_PATTERN = /^(?:BinaryExpression|ConditionalExpression)$/u;
  var SKIP_PATTERN = /^(?:ArrowFunction|Class|Function)Expression$/u;
  var DYNAMIC_PATTERN = /^(?:Call|Member|New|TaggedTemplate|Yield)Expression$/u;
  function isWriteReference(reference) {
    if (reference.init) {
      const def = reference.resolved && reference.resolved.defs[0];
      if (!def || def.type !== "Variable" || def.parent.kind !== "var") {
        return false;
      }
    }
    return reference.isWrite();
  }
  function isUnmodified(condition) {
    return !condition.modified;
  }
  function isUnmodifiedAndNotBelongToGroup(condition) {
    return !(condition.modified || condition.group);
  }
  function isInRange(node, reference) {
    const or = node.range;
    const ir = reference.identifier.range;
    return or[0] <= ir[0] && ir[1] <= or[1];
  }
  var isInLoop = {
    WhileStatement: isInRange,
    DoWhileStatement: isInRange,
    ForStatement(node, reference) {
      return isInRange(node, reference) && !(node.init && isInRange(node.init, reference));
    }
  };
  function getEncloseFunctionDeclaration(reference) {
    let node = reference.identifier;
    while (node) {
      if (node.type === "FunctionDeclaration") {
        return node.id ? node : null;
      }
      node = node.parent;
    }
    return null;
  }
  function updateModifiedFlag(conditions, modifiers) {
    for (let i = 0; i < conditions.length; ++i) {
      const condition = conditions[i];
      for (let j = 0; !condition.modified && j < modifiers.length; ++j) {
        const modifier = modifiers[j];
        let funcNode, funcVar;
        const inLoop = condition.isInLoop(modifier) || Boolean((funcNode = getEncloseFunctionDeclaration(modifier)) && (funcVar = astUtils.getVariableByName(modifier.from.upper, funcNode.id.name)) && funcVar.references.some(condition.isInLoop));
        condition.modified = inLoop;
      }
    }
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow unmodified loop conditions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-unmodified-loop-condition"
      },
      schema: [],
      messages: {
        loopConditionNotModified: "'{{name}}' is not modified in this loop."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let groupMap = null;
      function report(condition) {
        const node = condition.reference.identifier;
        context4.report({
          node,
          messageId: "loopConditionNotModified",
          data: node
        });
      }
      function registerConditionsToGroup(conditions) {
        for (let i = 0; i < conditions.length; ++i) {
          const condition = conditions[i];
          if (condition.group) {
            let group = groupMap.get(condition.group);
            if (!group) {
              group = [];
              groupMap.set(condition.group, group);
            }
            group.push(condition);
          }
        }
      }
      function checkConditionsInGroup(conditions) {
        if (conditions.every(isUnmodified)) {
          conditions.forEach(report);
        }
      }
      function hasDynamicExpressions(root) {
        let retv = false;
        Traverser.traverse(root, {
          visitorKeys: sourceCode.visitorKeys,
          enter(node) {
            if (DYNAMIC_PATTERN.test(node.type)) {
              retv = true;
              this.break();
            } else if (SKIP_PATTERN.test(node.type)) {
              this.skip();
            }
          }
        });
        return retv;
      }
      function toLoopCondition(reference) {
        if (reference.init) {
          return null;
        }
        let group = null;
        let child = reference.identifier;
        let node = child.parent;
        while (node) {
          if (SENTINEL_PATTERN.test(node.type)) {
            if (LOOP_PATTERN.test(node.type) && node.test === child) {
              return {
                reference,
                group,
                isInLoop: isInLoop[node.type].bind(null, node),
                modified: false
              };
            }
            break;
          }
          if (GROUP_PATTERN.test(node.type)) {
            if (hasDynamicExpressions(node)) {
              break;
            } else {
              group = node;
            }
          }
          child = node;
          node = node.parent;
        }
        return null;
      }
      function checkReferences(variable) {
        const conditions = variable.references.map(toLoopCondition).filter(Boolean);
        if (conditions.length === 0) {
          return;
        }
        registerConditionsToGroup(conditions);
        const modifiers = variable.references.filter(isWriteReference);
        if (modifiers.length > 0) {
          updateModifiedFlag(conditions, modifiers);
        }
        conditions.filter(isUnmodifiedAndNotBelongToGroup).forEach(report);
      }
      return {
        "Program:exit"() {
          const queue = [context4.getScope()];
          groupMap = new Map();
          let scope;
          while (scope = queue.pop()) {
            queue.push(...scope.childScopes);
            scope.variables.forEach(checkReferences);
          }
          groupMap.forEach(checkConditionsInGroup);
          groupMap = null;
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unneeded-ternary.js
var require_no_unneeded_ternary = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var BOOLEAN_OPERATORS = new Set(["==", "===", "!=", "!==", ">", ">=", "<", "<=", "in", "instanceof"]);
  var OPERATOR_INVERSES = {
    "==": "!=",
    "!=": "==",
    "===": "!==",
    "!==": "==="
  };
  var OR_PRECEDENCE = astUtils.getPrecedence({type: "LogicalExpression", operator: "||"});
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow ternary operators when simpler alternatives exist",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-unneeded-ternary"
      },
      schema: [
        {
          type: "object",
          properties: {
            defaultAssignment: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        unnecessaryConditionalExpression: "Unnecessary use of boolean literals in conditional expression.",
        unnecessaryConditionalAssignment: "Unnecessary use of conditional expression for default assignment."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const defaultAssignment = options.defaultAssignment !== false;
      const sourceCode = context4.getSourceCode();
      function isBooleanLiteral(node) {
        return node.type === "Literal" && typeof node.value === "boolean";
      }
      function invertExpression(node) {
        if (node.type === "BinaryExpression" && Object.prototype.hasOwnProperty.call(OPERATOR_INVERSES, node.operator)) {
          const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
          const text = sourceCode.getText();
          return text.slice(node.range[0], operatorToken.range[0]) + OPERATOR_INVERSES[node.operator] + text.slice(operatorToken.range[1], node.range[1]);
        }
        if (astUtils.getPrecedence(node) < astUtils.getPrecedence({type: "UnaryExpression"})) {
          return `!(${astUtils.getParenthesisedText(sourceCode, node)})`;
        }
        return `!${astUtils.getParenthesisedText(sourceCode, node)}`;
      }
      function isBooleanExpression(node) {
        return node.type === "BinaryExpression" && BOOLEAN_OPERATORS.has(node.operator) || node.type === "UnaryExpression" && node.operator === "!";
      }
      function matchesDefaultAssignment(node) {
        return node.test.type === "Identifier" && node.consequent.type === "Identifier" && node.test.name === node.consequent.name;
      }
      return {
        ConditionalExpression(node) {
          if (isBooleanLiteral(node.alternate) && isBooleanLiteral(node.consequent)) {
            context4.report({
              node,
              messageId: "unnecessaryConditionalExpression",
              fix(fixer) {
                if (node.consequent.value === node.alternate.value) {
                  return node.test.type === "Identifier" ? fixer.replaceText(node, node.consequent.value.toString()) : null;
                }
                if (node.alternate.value) {
                  return fixer.replaceText(node, invertExpression(node.test));
                }
                return fixer.replaceText(node, isBooleanExpression(node.test) ? astUtils.getParenthesisedText(sourceCode, node.test) : `!${invertExpression(node.test)}`);
              }
            });
          } else if (!defaultAssignment && matchesDefaultAssignment(node)) {
            context4.report({
              node,
              messageId: "unnecessaryConditionalAssignment",
              fix: (fixer) => {
                const shouldParenthesizeAlternate = (astUtils.getPrecedence(node.alternate) < OR_PRECEDENCE || astUtils.isCoalesceExpression(node.alternate)) && !astUtils.isParenthesised(sourceCode, node.alternate);
                const alternateText = shouldParenthesizeAlternate ? `(${sourceCode.getText(node.alternate)})` : astUtils.getParenthesisedText(sourceCode, node.alternate);
                const testText = astUtils.getParenthesisedText(sourceCode, node.test);
                return fixer.replaceText(node, `${testText} || ${alternateText}`);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unreachable.js
var require_no_unreachable = __commonJS((exports2, module2) => {
  "use strict";
  function isInitialized(node) {
    return Boolean(node.init);
  }
  function isUnreachable(segment) {
    return !segment.reachable;
  }
  var ConsecutiveRange = class {
    constructor(sourceCode) {
      this.sourceCode = sourceCode;
      this.startNode = null;
      this.endNode = null;
    }
    get location() {
      return {
        start: this.startNode.loc.start,
        end: this.endNode.loc.end
      };
    }
    get isEmpty() {
      return !(this.startNode && this.endNode);
    }
    contains(node) {
      return node.range[0] >= this.startNode.range[0] && node.range[1] <= this.endNode.range[1];
    }
    isConsecutive(node) {
      return this.contains(this.sourceCode.getTokenBefore(node));
    }
    merge(node) {
      this.endNode = node;
    }
    reset(node) {
      this.startNode = this.endNode = node;
    }
  };
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow unreachable code after `return`, `throw`, `continue`, and `break` statements",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unreachable"
      },
      schema: [],
      messages: {
        unreachableCode: "Unreachable code."
      }
    },
    create(context4) {
      let currentCodePath = null;
      const range = new ConsecutiveRange(context4.getSourceCode());
      function reportIfUnreachable(node) {
        let nextNode = null;
        if (node && currentCodePath.currentSegments.every(isUnreachable)) {
          if (range.isEmpty) {
            range.reset(node);
            return;
          }
          if (range.contains(node)) {
            return;
          }
          if (range.isConsecutive(node)) {
            range.merge(node);
            return;
          }
          nextNode = node;
        }
        if (!range.isEmpty) {
          context4.report({
            messageId: "unreachableCode",
            loc: range.location,
            node: range.startNode
          });
        }
        range.reset(nextNode);
      }
      return {
        onCodePathStart(codePath) {
          currentCodePath = codePath;
        },
        onCodePathEnd() {
          currentCodePath = currentCodePath.upper;
        },
        BlockStatement: reportIfUnreachable,
        BreakStatement: reportIfUnreachable,
        ClassDeclaration: reportIfUnreachable,
        ContinueStatement: reportIfUnreachable,
        DebuggerStatement: reportIfUnreachable,
        DoWhileStatement: reportIfUnreachable,
        ExpressionStatement: reportIfUnreachable,
        ForInStatement: reportIfUnreachable,
        ForOfStatement: reportIfUnreachable,
        ForStatement: reportIfUnreachable,
        IfStatement: reportIfUnreachable,
        ImportDeclaration: reportIfUnreachable,
        LabeledStatement: reportIfUnreachable,
        ReturnStatement: reportIfUnreachable,
        SwitchStatement: reportIfUnreachable,
        ThrowStatement: reportIfUnreachable,
        TryStatement: reportIfUnreachable,
        VariableDeclaration(node) {
          if (node.kind !== "var" || node.declarations.some(isInitialized)) {
            reportIfUnreachable(node);
          }
        },
        WhileStatement: reportIfUnreachable,
        WithStatement: reportIfUnreachable,
        ExportNamedDeclaration: reportIfUnreachable,
        ExportDefaultDeclaration: reportIfUnreachable,
        ExportAllDeclaration: reportIfUnreachable,
        "Program:exit"() {
          reportIfUnreachable();
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unreachable-loop.js
var require_no_unreachable_loop = __commonJS((exports2, module2) => {
  "use strict";
  var allLoopTypes = ["WhileStatement", "DoWhileStatement", "ForStatement", "ForInStatement", "ForOfStatement"];
  function isLoopingTarget(node) {
    const parent = node.parent;
    if (parent) {
      switch (parent.type) {
        case "WhileStatement":
          return node === parent.test;
        case "DoWhileStatement":
          return node === parent.body;
        case "ForStatement":
          return node === (parent.update || parent.test || parent.body);
        case "ForInStatement":
        case "ForOfStatement":
          return node === parent.left;
      }
    }
    return false;
  }
  function getDifference(arrA, arrB) {
    return arrA.filter((a) => !arrB.includes(a));
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow loops with a body that allows only one iteration",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-unreachable-loop"
      },
      schema: [{
        type: "object",
        properties: {
          ignore: {
            type: "array",
            items: {
              enum: allLoopTypes
            },
            uniqueItems: true
          }
        },
        additionalProperties: false
      }],
      messages: {
        invalid: "Invalid loop. Its body allows only one iteration."
      }
    },
    create(context4) {
      const ignoredLoopTypes = context4.options[0] && context4.options[0].ignore || [], loopTypesToCheck = getDifference(allLoopTypes, ignoredLoopTypes), loopSelector = loopTypesToCheck.join(","), loopsByTargetSegments = new Map(), loopsToReport = new Set();
      let currentCodePath = null;
      return {
        onCodePathStart(codePath) {
          currentCodePath = codePath;
        },
        onCodePathEnd() {
          currentCodePath = currentCodePath.upper;
        },
        [loopSelector](node) {
          if (currentCodePath.currentSegments.some((segment) => segment.reachable)) {
            loopsToReport.add(node);
          }
        },
        onCodePathSegmentStart(segment, node) {
          if (isLoopingTarget(node)) {
            const loop = node.parent;
            loopsByTargetSegments.set(segment, loop);
          }
        },
        onCodePathSegmentLoop(_, toSegment, node) {
          const loop = loopsByTargetSegments.get(toSegment);
          if (node === loop || node.type === "ContinueStatement") {
            loopsToReport.delete(loop);
          }
        },
        "Program:exit"() {
          loopsToReport.forEach((node) => context4.report({node, messageId: "invalid"}));
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unsafe-finally.js
var require_no_unsafe_finally = __commonJS((exports2, module2) => {
  "use strict";
  var SENTINEL_NODE_TYPE_RETURN_THROW = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression)$/u;
  var SENTINEL_NODE_TYPE_BREAK = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement|SwitchStatement)$/u;
  var SENTINEL_NODE_TYPE_CONTINUE = /^(?:Program|(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|DoWhileStatement|WhileStatement|ForOfStatement|ForInStatement|ForStatement)$/u;
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow control flow statements in `finally` blocks",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unsafe-finally"
      },
      schema: [],
      messages: {
        unsafeUsage: "Unsafe usage of {{nodeType}}."
      }
    },
    create(context4) {
      function isFinallyBlock(node) {
        return node.parent.type === "TryStatement" && node.parent.finalizer === node;
      }
      function isInFinallyBlock(node, label) {
        let labelInside = false;
        let sentinelNodeType;
        if (node.type === "BreakStatement" && !node.label) {
          sentinelNodeType = SENTINEL_NODE_TYPE_BREAK;
        } else if (node.type === "ContinueStatement") {
          sentinelNodeType = SENTINEL_NODE_TYPE_CONTINUE;
        } else {
          sentinelNodeType = SENTINEL_NODE_TYPE_RETURN_THROW;
        }
        for (let currentNode = node; currentNode && !sentinelNodeType.test(currentNode.type); currentNode = currentNode.parent) {
          if (currentNode.parent.label && label && currentNode.parent.label.name === label.name) {
            labelInside = true;
          }
          if (isFinallyBlock(currentNode)) {
            if (label && labelInside) {
              return false;
            }
            return true;
          }
        }
        return false;
      }
      function check(node) {
        if (isInFinallyBlock(node, node.label)) {
          context4.report({
            messageId: "unsafeUsage",
            data: {
              nodeType: node.type
            },
            node,
            line: node.loc.line,
            column: node.loc.column
          });
        }
      }
      return {
        ReturnStatement: check,
        ThrowStatement: check,
        BreakStatement: check,
        ContinueStatement: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unsafe-negation.js
var require_no_unsafe_negation = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isInOrInstanceOfOperator(op) {
    return op === "in" || op === "instanceof";
  }
  function isOrderingRelationalOperator(op) {
    return op === "<" || op === ">" || op === ">=" || op === "<=";
  }
  function isNegation(node) {
    return node.type === "UnaryExpression" && node.operator === "!";
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow negating the left operand of relational operators",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unsafe-negation",
        suggestion: true
      },
      schema: [
        {
          type: "object",
          properties: {
            enforceForOrderingRelations: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: null,
      messages: {
        unexpected: "Unexpected negating the left operand of '{{operator}}' operator.",
        suggestNegatedExpression: "Negate '{{operator}}' expression instead of its left operand. This changes the current behavior.",
        suggestParenthesisedNegation: "Wrap negation in '()' to make the intention explicit. This preserves the current behavior."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = context4.options[0] || {};
      const enforceForOrderingRelations = options.enforceForOrderingRelations === true;
      return {
        BinaryExpression(node) {
          const operator = node.operator;
          const orderingRelationRuleApplies = enforceForOrderingRelations && isOrderingRelationalOperator(operator);
          if ((isInOrInstanceOfOperator(operator) || orderingRelationRuleApplies) && isNegation(node.left) && !astUtils.isParenthesised(sourceCode, node.left)) {
            context4.report({
              node,
              loc: node.left.loc,
              messageId: "unexpected",
              data: {operator},
              suggest: [
                {
                  messageId: "suggestNegatedExpression",
                  data: {operator},
                  fix(fixer) {
                    const negationToken = sourceCode.getFirstToken(node.left);
                    const fixRange = [negationToken.range[1], node.range[1]];
                    const text = sourceCode.text.slice(fixRange[0], fixRange[1]);
                    return fixer.replaceTextRange(fixRange, `(${text})`);
                  }
                },
                {
                  messageId: "suggestParenthesisedNegation",
                  fix(fixer) {
                    return fixer.replaceText(node.left, `(${sourceCode.getText(node.left)})`);
                  }
                }
              ]
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unsafe-optional-chaining.js
var require_no_unsafe_optional_chaining = __commonJS((exports2, module2) => {
  "use strict";
  var UNSAFE_ARITHMETIC_OPERATORS = new Set(["+", "-", "/", "*", "%", "**"]);
  var UNSAFE_ASSIGNMENT_OPERATORS = new Set(["+=", "-=", "/=", "*=", "%=", "**="]);
  var UNSAFE_RELATIONAL_OPERATORS = new Set(["in", "instanceof"]);
  function isDestructuringPattern(node) {
    return node.type === "ObjectPattern" || node.type === "ArrayPattern";
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow use of optional chaining in contexts where the `undefined` value is not allowed",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-unsafe-optional-chaining"
      },
      schema: [{
        type: "object",
        properties: {
          disallowArithmeticOperators: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      fixable: null,
      messages: {
        unsafeOptionalChain: "Unsafe usage of optional chaining. If it short-circuits with 'undefined' the evaluation will throw TypeError.",
        unsafeArithmetic: "Unsafe arithmetic operation on optional chaining. It can result in NaN."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const disallowArithmeticOperators = options.disallowArithmeticOperators || false;
      function reportUnsafeUsage(node) {
        context4.report({
          messageId: "unsafeOptionalChain",
          node
        });
      }
      function reportUnsafeArithmetic(node) {
        context4.report({
          messageId: "unsafeArithmetic",
          node
        });
      }
      function checkUndefinedShortCircuit(node, reportFunc) {
        if (!node) {
          return;
        }
        switch (node.type) {
          case "LogicalExpression":
            if (node.operator === "||" || node.operator === "??") {
              checkUndefinedShortCircuit(node.right, reportFunc);
            } else if (node.operator === "&&") {
              checkUndefinedShortCircuit(node.left, reportFunc);
              checkUndefinedShortCircuit(node.right, reportFunc);
            }
            break;
          case "SequenceExpression":
            checkUndefinedShortCircuit(node.expressions[node.expressions.length - 1], reportFunc);
            break;
          case "ConditionalExpression":
            checkUndefinedShortCircuit(node.consequent, reportFunc);
            checkUndefinedShortCircuit(node.alternate, reportFunc);
            break;
          case "AwaitExpression":
            checkUndefinedShortCircuit(node.argument, reportFunc);
            break;
          case "ChainExpression":
            reportFunc(node);
            break;
          default:
            break;
        }
      }
      function checkUnsafeUsage(node) {
        checkUndefinedShortCircuit(node, reportUnsafeUsage);
      }
      function checkUnsafeArithmetic(node) {
        checkUndefinedShortCircuit(node, reportUnsafeArithmetic);
      }
      return {
        "AssignmentExpression, AssignmentPattern"(node) {
          if (isDestructuringPattern(node.left)) {
            checkUnsafeUsage(node.right);
          }
        },
        "ClassDeclaration, ClassExpression"(node) {
          checkUnsafeUsage(node.superClass);
        },
        CallExpression(node) {
          if (!node.optional) {
            checkUnsafeUsage(node.callee);
          }
        },
        NewExpression(node) {
          checkUnsafeUsage(node.callee);
        },
        VariableDeclarator(node) {
          if (isDestructuringPattern(node.id)) {
            checkUnsafeUsage(node.init);
          }
        },
        MemberExpression(node) {
          if (!node.optional) {
            checkUnsafeUsage(node.object);
          }
        },
        TaggedTemplateExpression(node) {
          checkUnsafeUsage(node.tag);
        },
        ForOfStatement(node) {
          checkUnsafeUsage(node.right);
        },
        SpreadElement(node) {
          if (node.parent && node.parent.type !== "ObjectExpression") {
            checkUnsafeUsage(node.argument);
          }
        },
        BinaryExpression(node) {
          if (UNSAFE_RELATIONAL_OPERATORS.has(node.operator)) {
            checkUnsafeUsage(node.right);
          }
          if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
            checkUnsafeArithmetic(node.right);
            checkUnsafeArithmetic(node.left);
          }
        },
        WithStatement(node) {
          checkUnsafeUsage(node.object);
        },
        UnaryExpression(node) {
          if (disallowArithmeticOperators && UNSAFE_ARITHMETIC_OPERATORS.has(node.operator)) {
            checkUnsafeArithmetic(node.argument);
          }
        },
        AssignmentExpression(node) {
          if (disallowArithmeticOperators && UNSAFE_ASSIGNMENT_OPERATORS.has(node.operator)) {
            checkUnsafeArithmetic(node.right);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unused-expressions.js
var require_no_unused_expressions = __commonJS((exports2, module2) => {
  "use strict";
  function alwaysTrue() {
    return true;
  }
  function alwaysFalse() {
    return false;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unused expressions",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-unused-expressions"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowShortCircuit: {
              type: "boolean",
              default: false
            },
            allowTernary: {
              type: "boolean",
              default: false
            },
            allowTaggedTemplates: {
              type: "boolean",
              default: false
            },
            enforceForJSX: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unusedExpression: "Expected an assignment or function call and instead saw an expression."
      }
    },
    create(context4) {
      const config = context4.options[0] || {}, allowShortCircuit = config.allowShortCircuit || false, allowTernary = config.allowTernary || false, allowTaggedTemplates = config.allowTaggedTemplates || false, enforceForJSX = config.enforceForJSX || false;
      function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
      }
      function takeWhile(predicate, list) {
        for (let i = 0; i < list.length; ++i) {
          if (!predicate(list[i])) {
            return list.slice(0, i);
          }
        }
        return list.slice();
      }
      function directives(node) {
        return takeWhile(looksLikeDirective, node.body);
      }
      function isDirective(node, ancestors) {
        const parent = ancestors[ancestors.length - 1], grandparent = ancestors[ancestors.length - 2];
        return (parent.type === "Program" || parent.type === "BlockStatement" && /Function/u.test(grandparent.type)) && directives(parent).indexOf(node) >= 0;
      }
      const Checker = Object.assign(Object.create(null), {
        isDisallowed(node) {
          return (Checker[node.type] || alwaysFalse)(node);
        },
        ArrayExpression: alwaysTrue,
        ArrowFunctionExpression: alwaysTrue,
        BinaryExpression: alwaysTrue,
        ChainExpression(node) {
          return Checker.isDisallowed(node.expression);
        },
        ClassExpression: alwaysTrue,
        ConditionalExpression(node) {
          if (allowTernary) {
            return Checker.isDisallowed(node.consequent) || Checker.isDisallowed(node.alternate);
          }
          return true;
        },
        FunctionExpression: alwaysTrue,
        Identifier: alwaysTrue,
        JSXElement() {
          return enforceForJSX;
        },
        JSXFragment() {
          return enforceForJSX;
        },
        Literal: alwaysTrue,
        LogicalExpression(node) {
          if (allowShortCircuit) {
            return Checker.isDisallowed(node.right);
          }
          return true;
        },
        MemberExpression: alwaysTrue,
        MetaProperty: alwaysTrue,
        ObjectExpression: alwaysTrue,
        SequenceExpression: alwaysTrue,
        TaggedTemplateExpression() {
          return !allowTaggedTemplates;
        },
        TemplateLiteral: alwaysTrue,
        ThisExpression: alwaysTrue,
        UnaryExpression(node) {
          return node.operator !== "void" && node.operator !== "delete";
        }
      });
      return {
        ExpressionStatement(node) {
          if (Checker.isDisallowed(node.expression) && !isDirective(node, context4.getAncestors())) {
            context4.report({node, messageId: "unusedExpression"});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unused-labels.js
var require_no_unused_labels = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unused labels",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unused-labels"
      },
      schema: [],
      fixable: "code",
      messages: {
        unused: "'{{name}}:' is defined but never used."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let scopeInfo = null;
      function enterLabeledScope(node) {
        scopeInfo = {
          label: node.label.name,
          used: false,
          upper: scopeInfo
        };
      }
      function exitLabeledScope(node) {
        if (!scopeInfo.used) {
          context4.report({
            node: node.label,
            messageId: "unused",
            data: node.label,
            fix(fixer) {
              if (sourceCode.getTokenAfter(node.label, {includeComments: true}) === sourceCode.getTokenBefore(node.body, {includeComments: true})) {
                return fixer.removeRange([node.range[0], node.body.range[0]]);
              }
              return null;
            }
          });
        }
        scopeInfo = scopeInfo.upper;
      }
      function markAsUsed(node) {
        if (!node.label) {
          return;
        }
        const label = node.label.name;
        let info3 = scopeInfo;
        while (info3) {
          if (info3.label === label) {
            info3.used = true;
            break;
          }
          info3 = info3.upper;
        }
      }
      return {
        LabeledStatement: enterLabeledScope,
        "LabeledStatement:exit": exitLabeledScope,
        BreakStatement: markAsUsed,
        ContinueStatement: markAsUsed
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-unused-vars.js
var require_no_unused_vars = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow unused variables",
        category: "Variables",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-unused-vars"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["all", "local"]
            },
            {
              type: "object",
              properties: {
                vars: {
                  enum: ["all", "local"]
                },
                varsIgnorePattern: {
                  type: "string"
                },
                args: {
                  enum: ["all", "after-used", "none"]
                },
                ignoreRestSiblings: {
                  type: "boolean"
                },
                argsIgnorePattern: {
                  type: "string"
                },
                caughtErrors: {
                  enum: ["all", "none"]
                },
                caughtErrorsIgnorePattern: {
                  type: "string"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unusedVar: "'{{varName}}' is {{action}} but never used{{additional}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const REST_PROPERTY_TYPE = /^(?:RestElement|(?:Experimental)?RestProperty)$/u;
      const config = {
        vars: "all",
        args: "after-used",
        ignoreRestSiblings: false,
        caughtErrors: "none"
      };
      const firstOption = context4.options[0];
      if (firstOption) {
        if (typeof firstOption === "string") {
          config.vars = firstOption;
        } else {
          config.vars = firstOption.vars || config.vars;
          config.args = firstOption.args || config.args;
          config.ignoreRestSiblings = firstOption.ignoreRestSiblings || config.ignoreRestSiblings;
          config.caughtErrors = firstOption.caughtErrors || config.caughtErrors;
          if (firstOption.varsIgnorePattern) {
            config.varsIgnorePattern = new RegExp(firstOption.varsIgnorePattern, "u");
          }
          if (firstOption.argsIgnorePattern) {
            config.argsIgnorePattern = new RegExp(firstOption.argsIgnorePattern, "u");
          }
          if (firstOption.caughtErrorsIgnorePattern) {
            config.caughtErrorsIgnorePattern = new RegExp(firstOption.caughtErrorsIgnorePattern, "u");
          }
        }
      }
      function getDefinedMessageData(unusedVar) {
        const defType = unusedVar.defs && unusedVar.defs[0] && unusedVar.defs[0].type;
        let type;
        let pattern;
        if (defType === "CatchClause" && config.caughtErrorsIgnorePattern) {
          type = "args";
          pattern = config.caughtErrorsIgnorePattern.toString();
        } else if (defType === "Parameter" && config.argsIgnorePattern) {
          type = "args";
          pattern = config.argsIgnorePattern.toString();
        } else if (defType !== "Parameter" && config.varsIgnorePattern) {
          type = "vars";
          pattern = config.varsIgnorePattern.toString();
        }
        const additional = type ? `. Allowed unused ${type} must match ${pattern}` : "";
        return {
          varName: unusedVar.name,
          action: "defined",
          additional
        };
      }
      function getAssignedMessageData(unusedVar) {
        const additional = config.varsIgnorePattern ? `. Allowed unused vars must match ${config.varsIgnorePattern.toString()}` : "";
        return {
          varName: unusedVar.name,
          action: "assigned a value",
          additional
        };
      }
      const STATEMENT_TYPE = /(?:Statement|Declaration)$/u;
      function isExported(variable) {
        const definition = variable.defs[0];
        if (definition) {
          let node = definition.node;
          if (node.type === "VariableDeclarator") {
            node = node.parent;
          } else if (definition.type === "Parameter") {
            return false;
          }
          return node.parent.type.indexOf("Export") === 0;
        }
        return false;
      }
      function hasRestSpreadSibling(variable) {
        if (config.ignoreRestSiblings) {
          return variable.defs.some((def) => {
            const propertyNode = def.name.parent;
            const patternNode = propertyNode.parent;
            return propertyNode.type === "Property" && patternNode.type === "ObjectPattern" && REST_PROPERTY_TYPE.test(patternNode.properties[patternNode.properties.length - 1].type);
          });
        }
        return false;
      }
      function isReadRef(ref) {
        return ref.isRead();
      }
      function isSelfReference(ref, nodes) {
        let scope = ref.from;
        while (scope) {
          if (nodes.indexOf(scope.block) >= 0) {
            return true;
          }
          scope = scope.upper;
        }
        return false;
      }
      function getFunctionDefinitions(variable) {
        const functionDefinitions = [];
        variable.defs.forEach((def) => {
          const {type, node} = def;
          if (type === "FunctionName") {
            functionDefinitions.push(node);
          }
          if (type === "Variable" && node.init && (node.init.type === "FunctionExpression" || node.init.type === "ArrowFunctionExpression")) {
            functionDefinitions.push(node.init);
          }
        });
        return functionDefinitions;
      }
      function isInside(inner, outer) {
        return inner.range[0] >= outer.range[0] && inner.range[1] <= outer.range[1];
      }
      function getRhsNode(ref, prevRhsNode) {
        const id = ref.identifier;
        const parent = id.parent;
        const grandparent = parent.parent;
        const refScope = ref.from.variableScope;
        const varScope = ref.resolved.scope.variableScope;
        const canBeUsedLater = refScope !== varScope || astUtils.isInLoop(id);
        if (prevRhsNode && isInside(id, prevRhsNode)) {
          return prevRhsNode;
        }
        if (parent.type === "AssignmentExpression" && grandparent.type === "ExpressionStatement" && id === parent.left && !canBeUsedLater) {
          return parent.right;
        }
        return null;
      }
      function isStorableFunction(funcNode, rhsNode) {
        let node = funcNode;
        let parent = funcNode.parent;
        while (parent && isInside(parent, rhsNode)) {
          switch (parent.type) {
            case "SequenceExpression":
              if (parent.expressions[parent.expressions.length - 1] !== node) {
                return false;
              }
              break;
            case "CallExpression":
            case "NewExpression":
              return parent.callee !== node;
            case "AssignmentExpression":
            case "TaggedTemplateExpression":
            case "YieldExpression":
              return true;
            default:
              if (STATEMENT_TYPE.test(parent.type)) {
                return true;
              }
          }
          node = parent;
          parent = parent.parent;
        }
        return false;
      }
      function isInsideOfStorableFunction(id, rhsNode) {
        const funcNode = astUtils.getUpperFunction(id);
        return funcNode && isInside(funcNode, rhsNode) && isStorableFunction(funcNode, rhsNode);
      }
      function isReadForItself(ref, rhsNode) {
        const id = ref.identifier;
        const parent = id.parent;
        const grandparent = parent.parent;
        return ref.isRead() && (parent.type === "AssignmentExpression" && grandparent.type === "ExpressionStatement" && parent.left === id || parent.type === "UpdateExpression" && grandparent.type === "ExpressionStatement" || rhsNode && isInside(id, rhsNode) && !isInsideOfStorableFunction(id, rhsNode));
      }
      function isForInRef(ref) {
        let target = ref.identifier.parent;
        if (target.type === "VariableDeclarator") {
          target = target.parent.parent;
        }
        if (target.type !== "ForInStatement") {
          return false;
        }
        if (target.body.type === "BlockStatement") {
          target = target.body.body[0];
        } else {
          target = target.body;
        }
        if (!target) {
          return false;
        }
        return target.type === "ReturnStatement";
      }
      function isUsedVariable(variable) {
        const functionNodes = getFunctionDefinitions(variable), isFunctionDefinition = functionNodes.length > 0;
        let rhsNode = null;
        return variable.references.some((ref) => {
          if (isForInRef(ref)) {
            return true;
          }
          const forItself = isReadForItself(ref, rhsNode);
          rhsNode = getRhsNode(ref, rhsNode);
          return isReadRef(ref) && !forItself && !(isFunctionDefinition && isSelfReference(ref, functionNodes));
        });
      }
      function isAfterLastUsedArg(variable) {
        const def = variable.defs[0];
        const params = context4.getDeclaredVariables(def.node);
        const posteriorParams = params.slice(params.indexOf(variable) + 1);
        return !posteriorParams.some((v) => v.references.length > 0 || v.eslintUsed);
      }
      function collectUnusedVariables(scope, unusedVars) {
        const variables = scope.variables;
        const childScopes = scope.childScopes;
        let i, l;
        if (scope.type !== "global" || config.vars === "all") {
          for (i = 0, l = variables.length; i < l; ++i) {
            const variable = variables[i];
            if (scope.type === "class" && scope.block.id === variable.identifiers[0]) {
              continue;
            }
            if (scope.functionExpressionScope || variable.eslintUsed) {
              continue;
            }
            if (scope.type === "function" && variable.name === "arguments" && variable.identifiers.length === 0) {
              continue;
            }
            const def = variable.defs[0];
            if (def) {
              const type = def.type;
              if (type === "CatchClause") {
                if (config.caughtErrors === "none") {
                  continue;
                }
                if (config.caughtErrorsIgnorePattern && config.caughtErrorsIgnorePattern.test(def.name.name)) {
                  continue;
                }
              }
              if (type === "Parameter") {
                if ((def.node.parent.type === "Property" || def.node.parent.type === "MethodDefinition") && def.node.parent.kind === "set") {
                  continue;
                }
                if (config.args === "none") {
                  continue;
                }
                if (config.argsIgnorePattern && config.argsIgnorePattern.test(def.name.name)) {
                  continue;
                }
                if (config.args === "after-used" && astUtils.isFunction(def.name.parent) && !isAfterLastUsedArg(variable)) {
                  continue;
                }
              } else {
                if (config.varsIgnorePattern && config.varsIgnorePattern.test(def.name.name)) {
                  continue;
                }
              }
            }
            if (!isUsedVariable(variable) && !isExported(variable) && !hasRestSpreadSibling(variable)) {
              unusedVars.push(variable);
            }
          }
        }
        for (i = 0, l = childScopes.length; i < l; ++i) {
          collectUnusedVariables(childScopes[i], unusedVars);
        }
        return unusedVars;
      }
      return {
        "Program:exit"(programNode) {
          const unusedVars = collectUnusedVariables(context4.getScope(), []);
          for (let i = 0, l = unusedVars.length; i < l; ++i) {
            const unusedVar = unusedVars[i];
            if (unusedVar.defs.length > 0) {
              context4.report({
                node: unusedVar.references.length ? unusedVar.references[unusedVar.references.length - 1].identifier : unusedVar.identifiers[0],
                messageId: "unusedVar",
                data: unusedVar.references.some((ref) => ref.isWrite()) ? getAssignedMessageData(unusedVar) : getDefinedMessageData(unusedVar)
              });
            } else if (unusedVar.eslintExplicitGlobalComments) {
              const directiveComment = unusedVar.eslintExplicitGlobalComments[0];
              context4.report({
                node: programNode,
                loc: astUtils.getNameLocationInGlobalDirectiveComment(sourceCode, directiveComment, unusedVar.name),
                messageId: "unusedVar",
                data: getDefinedMessageData(unusedVar)
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-use-before-define.js
var require_no_use_before_define = __commonJS((exports2, module2) => {
  "use strict";
  var SENTINEL_TYPE = /^(?:(?:Function|Class)(?:Declaration|Expression)|ArrowFunctionExpression|CatchClause|ImportDeclaration|ExportNamedDeclaration)$/u;
  var FOR_IN_OF_TYPE = /^For(?:In|Of)Statement$/u;
  function parseOptions(options) {
    let functions = true;
    let classes = true;
    let variables = true;
    if (typeof options === "string") {
      functions = options !== "nofunc";
    } else if (typeof options === "object" && options !== null) {
      functions = options.functions !== false;
      classes = options.classes !== false;
      variables = options.variables !== false;
    }
    return {functions, classes, variables};
  }
  function isFunction(variable) {
    return variable.defs[0].type === "FunctionName";
  }
  function isOuterClass(variable, reference) {
    return variable.defs[0].type === "ClassName" && variable.scope.variableScope !== reference.from.variableScope;
  }
  function isOuterVariable(variable, reference) {
    return variable.defs[0].type === "Variable" && variable.scope.variableScope !== reference.from.variableScope;
  }
  function isInRange(node, location) {
    return node && node.range[0] <= location && location <= node.range[1];
  }
  function isInInitializer(variable, reference) {
    if (variable.scope !== reference.from) {
      return false;
    }
    let node = variable.identifiers[0].parent;
    const location = reference.identifier.range[1];
    while (node) {
      if (node.type === "VariableDeclarator") {
        if (isInRange(node.init, location)) {
          return true;
        }
        if (FOR_IN_OF_TYPE.test(node.parent.parent.type) && isInRange(node.parent.parent.right, location)) {
          return true;
        }
        break;
      } else if (node.type === "AssignmentPattern") {
        if (isInRange(node.right, location)) {
          return true;
        }
      } else if (SENTINEL_TYPE.test(node.type)) {
        break;
      }
      node = node.parent;
    }
    return false;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow the use of variables before they are defined",
        category: "Variables",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-use-before-define"
      },
      schema: [
        {
          oneOf: [
            {
              enum: ["nofunc"]
            },
            {
              type: "object",
              properties: {
                functions: {type: "boolean"},
                classes: {type: "boolean"},
                variables: {type: "boolean"}
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        usedBeforeDefined: "'{{name}}' was used before it was defined."
      }
    },
    create(context4) {
      const options = parseOptions(context4.options[0]);
      function isForbidden(variable, reference) {
        if (isFunction(variable)) {
          return options.functions;
        }
        if (isOuterClass(variable, reference)) {
          return options.classes;
        }
        if (isOuterVariable(variable, reference)) {
          return options.variables;
        }
        return true;
      }
      function findVariablesInScope(scope) {
        scope.references.forEach((reference) => {
          const variable = reference.resolved;
          if (reference.init || !variable || variable.identifiers.length === 0 || variable.identifiers[0].range[1] < reference.identifier.range[1] && !isInInitializer(variable, reference) || !isForbidden(variable, reference)) {
            return;
          }
          context4.report({
            node: reference.identifier,
            messageId: "usedBeforeDefined",
            data: reference.identifier
          });
        });
        scope.childScopes.forEach(findVariablesInScope);
      }
      return {
        Program() {
          findVariablesInScope(context4.getScope());
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-backreference.js
var require_no_useless_backreference = __commonJS((exports2, module2) => {
  "use strict";
  var {CALL, CONSTRUCT, ReferenceTracker, getStringIfConstant} = require_eslint_utils();
  var {RegExpParser, visitRegExpAST} = require_regexpp();
  var lodash = require_lodash();
  var parser = new RegExpParser();
  function getPathToRoot(node) {
    const path3 = [];
    let current = node;
    do {
      path3.push(current);
      current = current.parent;
    } while (current);
    return path3;
  }
  function isLookaround(node) {
    return node.type === "Assertion" && (node.kind === "lookahead" || node.kind === "lookbehind");
  }
  function isNegativeLookaround(node) {
    return isLookaround(node) && node.negate;
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow useless backreferences in regular expressions",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-backreference"
      },
      schema: [],
      messages: {
        nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
        forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
        backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
        disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
        intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround."
      }
    },
    create(context4) {
      function checkRegex(node, pattern, flags) {
        let regExpAST;
        try {
          regExpAST = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
        } catch (e) {
          return;
        }
        visitRegExpAST(regExpAST, {
          onBackreferenceEnter(bref) {
            const group = bref.resolved, brefPath = getPathToRoot(bref), groupPath = getPathToRoot(group);
            let messageId = null;
            if (brefPath.includes(group)) {
              messageId = "nested";
            } else {
              let i = brefPath.length - 1, j = groupPath.length - 1;
              do {
                i--;
                j--;
              } while (brefPath[i] === groupPath[j]);
              const indexOfLowestCommonAncestor = j + 1, groupCut = groupPath.slice(0, indexOfLowestCommonAncestor), commonPath = groupPath.slice(indexOfLowestCommonAncestor), lowestCommonLookaround = commonPath.find(isLookaround), isMatchingBackward = lowestCommonLookaround && lowestCommonLookaround.kind === "lookbehind";
              if (!isMatchingBackward && bref.end <= group.start) {
                messageId = "forward";
              } else if (isMatchingBackward && group.end <= bref.start) {
                messageId = "backward";
              } else if (lodash.last(groupCut).type === "Alternative") {
                messageId = "disjunctive";
              } else if (groupCut.some(isNegativeLookaround)) {
                messageId = "intoNegativeLookaround";
              }
            }
            if (messageId) {
              context4.report({
                node,
                messageId,
                data: {
                  bref: bref.raw,
                  group: group.raw
                }
              });
            }
          }
        });
      }
      return {
        "Literal[regex]"(node) {
          const {pattern, flags} = node.regex;
          checkRegex(node, pattern, flags);
        },
        Program() {
          const scope = context4.getScope(), tracker = new ReferenceTracker(scope), traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const {node} of tracker.iterateGlobalReferences(traceMap)) {
            const [patternNode, flagsNode] = node.arguments, pattern = getStringIfConstant(patternNode, scope), flags = getStringIfConstant(flagsNode, scope);
            if (typeof pattern === "string") {
              checkRegex(node, pattern, flags || "");
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-call.js
var require_no_useless_call = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isCallOrNonVariadicApply(node) {
    const callee = astUtils.skipChainExpression(node.callee);
    return callee.type === "MemberExpression" && callee.property.type === "Identifier" && callee.computed === false && (callee.property.name === "call" && node.arguments.length >= 1 || callee.property.name === "apply" && node.arguments.length === 2 && node.arguments[1].type === "ArrayExpression");
  }
  function isValidThisArg(expectedThis, thisArg, sourceCode) {
    if (!expectedThis) {
      return astUtils.isNullOrUndefined(thisArg);
    }
    return astUtils.equalTokens(expectedThis, thisArg, sourceCode);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary calls to `.call()` and `.apply()`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-call"
      },
      schema: [],
      messages: {
        unnecessaryCall: "Unnecessary '.{{name}}()'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        CallExpression(node) {
          if (!isCallOrNonVariadicApply(node)) {
            return;
          }
          const callee = astUtils.skipChainExpression(node.callee);
          const applied = astUtils.skipChainExpression(callee.object);
          const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
          const thisArg = node.arguments[0];
          if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
            context4.report({node, messageId: "unnecessaryCall", data: {name: callee.property.name}});
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-catch.js
var require_no_useless_catch = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary `catch` clauses",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-useless-catch"
      },
      schema: [],
      messages: {
        unnecessaryCatchClause: "Unnecessary catch clause.",
        unnecessaryCatch: "Unnecessary try/catch wrapper."
      }
    },
    create(context4) {
      return {
        CatchClause(node) {
          if (node.param && node.param.type === "Identifier" && node.body.body.length && node.body.body[0].type === "ThrowStatement" && node.body.body[0].argument.type === "Identifier" && node.body.body[0].argument.name === node.param.name) {
            if (node.parent.finalizer) {
              context4.report({
                node,
                messageId: "unnecessaryCatchClause"
              });
            } else {
              context4.report({
                node: node.parent,
                messageId: "unnecessaryCatch"
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-computed-key.js
var require_no_useless_computed_key = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary computed property keys in objects and classes",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-computed-key"
      },
      schema: [{
        type: "object",
        properties: {
          enforceForClassMembers: {
            type: "boolean",
            default: false
          }
        },
        additionalProperties: false
      }],
      fixable: "code",
      messages: {
        unnecessarilyComputedProperty: "Unnecessarily computed property [{{property}}] found."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const enforceForClassMembers = context4.options[0] && context4.options[0].enforceForClassMembers;
      function check(node) {
        if (!node.computed) {
          return;
        }
        const key = node.key, nodeType = typeof key.value;
        let allowedKey;
        if (node.type === "MethodDefinition") {
          allowedKey = node.static ? "prototype" : "constructor";
        } else {
          allowedKey = "__proto__";
        }
        if (key.type === "Literal" && (nodeType === "string" || nodeType === "number") && key.value !== allowedKey) {
          context4.report({
            node,
            messageId: "unnecessarilyComputedProperty",
            data: {property: sourceCode.getText(key)},
            fix(fixer) {
              const leftSquareBracket = sourceCode.getTokenBefore(key, astUtils.isOpeningBracketToken);
              const rightSquareBracket = sourceCode.getTokenAfter(key, astUtils.isClosingBracketToken);
              if (sourceCode.commentsExistBetween(leftSquareBracket, rightSquareBracket)) {
                return null;
              }
              const tokenBeforeLeftBracket = sourceCode.getTokenBefore(leftSquareBracket);
              const needsSpaceBeforeKey = tokenBeforeLeftBracket.range[1] === leftSquareBracket.range[0] && !astUtils.canTokensBeAdjacent(tokenBeforeLeftBracket, sourceCode.getFirstToken(key));
              const replacementKey = (needsSpaceBeforeKey ? " " : "") + key.raw;
              return fixer.replaceTextRange([leftSquareBracket.range[0], rightSquareBracket.range[1]], replacementKey);
            }
          });
        }
      }
      return {
        Property: check,
        MethodDefinition: enforceForClassMembers ? check : lodash.noop
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-concat.js
var require_no_useless_concat = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
  }
  function isConcatOperatorToken(token) {
    return token.value === "+" && token.type === "Punctuator";
  }
  function getLeft(node) {
    let left = node.left;
    while (isConcatenation(left)) {
      left = left.right;
    }
    return left;
  }
  function getRight(node) {
    let right = node.right;
    while (isConcatenation(right)) {
      right = right.left;
    }
    return right;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary concatenation of literals or template literals",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-concat"
      },
      schema: [],
      messages: {
        unexpectedConcat: "Unexpected string concatenation of literals."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        BinaryExpression(node) {
          if (node.operator !== "+") {
            return;
          }
          const left = getLeft(node);
          const right = getRight(node);
          if (astUtils.isStringLiteral(left) && astUtils.isStringLiteral(right) && astUtils.isTokenOnSameLine(left, right)) {
            const operatorToken = sourceCode.getFirstTokenBetween(left, right, isConcatOperatorToken);
            context4.report({
              node,
              loc: operatorToken.loc,
              messageId: "unexpectedConcat"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-constructor.js
var require_no_useless_constructor = __commonJS((exports2, module2) => {
  "use strict";
  function isSingleSuperCall(body) {
    return body.length === 1 && body[0].type === "ExpressionStatement" && body[0].expression.type === "CallExpression" && body[0].expression.callee.type === "Super";
  }
  function isSimple(node) {
    return node.type === "Identifier" || node.type === "RestElement";
  }
  function isSpreadArguments(superArgs) {
    return superArgs.length === 1 && superArgs[0].type === "SpreadElement" && superArgs[0].argument.type === "Identifier" && superArgs[0].argument.name === "arguments";
  }
  function isValidIdentifierPair(ctorParam, superArg) {
    return ctorParam.type === "Identifier" && superArg.type === "Identifier" && ctorParam.name === superArg.name;
  }
  function isValidRestSpreadPair(ctorParam, superArg) {
    return ctorParam.type === "RestElement" && superArg.type === "SpreadElement" && isValidIdentifierPair(ctorParam.argument, superArg.argument);
  }
  function isValidPair(ctorParam, superArg) {
    return isValidIdentifierPair(ctorParam, superArg) || isValidRestSpreadPair(ctorParam, superArg);
  }
  function isPassingThrough(ctorParams, superArgs) {
    if (ctorParams.length !== superArgs.length) {
      return false;
    }
    for (let i = 0; i < ctorParams.length; ++i) {
      if (!isValidPair(ctorParams[i], superArgs[i])) {
        return false;
      }
    }
    return true;
  }
  function isRedundantSuperCall(body, ctorParams) {
    return isSingleSuperCall(body) && ctorParams.every(isSimple) && (isSpreadArguments(body[0].expression.arguments) || isPassingThrough(ctorParams, body[0].expression.arguments));
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary constructors",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-constructor"
      },
      schema: [],
      messages: {
        noUselessConstructor: "Useless constructor."
      }
    },
    create(context4) {
      function checkForConstructor(node) {
        if (node.kind !== "constructor") {
          return;
        }
        if (!node.value.body) {
          return;
        }
        const body = node.value.body.body;
        const ctorParams = node.value.params;
        const superClass = node.parent.parent.superClass;
        if (superClass ? isRedundantSuperCall(body, ctorParams) : body.length === 0) {
          context4.report({
            node,
            messageId: "noUselessConstructor"
          });
        }
      }
      return {
        MethodDefinition: checkForConstructor
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-escape.js
var require_no_useless_escape = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function union(setA, setB) {
    return new Set(function* () {
      yield* setA;
      yield* setB;
    }());
  }
  var VALID_STRING_ESCAPES = union(new Set("\\nrvtbfux"), astUtils.LINEBREAKS);
  var REGEX_GENERAL_ESCAPES = new Set("\\bcdDfnpPrsStvwWxu0123456789]");
  var REGEX_NON_CHARCLASS_ESCAPES = union(REGEX_GENERAL_ESCAPES, new Set("^/.$*+?[{}|()Bk"));
  function parseRegExp(regExpText) {
    const charList = [];
    regExpText.split("").reduce((state, char, index) => {
      if (!state.escapeNextChar) {
        if (char === "\\") {
          return Object.assign(state, {escapeNextChar: true});
        }
        if (char === "[" && !state.inCharClass) {
          return Object.assign(state, {inCharClass: true, startingCharClass: true});
        }
        if (char === "]" && state.inCharClass) {
          if (charList.length && charList[charList.length - 1].inCharClass) {
            charList[charList.length - 1].endsCharClass = true;
          }
          return Object.assign(state, {inCharClass: false, startingCharClass: false});
        }
      }
      charList.push({
        text: char,
        index,
        escaped: state.escapeNextChar,
        inCharClass: state.inCharClass,
        startsCharClass: state.startingCharClass,
        endsCharClass: false
      });
      return Object.assign(state, {escapeNextChar: false, startingCharClass: false});
    }, {escapeNextChar: false, inCharClass: false, startingCharClass: false});
    return charList;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow unnecessary escape characters",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-useless-escape",
        suggestion: true
      },
      messages: {
        unnecessaryEscape: "Unnecessary escape character: \\{{character}}.",
        removeEscape: "Remove the `\\`. This maintains the current functionality.",
        escapeBackslash: "Replace the `\\` with `\\\\` to include the actual backslash character."
      },
      schema: []
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function report(node, startOffset, character) {
        const rangeStart = node.range[0] + startOffset;
        const range = [rangeStart, rangeStart + 1];
        const start = sourceCode.getLocFromIndex(rangeStart);
        context4.report({
          node,
          loc: {
            start,
            end: {line: start.line, column: start.column + 1}
          },
          messageId: "unnecessaryEscape",
          data: {character},
          suggest: [
            {
              messageId: "removeEscape",
              fix(fixer) {
                return fixer.removeRange(range);
              }
            },
            {
              messageId: "escapeBackslash",
              fix(fixer) {
                return fixer.insertTextBeforeRange(range, "\\");
              }
            }
          ]
        });
      }
      function validateString(node, match) {
        const isTemplateElement = node.type === "TemplateElement";
        const escapedChar = match[0][1];
        let isUnnecessaryEscape = !VALID_STRING_ESCAPES.has(escapedChar);
        let isQuoteEscape;
        if (isTemplateElement) {
          isQuoteEscape = escapedChar === "`";
          if (escapedChar === "$") {
            isUnnecessaryEscape = match.input[match.index + 2] !== "{";
          } else if (escapedChar === "{") {
            isUnnecessaryEscape = match.input[match.index - 1] !== "$";
          }
        } else {
          isQuoteEscape = escapedChar === node.raw[0];
        }
        if (isUnnecessaryEscape && !isQuoteEscape) {
          report(node, match.index, match[0].slice(1));
        }
      }
      function check(node) {
        const isTemplateElement = node.type === "TemplateElement";
        if (isTemplateElement && node.parent && node.parent.parent && node.parent.parent.type === "TaggedTemplateExpression" && node.parent === node.parent.parent.quasi) {
          return;
        }
        if (typeof node.value === "string" || isTemplateElement) {
          if (node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment") {
            return;
          }
          const value = isTemplateElement ? sourceCode.getText(node) : node.raw;
          const pattern = /\\[^\d]/gu;
          let match;
          while (match = pattern.exec(value)) {
            validateString(node, match);
          }
        } else if (node.regex) {
          parseRegExp(node.regex.pattern).filter((charInfo) => !(charInfo.text === "-" && charInfo.inCharClass && !charInfo.startsCharClass && !charInfo.endsCharClass)).filter((charInfo) => !(charInfo.text === "^" && charInfo.startsCharClass)).filter((charInfo) => charInfo.escaped).filter((charInfo) => !(charInfo.inCharClass ? REGEX_GENERAL_ESCAPES : REGEX_NON_CHARCLASS_ESCAPES).has(charInfo.text)).forEach((charInfo) => report(node, charInfo.index, charInfo.text));
        }
      }
      return {
        Literal: check,
        TemplateElement: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-rename.js
var require_no_useless_rename = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow renaming import, export, and destructured assignments to the same name",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-rename"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            ignoreDestructuring: {type: "boolean", default: false},
            ignoreImport: {type: "boolean", default: false},
            ignoreExport: {type: "boolean", default: false}
          },
          additionalProperties: false
        }
      ],
      messages: {
        unnecessarilyRenamed: "{{type}} {{name}} unnecessarily renamed."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode(), options = context4.options[0] || {}, ignoreDestructuring = options.ignoreDestructuring === true, ignoreImport = options.ignoreImport === true, ignoreExport = options.ignoreExport === true;
      function reportError(node, initial, type) {
        const name = initial.type === "Identifier" ? initial.name : initial.value;
        return context4.report({
          node,
          messageId: "unnecessarilyRenamed",
          data: {
            name,
            type
          },
          fix(fixer) {
            const replacementNode = node.type === "Property" ? node.value : node.local;
            if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(replacementNode).length) {
              return null;
            }
            if (replacementNode.type === "AssignmentPattern" && astUtils.isParenthesised(sourceCode, replacementNode.left)) {
              return null;
            }
            return fixer.replaceText(node, sourceCode.getText(replacementNode));
          }
        });
      }
      function checkDestructured(node) {
        if (ignoreDestructuring) {
          return;
        }
        for (const property of node.properties) {
          if (property.type !== "Property" || property.shorthand || property.computed) {
            continue;
          }
          const key = property.key.type === "Identifier" && property.key.name || property.key.type === "Literal" && property.key.value;
          const renamedKey = property.value.type === "AssignmentPattern" ? property.value.left.name : property.value.name;
          if (key === renamedKey) {
            reportError(property, property.key, "Destructuring assignment");
          }
        }
      }
      function checkImport(node) {
        if (ignoreImport) {
          return;
        }
        if (node.imported.name === node.local.name && node.imported.range[0] !== node.local.range[0]) {
          reportError(node, node.imported, "Import");
        }
      }
      function checkExport(node) {
        if (ignoreExport) {
          return;
        }
        if (node.local.name === node.exported.name && node.local.range[0] !== node.exported.range[0]) {
          reportError(node, node.local, "Export");
        }
      }
      return {
        ObjectPattern: checkDestructured,
        ImportSpecifier: checkImport,
        ExportSpecifier: checkExport
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-useless-return.js
var require_no_useless_return = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var FixTracker = require_fix_tracker();
  function remove(array, element) {
    const index = array.indexOf(element);
    if (index !== -1) {
      array.splice(index, 1);
    }
  }
  function isRemovable(node) {
    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
  }
  function isInFinally(node) {
    for (let currentNode = node; currentNode && currentNode.parent && !astUtils.isFunction(currentNode); currentNode = currentNode.parent) {
      if (currentNode.parent.type === "TryStatement" && currentNode.parent.finalizer === currentNode) {
        return true;
      }
    }
    return false;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow redundant return statements",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-useless-return"
      },
      fixable: "code",
      schema: [],
      messages: {
        unnecessaryReturn: "Unnecessary return statement."
      }
    },
    create(context4) {
      const segmentInfoMap = new WeakMap();
      const usedUnreachableSegments = new WeakSet();
      const sourceCode = context4.getSourceCode();
      let scopeInfo = null;
      function isReturned(segment) {
        const info3 = segmentInfoMap.get(segment);
        return !info3 || info3.returned;
      }
      function getUselessReturns(uselessReturns, prevSegments, providedTraversedSegments) {
        const traversedSegments = providedTraversedSegments || new WeakSet();
        for (const segment of prevSegments) {
          if (!segment.reachable) {
            if (!traversedSegments.has(segment)) {
              traversedSegments.add(segment);
              getUselessReturns(uselessReturns, segment.allPrevSegments.filter(isReturned), traversedSegments);
            }
            continue;
          }
          uselessReturns.push(...segmentInfoMap.get(segment).uselessReturns);
        }
        return uselessReturns;
      }
      function markReturnStatementsOnSegmentAsUsed(segment) {
        if (!segment.reachable) {
          usedUnreachableSegments.add(segment);
          segment.allPrevSegments.filter(isReturned).filter((prevSegment) => !usedUnreachableSegments.has(prevSegment)).forEach(markReturnStatementsOnSegmentAsUsed);
          return;
        }
        const info3 = segmentInfoMap.get(segment);
        for (const node of info3.uselessReturns) {
          remove(scopeInfo.uselessReturns, node);
        }
        info3.uselessReturns = [];
      }
      function markReturnStatementsOnCurrentSegmentsAsUsed() {
        scopeInfo.codePath.currentSegments.forEach(markReturnStatementsOnSegmentAsUsed);
      }
      return {
        onCodePathStart(codePath) {
          scopeInfo = {
            upper: scopeInfo,
            uselessReturns: [],
            codePath
          };
        },
        onCodePathEnd() {
          for (const node of scopeInfo.uselessReturns) {
            context4.report({
              node,
              loc: node.loc,
              messageId: "unnecessaryReturn",
              fix(fixer) {
                if (isRemovable(node) && !sourceCode.getCommentsInside(node).length) {
                  return new FixTracker(fixer, sourceCode).retainEnclosingFunction(node).remove(node);
                }
                return null;
              }
            });
          }
          scopeInfo = scopeInfo.upper;
        },
        onCodePathSegmentStart(segment) {
          const info3 = {
            uselessReturns: getUselessReturns([], segment.allPrevSegments),
            returned: false
          };
          segmentInfoMap.set(segment, info3);
        },
        ReturnStatement(node) {
          if (node.argument) {
            markReturnStatementsOnCurrentSegmentsAsUsed();
          }
          if (node.argument || astUtils.isInLoop(node) || isInFinally(node) || !scopeInfo.codePath.currentSegments.some((s) => s.reachable)) {
            return;
          }
          for (const segment of scopeInfo.codePath.currentSegments) {
            const info3 = segmentInfoMap.get(segment);
            if (info3) {
              info3.uselessReturns.push(node);
              info3.returned = true;
            }
          }
          scopeInfo.uselessReturns.push(node);
        },
        ClassDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ContinueStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DebuggerStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        DoWhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        EmptyStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExpressionStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForInStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForOfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ForStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        IfStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ImportDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        LabeledStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        SwitchStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ThrowStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        TryStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        VariableDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        WhileStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        WithStatement: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportNamedDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportDefaultDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed,
        ExportAllDeclaration: markReturnStatementsOnCurrentSegmentsAsUsed
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-var.js
var require_no_var = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isGlobal(variable) {
    return Boolean(variable.scope) && variable.scope.type === "global";
  }
  function getEnclosingFunctionScope(scope) {
    let currentScope = scope;
    while (currentScope.type !== "function" && currentScope.type !== "global") {
      currentScope = currentScope.upper;
    }
    return currentScope;
  }
  function isReferencedInClosure(variable) {
    const enclosingFunctionScope = getEnclosingFunctionScope(variable.scope);
    return variable.references.some((reference) => getEnclosingFunctionScope(reference.from) !== enclosingFunctionScope);
  }
  function isLoopAssignee(node) {
    return (node.parent.type === "ForOfStatement" || node.parent.type === "ForInStatement") && node === node.parent.left;
  }
  function isDeclarationInitialized(node) {
    return node.declarations.every((declarator) => declarator.init !== null);
  }
  var SCOPE_NODE_TYPE = /^(?:Program|BlockStatement|SwitchStatement|ForStatement|ForInStatement|ForOfStatement)$/u;
  function getScopeNode(node) {
    for (let currentNode = node; currentNode; currentNode = currentNode.parent) {
      if (SCOPE_NODE_TYPE.test(currentNode.type)) {
        return currentNode;
      }
    }
    return null;
  }
  function isRedeclared(variable) {
    return variable.defs.length >= 2;
  }
  function isUsedFromOutsideOf(scopeNode) {
    function isOutsideOfScope(reference) {
      const scope = scopeNode.range;
      const id = reference.identifier.range;
      return id[0] < scope[0] || id[1] > scope[1];
    }
    return function(variable) {
      return variable.references.some(isOutsideOfScope);
    };
  }
  function hasReferenceInTDZ(node) {
    const initStart = node.range[0];
    const initEnd = node.range[1];
    return (variable) => {
      const id = variable.defs[0].name;
      const idStart = id.range[0];
      const defaultValue = id.parent.type === "AssignmentPattern" ? id.parent.right : null;
      const defaultStart = defaultValue && defaultValue.range[0];
      const defaultEnd = defaultValue && defaultValue.range[1];
      return variable.references.some((reference) => {
        const start = reference.identifier.range[0];
        const end = reference.identifier.range[1];
        return !reference.init && (start < idStart || defaultValue !== null && start >= defaultStart && end <= defaultEnd || start >= initStart && end <= initEnd);
      });
    };
  }
  function hasNameDisallowedForLetDeclarations(variable) {
    return variable.name === "let";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `let` or `const` instead of `var`",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-var"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedVar: "Unexpected var, use let or const instead."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function hasSelfReferenceInTDZ(declarator) {
        if (!declarator.init) {
          return false;
        }
        const variables = context4.getDeclaredVariables(declarator);
        return variables.some(hasReferenceInTDZ(declarator.init));
      }
      function canFix(node) {
        const variables = context4.getDeclaredVariables(node);
        const scopeNode = getScopeNode(node);
        if (node.parent.type === "SwitchCase" || node.declarations.some(hasSelfReferenceInTDZ) || variables.some(isGlobal) || variables.some(isRedeclared) || variables.some(isUsedFromOutsideOf(scopeNode)) || variables.some(hasNameDisallowedForLetDeclarations)) {
          return false;
        }
        if (astUtils.isInLoop(node)) {
          if (variables.some(isReferencedInClosure)) {
            return false;
          }
          if (!isLoopAssignee(node) && !isDeclarationInitialized(node)) {
            return false;
          }
        }
        if (!isLoopAssignee(node) && !(node.parent.type === "ForStatement" && node.parent.init === node) && !astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type)) {
          return false;
        }
        return true;
      }
      function report(node) {
        context4.report({
          node,
          messageId: "unexpectedVar",
          fix(fixer) {
            const varToken = sourceCode.getFirstToken(node, {filter: (t) => t.value === "var"});
            return canFix(node) ? fixer.replaceText(varToken, "let") : null;
          }
        });
      }
      return {
        "VariableDeclaration:exit"(node) {
          if (node.kind === "var") {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-void.js
var require_no_void = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `void` operators",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-void"
      },
      messages: {
        noVoid: "Expected 'undefined' and instead saw 'void'."
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAsStatement: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ]
    },
    create(context4) {
      const allowAsStatement = context4.options[0] && context4.options[0].allowAsStatement;
      return {
        'UnaryExpression[operator="void"]'(node) {
          if (allowAsStatement && node.parent && node.parent.type === "ExpressionStatement") {
            return;
          }
          context4.report({
            node,
            messageId: "noVoid"
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-warning-comments.js
var require_no_warning_comments = __commonJS((exports2, module2) => {
  "use strict";
  var {escapeRegExp} = require_lodash();
  var astUtils = require_ast_utils2();
  var CHAR_LIMIT = 40;
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow specified warning terms in comments",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-warning-comments"
      },
      schema: [
        {
          type: "object",
          properties: {
            terms: {
              type: "array",
              items: {
                type: "string"
              }
            },
            location: {
              enum: ["start", "anywhere"]
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedComment: "Unexpected '{{matchedTerm}}' comment: '{{comment}}'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode(), configuration = context4.options[0] || {}, warningTerms = configuration.terms || ["todo", "fixme", "xxx"], location = configuration.location || "start", selfConfigRegEx = /\bno-warning-comments\b/u;
      function convertToRegExp(term) {
        const escaped = escapeRegExp(term);
        const wordBoundary = "\\b";
        const eitherOrWordBoundary = `|${wordBoundary}`;
        let prefix;
        const suffix = /\w$/u.test(term) ? "\\b" : "";
        if (location === "start") {
          prefix = "^\\s*";
        } else if (/^\w/u.test(term)) {
          prefix = wordBoundary;
        } else {
          prefix = "";
        }
        if (location === "start") {
          return new RegExp(prefix + escaped + suffix, "iu");
        }
        return new RegExp(prefix + escaped + suffix + eitherOrWordBoundary + term + wordBoundary, "iu");
      }
      const warningRegExps = warningTerms.map(convertToRegExp);
      function commentContainsWarningTerm(comment) {
        const matches = [];
        warningRegExps.forEach((regex, index) => {
          if (regex.test(comment)) {
            matches.push(warningTerms[index]);
          }
        });
        return matches;
      }
      function checkComment(node) {
        const comment = node.value;
        if (astUtils.isDirectiveComment(node) && selfConfigRegEx.test(comment)) {
          return;
        }
        const matches = commentContainsWarningTerm(comment);
        matches.forEach((matchedTerm) => {
          let commentToDisplay = "";
          let truncated = false;
          for (const c of comment.trim().split(/\s+/u)) {
            const tmp = commentToDisplay ? `${commentToDisplay} ${c}` : c;
            if (tmp.length <= CHAR_LIMIT) {
              commentToDisplay = tmp;
            } else {
              truncated = true;
              break;
            }
          }
          context4.report({
            node,
            messageId: "unexpectedComment",
            data: {
              matchedTerm,
              comment: `${commentToDisplay}${truncated ? "..." : ""}`
            }
          });
        });
      }
      return {
        Program() {
          const comments = sourceCode.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(checkComment);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-whitespace-before-property.js
var require_no_whitespace_before_property = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "disallow whitespace before properties",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/no-whitespace-before-property"
      },
      fixable: "whitespace",
      schema: [],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace before property {{propName}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function reportError(node, leftToken, rightToken) {
        context4.report({
          node,
          messageId: "unexpectedWhitespace",
          data: {
            propName: sourceCode.getText(node.property)
          },
          fix(fixer) {
            let replacementText = "";
            if (!node.computed && !node.optional && astUtils.isDecimalInteger(node.object)) {
              return null;
            }
            if (sourceCode.commentsExistBetween(leftToken, rightToken)) {
              return null;
            }
            if (node.optional) {
              replacementText = "?.";
            } else if (!node.computed) {
              replacementText = ".";
            }
            return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], replacementText);
          }
        });
      }
      return {
        MemberExpression(node) {
          let rightToken;
          let leftToken;
          if (!astUtils.isTokenOnSameLine(node.object, node.property)) {
            return;
          }
          if (node.computed) {
            rightToken = sourceCode.getTokenBefore(node.property, astUtils.isOpeningBracketToken);
            leftToken = sourceCode.getTokenBefore(rightToken, node.optional ? 1 : 0);
          } else {
            rightToken = sourceCode.getFirstToken(node.property);
            leftToken = sourceCode.getTokenBefore(rightToken, 1);
          }
          if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken)) {
            reportError(node, leftToken, rightToken);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/no-with.js
var require_no_with = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `with` statements",
        category: "Best Practices",
        recommended: true,
        url: "https://eslint.org/docs/rules/no-with"
      },
      schema: [],
      messages: {
        unexpectedWith: "Unexpected use of 'with' statement."
      }
    },
    create(context4) {
      return {
        WithStatement(node) {
          context4.report({node, messageId: "unexpectedWith"});
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/nonblock-statement-body-position.js
var require_nonblock_statement_body_position = __commonJS((exports2, module2) => {
  "use strict";
  var POSITION_SCHEMA = {enum: ["beside", "below", "any"]};
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce the location of single-line statements",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/nonblock-statement-body-position"
      },
      fixable: "whitespace",
      schema: [
        POSITION_SCHEMA,
        {
          properties: {
            overrides: {
              properties: {
                if: POSITION_SCHEMA,
                else: POSITION_SCHEMA,
                while: POSITION_SCHEMA,
                do: POSITION_SCHEMA,
                for: POSITION_SCHEMA
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        expectNoLinebreak: "Expected no linebreak before this statement.",
        expectLinebreak: "Expected a linebreak before this statement."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function getOption(keywordName) {
        return context4.options[1] && context4.options[1].overrides && context4.options[1].overrides[keywordName] || context4.options[0] || "beside";
      }
      function validateStatement(node, keywordName) {
        const option = getOption(keywordName);
        if (node.type === "BlockStatement" || option === "any") {
          return;
        }
        const tokenBefore = sourceCode.getTokenBefore(node);
        if (tokenBefore.loc.end.line === node.loc.start.line && option === "below") {
          context4.report({
            node,
            messageId: "expectLinebreak",
            fix: (fixer) => fixer.insertTextBefore(node, "\n")
          });
        } else if (tokenBefore.loc.end.line !== node.loc.start.line && option === "beside") {
          context4.report({
            node,
            messageId: "expectNoLinebreak",
            fix(fixer) {
              if (sourceCode.getText().slice(tokenBefore.range[1], node.range[0]).trim()) {
                return null;
              }
              return fixer.replaceTextRange([tokenBefore.range[1], node.range[0]], " ");
            }
          });
        }
      }
      return {
        IfStatement(node) {
          validateStatement(node.consequent, "if");
          if (node.alternate && node.alternate.type !== "IfStatement") {
            validateStatement(node.alternate, "else");
          }
        },
        WhileStatement: (node) => validateStatement(node.body, "while"),
        DoWhileStatement: (node) => validateStatement(node.body, "do"),
        ForStatement: (node) => validateStatement(node.body, "for"),
        ForInStatement: (node) => validateStatement(node.body, "for"),
        ForOfStatement: (node) => validateStatement(node.body, "for")
      };
    }
  };
});

// node_modules/eslint/lib/rules/object-curly-newline.js
var require_object_curly_newline = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var lodash = require_lodash();
  var OPTION_VALUE = {
    oneOf: [
      {
        enum: ["always", "never"]
      },
      {
        type: "object",
        properties: {
          multiline: {
            type: "boolean"
          },
          minProperties: {
            type: "integer",
            minimum: 0
          },
          consistent: {
            type: "boolean"
          }
        },
        additionalProperties: false,
        minProperties: 1
      }
    ]
  };
  function normalizeOptionValue(value) {
    let multiline = false;
    let minProperties = Number.POSITIVE_INFINITY;
    let consistent = false;
    if (value) {
      if (value === "always") {
        minProperties = 0;
      } else if (value === "never") {
        minProperties = Number.POSITIVE_INFINITY;
      } else {
        multiline = Boolean(value.multiline);
        minProperties = value.minProperties || Number.POSITIVE_INFINITY;
        consistent = Boolean(value.consistent);
      }
    } else {
      consistent = true;
    }
    return {multiline, minProperties, consistent};
  }
  function normalizeOptions(options) {
    const isNodeSpecificOption = lodash.overSome([lodash.isPlainObject, lodash.isString]);
    if (lodash.isPlainObject(options) && Object.values(options).some(isNodeSpecificOption)) {
      return {
        ObjectExpression: normalizeOptionValue(options.ObjectExpression),
        ObjectPattern: normalizeOptionValue(options.ObjectPattern),
        ImportDeclaration: normalizeOptionValue(options.ImportDeclaration),
        ExportNamedDeclaration: normalizeOptionValue(options.ExportDeclaration)
      };
    }
    const value = normalizeOptionValue(options);
    return {ObjectExpression: value, ObjectPattern: value, ImportDeclaration: value, ExportNamedDeclaration: value};
  }
  function areLineBreaksRequired(node, options, first, last) {
    let objectProperties;
    if (node.type === "ObjectExpression" || node.type === "ObjectPattern") {
      objectProperties = node.properties;
    } else {
      objectProperties = node.specifiers.filter((s) => s.type === "ImportSpecifier" || s.type === "ExportSpecifier");
    }
    return objectProperties.length >= options.minProperties || options.multiline && objectProperties.length > 0 && first.loc.start.line !== last.loc.end.line;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent line breaks after opening and before closing braces",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/object-curly-newline"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            OPTION_VALUE,
            {
              type: "object",
              properties: {
                ObjectExpression: OPTION_VALUE,
                ObjectPattern: OPTION_VALUE,
                ImportDeclaration: OPTION_VALUE,
                ExportDeclaration: OPTION_VALUE
              },
              additionalProperties: false,
              minProperties: 1
            }
          ]
        }
      ],
      messages: {
        unexpectedLinebreakBeforeClosingBrace: "Unexpected line break before this closing brace.",
        unexpectedLinebreakAfterOpeningBrace: "Unexpected line break after this opening brace.",
        expectedLinebreakBeforeClosingBrace: "Expected a line break before this closing brace.",
        expectedLinebreakAfterOpeningBrace: "Expected a line break after this opening brace."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const normalizedOptions = normalizeOptions(context4.options[0]);
      function check(node) {
        const options = normalizedOptions[node.type];
        if (node.type === "ImportDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ImportSpecifier") || node.type === "ExportNamedDeclaration" && !node.specifiers.some((specifier) => specifier.type === "ExportSpecifier")) {
          return;
        }
        const openBrace = sourceCode.getFirstToken(node, (token) => token.value === "{");
        let closeBrace;
        if (node.typeAnnotation) {
          closeBrace = sourceCode.getTokenBefore(node.typeAnnotation);
        } else {
          closeBrace = sourceCode.getLastToken(node, (token) => token.value === "}");
        }
        let first = sourceCode.getTokenAfter(openBrace, {includeComments: true});
        let last = sourceCode.getTokenBefore(closeBrace, {includeComments: true});
        const needsLineBreaks = areLineBreaksRequired(node, options, first, last);
        const hasCommentsFirstToken = astUtils.isCommentToken(first);
        const hasCommentsLastToken = astUtils.isCommentToken(last);
        first = sourceCode.getTokenAfter(openBrace);
        last = sourceCode.getTokenBefore(closeBrace);
        if (needsLineBreaks) {
          if (astUtils.isTokenOnSameLine(openBrace, first)) {
            context4.report({
              messageId: "expectedLinebreakAfterOpeningBrace",
              node,
              loc: openBrace.loc,
              fix(fixer) {
                if (hasCommentsFirstToken) {
                  return null;
                }
                return fixer.insertTextAfter(openBrace, "\n");
              }
            });
          }
          if (astUtils.isTokenOnSameLine(last, closeBrace)) {
            context4.report({
              messageId: "expectedLinebreakBeforeClosingBrace",
              node,
              loc: closeBrace.loc,
              fix(fixer) {
                if (hasCommentsLastToken) {
                  return null;
                }
                return fixer.insertTextBefore(closeBrace, "\n");
              }
            });
          }
        } else {
          const consistent = options.consistent;
          const hasLineBreakBetweenOpenBraceAndFirst = !astUtils.isTokenOnSameLine(openBrace, first);
          const hasLineBreakBetweenCloseBraceAndLast = !astUtils.isTokenOnSameLine(last, closeBrace);
          if (!consistent && hasLineBreakBetweenOpenBraceAndFirst || consistent && hasLineBreakBetweenOpenBraceAndFirst && !hasLineBreakBetweenCloseBraceAndLast) {
            context4.report({
              messageId: "unexpectedLinebreakAfterOpeningBrace",
              node,
              loc: openBrace.loc,
              fix(fixer) {
                if (hasCommentsFirstToken) {
                  return null;
                }
                return fixer.removeRange([
                  openBrace.range[1],
                  first.range[0]
                ]);
              }
            });
          }
          if (!consistent && hasLineBreakBetweenCloseBraceAndLast || consistent && !hasLineBreakBetweenOpenBraceAndFirst && hasLineBreakBetweenCloseBraceAndLast) {
            context4.report({
              messageId: "unexpectedLinebreakBeforeClosingBrace",
              node,
              loc: closeBrace.loc,
              fix(fixer) {
                if (hasCommentsLastToken) {
                  return null;
                }
                return fixer.removeRange([
                  last.range[1],
                  closeBrace.range[0]
                ]);
              }
            });
          }
        }
      }
      return {
        ObjectExpression: check,
        ObjectPattern: check,
        ImportDeclaration: check,
        ExportNamedDeclaration: check
      };
    }
  };
});

// node_modules/eslint/lib/rules/object-curly-spacing.js
var require_object_curly_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing inside braces",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/object-curly-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            arraysInObjects: {
              type: "boolean"
            },
            objectsInObjects: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        requireSpaceBefore: "A space is required before '{{token}}'.",
        requireSpaceAfter: "A space is required after '{{token}}'.",
        unexpectedSpaceBefore: "There should be no space before '{{token}}'.",
        unexpectedSpaceAfter: "There should be no space after '{{token}}'."
      }
    },
    create(context4) {
      const spaced = context4.options[0] === "always", sourceCode = context4.getSourceCode();
      function isOptionSet(option) {
        return context4.options[1] ? context4.options[1][option] === !spaced : false;
      }
      const options = {
        spaced,
        arraysInObjectsException: isOptionSet("arraysInObjects"),
        objectsInObjectsException: isOptionSet("objectsInObjects")
      };
      function reportNoBeginningSpace(node, token) {
        const nextToken = context4.getSourceCode().getTokenAfter(token, {includeComments: true});
        context4.report({
          node,
          loc: {start: token.loc.end, end: nextToken.loc.start},
          messageId: "unexpectedSpaceAfter",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.removeRange([token.range[1], nextToken.range[0]]);
          }
        });
      }
      function reportNoEndingSpace(node, token) {
        const previousToken = context4.getSourceCode().getTokenBefore(token, {includeComments: true});
        context4.report({
          node,
          loc: {start: previousToken.loc.end, end: token.loc.start},
          messageId: "unexpectedSpaceBefore",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.removeRange([previousToken.range[1], token.range[0]]);
          }
        });
      }
      function reportRequiredBeginningSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "requireSpaceAfter",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.insertTextAfter(token, " ");
          }
        });
      }
      function reportRequiredEndingSpace(node, token) {
        context4.report({
          node,
          loc: token.loc,
          messageId: "requireSpaceBefore",
          data: {
            token: token.value
          },
          fix(fixer) {
            return fixer.insertTextBefore(token, " ");
          }
        });
      }
      function validateBraceSpacing(node, first, second, penultimate, last) {
        if (astUtils.isTokenOnSameLine(first, second)) {
          const firstSpaced = sourceCode.isSpaceBetweenTokens(first, second);
          if (options.spaced && !firstSpaced) {
            reportRequiredBeginningSpace(node, first);
          }
          if (!options.spaced && firstSpaced && second.type !== "Line") {
            reportNoBeginningSpace(node, first);
          }
        }
        if (astUtils.isTokenOnSameLine(penultimate, last)) {
          const shouldCheckPenultimate = options.arraysInObjectsException && astUtils.isClosingBracketToken(penultimate) || options.objectsInObjectsException && astUtils.isClosingBraceToken(penultimate);
          const penultimateType = shouldCheckPenultimate && sourceCode.getNodeByRangeIndex(penultimate.range[0]).type;
          const closingCurlyBraceMustBeSpaced = options.arraysInObjectsException && penultimateType === "ArrayExpression" || options.objectsInObjectsException && (penultimateType === "ObjectExpression" || penultimateType === "ObjectPattern") ? !options.spaced : options.spaced;
          const lastSpaced = sourceCode.isSpaceBetweenTokens(penultimate, last);
          if (closingCurlyBraceMustBeSpaced && !lastSpaced) {
            reportRequiredEndingSpace(node, last);
          }
          if (!closingCurlyBraceMustBeSpaced && lastSpaced) {
            reportNoEndingSpace(node, last);
          }
        }
      }
      function getClosingBraceOfObject(node) {
        const lastProperty = node.properties[node.properties.length - 1];
        return sourceCode.getTokenAfter(lastProperty, astUtils.isClosingBraceToken);
      }
      function checkForObject(node) {
        if (node.properties.length === 0) {
          return;
        }
        const first = sourceCode.getFirstToken(node), last = getClosingBraceOfObject(node), second = sourceCode.getTokenAfter(first, {includeComments: true}), penultimate = sourceCode.getTokenBefore(last, {includeComments: true});
        validateBraceSpacing(node, first, second, penultimate, last);
      }
      function checkForImport(node) {
        if (node.specifiers.length === 0) {
          return;
        }
        let firstSpecifier = node.specifiers[0];
        const lastSpecifier = node.specifiers[node.specifiers.length - 1];
        if (lastSpecifier.type !== "ImportSpecifier") {
          return;
        }
        if (firstSpecifier.type !== "ImportSpecifier") {
          firstSpecifier = node.specifiers[1];
        }
        const first = sourceCode.getTokenBefore(firstSpecifier), last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken), second = sourceCode.getTokenAfter(first, {includeComments: true}), penultimate = sourceCode.getTokenBefore(last, {includeComments: true});
        validateBraceSpacing(node, first, second, penultimate, last);
      }
      function checkForExport(node) {
        if (node.specifiers.length === 0) {
          return;
        }
        const firstSpecifier = node.specifiers[0], lastSpecifier = node.specifiers[node.specifiers.length - 1], first = sourceCode.getTokenBefore(firstSpecifier), last = sourceCode.getTokenAfter(lastSpecifier, astUtils.isNotCommaToken), second = sourceCode.getTokenAfter(first, {includeComments: true}), penultimate = sourceCode.getTokenBefore(last, {includeComments: true});
        validateBraceSpacing(node, first, second, penultimate, last);
      }
      return {
        ObjectPattern: checkForObject,
        ObjectExpression: checkForObject,
        ImportDeclaration: checkForImport,
        ExportNamedDeclaration: checkForExport
      };
    }
  };
});

// node_modules/eslint/lib/rules/object-property-newline.js
var require_object_property_newline = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce placing object properties on separate lines",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/object-property-newline"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowAllPropertiesOnSameLine: {
              type: "boolean",
              default: false
            },
            allowMultiplePropertiesPerLine: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        propertiesOnNewlineAll: "Object properties must go on a new line if they aren't all on the same line.",
        propertiesOnNewline: "Object properties must go on a new line."
      }
    },
    create(context4) {
      const allowSameLine = context4.options[0] && (context4.options[0].allowAllPropertiesOnSameLine || context4.options[0].allowMultiplePropertiesPerLine);
      const messageId = allowSameLine ? "propertiesOnNewlineAll" : "propertiesOnNewline";
      const sourceCode = context4.getSourceCode();
      return {
        ObjectExpression(node) {
          if (allowSameLine) {
            if (node.properties.length > 1) {
              const firstTokenOfFirstProperty = sourceCode.getFirstToken(node.properties[0]);
              const lastTokenOfLastProperty = sourceCode.getLastToken(node.properties[node.properties.length - 1]);
              if (firstTokenOfFirstProperty.loc.end.line === lastTokenOfLastProperty.loc.start.line) {
                return;
              }
            }
          }
          for (let i = 1; i < node.properties.length; i++) {
            const lastTokenOfPreviousProperty = sourceCode.getLastToken(node.properties[i - 1]);
            const firstTokenOfCurrentProperty = sourceCode.getFirstToken(node.properties[i]);
            if (lastTokenOfPreviousProperty.loc.end.line === firstTokenOfCurrentProperty.loc.start.line) {
              context4.report({
                node,
                loc: firstTokenOfCurrentProperty.loc,
                messageId,
                fix(fixer) {
                  const comma = sourceCode.getTokenBefore(firstTokenOfCurrentProperty);
                  const rangeAfterComma = [comma.range[1], firstTokenOfCurrentProperty.range[0]];
                  if (sourceCode.text.slice(rangeAfterComma[0], rangeAfterComma[1]).trim()) {
                    return null;
                  }
                  return fixer.replaceTextRange(rangeAfterComma, "\n");
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/object-shorthand.js
var require_object_shorthand = __commonJS((exports2, module2) => {
  "use strict";
  var OPTIONS = {
    always: "always",
    never: "never",
    methods: "methods",
    properties: "properties",
    consistent: "consistent",
    consistentAsNeeded: "consistent-as-needed"
  };
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow method and property shorthand syntax for object literals",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/object-shorthand"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods", "properties", "never", "consistent", "consistent-as-needed"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods", "properties"]
              },
              {
                type: "object",
                properties: {
                  avoidQuotes: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "methods"]
              },
              {
                type: "object",
                properties: {
                  ignoreConstructors: {
                    type: "boolean"
                  },
                  avoidQuotes: {
                    type: "boolean"
                  },
                  avoidExplicitReturnArrows: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        expectedAllPropertiesShorthanded: "Expected shorthand for all properties.",
        expectedLiteralMethodLongform: "Expected longform method syntax for string literal keys.",
        expectedPropertyShorthand: "Expected property shorthand.",
        expectedPropertyLongform: "Expected longform property syntax.",
        expectedMethodShorthand: "Expected method shorthand.",
        expectedMethodLongform: "Expected longform method syntax.",
        unexpectedMix: "Unexpected mix of shorthand and non-shorthand properties."
      }
    },
    create(context4) {
      const APPLY = context4.options[0] || OPTIONS.always;
      const APPLY_TO_METHODS = APPLY === OPTIONS.methods || APPLY === OPTIONS.always;
      const APPLY_TO_PROPS = APPLY === OPTIONS.properties || APPLY === OPTIONS.always;
      const APPLY_NEVER = APPLY === OPTIONS.never;
      const APPLY_CONSISTENT = APPLY === OPTIONS.consistent;
      const APPLY_CONSISTENT_AS_NEEDED = APPLY === OPTIONS.consistentAsNeeded;
      const PARAMS = context4.options[1] || {};
      const IGNORE_CONSTRUCTORS = PARAMS.ignoreConstructors;
      const AVOID_QUOTES = PARAMS.avoidQuotes;
      const AVOID_EXPLICIT_RETURN_ARROWS = !!PARAMS.avoidExplicitReturnArrows;
      const sourceCode = context4.getSourceCode();
      const CTOR_PREFIX_REGEX = /[^_$0-9]/u;
      function isConstructor(name) {
        const match = CTOR_PREFIX_REGEX.exec(name);
        if (!match) {
          return false;
        }
        const firstChar = name.charAt(match.index);
        return firstChar === firstChar.toUpperCase();
      }
      function canHaveShorthand(property) {
        return property.kind !== "set" && property.kind !== "get" && property.type !== "SpreadElement" && property.type !== "SpreadProperty" && property.type !== "ExperimentalSpreadProperty";
      }
      function isStringLiteral(node) {
        return node.type === "Literal" && typeof node.value === "string";
      }
      function isShorthand(property) {
        return property.shorthand || property.method;
      }
      function isRedundant(property) {
        const value = property.value;
        if (value.type === "FunctionExpression") {
          return !value.id;
        }
        if (value.type === "Identifier") {
          return astUtils.getStaticPropertyName(property) === value.name;
        }
        return false;
      }
      function checkConsistency(node, checkRedundancy) {
        const properties = node.properties.filter(canHaveShorthand);
        if (properties.length > 0) {
          const shorthandProperties = properties.filter(isShorthand);
          if (shorthandProperties.length !== properties.length) {
            if (shorthandProperties.length > 0) {
              context4.report({node, messageId: "unexpectedMix"});
            } else if (checkRedundancy) {
              const canAlwaysUseShorthand = properties.every(isRedundant);
              if (canAlwaysUseShorthand) {
                context4.report({node, messageId: "expectedAllPropertiesShorthanded"});
              }
            }
          }
        }
      }
      function makeFunctionShorthand(fixer, node) {
        const firstKeyToken = node.computed ? sourceCode.getFirstToken(node, astUtils.isOpeningBracketToken) : sourceCode.getFirstToken(node.key);
        const lastKeyToken = node.computed ? sourceCode.getFirstTokenBetween(node.key, node.value, astUtils.isClosingBracketToken) : sourceCode.getLastToken(node.key);
        const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
        let keyPrefix = "";
        if (sourceCode.commentsExistBetween(lastKeyToken, node.value)) {
          return null;
        }
        if (node.value.async) {
          keyPrefix += "async ";
        }
        if (node.value.generator) {
          keyPrefix += "*";
        }
        const fixRange = [firstKeyToken.range[0], node.range[1]];
        const methodPrefix = keyPrefix + keyText;
        if (node.value.type === "FunctionExpression") {
          const functionToken = sourceCode.getTokens(node.value).find((token) => token.type === "Keyword" && token.value === "function");
          const tokenBeforeParams2 = node.value.generator ? sourceCode.getTokenAfter(functionToken) : functionToken;
          return fixer.replaceTextRange(fixRange, methodPrefix + sourceCode.text.slice(tokenBeforeParams2.range[1], node.value.range[1]));
        }
        const arrowToken = sourceCode.getTokenBefore(node.value.body, astUtils.isArrowToken);
        const fnBody = sourceCode.text.slice(arrowToken.range[1], node.value.range[1]);
        let shouldAddParensAroundParameters = false;
        let tokenBeforeParams;
        if (node.value.params.length === 0) {
          tokenBeforeParams = sourceCode.getFirstToken(node.value, astUtils.isOpeningParenToken);
        } else {
          tokenBeforeParams = sourceCode.getTokenBefore(node.value.params[0]);
        }
        if (node.value.params.length === 1) {
          const hasParen = astUtils.isOpeningParenToken(tokenBeforeParams);
          const isTokenOutsideNode = tokenBeforeParams.range[0] < node.range[0];
          shouldAddParensAroundParameters = !hasParen || isTokenOutsideNode;
        }
        const sliceStart = shouldAddParensAroundParameters ? node.value.params[0].range[0] : tokenBeforeParams.range[0];
        const sliceEnd = sourceCode.getTokenBefore(arrowToken).range[1];
        const oldParamText = sourceCode.text.slice(sliceStart, sliceEnd);
        const newParamText = shouldAddParensAroundParameters ? `(${oldParamText})` : oldParamText;
        return fixer.replaceTextRange(fixRange, methodPrefix + newParamText + fnBody);
      }
      function makeFunctionLongform(fixer, node) {
        const firstKeyToken = node.computed ? sourceCode.getTokens(node).find((token) => token.value === "[") : sourceCode.getFirstToken(node.key);
        const lastKeyToken = node.computed ? sourceCode.getTokensBetween(node.key, node.value).find((token) => token.value === "]") : sourceCode.getLastToken(node.key);
        const keyText = sourceCode.text.slice(firstKeyToken.range[0], lastKeyToken.range[1]);
        let functionHeader = "function";
        if (node.value.async) {
          functionHeader = `async ${functionHeader}`;
        }
        if (node.value.generator) {
          functionHeader = `${functionHeader}*`;
        }
        return fixer.replaceTextRange([node.range[0], lastKeyToken.range[1]], `${keyText}: ${functionHeader}`);
      }
      const lexicalScopeStack = [];
      const arrowsWithLexicalIdentifiers = new WeakSet();
      const argumentsIdentifiers = new WeakSet();
      function enterFunction() {
        lexicalScopeStack.unshift(new Set());
        context4.getScope().variables.filter((variable) => variable.name === "arguments").forEach((variable) => {
          variable.references.map((ref) => ref.identifier).forEach((identifier) => argumentsIdentifiers.add(identifier));
        });
      }
      function exitFunction() {
        lexicalScopeStack.shift();
      }
      function reportLexicalIdentifier() {
        lexicalScopeStack[0].forEach((arrowFunction) => arrowsWithLexicalIdentifiers.add(arrowFunction));
      }
      return {
        Program: enterFunction,
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        "Program:exit": exitFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        ArrowFunctionExpression(node) {
          lexicalScopeStack[0].add(node);
        },
        "ArrowFunctionExpression:exit"(node) {
          lexicalScopeStack[0].delete(node);
        },
        ThisExpression: reportLexicalIdentifier,
        Super: reportLexicalIdentifier,
        MetaProperty(node) {
          if (node.meta.name === "new" && node.property.name === "target") {
            reportLexicalIdentifier();
          }
        },
        Identifier(node) {
          if (argumentsIdentifiers.has(node)) {
            reportLexicalIdentifier();
          }
        },
        ObjectExpression(node) {
          if (APPLY_CONSISTENT) {
            checkConsistency(node, false);
          } else if (APPLY_CONSISTENT_AS_NEEDED) {
            checkConsistency(node, true);
          }
        },
        "Property:exit"(node) {
          const isConciseProperty = node.method || node.shorthand;
          if (node.parent.type === "ObjectPattern") {
            return;
          }
          if (node.kind === "get" || node.kind === "set") {
            return;
          }
          if (node.computed && node.value.type !== "FunctionExpression" && node.value.type !== "ArrowFunctionExpression") {
            return;
          }
          if (isConciseProperty) {
            if (node.method && (APPLY_NEVER || AVOID_QUOTES && isStringLiteral(node.key))) {
              const messageId = APPLY_NEVER ? "expectedMethodLongform" : "expectedLiteralMethodLongform";
              context4.report({
                node,
                messageId,
                fix: (fixer) => makeFunctionLongform(fixer, node)
              });
            } else if (APPLY_NEVER) {
              context4.report({
                node,
                messageId: "expectedPropertyLongform",
                fix: (fixer) => fixer.insertTextAfter(node.key, `: ${node.key.name}`)
              });
            }
          } else if (APPLY_TO_METHODS && !node.value.id && (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression")) {
            if (IGNORE_CONSTRUCTORS && node.key.type === "Identifier" && isConstructor(node.key.name)) {
              return;
            }
            if (AVOID_QUOTES && isStringLiteral(node.key)) {
              return;
            }
            if (node.value.type === "FunctionExpression" || node.value.type === "ArrowFunctionExpression" && node.value.body.type === "BlockStatement" && AVOID_EXPLICIT_RETURN_ARROWS && !arrowsWithLexicalIdentifiers.has(node.value)) {
              context4.report({
                node,
                messageId: "expectedMethodShorthand",
                fix: (fixer) => makeFunctionShorthand(fixer, node)
              });
            }
          } else if (node.value.type === "Identifier" && node.key.name === node.value.name && APPLY_TO_PROPS) {
            context4.report({
              node,
              messageId: "expectedPropertyShorthand",
              fix(fixer) {
                return fixer.replaceText(node, node.value.name);
              }
            });
          } else if (node.value.type === "Identifier" && node.key.type === "Literal" && node.key.value === node.value.name && APPLY_TO_PROPS) {
            if (AVOID_QUOTES) {
              return;
            }
            context4.report({
              node,
              messageId: "expectedPropertyShorthand",
              fix(fixer) {
                return fixer.replaceText(node, node.value.name);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/one-var.js
var require_one_var = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isInStatementList(node) {
    return astUtils.STATEMENT_LIST_PARENTS.has(node.parent.type);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce variables to be declared either together or separately in functions",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/one-var"
      },
      fixable: "code",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never", "consecutive"]
            },
            {
              type: "object",
              properties: {
                separateRequires: {
                  type: "boolean"
                },
                var: {
                  enum: ["always", "never", "consecutive"]
                },
                let: {
                  enum: ["always", "never", "consecutive"]
                },
                const: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                initialized: {
                  enum: ["always", "never", "consecutive"]
                },
                uninitialized: {
                  enum: ["always", "never", "consecutive"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        combineUninitialized: "Combine this with the previous '{{type}}' statement with uninitialized variables.",
        combineInitialized: "Combine this with the previous '{{type}}' statement with initialized variables.",
        splitUninitialized: "Split uninitialized '{{type}}' declarations into multiple statements.",
        splitInitialized: "Split initialized '{{type}}' declarations into multiple statements.",
        splitRequires: "Split requires to be separated into a single block.",
        combine: "Combine this with the previous '{{type}}' statement.",
        split: "Split '{{type}}' declarations into multiple statements."
      }
    },
    create(context4) {
      const MODE_ALWAYS = "always";
      const MODE_NEVER = "never";
      const MODE_CONSECUTIVE = "consecutive";
      const mode = context4.options[0] || MODE_ALWAYS;
      const options = {};
      if (typeof mode === "string") {
        options.var = {uninitialized: mode, initialized: mode};
        options.let = {uninitialized: mode, initialized: mode};
        options.const = {uninitialized: mode, initialized: mode};
      } else if (typeof mode === "object") {
        options.separateRequires = !!mode.separateRequires;
        options.var = {uninitialized: mode.var, initialized: mode.var};
        options.let = {uninitialized: mode.let, initialized: mode.let};
        options.const = {uninitialized: mode.const, initialized: mode.const};
        if (Object.prototype.hasOwnProperty.call(mode, "uninitialized")) {
          options.var.uninitialized = mode.uninitialized;
          options.let.uninitialized = mode.uninitialized;
          options.const.uninitialized = mode.uninitialized;
        }
        if (Object.prototype.hasOwnProperty.call(mode, "initialized")) {
          options.var.initialized = mode.initialized;
          options.let.initialized = mode.initialized;
          options.const.initialized = mode.initialized;
        }
      }
      const sourceCode = context4.getSourceCode();
      const functionStack = [];
      const blockStack = [];
      function startBlock() {
        blockStack.push({
          let: {initialized: false, uninitialized: false},
          const: {initialized: false, uninitialized: false}
        });
      }
      function startFunction() {
        functionStack.push({initialized: false, uninitialized: false});
        startBlock();
      }
      function endBlock() {
        blockStack.pop();
      }
      function endFunction() {
        functionStack.pop();
        endBlock();
      }
      function isRequire(decl) {
        return decl.init && decl.init.type === "CallExpression" && decl.init.callee.name === "require";
      }
      function recordTypes(statementType, declarations, currentScope) {
        for (let i = 0; i < declarations.length; i++) {
          if (declarations[i].init === null) {
            if (options[statementType] && options[statementType].uninitialized === MODE_ALWAYS) {
              currentScope.uninitialized = true;
            }
          } else {
            if (options[statementType] && options[statementType].initialized === MODE_ALWAYS) {
              if (options.separateRequires && isRequire(declarations[i])) {
                currentScope.required = true;
              } else {
                currentScope.initialized = true;
              }
            }
          }
        }
      }
      function getCurrentScope(statementType) {
        let currentScope;
        if (statementType === "var") {
          currentScope = functionStack[functionStack.length - 1];
        } else if (statementType === "let") {
          currentScope = blockStack[blockStack.length - 1].let;
        } else if (statementType === "const") {
          currentScope = blockStack[blockStack.length - 1].const;
        }
        return currentScope;
      }
      function countDeclarations(declarations) {
        const counts = {uninitialized: 0, initialized: 0};
        for (let i = 0; i < declarations.length; i++) {
          if (declarations[i].init === null) {
            counts.uninitialized++;
          } else {
            counts.initialized++;
          }
        }
        return counts;
      }
      function hasOnlyOneStatement(statementType, declarations) {
        const declarationCounts = countDeclarations(declarations);
        const currentOptions = options[statementType] || {};
        const currentScope = getCurrentScope(statementType);
        const hasRequires = declarations.some(isRequire);
        if (currentOptions.uninitialized === MODE_ALWAYS && currentOptions.initialized === MODE_ALWAYS) {
          if (currentScope.uninitialized || currentScope.initialized) {
            if (!hasRequires) {
              return false;
            }
          }
        }
        if (declarationCounts.uninitialized > 0) {
          if (currentOptions.uninitialized === MODE_ALWAYS && currentScope.uninitialized) {
            return false;
          }
        }
        if (declarationCounts.initialized > 0) {
          if (currentOptions.initialized === MODE_ALWAYS && currentScope.initialized) {
            if (!hasRequires) {
              return false;
            }
          }
        }
        if (currentScope.required && hasRequires) {
          return false;
        }
        recordTypes(statementType, declarations, currentScope);
        return true;
      }
      function joinDeclarations(declarations) {
        const declaration = declarations[0];
        const body = Array.isArray(declaration.parent.parent.body) ? declaration.parent.parent.body : [];
        const currentIndex = body.findIndex((node) => node.range[0] === declaration.parent.range[0]);
        const previousNode = body[currentIndex - 1];
        return (fixer) => {
          const type = sourceCode.getTokenBefore(declaration);
          const prevSemi = sourceCode.getTokenBefore(type);
          const res = [];
          if (previousNode && previousNode.kind === sourceCode.getText(type)) {
            if (prevSemi.value === ";") {
              res.push(fixer.replaceText(prevSemi, ","));
            } else {
              res.push(fixer.insertTextAfter(prevSemi, ","));
            }
            res.push(fixer.replaceText(type, ""));
          }
          return res;
        };
      }
      function splitDeclarations(declaration) {
        const {parent} = declaration;
        if (!isInStatementList(parent.type === "ExportNamedDeclaration" ? parent : declaration)) {
          return null;
        }
        return (fixer) => declaration.declarations.map((declarator) => {
          const tokenAfterDeclarator = sourceCode.getTokenAfter(declarator);
          if (tokenAfterDeclarator === null) {
            return null;
          }
          const afterComma = sourceCode.getTokenAfter(tokenAfterDeclarator, {includeComments: true});
          if (tokenAfterDeclarator.value !== ",") {
            return null;
          }
          const exportPlacement = declaration.parent.type === "ExportNamedDeclaration" ? "export " : "";
          if (afterComma.range[0] === tokenAfterDeclarator.range[1]) {
            return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind} `);
          }
          if (afterComma.loc.start.line > tokenAfterDeclarator.loc.end.line || afterComma.type === "Line" || afterComma.type === "Block") {
            let lastComment = afterComma;
            while (lastComment.type === "Line" || lastComment.type === "Block") {
              lastComment = sourceCode.getTokenAfter(lastComment, {includeComments: true});
            }
            return fixer.replaceTextRange([tokenAfterDeclarator.range[0], lastComment.range[0]], `;${sourceCode.text.slice(tokenAfterDeclarator.range[1], lastComment.range[0])}${exportPlacement}${declaration.kind} `);
          }
          return fixer.replaceText(tokenAfterDeclarator, `; ${exportPlacement}${declaration.kind}`);
        }).filter((x) => x);
      }
      function checkVariableDeclaration(node) {
        const parent = node.parent;
        const type = node.kind;
        if (!options[type]) {
          return;
        }
        const declarations = node.declarations;
        const declarationCounts = countDeclarations(declarations);
        const mixedRequires = declarations.some(isRequire) && !declarations.every(isRequire);
        if (options[type].initialized === MODE_ALWAYS) {
          if (options.separateRequires && mixedRequires) {
            context4.report({
              node,
              messageId: "splitRequires"
            });
          }
        }
        const nodeIndex = parent.body && parent.body.length > 0 && parent.body.indexOf(node) || 0;
        if (nodeIndex > 0) {
          const previousNode = parent.body[nodeIndex - 1];
          const isPreviousNodeDeclaration = previousNode.type === "VariableDeclaration";
          const declarationsWithPrevious = declarations.concat(previousNode.declarations || []);
          if (isPreviousNodeDeclaration && previousNode.kind === type && !(declarationsWithPrevious.some(isRequire) && !declarationsWithPrevious.every(isRequire))) {
            const previousDeclCounts = countDeclarations(previousNode.declarations);
            if (options[type].initialized === MODE_CONSECUTIVE && options[type].uninitialized === MODE_CONSECUTIVE) {
              context4.report({
                node,
                messageId: "combine",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[type].initialized === MODE_CONSECUTIVE && declarationCounts.initialized > 0 && previousDeclCounts.initialized > 0) {
              context4.report({
                node,
                messageId: "combineInitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            } else if (options[type].uninitialized === MODE_CONSECUTIVE && declarationCounts.uninitialized > 0 && previousDeclCounts.uninitialized > 0) {
              context4.report({
                node,
                messageId: "combineUninitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }
        if (!hasOnlyOneStatement(type, declarations)) {
          if (options[type].initialized === MODE_ALWAYS && options[type].uninitialized === MODE_ALWAYS) {
            context4.report({
              node,
              messageId: "combine",
              data: {
                type
              },
              fix: joinDeclarations(declarations)
            });
          } else {
            if (options[type].initialized === MODE_ALWAYS && declarationCounts.initialized > 0) {
              context4.report({
                node,
                messageId: "combineInitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }
            if (options[type].uninitialized === MODE_ALWAYS && declarationCounts.uninitialized > 0) {
              if (node.parent.left === node && (node.parent.type === "ForInStatement" || node.parent.type === "ForOfStatement")) {
                return;
              }
              context4.report({
                node,
                messageId: "combineUninitialized",
                data: {
                  type
                },
                fix: joinDeclarations(declarations)
              });
            }
          }
        }
        if (parent.type !== "ForStatement" || parent.init !== node) {
          const totalDeclarations = declarationCounts.uninitialized + declarationCounts.initialized;
          if (totalDeclarations > 1) {
            if (options[type].initialized === MODE_NEVER && options[type].uninitialized === MODE_NEVER) {
              context4.report({
                node,
                messageId: "split",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            } else if (options[type].initialized === MODE_NEVER && declarationCounts.initialized > 0) {
              context4.report({
                node,
                messageId: "splitInitialized",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            } else if (options[type].uninitialized === MODE_NEVER && declarationCounts.uninitialized > 0) {
              context4.report({
                node,
                messageId: "splitUninitialized",
                data: {
                  type
                },
                fix: splitDeclarations(node)
              });
            }
          }
        }
      }
      return {
        Program: startFunction,
        FunctionDeclaration: startFunction,
        FunctionExpression: startFunction,
        ArrowFunctionExpression: startFunction,
        BlockStatement: startBlock,
        ForStatement: startBlock,
        ForInStatement: startBlock,
        ForOfStatement: startBlock,
        SwitchStatement: startBlock,
        VariableDeclaration: checkVariableDeclaration,
        "ForStatement:exit": endBlock,
        "ForOfStatement:exit": endBlock,
        "ForInStatement:exit": endBlock,
        "SwitchStatement:exit": endBlock,
        "BlockStatement:exit": endBlock,
        "Program:exit": endFunction,
        "FunctionDeclaration:exit": endFunction,
        "FunctionExpression:exit": endFunction,
        "ArrowFunctionExpression:exit": endFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/one-var-declaration-per-line.js
var require_one_var_declaration_per_line = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow newlines around variable declarations",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/one-var-declaration-per-line"
      },
      schema: [
        {
          enum: ["always", "initializations"]
        }
      ],
      fixable: "whitespace",
      messages: {
        expectVarOnNewline: "Expected variable declaration to be on a new line."
      }
    },
    create(context4) {
      const always = context4.options[0] === "always";
      function isForTypeSpecifier(keyword) {
        return keyword === "ForStatement" || keyword === "ForInStatement" || keyword === "ForOfStatement";
      }
      function checkForNewLine(node) {
        if (isForTypeSpecifier(node.parent.type)) {
          return;
        }
        const declarations = node.declarations;
        let prev;
        declarations.forEach((current) => {
          if (prev && prev.loc.end.line === current.loc.start.line) {
            if (always || prev.init || current.init) {
              context4.report({
                node,
                messageId: "expectVarOnNewline",
                loc: current.loc,
                fix: (fixer) => fixer.insertTextBefore(current, "\n")
              });
            }
          }
          prev = current;
        });
      }
      return {
        VariableDeclaration: checkForNewLine
      };
    }
  };
});

// node_modules/eslint/lib/rules/operator-assignment.js
var require_operator_assignment = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isCommutativeOperatorWithShorthand(operator) {
    return ["*", "&", "^", "|"].indexOf(operator) >= 0;
  }
  function isNonCommutativeOperatorWithShorthand(operator) {
    return ["+", "-", "/", "%", "<<", ">>", ">>>", "**"].indexOf(operator) >= 0;
  }
  function canBeFixed(node) {
    return node.type === "Identifier" || node.type === "MemberExpression" && (node.object.type === "Identifier" || node.object.type === "ThisExpression") && (!node.computed || node.property.type === "Literal");
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow assignment operator shorthand where possible",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/operator-assignment"
      },
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      fixable: "code",
      messages: {
        replaced: "Assignment can be replaced with operator assignment.",
        unexpected: "Unexpected operator assignment shorthand."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function getOperatorToken(node) {
        return sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
      }
      function verify(node) {
        if (node.operator !== "=" || node.right.type !== "BinaryExpression") {
          return;
        }
        const left = node.left;
        const expr = node.right;
        const operator = expr.operator;
        if (isCommutativeOperatorWithShorthand(operator) || isNonCommutativeOperatorWithShorthand(operator)) {
          if (astUtils.isSameReference(left, expr.left, true)) {
            context4.report({
              node,
              messageId: "replaced",
              fix(fixer) {
                if (canBeFixed(left) && canBeFixed(expr.left)) {
                  const equalsToken = getOperatorToken(node);
                  const operatorToken = getOperatorToken(expr);
                  const leftText = sourceCode.getText().slice(node.range[0], equalsToken.range[0]);
                  const rightText = sourceCode.getText().slice(operatorToken.range[1], node.right.range[1]);
                  if (sourceCode.commentsExistBetween(equalsToken, operatorToken)) {
                    return null;
                  }
                  return fixer.replaceText(node, `${leftText}${expr.operator}=${rightText}`);
                }
                return null;
              }
            });
          } else if (astUtils.isSameReference(left, expr.right, true) && isCommutativeOperatorWithShorthand(operator)) {
            context4.report({
              node,
              messageId: "replaced"
            });
          }
        }
      }
      function prohibit(node) {
        if (node.operator !== "=" && !astUtils.isLogicalAssignmentOperator(node.operator)) {
          context4.report({
            node,
            messageId: "unexpected",
            fix(fixer) {
              if (canBeFixed(node.left)) {
                const firstToken = sourceCode.getFirstToken(node);
                const operatorToken = getOperatorToken(node);
                const leftText = sourceCode.getText().slice(node.range[0], operatorToken.range[0]);
                const newOperator = node.operator.slice(0, -1);
                let rightText;
                if (sourceCode.commentsExistBetween(firstToken, operatorToken)) {
                  return null;
                }
                if (astUtils.getPrecedence(node.right) <= astUtils.getPrecedence({type: "BinaryExpression", operator: newOperator}) && !astUtils.isParenthesised(sourceCode, node.right)) {
                  rightText = `${sourceCode.text.slice(operatorToken.range[1], node.right.range[0])}(${sourceCode.getText(node.right)})`;
                } else {
                  const tokenAfterOperator = sourceCode.getTokenAfter(operatorToken, {includeComments: true});
                  let rightTextPrefix = "";
                  if (operatorToken.range[1] === tokenAfterOperator.range[0] && !astUtils.canTokensBeAdjacent({type: "Punctuator", value: newOperator}, tokenAfterOperator)) {
                    rightTextPrefix = " ";
                  }
                  rightText = `${rightTextPrefix}${sourceCode.text.slice(operatorToken.range[1], node.range[1])}`;
                }
                return fixer.replaceText(node, `${leftText}= ${leftText}${newOperator}${rightText}`);
              }
              return null;
            }
          });
        }
      }
      return {
        AssignmentExpression: context4.options[0] !== "never" ? verify : prohibit
      };
    }
  };
});

// node_modules/eslint/lib/rules/operator-linebreak.js
var require_operator_linebreak = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent linebreak style for operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/operator-linebreak"
      },
      schema: [
        {
          enum: ["after", "before", "none", null]
        },
        {
          type: "object",
          properties: {
            overrides: {
              type: "object",
              additionalProperties: {
                enum: ["after", "before", "none", "ignore"]
              }
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        operatorAtBeginning: "'{{operator}}' should be placed at the beginning of the line.",
        operatorAtEnd: "'{{operator}}' should be placed at the end of the line.",
        badLinebreak: "Bad line breaking before and after '{{operator}}'.",
        noLinebreak: "There should be no line break before or after '{{operator}}'."
      }
    },
    create(context4) {
      const usedDefaultGlobal = !context4.options[0];
      const globalStyle = context4.options[0] || "after";
      const options = context4.options[1] || {};
      const styleOverrides = options.overrides ? Object.assign({}, options.overrides) : {};
      if (usedDefaultGlobal && !styleOverrides["?"]) {
        styleOverrides["?"] = "before";
      }
      if (usedDefaultGlobal && !styleOverrides[":"]) {
        styleOverrides[":"] = "before";
      }
      const sourceCode = context4.getSourceCode();
      function getFixer(operatorToken, desiredStyle) {
        return (fixer) => {
          const tokenBefore = sourceCode.getTokenBefore(operatorToken);
          const tokenAfter = sourceCode.getTokenAfter(operatorToken);
          const textBefore = sourceCode.text.slice(tokenBefore.range[1], operatorToken.range[0]);
          const textAfter = sourceCode.text.slice(operatorToken.range[1], tokenAfter.range[0]);
          const hasLinebreakBefore = !astUtils.isTokenOnSameLine(tokenBefore, operatorToken);
          const hasLinebreakAfter = !astUtils.isTokenOnSameLine(operatorToken, tokenAfter);
          let newTextBefore, newTextAfter;
          if (hasLinebreakBefore !== hasLinebreakAfter && desiredStyle !== "none") {
            if (sourceCode.getTokenBefore(operatorToken, {includeComments: true}) !== tokenBefore && sourceCode.getTokenAfter(operatorToken, {includeComments: true}) !== tokenAfter) {
              return null;
            }
            newTextBefore = textAfter;
            newTextAfter = textBefore;
          } else {
            const LINEBREAK_REGEX = astUtils.createGlobalLinebreakMatcher();
            newTextBefore = desiredStyle === "before" || textBefore.trim() ? textBefore : textBefore.replace(LINEBREAK_REGEX, "");
            newTextAfter = desiredStyle === "after" || textAfter.trim() ? textAfter : textAfter.replace(LINEBREAK_REGEX, "");
            if (newTextBefore === textBefore && newTextAfter === textAfter) {
              return null;
            }
          }
          if (newTextAfter === "" && tokenAfter.type === "Punctuator" && "+-".includes(operatorToken.value) && tokenAfter.value === operatorToken.value) {
            newTextAfter += " ";
          }
          return fixer.replaceTextRange([tokenBefore.range[1], tokenAfter.range[0]], newTextBefore + operatorToken.value + newTextAfter);
        };
      }
      function validateNode(node, leftSide) {
        const operatorToken = sourceCode.getTokenAfter(leftSide, astUtils.isNotClosingParenToken);
        const leftToken = sourceCode.getTokenBefore(operatorToken);
        const rightToken = sourceCode.getTokenAfter(operatorToken);
        const operator = operatorToken.value;
        const operatorStyleOverride = styleOverrides[operator];
        const style = operatorStyleOverride || globalStyle;
        const fix = getFixer(operatorToken, style);
        if (astUtils.isTokenOnSameLine(leftToken, operatorToken) && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
        } else if (operatorStyleOverride !== "ignore" && !astUtils.isTokenOnSameLine(leftToken, operatorToken) && !astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
          context4.report({
            node,
            loc: operatorToken.loc,
            messageId: "badLinebreak",
            data: {
              operator
            },
            fix
          });
        } else if (style === "before" && astUtils.isTokenOnSameLine(leftToken, operatorToken)) {
          context4.report({
            node,
            loc: operatorToken.loc,
            messageId: "operatorAtBeginning",
            data: {
              operator
            },
            fix
          });
        } else if (style === "after" && astUtils.isTokenOnSameLine(operatorToken, rightToken)) {
          context4.report({
            node,
            loc: operatorToken.loc,
            messageId: "operatorAtEnd",
            data: {
              operator
            },
            fix
          });
        } else if (style === "none") {
          context4.report({
            node,
            loc: operatorToken.loc,
            messageId: "noLinebreak",
            data: {
              operator
            },
            fix
          });
        }
      }
      function validateBinaryExpression(node) {
        validateNode(node, node.left);
      }
      return {
        BinaryExpression: validateBinaryExpression,
        LogicalExpression: validateBinaryExpression,
        AssignmentExpression: validateBinaryExpression,
        VariableDeclarator(node) {
          if (node.init) {
            validateNode(node, node.id);
          }
        },
        ConditionalExpression(node) {
          validateNode(node, node.test);
          validateNode(node, node.consequent);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/padded-blocks.js
var require_padded_blocks = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow padding within blocks",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/padded-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                blocks: {
                  enum: ["always", "never"]
                },
                switches: {
                  enum: ["always", "never"]
                },
                classes: {
                  enum: ["always", "never"]
                }
              },
              additionalProperties: false,
              minProperties: 1
            }
          ]
        },
        {
          type: "object",
          properties: {
            allowSingleLineBlocks: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        alwaysPadBlock: "Block must be padded by blank lines.",
        neverPadBlock: "Block must not be padded by blank lines."
      }
    },
    create(context4) {
      const options = {};
      const typeOptions = context4.options[0] || "always";
      const exceptOptions = context4.options[1] || {};
      if (typeof typeOptions === "string") {
        const shouldHavePadding = typeOptions === "always";
        options.blocks = shouldHavePadding;
        options.switches = shouldHavePadding;
        options.classes = shouldHavePadding;
      } else {
        if (Object.prototype.hasOwnProperty.call(typeOptions, "blocks")) {
          options.blocks = typeOptions.blocks === "always";
        }
        if (Object.prototype.hasOwnProperty.call(typeOptions, "switches")) {
          options.switches = typeOptions.switches === "always";
        }
        if (Object.prototype.hasOwnProperty.call(typeOptions, "classes")) {
          options.classes = typeOptions.classes === "always";
        }
      }
      if (Object.prototype.hasOwnProperty.call(exceptOptions, "allowSingleLineBlocks")) {
        options.allowSingleLineBlocks = exceptOptions.allowSingleLineBlocks === true;
      }
      const sourceCode = context4.getSourceCode();
      function getOpenBrace(node) {
        if (node.type === "SwitchStatement") {
          return sourceCode.getTokenBefore(node.cases[0]);
        }
        return sourceCode.getFirstToken(node);
      }
      function isComment(node) {
        return node.type === "Line" || node.type === "Block";
      }
      function isPaddingBetweenTokens(first, second) {
        return second.loc.start.line - first.loc.end.line >= 2;
      }
      function getFirstBlockToken(token) {
        let prev, first = token;
        do {
          prev = first;
          first = sourceCode.getTokenAfter(first, {includeComments: true});
        } while (isComment(first) && first.loc.start.line === prev.loc.end.line);
        return first;
      }
      function getLastBlockToken(token) {
        let last = token, next;
        do {
          next = last;
          last = sourceCode.getTokenBefore(last, {includeComments: true});
        } while (isComment(last) && last.loc.end.line === next.loc.start.line);
        return last;
      }
      function requirePaddingFor(node) {
        switch (node.type) {
          case "BlockStatement":
            return options.blocks;
          case "SwitchStatement":
            return options.switches;
          case "ClassBody":
            return options.classes;
          default:
            throw new Error("unreachable");
        }
      }
      function checkPadding(node) {
        const openBrace = getOpenBrace(node), firstBlockToken = getFirstBlockToken(openBrace), tokenBeforeFirst = sourceCode.getTokenBefore(firstBlockToken, {includeComments: true}), closeBrace = sourceCode.getLastToken(node), lastBlockToken = getLastBlockToken(closeBrace), tokenAfterLast = sourceCode.getTokenAfter(lastBlockToken, {includeComments: true}), blockHasTopPadding = isPaddingBetweenTokens(tokenBeforeFirst, firstBlockToken), blockHasBottomPadding = isPaddingBetweenTokens(lastBlockToken, tokenAfterLast);
        if (options.allowSingleLineBlocks && astUtils.isTokenOnSameLine(tokenBeforeFirst, tokenAfterLast)) {
          return;
        }
        if (requirePaddingFor(node)) {
          if (!blockHasTopPadding) {
            context4.report({
              node,
              loc: {
                start: tokenBeforeFirst.loc.start,
                end: firstBlockToken.loc.start
              },
              fix(fixer) {
                return fixer.insertTextAfter(tokenBeforeFirst, "\n");
              },
              messageId: "alwaysPadBlock"
            });
          }
          if (!blockHasBottomPadding) {
            context4.report({
              node,
              loc: {
                end: tokenAfterLast.loc.start,
                start: lastBlockToken.loc.end
              },
              fix(fixer) {
                return fixer.insertTextBefore(tokenAfterLast, "\n");
              },
              messageId: "alwaysPadBlock"
            });
          }
        } else {
          if (blockHasTopPadding) {
            context4.report({
              node,
              loc: {
                start: tokenBeforeFirst.loc.start,
                end: firstBlockToken.loc.start
              },
              fix(fixer) {
                return fixer.replaceTextRange([tokenBeforeFirst.range[1], firstBlockToken.range[0] - firstBlockToken.loc.start.column], "\n");
              },
              messageId: "neverPadBlock"
            });
          }
          if (blockHasBottomPadding) {
            context4.report({
              node,
              loc: {
                end: tokenAfterLast.loc.start,
                start: lastBlockToken.loc.end
              },
              messageId: "neverPadBlock",
              fix(fixer) {
                return fixer.replaceTextRange([lastBlockToken.range[1], tokenAfterLast.range[0] - tokenAfterLast.loc.start.column], "\n");
              }
            });
          }
        }
      }
      const rule = {};
      if (Object.prototype.hasOwnProperty.call(options, "switches")) {
        rule.SwitchStatement = function(node) {
          if (node.cases.length === 0) {
            return;
          }
          checkPadding(node);
        };
      }
      if (Object.prototype.hasOwnProperty.call(options, "blocks")) {
        rule.BlockStatement = function(node) {
          if (node.body.length === 0) {
            return;
          }
          checkPadding(node);
        };
      }
      if (Object.prototype.hasOwnProperty.call(options, "classes")) {
        rule.ClassBody = function(node) {
          if (node.body.length === 0) {
            return;
          }
          checkPadding(node);
        };
      }
      return rule;
    }
  };
});

// node_modules/eslint/lib/rules/padding-line-between-statements.js
var require_padding_line_between_statements = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var LT = `[${Array.from(astUtils.LINEBREAKS).join("")}]`;
  var PADDING_LINE_SEQUENCE = new RegExp(String.raw`^(\s*?${LT})\s*${LT}(\s*;?)$`, "u");
  var CJS_EXPORT = /^(?:module\s*\.\s*)?exports(?:\s*\.|\s*\[|$)/u;
  var CJS_IMPORT = /^require\(/u;
  function newKeywordTester(keyword) {
    return {
      test: (node, sourceCode) => sourceCode.getFirstToken(node).value === keyword
    };
  }
  function newSinglelineKeywordTester(keyword) {
    return {
      test: (node, sourceCode) => node.loc.start.line === node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
    };
  }
  function newMultilineKeywordTester(keyword) {
    return {
      test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && sourceCode.getFirstToken(node).value === keyword
    };
  }
  function newNodeTypeTester(type) {
    return {
      test: (node) => node.type === type
    };
  }
  function isIIFEStatement(node) {
    if (node.type === "ExpressionStatement") {
      let call = astUtils.skipChainExpression(node.expression);
      if (call.type === "UnaryExpression") {
        call = astUtils.skipChainExpression(call.argument);
      }
      return call.type === "CallExpression" && astUtils.isFunction(call.callee);
    }
    return false;
  }
  function isBlockLikeStatement(sourceCode, node) {
    if (node.type === "DoWhileStatement" && node.body.type === "BlockStatement") {
      return true;
    }
    if (isIIFEStatement(node)) {
      return true;
    }
    const lastToken = sourceCode.getLastToken(node, astUtils.isNotSemicolonToken);
    const belongingNode = lastToken && astUtils.isClosingBraceToken(lastToken) ? sourceCode.getNodeByRangeIndex(lastToken.range[0]) : null;
    return Boolean(belongingNode) && (belongingNode.type === "BlockStatement" || belongingNode.type === "SwitchStatement");
  }
  function isDirective(node, sourceCode) {
    return node.type === "ExpressionStatement" && (node.parent.type === "Program" || node.parent.type === "BlockStatement" && astUtils.isFunction(node.parent.parent)) && node.expression.type === "Literal" && typeof node.expression.value === "string" && !astUtils.isParenthesised(sourceCode, node.expression);
  }
  function isDirectivePrologue(node, sourceCode) {
    if (isDirective(node, sourceCode)) {
      for (const sibling of node.parent.body) {
        if (sibling === node) {
          break;
        }
        if (!isDirective(sibling, sourceCode)) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  function getActualLastToken(sourceCode, node) {
    const semiToken = sourceCode.getLastToken(node);
    const prevToken = sourceCode.getTokenBefore(semiToken);
    const nextToken = sourceCode.getTokenAfter(semiToken);
    const isSemicolonLessStyle = Boolean(prevToken && nextToken && prevToken.range[0] >= node.range[0] && astUtils.isSemicolonToken(semiToken) && semiToken.loc.start.line !== prevToken.loc.end.line && semiToken.loc.end.line === nextToken.loc.start.line);
    return isSemicolonLessStyle ? prevToken : semiToken;
  }
  function replacerToRemovePaddingLines(_, trailingSpaces, indentSpaces) {
    return trailingSpaces + indentSpaces;
  }
  function verifyForAny() {
  }
  function verifyForNever(context4, _, nextNode, paddingLines) {
    if (paddingLines.length === 0) {
      return;
    }
    context4.report({
      node: nextNode,
      messageId: "unexpectedBlankLine",
      fix(fixer) {
        if (paddingLines.length >= 2) {
          return null;
        }
        const prevToken = paddingLines[0][0];
        const nextToken = paddingLines[0][1];
        const start = prevToken.range[1];
        const end = nextToken.range[0];
        const text = context4.getSourceCode().text.slice(start, end).replace(PADDING_LINE_SEQUENCE, replacerToRemovePaddingLines);
        return fixer.replaceTextRange([start, end], text);
      }
    });
  }
  function verifyForAlways(context4, prevNode, nextNode, paddingLines) {
    if (paddingLines.length > 0) {
      return;
    }
    context4.report({
      node: nextNode,
      messageId: "expectedBlankLine",
      fix(fixer) {
        const sourceCode = context4.getSourceCode();
        let prevToken = getActualLastToken(sourceCode, prevNode);
        const nextToken = sourceCode.getFirstTokenBetween(prevToken, nextNode, {
          includeComments: true,
          filter(token) {
            if (astUtils.isTokenOnSameLine(prevToken, token)) {
              prevToken = token;
              return false;
            }
            return true;
          }
        }) || nextNode;
        const insertText = astUtils.isTokenOnSameLine(prevToken, nextToken) ? "\n\n" : "\n";
        return fixer.insertTextAfter(prevToken, insertText);
      }
    });
  }
  var PaddingTypes = {
    any: {verify: verifyForAny},
    never: {verify: verifyForNever},
    always: {verify: verifyForAlways}
  };
  var StatementTypes = {
    "*": {test: () => true},
    "block-like": {
      test: (node, sourceCode) => isBlockLikeStatement(sourceCode, node)
    },
    "cjs-export": {
      test: (node, sourceCode) => node.type === "ExpressionStatement" && node.expression.type === "AssignmentExpression" && CJS_EXPORT.test(sourceCode.getText(node.expression.left))
    },
    "cjs-import": {
      test: (node, sourceCode) => node.type === "VariableDeclaration" && node.declarations.length > 0 && Boolean(node.declarations[0].init) && CJS_IMPORT.test(sourceCode.getText(node.declarations[0].init))
    },
    directive: {
      test: isDirectivePrologue
    },
    expression: {
      test: (node, sourceCode) => node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
    },
    iife: {
      test: isIIFEStatement
    },
    "multiline-block-like": {
      test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && isBlockLikeStatement(sourceCode, node)
    },
    "multiline-expression": {
      test: (node, sourceCode) => node.loc.start.line !== node.loc.end.line && node.type === "ExpressionStatement" && !isDirectivePrologue(node, sourceCode)
    },
    "multiline-const": newMultilineKeywordTester("const"),
    "multiline-let": newMultilineKeywordTester("let"),
    "multiline-var": newMultilineKeywordTester("var"),
    "singleline-const": newSinglelineKeywordTester("const"),
    "singleline-let": newSinglelineKeywordTester("let"),
    "singleline-var": newSinglelineKeywordTester("var"),
    block: newNodeTypeTester("BlockStatement"),
    empty: newNodeTypeTester("EmptyStatement"),
    function: newNodeTypeTester("FunctionDeclaration"),
    break: newKeywordTester("break"),
    case: newKeywordTester("case"),
    class: newKeywordTester("class"),
    const: newKeywordTester("const"),
    continue: newKeywordTester("continue"),
    debugger: newKeywordTester("debugger"),
    default: newKeywordTester("default"),
    do: newKeywordTester("do"),
    export: newKeywordTester("export"),
    for: newKeywordTester("for"),
    if: newKeywordTester("if"),
    import: newKeywordTester("import"),
    let: newKeywordTester("let"),
    return: newKeywordTester("return"),
    switch: newKeywordTester("switch"),
    throw: newKeywordTester("throw"),
    try: newKeywordTester("try"),
    var: newKeywordTester("var"),
    while: newKeywordTester("while"),
    with: newKeywordTester("with")
  };
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow padding lines between statements",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/padding-line-between-statements"
      },
      fixable: "whitespace",
      schema: {
        definitions: {
          paddingType: {
            enum: Object.keys(PaddingTypes)
          },
          statementType: {
            anyOf: [
              {enum: Object.keys(StatementTypes)},
              {
                type: "array",
                items: {enum: Object.keys(StatementTypes)},
                minItems: 1,
                uniqueItems: true,
                additionalItems: false
              }
            ]
          }
        },
        type: "array",
        items: {
          type: "object",
          properties: {
            blankLine: {$ref: "#/definitions/paddingType"},
            prev: {$ref: "#/definitions/statementType"},
            next: {$ref: "#/definitions/statementType"}
          },
          additionalProperties: false,
          required: ["blankLine", "prev", "next"]
        },
        additionalItems: false
      },
      messages: {
        unexpectedBlankLine: "Unexpected blank line before this statement.",
        expectedBlankLine: "Expected blank line before this statement."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const configureList = context4.options || [];
      let scopeInfo = null;
      function enterScope() {
        scopeInfo = {
          upper: scopeInfo,
          prevNode: null
        };
      }
      function exitScope() {
        scopeInfo = scopeInfo.upper;
      }
      function match(node, type) {
        let innerStatementNode = node;
        while (innerStatementNode.type === "LabeledStatement") {
          innerStatementNode = innerStatementNode.body;
        }
        if (Array.isArray(type)) {
          return type.some(match.bind(null, innerStatementNode));
        }
        return StatementTypes[type].test(innerStatementNode, sourceCode);
      }
      function getPaddingType(prevNode, nextNode) {
        for (let i = configureList.length - 1; i >= 0; --i) {
          const configure = configureList[i];
          const matched = match(prevNode, configure.prev) && match(nextNode, configure.next);
          if (matched) {
            return PaddingTypes[configure.blankLine];
          }
        }
        return PaddingTypes.any;
      }
      function getPaddingLineSequences(prevNode, nextNode) {
        const pairs = [];
        let prevToken = getActualLastToken(sourceCode, prevNode);
        if (nextNode.loc.start.line - prevToken.loc.end.line >= 2) {
          do {
            const token = sourceCode.getTokenAfter(prevToken, {includeComments: true});
            if (token.loc.start.line - prevToken.loc.end.line >= 2) {
              pairs.push([prevToken, token]);
            }
            prevToken = token;
          } while (prevToken.range[0] < nextNode.range[0]);
        }
        return pairs;
      }
      function verify(node) {
        const parentType = node.parent.type;
        const validParent = astUtils.STATEMENT_LIST_PARENTS.has(parentType) || parentType === "SwitchStatement";
        if (!validParent) {
          return;
        }
        const prevNode = scopeInfo.prevNode;
        if (prevNode) {
          const type = getPaddingType(prevNode, node);
          const paddingLines = getPaddingLineSequences(prevNode, node);
          type.verify(context4, prevNode, node, paddingLines);
        }
        scopeInfo.prevNode = node;
      }
      function verifyThenEnterScope(node) {
        verify(node);
        enterScope();
      }
      return {
        Program: enterScope,
        BlockStatement: enterScope,
        SwitchStatement: enterScope,
        "Program:exit": exitScope,
        "BlockStatement:exit": exitScope,
        "SwitchStatement:exit": exitScope,
        ":statement": verify,
        SwitchCase: verifyThenEnterScope,
        "SwitchCase:exit": exitScope
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-arrow-callback.js
var require_prefer_arrow_callback = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isFunctionName(variable) {
    return variable && variable.defs[0].type === "FunctionName";
  }
  function checkMetaProperty(node, metaName, propertyName) {
    return node.meta.name === metaName && node.property.name === propertyName;
  }
  function getVariableOfArguments(scope) {
    const variables = scope.variables;
    for (let i = 0; i < variables.length; ++i) {
      const variable = variables[i];
      if (variable.name === "arguments") {
        return variable.identifiers.length === 0 ? variable : null;
      }
    }
    return null;
  }
  function getCallbackInfo(node) {
    const retv = {isCallback: false, isLexicalThis: false};
    let currentNode = node;
    let parent = node.parent;
    let bound = false;
    while (currentNode) {
      switch (parent.type) {
        case "LogicalExpression":
        case "ChainExpression":
        case "ConditionalExpression":
          break;
        case "MemberExpression":
          if (parent.object === currentNode && !parent.property.computed && parent.property.type === "Identifier" && parent.property.name === "bind") {
            const maybeCallee = parent.parent.type === "ChainExpression" ? parent.parent : parent;
            if (astUtils.isCallee(maybeCallee)) {
              if (!bound) {
                bound = true;
                retv.isLexicalThis = maybeCallee.parent.arguments.length === 1 && maybeCallee.parent.arguments[0].type === "ThisExpression";
              }
              parent = maybeCallee.parent;
            } else {
              return retv;
            }
          } else {
            return retv;
          }
          break;
        case "CallExpression":
        case "NewExpression":
          if (parent.callee !== currentNode) {
            retv.isCallback = true;
          }
          return retv;
        default:
          return retv;
      }
      currentNode = parent;
      parent = parent.parent;
    }
    throw new Error("unreachable");
  }
  function hasDuplicateParams(paramsList) {
    return paramsList.every((param) => param.type === "Identifier") && paramsList.length !== new Set(paramsList.map((param) => param.name)).size;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require using arrow functions for callbacks",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-arrow-callback"
      },
      schema: [
        {
          type: "object",
          properties: {
            allowNamedFunctions: {
              type: "boolean",
              default: false
            },
            allowUnboundThis: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        preferArrowCallback: "Unexpected function expression."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const allowUnboundThis = options.allowUnboundThis !== false;
      const allowNamedFunctions = options.allowNamedFunctions;
      const sourceCode = context4.getSourceCode();
      let stack = [];
      function enterScope() {
        stack.push({this: false, super: false, meta: false});
      }
      function exitScope() {
        return stack.pop();
      }
      return {
        Program() {
          stack = [];
        },
        ThisExpression() {
          const info3 = stack[stack.length - 1];
          if (info3) {
            info3.this = true;
          }
        },
        Super() {
          const info3 = stack[stack.length - 1];
          if (info3) {
            info3.super = true;
          }
        },
        MetaProperty(node) {
          const info3 = stack[stack.length - 1];
          if (info3 && checkMetaProperty(node, "new", "target")) {
            info3.meta = true;
          }
        },
        FunctionDeclaration: enterScope,
        "FunctionDeclaration:exit": exitScope,
        FunctionExpression: enterScope,
        "FunctionExpression:exit"(node) {
          const scopeInfo = exitScope();
          if (allowNamedFunctions && node.id && node.id.name) {
            return;
          }
          if (node.generator) {
            return;
          }
          const nameVar = context4.getDeclaredVariables(node)[0];
          if (isFunctionName(nameVar) && nameVar.references.length > 0) {
            return;
          }
          const variable = getVariableOfArguments(context4.getScope());
          if (variable && variable.references.length > 0) {
            return;
          }
          const callbackInfo = getCallbackInfo(node);
          if (callbackInfo.isCallback && (!allowUnboundThis || !scopeInfo.this || callbackInfo.isLexicalThis) && !scopeInfo.super && !scopeInfo.meta) {
            context4.report({
              node,
              messageId: "preferArrowCallback",
              *fix(fixer) {
                if (!callbackInfo.isLexicalThis && scopeInfo.this || hasDuplicateParams(node.params)) {
                  return;
                }
                if (callbackInfo.isLexicalThis) {
                  const memberNode = node.parent;
                  if (memberNode.type !== "MemberExpression") {
                    return;
                  }
                  const callNode = memberNode.parent;
                  const firstTokenToRemove = sourceCode.getTokenAfter(memberNode.object, astUtils.isNotClosingParenToken);
                  const lastTokenToRemove = sourceCode.getLastToken(callNode);
                  if (astUtils.isParenthesised(sourceCode, memberNode)) {
                    return;
                  }
                  if (sourceCode.commentsExistBetween(firstTokenToRemove, lastTokenToRemove)) {
                    return;
                  }
                  yield fixer.removeRange([firstTokenToRemove.range[0], lastTokenToRemove.range[1]]);
                }
                const functionToken = sourceCode.getFirstToken(node, node.async ? 1 : 0);
                const leftParenToken = sourceCode.getTokenAfter(functionToken, astUtils.isOpeningParenToken);
                if (sourceCode.commentsExistBetween(functionToken, leftParenToken)) {
                  yield fixer.remove(functionToken);
                  if (node.id) {
                    yield fixer.remove(node.id);
                  }
                } else {
                  yield fixer.removeRange([functionToken.range[0], leftParenToken.range[0]]);
                }
                yield fixer.insertTextBefore(node.body, "=> ");
                let replacedNode = callbackInfo.isLexicalThis ? node.parent.parent : node;
                if (replacedNode.type === "ChainExpression") {
                  replacedNode = replacedNode.parent;
                }
                if (replacedNode.parent.type !== "CallExpression" && replacedNode.parent.type !== "ConditionalExpression" && !astUtils.isParenthesised(sourceCode, replacedNode) && !astUtils.isParenthesised(sourceCode, node)) {
                  yield fixer.insertTextBefore(replacedNode, "(");
                  yield fixer.insertTextAfter(replacedNode, ")");
                }
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-const.js
var require_prefer_const = __commonJS((exports2, module2) => {
  "use strict";
  var FixTracker = require_fix_tracker();
  var astUtils = require_ast_utils2();
  var PATTERN_TYPE = /^(?:.+?Pattern|RestElement|SpreadProperty|ExperimentalRestProperty|Property)$/u;
  var DECLARATION_HOST_TYPE = /^(?:Program|BlockStatement|SwitchCase)$/u;
  var DESTRUCTURING_HOST_TYPE = /^(?:VariableDeclarator|AssignmentExpression)$/u;
  function isInitOfForStatement(node) {
    return node.parent.type === "ForStatement" && node.parent.init === node;
  }
  function canBecomeVariableDeclaration(identifier) {
    let node = identifier.parent;
    while (PATTERN_TYPE.test(node.type)) {
      node = node.parent;
    }
    return node.type === "VariableDeclarator" || node.type === "AssignmentExpression" && node.parent.type === "ExpressionStatement" && DECLARATION_HOST_TYPE.test(node.parent.parent.type);
  }
  function isOuterVariableInDestructing(name, initScope) {
    if (initScope.through.find((ref) => ref.resolved && ref.resolved.name === name)) {
      return true;
    }
    const variable = astUtils.getVariableByName(initScope, name);
    if (variable !== null) {
      return variable.defs.some((def) => def.type === "Parameter");
    }
    return false;
  }
  function getDestructuringHost(reference) {
    if (!reference.isWrite()) {
      return null;
    }
    let node = reference.identifier.parent;
    while (PATTERN_TYPE.test(node.type)) {
      node = node.parent;
    }
    if (!DESTRUCTURING_HOST_TYPE.test(node.type)) {
      return null;
    }
    return node;
  }
  function hasMemberExpressionAssignment(node) {
    switch (node.type) {
      case "ObjectPattern":
        return node.properties.some((prop) => {
          if (prop) {
            return hasMemberExpressionAssignment(prop.argument || prop.value);
          }
          return false;
        });
      case "ArrayPattern":
        return node.elements.some((element) => {
          if (element) {
            return hasMemberExpressionAssignment(element);
          }
          return false;
        });
      case "AssignmentPattern":
        return hasMemberExpressionAssignment(node.left);
      case "MemberExpression":
        return true;
    }
    return false;
  }
  function getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign) {
    if (variable.eslintUsed && variable.scope.type === "global") {
      return null;
    }
    let writer = null;
    let isReadBeforeInit = false;
    const references = variable.references;
    for (let i = 0; i < references.length; ++i) {
      const reference = references[i];
      if (reference.isWrite()) {
        const isReassigned = writer !== null && writer.identifier !== reference.identifier;
        if (isReassigned) {
          return null;
        }
        const destructuringHost = getDestructuringHost(reference);
        if (destructuringHost !== null && destructuringHost.left !== void 0) {
          const leftNode = destructuringHost.left;
          let hasOuterVariables = false, hasNonIdentifiers = false;
          if (leftNode.type === "ObjectPattern") {
            const properties = leftNode.properties;
            hasOuterVariables = properties.filter((prop) => prop.value).map((prop) => prop.value.name).some((name) => isOuterVariableInDestructing(name, variable.scope));
            hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
          } else if (leftNode.type === "ArrayPattern") {
            const elements = leftNode.elements;
            hasOuterVariables = elements.map((element) => element && element.name).some((name) => isOuterVariableInDestructing(name, variable.scope));
            hasNonIdentifiers = hasMemberExpressionAssignment(leftNode);
          }
          if (hasOuterVariables || hasNonIdentifiers) {
            return null;
          }
        }
        writer = reference;
      } else if (reference.isRead() && writer === null) {
        if (ignoreReadBeforeAssign) {
          return null;
        }
        isReadBeforeInit = true;
      }
    }
    const shouldBeConst = writer !== null && writer.from === variable.scope && canBecomeVariableDeclaration(writer.identifier);
    if (!shouldBeConst) {
      return null;
    }
    if (isReadBeforeInit) {
      return variable.defs[0].name;
    }
    return writer.identifier;
  }
  function groupByDestructuring(variables, ignoreReadBeforeAssign) {
    const identifierMap = new Map();
    for (let i = 0; i < variables.length; ++i) {
      const variable = variables[i];
      const references = variable.references;
      const identifier = getIdentifierIfShouldBeConst(variable, ignoreReadBeforeAssign);
      let prevId = null;
      for (let j = 0; j < references.length; ++j) {
        const reference = references[j];
        const id = reference.identifier;
        if (id === prevId) {
          continue;
        }
        prevId = id;
        const group = getDestructuringHost(reference);
        if (group) {
          if (identifierMap.has(group)) {
            identifierMap.get(group).push(identifier);
          } else {
            identifierMap.set(group, [identifier]);
          }
        }
      }
    }
    return identifierMap;
  }
  function findUp(node, type, shouldStop) {
    if (!node || shouldStop(node)) {
      return null;
    }
    if (node.type === type) {
      return node;
    }
    return findUp(node.parent, type, shouldStop);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `const` declarations for variables that are never reassigned after declared",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-const"
      },
      fixable: "code",
      schema: [
        {
          type: "object",
          properties: {
            destructuring: {enum: ["any", "all"], default: "any"},
            ignoreReadBeforeAssign: {type: "boolean", default: false}
          },
          additionalProperties: false
        }
      ],
      messages: {
        useConst: "'{{name}}' is never reassigned. Use 'const' instead."
      }
    },
    create(context4) {
      const options = context4.options[0] || {};
      const sourceCode = context4.getSourceCode();
      const shouldMatchAnyDestructuredVariable = options.destructuring !== "all";
      const ignoreReadBeforeAssign = options.ignoreReadBeforeAssign === true;
      const variables = [];
      let reportCount = 0;
      let checkedId = null;
      let checkedName = "";
      function checkGroup(nodes) {
        const nodesToReport = nodes.filter(Boolean);
        if (nodes.length && (shouldMatchAnyDestructuredVariable || nodesToReport.length === nodes.length)) {
          const varDeclParent = findUp(nodes[0], "VariableDeclaration", (parentNode) => parentNode.type.endsWith("Statement"));
          const isVarDecParentNull = varDeclParent === null;
          if (!isVarDecParentNull && varDeclParent.declarations.length > 0) {
            const firstDeclaration = varDeclParent.declarations[0];
            if (firstDeclaration.init) {
              const firstDecParent = firstDeclaration.init.parent;
              if (firstDecParent.type === "VariableDeclarator") {
                if (firstDecParent.id.name !== checkedName) {
                  checkedName = firstDecParent.id.name;
                  reportCount = 0;
                }
                if (firstDecParent.id.type === "ObjectPattern") {
                  if (firstDecParent.init.name !== checkedName) {
                    checkedName = firstDecParent.init.name;
                    reportCount = 0;
                  }
                }
                if (firstDecParent.id !== checkedId) {
                  checkedId = firstDecParent.id;
                  reportCount = 0;
                }
              }
            }
          }
          let shouldFix = varDeclParent && (varDeclParent.parent.type === "ForInStatement" || varDeclParent.parent.type === "ForOfStatement" || varDeclParent.declarations.every((declaration) => declaration.init)) && nodesToReport.length === nodes.length;
          if (!isVarDecParentNull && varDeclParent.declarations && varDeclParent.declarations.length !== 1) {
            if (varDeclParent && varDeclParent.declarations && varDeclParent.declarations.length >= 1) {
              reportCount += nodesToReport.length;
              shouldFix = shouldFix && reportCount === varDeclParent.declarations.length;
            }
          }
          nodesToReport.forEach((node) => {
            context4.report({
              node,
              messageId: "useConst",
              data: node,
              fix: shouldFix ? (fixer) => {
                const letKeywordToken = sourceCode.getFirstToken(varDeclParent, (t) => t.value === varDeclParent.kind);
                return new FixTracker(fixer, sourceCode).retainRange(varDeclParent.range).replaceTextRange(letKeywordToken.range, "const");
              } : null
            });
          });
        }
      }
      return {
        "Program:exit"() {
          groupByDestructuring(variables, ignoreReadBeforeAssign).forEach(checkGroup);
        },
        VariableDeclaration(node) {
          if (node.kind === "let" && !isInitOfForStatement(node)) {
            variables.push(...context4.getDeclaredVariables(node));
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-destructuring.js
var require_prefer_destructuring = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var PRECEDENCE_OF_ASSIGNMENT_EXPR = astUtils.getPrecedence({type: "AssignmentExpression"});
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require destructuring from arrays and/or objects",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-destructuring"
      },
      fixable: "code",
      schema: [
        {
          oneOf: [
            {
              type: "object",
              properties: {
                VariableDeclarator: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                },
                AssignmentExpression: {
                  type: "object",
                  properties: {
                    array: {
                      type: "boolean"
                    },
                    object: {
                      type: "boolean"
                    }
                  },
                  additionalProperties: false
                }
              },
              additionalProperties: false
            },
            {
              type: "object",
              properties: {
                array: {
                  type: "boolean"
                },
                object: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        },
        {
          type: "object",
          properties: {
            enforceForRenamedProperties: {
              type: "boolean"
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        preferDestructuring: "Use {{type}} destructuring."
      }
    },
    create(context4) {
      const enabledTypes = context4.options[0];
      const enforceForRenamedProperties = context4.options[1] && context4.options[1].enforceForRenamedProperties;
      let normalizedOptions = {
        VariableDeclarator: {array: true, object: true},
        AssignmentExpression: {array: true, object: true}
      };
      if (enabledTypes) {
        normalizedOptions = typeof enabledTypes.array !== "undefined" || typeof enabledTypes.object !== "undefined" ? {VariableDeclarator: enabledTypes, AssignmentExpression: enabledTypes} : enabledTypes;
      }
      function shouldCheck(nodeType, destructuringType) {
        return normalizedOptions && normalizedOptions[nodeType] && normalizedOptions[nodeType][destructuringType];
      }
      function isArrayIndexAccess(node) {
        return Number.isInteger(node.property.value);
      }
      function report(reportNode, type, fix) {
        context4.report({
          node: reportNode,
          messageId: "preferDestructuring",
          data: {type},
          fix
        });
      }
      function shouldFix(node) {
        return node.type === "VariableDeclarator" && node.id.type === "Identifier" && node.init.type === "MemberExpression" && !node.init.computed && node.init.property.type === "Identifier" && node.id.name === node.init.property.name;
      }
      function fixIntoObjectDestructuring(fixer, node) {
        const rightNode = node.init;
        const sourceCode = context4.getSourceCode();
        if (sourceCode.getCommentsInside(node).length > sourceCode.getCommentsInside(rightNode.object).length) {
          return null;
        }
        let objectText = sourceCode.getText(rightNode.object);
        if (astUtils.getPrecedence(rightNode.object) < PRECEDENCE_OF_ASSIGNMENT_EXPR) {
          objectText = `(${objectText})`;
        }
        return fixer.replaceText(node, `{${rightNode.property.name}} = ${objectText}`);
      }
      function performCheck(leftNode, rightNode, reportNode) {
        if (rightNode.type !== "MemberExpression" || rightNode.object.type === "Super") {
          return;
        }
        if (isArrayIndexAccess(rightNode)) {
          if (shouldCheck(reportNode.type, "array")) {
            report(reportNode, "array", null);
          }
          return;
        }
        const fix = shouldFix(reportNode) ? (fixer) => fixIntoObjectDestructuring(fixer, reportNode) : null;
        if (shouldCheck(reportNode.type, "object") && enforceForRenamedProperties) {
          report(reportNode, "object", fix);
          return;
        }
        if (shouldCheck(reportNode.type, "object")) {
          const property = rightNode.property;
          if (property.type === "Literal" && leftNode.name === property.value || property.type === "Identifier" && leftNode.name === property.name && !rightNode.computed) {
            report(reportNode, "object", fix);
          }
        }
      }
      function checkVariableDeclarator(node) {
        if (!node.init) {
          return;
        }
        if (node.init.type !== "MemberExpression") {
          return;
        }
        performCheck(node.id, node.init, node);
      }
      function checkAssignmentExpression(node) {
        if (node.operator === "=") {
          performCheck(node.left, node.right, node);
        }
      }
      return {
        VariableDeclarator: checkVariableDeclarator,
        AssignmentExpression: checkAssignmentExpression
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-exponentiation-operator.js
var require_prefer_exponentiation_operator = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var {CALL, ReferenceTracker} = require_eslint_utils();
  var PRECEDENCE_OF_EXPONENTIATION_EXPR = astUtils.getPrecedence({type: "BinaryExpression", operator: "**"});
  function doesBaseNeedParens(base) {
    return astUtils.getPrecedence(base) <= PRECEDENCE_OF_EXPONENTIATION_EXPR || base.type === "AwaitExpression" || base.type === "UnaryExpression";
  }
  function doesExponentNeedParens(exponent) {
    return astUtils.getPrecedence(exponent) < PRECEDENCE_OF_EXPONENTIATION_EXPR;
  }
  function doesExponentiationExpressionNeedParens(node, sourceCode) {
    const parent = node.parent.type === "ChainExpression" ? node.parent.parent : node.parent;
    const needsParens = parent.type === "ClassDeclaration" || parent.type.endsWith("Expression") && astUtils.getPrecedence(parent) >= PRECEDENCE_OF_EXPONENTIATION_EXPR && !(parent.type === "BinaryExpression" && parent.operator === "**" && parent.right === node) && !((parent.type === "CallExpression" || parent.type === "NewExpression") && parent.arguments.includes(node)) && !(parent.type === "MemberExpression" && parent.computed && parent.property === node) && !(parent.type === "ArrayExpression");
    return needsParens && !astUtils.isParenthesised(sourceCode, node);
  }
  function parenthesizeIfShould(text, shouldParenthesize) {
    return shouldParenthesize ? `(${text})` : text;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow the use of `Math.pow` in favor of the `**` operator",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-exponentiation-operator"
      },
      schema: [],
      fixable: "code",
      messages: {
        useExponentiation: "Use the '**' operator instead of 'Math.pow'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      function report(node) {
        context4.report({
          node,
          messageId: "useExponentiation",
          fix(fixer) {
            if (node.arguments.length !== 2 || node.arguments.some((arg) => arg.type === "SpreadElement") || sourceCode.getCommentsInside(node).length > 0) {
              return null;
            }
            const base = node.arguments[0], exponent = node.arguments[1], baseText = sourceCode.getText(base), exponentText = sourceCode.getText(exponent), shouldParenthesizeBase = doesBaseNeedParens(base), shouldParenthesizeExponent = doesExponentNeedParens(exponent), shouldParenthesizeAll = doesExponentiationExpressionNeedParens(node, sourceCode);
            let prefix = "", suffix = "";
            if (!shouldParenthesizeAll) {
              if (!shouldParenthesizeBase) {
                const firstReplacementToken = sourceCode.getFirstToken(base), tokenBefore = sourceCode.getTokenBefore(node);
                if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstReplacementToken)) {
                  prefix = " ";
                }
              }
              if (!shouldParenthesizeExponent) {
                const lastReplacementToken = sourceCode.getLastToken(exponent), tokenAfter = sourceCode.getTokenAfter(node);
                if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastReplacementToken, tokenAfter)) {
                  suffix = " ";
                }
              }
            }
            const baseReplacement = parenthesizeIfShould(baseText, shouldParenthesizeBase), exponentReplacement = parenthesizeIfShould(exponentText, shouldParenthesizeExponent), replacement = parenthesizeIfShould(`${baseReplacement}**${exponentReplacement}`, shouldParenthesizeAll);
            return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
          }
        });
      }
      return {
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            Math: {
              pow: {[CALL]: true}
            }
          };
          for (const {node} of tracker.iterateGlobalReferences(trackMap)) {
            report(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-named-capture-group.js
var require_prefer_named_capture_group = __commonJS((exports2, module2) => {
  "use strict";
  var {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStringIfConstant
  } = require_eslint_utils();
  var regexpp = require_regexpp();
  var parser = new regexpp.RegExpParser();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce using named capture group in regular expression",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-named-capture-group"
      },
      schema: [],
      messages: {
        required: "Capture group '{{group}}' should be converted to a named or non-capturing group."
      }
    },
    create(context4) {
      function checkRegex(pattern, node, uFlag) {
        let ast;
        try {
          ast = parser.parsePattern(pattern, 0, pattern.length, uFlag);
        } catch (e) {
          return;
        }
        regexpp.visitRegExpAST(ast, {
          onCapturingGroupEnter(group) {
            if (!group.name) {
              context4.report({
                node,
                messageId: "required",
                data: {
                  group: group.raw
                }
              });
            }
          }
        });
      }
      return {
        Literal(node) {
          if (node.regex) {
            checkRegex(node.regex.pattern, node, node.regex.flags.includes("u"));
          }
        },
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const {node} of tracker.iterateGlobalReferences(traceMap)) {
            const regex = getStringIfConstant(node.arguments[0]);
            const flags = getStringIfConstant(node.arguments[1]);
            if (regex) {
              checkRegex(regex, node, flags && flags.includes("u"));
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-numeric-literals.js
var require_prefer_numeric_literals = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var radixMap = new Map([
    [2, {system: "binary", literalPrefix: "0b"}],
    [8, {system: "octal", literalPrefix: "0o"}],
    [16, {system: "hexadecimal", literalPrefix: "0x"}]
  ]);
  function isParseInt(calleeNode) {
    return astUtils.isSpecificId(calleeNode, "parseInt") || astUtils.isSpecificMemberAccess(calleeNode, "Number", "parseInt");
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow `parseInt()` and `Number.parseInt()` in favor of binary, octal, and hexadecimal literals",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-numeric-literals"
      },
      schema: [],
      messages: {
        useLiteral: "Use {{system}} literals instead of {{functionName}}()."
      },
      fixable: "code"
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        "CallExpression[arguments.length=2]"(node) {
          const [strNode, radixNode] = node.arguments, str = astUtils.getStaticStringValue(strNode), radix = radixNode.value;
          if (str !== null && astUtils.isStringLiteral(strNode) && radixNode.type === "Literal" && typeof radix === "number" && radixMap.has(radix) && isParseInt(node.callee)) {
            const {system, literalPrefix} = radixMap.get(radix);
            context4.report({
              node,
              messageId: "useLiteral",
              data: {
                system,
                functionName: sourceCode.getText(node.callee)
              },
              fix(fixer) {
                if (sourceCode.getCommentsInside(node).length) {
                  return null;
                }
                const replacement = `${literalPrefix}${str}`;
                if (+replacement !== parseInt(str, radix)) {
                  return null;
                }
                const tokenBefore = sourceCode.getTokenBefore(node), tokenAfter = sourceCode.getTokenAfter(node);
                let prefix = "", suffix = "";
                if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, replacement)) {
                  prefix = " ";
                }
                if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(replacement, tokenAfter)) {
                  suffix = " ";
                }
                return fixer.replaceText(node, `${prefix}${replacement}${suffix}`);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-object-spread.js
var require_prefer_object_spread = __commonJS((exports2, module2) => {
  "use strict";
  var {CALL, ReferenceTracker} = require_eslint_utils();
  var {
    isCommaToken,
    isOpeningParenToken,
    isClosingParenToken,
    isParenthesised
  } = require_ast_utils2();
  var ANY_SPACE = /\s/u;
  function hasArraySpread(node) {
    return node.arguments.some((arg) => arg.type === "SpreadElement");
  }
  function isAccessorProperty(node) {
    return node.type === "Property" && (node.kind === "get" || node.kind === "set");
  }
  function hasAccessors(node) {
    return node.properties.some(isAccessorProperty);
  }
  function hasArgumentsWithAccessors(node) {
    return node.arguments.filter((arg) => arg.type === "ObjectExpression").some(hasAccessors);
  }
  function needsParens(node, sourceCode) {
    const parent = node.parent;
    switch (parent.type) {
      case "VariableDeclarator":
      case "ArrayExpression":
      case "ReturnStatement":
      case "CallExpression":
      case "Property":
        return false;
      case "AssignmentExpression":
        return parent.left === node && !isParenthesised(sourceCode, node);
      default:
        return !isParenthesised(sourceCode, node);
    }
  }
  function argNeedsParens(node, sourceCode) {
    switch (node.type) {
      case "AssignmentExpression":
      case "ArrowFunctionExpression":
      case "ConditionalExpression":
        return !isParenthesised(sourceCode, node);
      default:
        return false;
    }
  }
  function getParenTokens(node, leftArgumentListParen, sourceCode) {
    const parens = [sourceCode.getFirstToken(node), sourceCode.getLastToken(node)];
    let leftNext = sourceCode.getTokenBefore(node);
    let rightNext = sourceCode.getTokenAfter(node);
    while (leftNext && rightNext && leftNext.range[0] > leftArgumentListParen.range[0] && isOpeningParenToken(leftNext) && isClosingParenToken(rightNext)) {
      parens.push(leftNext, rightNext);
      leftNext = sourceCode.getTokenBefore(leftNext);
      rightNext = sourceCode.getTokenAfter(rightNext);
    }
    return parens.sort((a, b) => a.range[0] - b.range[0]);
  }
  function getStartWithSpaces(token, sourceCode) {
    const text = sourceCode.text;
    let start = token.range[0];
    {
      const prevToken = sourceCode.getTokenBefore(token, {includeComments: true});
      if (prevToken && prevToken.type === "Line") {
        return start;
      }
    }
    while (ANY_SPACE.test(text[start - 1] || "")) {
      start -= 1;
    }
    return start;
  }
  function getEndWithSpaces(token, sourceCode) {
    const text = sourceCode.text;
    let end = token.range[1];
    while (ANY_SPACE.test(text[end] || "")) {
      end += 1;
    }
    return end;
  }
  function defineFixer(node, sourceCode) {
    return function* (fixer) {
      const leftParen = sourceCode.getTokenAfter(node.callee, isOpeningParenToken);
      const rightParen = sourceCode.getLastToken(node);
      yield fixer.removeRange([node.range[0], leftParen.range[0]]);
      if (needsParens(node, sourceCode)) {
        yield fixer.replaceText(leftParen, "({");
        yield fixer.replaceText(rightParen, "})");
      } else {
        yield fixer.replaceText(leftParen, "{");
        yield fixer.replaceText(rightParen, "}");
      }
      for (const argNode of node.arguments) {
        const innerParens = getParenTokens(argNode, leftParen, sourceCode);
        const left = innerParens.shift();
        const right = innerParens.pop();
        if (argNode.type === "ObjectExpression") {
          const maybeTrailingComma = sourceCode.getLastToken(argNode, 1);
          const maybeArgumentComma = sourceCode.getTokenAfter(right);
          for (const innerParen of innerParens) {
            yield fixer.remove(innerParen);
          }
          const leftRange = [left.range[0], getEndWithSpaces(left, sourceCode)];
          const rightRange = [
            Math.max(getStartWithSpaces(right, sourceCode), leftRange[1]),
            right.range[1]
          ];
          yield fixer.removeRange(leftRange);
          yield fixer.removeRange(rightRange);
          if ((argNode.properties.length === 0 || isCommaToken(maybeTrailingComma)) && isCommaToken(maybeArgumentComma)) {
            yield fixer.remove(maybeArgumentComma);
          }
        } else {
          if (argNeedsParens(argNode, sourceCode)) {
            yield fixer.insertTextBefore(left, "...(");
            yield fixer.insertTextAfter(right, ")");
          } else {
            yield fixer.insertTextBefore(left, "...");
          }
        }
      }
    };
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow using Object.assign with an object literal as the first argument and prefer the use of object spread instead.",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-object-spread"
      },
      schema: [],
      fixable: "code",
      messages: {
        useSpreadMessage: "Use an object spread instead of `Object.assign` eg: `{ ...foo }`.",
        useLiteralMessage: "Use an object literal instead of `Object.assign`. eg: `{ foo: bar }`."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            Object: {
              assign: {[CALL]: true}
            }
          };
          for (const {node} of tracker.iterateGlobalReferences(trackMap)) {
            if (node.arguments.length >= 1 && node.arguments[0].type === "ObjectExpression" && !hasArraySpread(node) && !(node.arguments.length > 1 && hasArgumentsWithAccessors(node))) {
              const messageId = node.arguments.length === 1 ? "useLiteralMessage" : "useSpreadMessage";
              const fix = defineFixer(node, sourceCode);
              context4.report({node, messageId, fix});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-promise-reject-errors.js
var require_prefer_promise_reject_errors = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require using Error objects as Promise rejection reasons",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-promise-reject-errors"
      },
      fixable: null,
      schema: [
        {
          type: "object",
          properties: {
            allowEmptyReject: {type: "boolean", default: false}
          },
          additionalProperties: false
        }
      ],
      messages: {
        rejectAnError: "Expected the Promise rejection reason to be an Error."
      }
    },
    create(context4) {
      const ALLOW_EMPTY_REJECT = context4.options.length && context4.options[0].allowEmptyReject;
      function checkRejectCall(callExpression) {
        if (!callExpression.arguments.length && ALLOW_EMPTY_REJECT) {
          return;
        }
        if (!callExpression.arguments.length || !astUtils.couldBeError(callExpression.arguments[0]) || callExpression.arguments[0].type === "Identifier" && callExpression.arguments[0].name === "undefined") {
          context4.report({
            node: callExpression,
            messageId: "rejectAnError"
          });
        }
      }
      function isPromiseRejectCall(node) {
        return astUtils.isSpecificMemberAccess(node.callee, "Promise", "reject");
      }
      return {
        CallExpression(node) {
          if (isPromiseRejectCall(node)) {
            checkRejectCall(node);
          }
        },
        "NewExpression:exit"(node) {
          if (node.callee.type === "Identifier" && node.callee.name === "Promise" && node.arguments.length && astUtils.isFunction(node.arguments[0]) && node.arguments[0].params.length > 1 && node.arguments[0].params[1].type === "Identifier") {
            context4.getDeclaredVariables(node.arguments[0]).find((variable) => variable.name === node.arguments[0].params[1].name).references.filter((ref) => ref.isRead()).filter((ref) => ref.identifier.parent.type === "CallExpression" && ref.identifier === ref.identifier.parent.callee).forEach((ref) => checkRejectCall(ref.identifier.parent));
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-reflect.js
var require_prefer_reflect = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `Reflect` methods where applicable",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-reflect"
      },
      deprecated: true,
      replacedBy: [],
      schema: [
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: [
                  "apply",
                  "call",
                  "delete",
                  "defineProperty",
                  "getOwnPropertyDescriptor",
                  "getPrototypeOf",
                  "setPrototypeOf",
                  "isExtensible",
                  "getOwnPropertyNames",
                  "preventExtensions"
                ]
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        preferReflect: "Avoid using {{existing}}, instead use {{substitute}}."
      }
    },
    create(context4) {
      const existingNames = {
        apply: "Function.prototype.apply",
        call: "Function.prototype.call",
        defineProperty: "Object.defineProperty",
        getOwnPropertyDescriptor: "Object.getOwnPropertyDescriptor",
        getPrototypeOf: "Object.getPrototypeOf",
        setPrototypeOf: "Object.setPrototypeOf",
        isExtensible: "Object.isExtensible",
        getOwnPropertyNames: "Object.getOwnPropertyNames",
        preventExtensions: "Object.preventExtensions"
      };
      const reflectSubstitutes = {
        apply: "Reflect.apply",
        call: "Reflect.apply",
        defineProperty: "Reflect.defineProperty",
        getOwnPropertyDescriptor: "Reflect.getOwnPropertyDescriptor",
        getPrototypeOf: "Reflect.getPrototypeOf",
        setPrototypeOf: "Reflect.setPrototypeOf",
        isExtensible: "Reflect.isExtensible",
        getOwnPropertyNames: "Reflect.getOwnPropertyNames",
        preventExtensions: "Reflect.preventExtensions"
      };
      const exceptions = (context4.options[0] || {}).exceptions || [];
      function report(node, existing, substitute) {
        context4.report({
          node,
          messageId: "preferReflect",
          data: {
            existing,
            substitute
          }
        });
      }
      return {
        CallExpression(node) {
          const methodName = (node.callee.property || {}).name;
          const isReflectCall = (node.callee.object || {}).name === "Reflect";
          const hasReflectSubstitute = Object.prototype.hasOwnProperty.call(reflectSubstitutes, methodName);
          const userConfiguredException = exceptions.indexOf(methodName) !== -1;
          if (hasReflectSubstitute && !isReflectCall && !userConfiguredException) {
            report(node, existingNames[methodName], reflectSubstitutes[methodName]);
          }
        },
        UnaryExpression(node) {
          const isDeleteOperator = node.operator === "delete";
          const targetsIdentifier = node.argument.type === "Identifier";
          const userConfiguredException = exceptions.indexOf("delete") !== -1;
          if (isDeleteOperator && !targetsIdentifier && !userConfiguredException) {
            report(node, "the delete keyword", "Reflect.deleteProperty");
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-regex-literals.js
var require_prefer_regex_literals = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var {CALL, CONSTRUCT, ReferenceTracker, findVariable} = require_eslint_utils();
  function isStringLiteral(node) {
    return node.type === "Literal" && typeof node.value === "string";
  }
  function isRegexLiteral(node) {
    return node.type === "Literal" && Object.prototype.hasOwnProperty.call(node, "regex");
  }
  function isStaticTemplateLiteral(node) {
    return node.type === "TemplateLiteral" && node.expressions.length === 0;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow use of the `RegExp` constructor in favor of regular expression literals",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-regex-literals"
      },
      schema: [
        {
          type: "object",
          properties: {
            disallowRedundantWrapping: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedRegExp: "Use a regular expression literal instead of the 'RegExp' constructor.",
        unexpectedRedundantRegExp: "Regular expression literal is unnecessarily wrapped within a 'RegExp' constructor.",
        unexpectedRedundantRegExpWithFlags: "Use regular expression literal with flags instead of the 'RegExp' constructor."
      }
    },
    create(context4) {
      const [{disallowRedundantWrapping = false} = {}] = context4.options;
      function isGlobalReference(node) {
        const scope = context4.getScope();
        const variable = findVariable(scope, node);
        return variable !== null && variable.scope.type === "global" && variable.defs.length === 0;
      }
      function isStringRawTaggedStaticTemplateLiteral(node) {
        return node.type === "TaggedTemplateExpression" && astUtils.isSpecificMemberAccess(node.tag, "String", "raw") && isGlobalReference(astUtils.skipChainExpression(node.tag).object) && isStaticTemplateLiteral(node.quasi);
      }
      function isStaticString(node) {
        return isStringLiteral(node) || isStaticTemplateLiteral(node) || isStringRawTaggedStaticTemplateLiteral(node);
      }
      function hasOnlyStaticStringArguments(node) {
        const args = node.arguments;
        if ((args.length === 1 || args.length === 2) && args.every(isStaticString)) {
          return true;
        }
        return false;
      }
      function isUnnecessarilyWrappedRegexLiteral(node) {
        const args = node.arguments;
        if (args.length === 1 && isRegexLiteral(args[0])) {
          return true;
        }
        if (args.length === 2 && isRegexLiteral(args[0]) && isStaticString(args[1])) {
          return true;
        }
        return false;
      }
      return {
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const traceMap = {
            RegExp: {
              [CALL]: true,
              [CONSTRUCT]: true
            }
          };
          for (const {node} of tracker.iterateGlobalReferences(traceMap)) {
            if (disallowRedundantWrapping && isUnnecessarilyWrappedRegexLiteral(node)) {
              if (node.arguments.length === 2) {
                context4.report({node, messageId: "unexpectedRedundantRegExpWithFlags"});
              } else {
                context4.report({node, messageId: "unexpectedRedundantRegExp"});
              }
            } else if (hasOnlyStaticStringArguments(node)) {
              context4.report({node, messageId: "unexpectedRegExp"});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-rest-params.js
var require_prefer_rest_params = __commonJS((exports2, module2) => {
  "use strict";
  function getVariableOfArguments(scope) {
    const variables = scope.variables;
    for (let i = 0; i < variables.length; ++i) {
      const variable = variables[i];
      if (variable.name === "arguments") {
        return variable.identifiers.length === 0 ? variable : null;
      }
    }
    return null;
  }
  function isNotNormalMemberAccess(reference) {
    const id = reference.identifier;
    const parent = id.parent;
    return !(parent.type === "MemberExpression" && parent.object === id && !parent.computed);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require rest parameters instead of `arguments`",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-rest-params"
      },
      schema: [],
      messages: {
        preferRestParams: "Use the rest parameters instead of 'arguments'."
      }
    },
    create(context4) {
      function report(reference) {
        context4.report({
          node: reference.identifier,
          loc: reference.identifier.loc,
          messageId: "preferRestParams"
        });
      }
      function checkForArguments() {
        const argumentsVar = getVariableOfArguments(context4.getScope());
        if (argumentsVar) {
          argumentsVar.references.filter(isNotNormalMemberAccess).forEach(report);
        }
      }
      return {
        "FunctionDeclaration:exit": checkForArguments,
        "FunctionExpression:exit": checkForArguments
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-spread.js
var require_prefer_spread = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isVariadicApplyCalling(node) {
    return astUtils.isSpecificMemberAccess(node.callee, null, "apply") && node.arguments.length === 2 && node.arguments[1].type !== "ArrayExpression" && node.arguments[1].type !== "SpreadElement";
  }
  function isValidThisArg(expectedThis, thisArg, context4) {
    if (!expectedThis) {
      return astUtils.isNullOrUndefined(thisArg);
    }
    return astUtils.equalTokens(expectedThis, thisArg, context4);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require spread operators instead of `.apply()`",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-spread"
      },
      schema: [],
      fixable: null,
      messages: {
        preferSpread: "Use the spread operator instead of '.apply()'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        CallExpression(node) {
          if (!isVariadicApplyCalling(node)) {
            return;
          }
          const applied = astUtils.skipChainExpression(astUtils.skipChainExpression(node.callee).object);
          const expectedThis = applied.type === "MemberExpression" ? applied.object : null;
          const thisArg = node.arguments[0];
          if (isValidThisArg(expectedThis, thisArg, sourceCode)) {
            context4.report({
              node,
              messageId: "preferSpread"
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/prefer-template.js
var require_prefer_template = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isConcatenation(node) {
    return node.type === "BinaryExpression" && node.operator === "+";
  }
  function getTopConcatBinaryExpression(node) {
    let currentNode = node;
    while (isConcatenation(currentNode.parent)) {
      currentNode = currentNode.parent;
    }
    return currentNode;
  }
  function hasOctalOrNonOctalDecimalEscapeSequence(node) {
    if (isConcatenation(node)) {
      return hasOctalOrNonOctalDecimalEscapeSequence(node.left) || hasOctalOrNonOctalDecimalEscapeSequence(node.right);
    }
    if (node.type === "Literal" && typeof node.value === "string") {
      return astUtils.hasOctalOrNonOctalDecimalEscapeSequence(node.raw);
    }
    return false;
  }
  function hasStringLiteral(node) {
    if (isConcatenation(node)) {
      return hasStringLiteral(node.right) || hasStringLiteral(node.left);
    }
    return astUtils.isStringLiteral(node);
  }
  function hasNonStringLiteral(node) {
    if (isConcatenation(node)) {
      return hasNonStringLiteral(node.right) || hasNonStringLiteral(node.left);
    }
    return !astUtils.isStringLiteral(node);
  }
  function startsWithTemplateCurly(node) {
    if (node.type === "BinaryExpression") {
      return startsWithTemplateCurly(node.left);
    }
    if (node.type === "TemplateLiteral") {
      return node.expressions.length && node.quasis.length && node.quasis[0].range[0] === node.quasis[0].range[1];
    }
    return node.type !== "Literal" || typeof node.value !== "string";
  }
  function endsWithTemplateCurly(node) {
    if (node.type === "BinaryExpression") {
      return startsWithTemplateCurly(node.right);
    }
    if (node.type === "TemplateLiteral") {
      return node.expressions.length && node.quasis.length && node.quasis[node.quasis.length - 1].range[0] === node.quasis[node.quasis.length - 1].range[1];
    }
    return node.type !== "Literal" || typeof node.value !== "string";
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require template literals instead of string concatenation",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/prefer-template"
      },
      schema: [],
      fixable: "code",
      messages: {
        unexpectedStringConcatenation: "Unexpected string concatenation."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let done = Object.create(null);
      function getTextBetween(node1, node2) {
        const allTokens = [node1].concat(sourceCode.getTokensBetween(node1, node2)).concat(node2);
        const sourceText = sourceCode.getText();
        return allTokens.slice(0, -1).reduce((accumulator, token, index) => accumulator + sourceText.slice(token.range[1], allTokens[index + 1].range[0]), "");
      }
      function getTemplateLiteral(currentNode, textBeforeNode, textAfterNode) {
        if (currentNode.type === "Literal" && typeof currentNode.value === "string") {
          return `\`${currentNode.raw.slice(1, -1).replace(/\\*(\$\{|`)/gu, (matched) => {
            if (matched.lastIndexOf("\\") % 2) {
              return `\\${matched}`;
            }
            return matched;
          }).replace(new RegExp(`\\\\${currentNode.raw[0]}`, "gu"), currentNode.raw[0])}\``;
        }
        if (currentNode.type === "TemplateLiteral") {
          return sourceCode.getText(currentNode);
        }
        if (isConcatenation(currentNode) && hasStringLiteral(currentNode) && hasNonStringLiteral(currentNode)) {
          const plusSign = sourceCode.getFirstTokenBetween(currentNode.left, currentNode.right, (token) => token.value === "+");
          const textBeforePlus = getTextBetween(currentNode.left, plusSign);
          const textAfterPlus = getTextBetween(plusSign, currentNode.right);
          const leftEndsWithCurly = endsWithTemplateCurly(currentNode.left);
          const rightStartsWithCurly = startsWithTemplateCurly(currentNode.right);
          if (leftEndsWithCurly) {
            return getTemplateLiteral(currentNode.left, textBeforeNode, textBeforePlus + textAfterPlus).slice(0, -1) + getTemplateLiteral(currentNode.right, null, textAfterNode).slice(1);
          }
          if (rightStartsWithCurly) {
            return getTemplateLiteral(currentNode.left, textBeforeNode, null).slice(0, -1) + getTemplateLiteral(currentNode.right, textBeforePlus + textAfterPlus, textAfterNode).slice(1);
          }
          return `${getTemplateLiteral(currentNode.left, textBeforeNode, null)}${textBeforePlus}+${textAfterPlus}${getTemplateLiteral(currentNode.right, textAfterNode, null)}`;
        }
        return `\`\${${textBeforeNode || ""}${sourceCode.getText(currentNode)}${textAfterNode || ""}}\``;
      }
      function fixNonStringBinaryExpression(fixer, node) {
        const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
        if (hasOctalOrNonOctalDecimalEscapeSequence(topBinaryExpr)) {
          return null;
        }
        return fixer.replaceText(topBinaryExpr, getTemplateLiteral(topBinaryExpr, null, null));
      }
      function checkForStringConcat(node) {
        if (!astUtils.isStringLiteral(node) || !isConcatenation(node.parent)) {
          return;
        }
        const topBinaryExpr = getTopConcatBinaryExpression(node.parent);
        if (done[topBinaryExpr.range[0]]) {
          return;
        }
        done[topBinaryExpr.range[0]] = true;
        if (hasNonStringLiteral(topBinaryExpr)) {
          context4.report({
            node: topBinaryExpr,
            messageId: "unexpectedStringConcatenation",
            fix: (fixer) => fixNonStringBinaryExpression(fixer, node)
          });
        }
      }
      return {
        Program() {
          done = Object.create(null);
        },
        Literal: checkForStringConcat,
        TemplateLiteral: checkForStringConcat
      };
    }
  };
});

// node_modules/eslint/lib/rules/quote-props.js
var require_quote_props = __commonJS((exports2, module2) => {
  "use strict";
  var espree = require("espree");
  var astUtils = require_ast_utils2();
  var keywords = require_keywords();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require quotes around object literal property names",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/quote-props"
      },
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
              }
            ],
            minItems: 0,
            maxItems: 1
          },
          {
            type: "array",
            items: [
              {
                enum: ["always", "as-needed", "consistent", "consistent-as-needed"]
              },
              {
                type: "object",
                properties: {
                  keywords: {
                    type: "boolean"
                  },
                  unnecessary: {
                    type: "boolean"
                  },
                  numbers: {
                    type: "boolean"
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      fixable: "code",
      messages: {
        requireQuotesDueToReservedWord: "Properties should be quoted as '{{property}}' is a reserved word.",
        inconsistentlyQuotedProperty: "Inconsistently quoted property '{{key}}' found.",
        unnecessarilyQuotedProperty: "Unnecessarily quoted property '{{property}}' found.",
        unquotedReservedProperty: "Unquoted reserved word '{{property}}' used as key.",
        unquotedNumericProperty: "Unquoted number literal '{{property}}' used as key.",
        unquotedPropertyFound: "Unquoted property '{{property}}' found.",
        redundantQuoting: "Properties shouldn't be quoted as all quotes are redundant."
      }
    },
    create(context4) {
      const MODE = context4.options[0], KEYWORDS = context4.options[1] && context4.options[1].keywords, CHECK_UNNECESSARY = !context4.options[1] || context4.options[1].unnecessary !== false, NUMBERS = context4.options[1] && context4.options[1].numbers, sourceCode = context4.getSourceCode();
      function isKeyword(tokenStr) {
        return keywords.indexOf(tokenStr) >= 0;
      }
      function areQuotesRedundant(rawKey, tokens, skipNumberLiterals) {
        return tokens.length === 1 && tokens[0].start === 0 && tokens[0].end === rawKey.length && (["Identifier", "Keyword", "Null", "Boolean"].indexOf(tokens[0].type) >= 0 || tokens[0].type === "Numeric" && !skipNumberLiterals && String(+tokens[0].value) === tokens[0].value);
      }
      function getUnquotedKey(key) {
        return key.type === "Identifier" ? key.name : key.value;
      }
      function getQuotedKey(key) {
        if (key.type === "Literal" && typeof key.value === "string") {
          return sourceCode.getText(key);
        }
        return `"${key.type === "Identifier" ? key.name : key.value}"`;
      }
      function checkUnnecessaryQuotes(node) {
        const key = node.key;
        if (node.method || node.computed || node.shorthand) {
          return;
        }
        if (key.type === "Literal" && typeof key.value === "string") {
          let tokens;
          try {
            tokens = espree.tokenize(key.value);
          } catch (e) {
            return;
          }
          if (tokens.length !== 1) {
            return;
          }
          const isKeywordToken = isKeyword(tokens[0].value);
          if (isKeywordToken && KEYWORDS) {
            return;
          }
          if (CHECK_UNNECESSARY && areQuotesRedundant(key.value, tokens, NUMBERS)) {
            context4.report({
              node,
              messageId: "unnecessarilyQuotedProperty",
              data: {property: key.value},
              fix: (fixer) => fixer.replaceText(key, getUnquotedKey(key))
            });
          }
        } else if (KEYWORDS && key.type === "Identifier" && isKeyword(key.name)) {
          context4.report({
            node,
            messageId: "unquotedReservedProperty",
            data: {property: key.name},
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        } else if (NUMBERS && key.type === "Literal" && astUtils.isNumericLiteral(key)) {
          context4.report({
            node,
            messageId: "unquotedNumericProperty",
            data: {property: key.value},
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        }
      }
      function checkOmittedQuotes(node) {
        const key = node.key;
        if (!node.method && !node.computed && !node.shorthand && !(key.type === "Literal" && typeof key.value === "string")) {
          context4.report({
            node,
            messageId: "unquotedPropertyFound",
            data: {property: key.name || key.value},
            fix: (fixer) => fixer.replaceText(key, getQuotedKey(key))
          });
        }
      }
      function checkConsistency(node, checkQuotesRedundancy) {
        const quotedProps = [], unquotedProps = [];
        let keywordKeyName = null, necessaryQuotes = false;
        node.properties.forEach((property) => {
          const key = property.key;
          if (!key || property.method || property.computed || property.shorthand) {
            return;
          }
          if (key.type === "Literal" && typeof key.value === "string") {
            quotedProps.push(property);
            if (checkQuotesRedundancy) {
              let tokens;
              try {
                tokens = espree.tokenize(key.value);
              } catch (e) {
                necessaryQuotes = true;
                return;
              }
              necessaryQuotes = necessaryQuotes || !areQuotesRedundant(key.value, tokens) || KEYWORDS && isKeyword(tokens[0].value);
            }
          } else if (KEYWORDS && checkQuotesRedundancy && key.type === "Identifier" && isKeyword(key.name)) {
            unquotedProps.push(property);
            necessaryQuotes = true;
            keywordKeyName = key.name;
          } else {
            unquotedProps.push(property);
          }
        });
        if (checkQuotesRedundancy && quotedProps.length && !necessaryQuotes) {
          quotedProps.forEach((property) => {
            context4.report({
              node: property,
              messageId: "redundantQuoting",
              fix: (fixer) => fixer.replaceText(property.key, getUnquotedKey(property.key))
            });
          });
        } else if (unquotedProps.length && keywordKeyName) {
          unquotedProps.forEach((property) => {
            context4.report({
              node: property,
              messageId: "requireQuotesDueToReservedWord",
              data: {property: keywordKeyName},
              fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
            });
          });
        } else if (quotedProps.length && unquotedProps.length) {
          unquotedProps.forEach((property) => {
            context4.report({
              node: property,
              messageId: "inconsistentlyQuotedProperty",
              data: {key: property.key.name || property.key.value},
              fix: (fixer) => fixer.replaceText(property.key, getQuotedKey(property.key))
            });
          });
        }
      }
      return {
        Property(node) {
          if (MODE === "always" || !MODE) {
            checkOmittedQuotes(node);
          }
          if (MODE === "as-needed") {
            checkUnnecessaryQuotes(node);
          }
        },
        ObjectExpression(node) {
          if (MODE === "consistent") {
            checkConsistency(node, false);
          }
          if (MODE === "consistent-as-needed") {
            checkConsistency(node, true);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/quotes.js
var require_quotes = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var QUOTE_SETTINGS = {
    double: {
      quote: '"',
      alternateQuote: "'",
      description: "doublequote"
    },
    single: {
      quote: "'",
      alternateQuote: '"',
      description: "singlequote"
    },
    backtick: {
      quote: "`",
      alternateQuote: '"',
      description: "backtick"
    }
  };
  var UNESCAPED_LINEBREAK_PATTERN = new RegExp(String.raw`(^|[^\\])(\\\\)*[${Array.from(astUtils.LINEBREAKS).join("")}]`, "u");
  QUOTE_SETTINGS.double.convert = QUOTE_SETTINGS.single.convert = QUOTE_SETTINGS.backtick.convert = function(str) {
    const newQuote = this.quote;
    const oldQuote = str[0];
    if (newQuote === oldQuote) {
      return str;
    }
    return newQuote + str.slice(1, -1).replace(/\\(\$\{|\r\n?|\n|.)|["'`]|\$\{|(\r\n?|\n)/gu, (match, escaped, newline) => {
      if (escaped === oldQuote || oldQuote === "`" && escaped === "${") {
        return escaped;
      }
      if (match === newQuote || newQuote === "`" && match === "${") {
        return `\\${match}`;
      }
      if (newline && oldQuote === "`") {
        return "\\n";
      }
      return match;
    }) + newQuote;
  };
  var AVOID_ESCAPE = "avoid-escape";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce the consistent use of either backticks, double, or single quotes",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/quotes"
      },
      fixable: "code",
      schema: [
        {
          enum: ["single", "double", "backtick"]
        },
        {
          anyOf: [
            {
              enum: ["avoid-escape"]
            },
            {
              type: "object",
              properties: {
                avoidEscape: {
                  type: "boolean"
                },
                allowTemplateLiterals: {
                  type: "boolean"
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        wrongQuotes: "Strings must use {{description}}."
      }
    },
    create(context4) {
      const quoteOption = context4.options[0], settings = QUOTE_SETTINGS[quoteOption || "double"], options = context4.options[1], allowTemplateLiterals = options && options.allowTemplateLiterals === true, sourceCode = context4.getSourceCode();
      let avoidEscape = options && options.avoidEscape === true;
      if (options === AVOID_ESCAPE) {
        avoidEscape = true;
      }
      function isJSXLiteral(node) {
        return node.parent.type === "JSXAttribute" || node.parent.type === "JSXElement" || node.parent.type === "JSXFragment";
      }
      function isDirective(node) {
        return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
      }
      function isPartOfDirectivePrologue(node) {
        const block = node.parent.parent;
        if (block.type !== "Program" && (block.type !== "BlockStatement" || !astUtils.isFunction(block.parent))) {
          return false;
        }
        for (let i = 0; i < block.body.length; ++i) {
          const statement = block.body[i];
          if (statement === node.parent) {
            return true;
          }
          if (!isDirective(statement)) {
            break;
          }
        }
        return false;
      }
      function isAllowedAsNonBacktick(node) {
        const parent = node.parent;
        switch (parent.type) {
          case "ExpressionStatement":
            return isPartOfDirectivePrologue(node);
          case "Property":
          case "MethodDefinition":
            return parent.key === node && !parent.computed;
          case "ImportDeclaration":
          case "ExportNamedDeclaration":
          case "ExportAllDeclaration":
            return parent.source === node;
          default:
            return false;
        }
      }
      function isUsingFeatureOfTemplateLiteral(node) {
        const hasTag = node.parent.type === "TaggedTemplateExpression" && node === node.parent.quasi;
        if (hasTag) {
          return true;
        }
        const hasStringInterpolation = node.expressions.length > 0;
        if (hasStringInterpolation) {
          return true;
        }
        const isMultilineString = node.quasis.length >= 1 && UNESCAPED_LINEBREAK_PATTERN.test(node.quasis[0].value.raw);
        if (isMultilineString) {
          return true;
        }
        return false;
      }
      return {
        Literal(node) {
          const val = node.value, rawVal = node.raw;
          if (settings && typeof val === "string") {
            let isValid = quoteOption === "backtick" && isAllowedAsNonBacktick(node) || isJSXLiteral(node) || astUtils.isSurroundedBy(rawVal, settings.quote);
            if (!isValid && avoidEscape) {
              isValid = astUtils.isSurroundedBy(rawVal, settings.alternateQuote) && rawVal.indexOf(settings.quote) >= 0;
            }
            if (!isValid) {
              context4.report({
                node,
                messageId: "wrongQuotes",
                data: {
                  description: settings.description
                },
                fix(fixer) {
                  if (quoteOption === "backtick" && astUtils.hasOctalOrNonOctalDecimalEscapeSequence(rawVal)) {
                    return null;
                  }
                  return fixer.replaceText(node, settings.convert(node.raw));
                }
              });
            }
          }
        },
        TemplateLiteral(node) {
          if (allowTemplateLiterals || quoteOption === "backtick" || isUsingFeatureOfTemplateLiteral(node)) {
            return;
          }
          context4.report({
            node,
            messageId: "wrongQuotes",
            data: {
              description: settings.description
            },
            fix(fixer) {
              if (isPartOfDirectivePrologue(node)) {
                return null;
              }
              return fixer.replaceText(node, settings.convert(sourceCode.getText(node)));
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/radix.js
var require_radix = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var MODE_ALWAYS = "always";
  var MODE_AS_NEEDED = "as-needed";
  var validRadixValues = new Set(Array.from({length: 37 - 2}, (_, index) => index + 2));
  function isShadowed(variable) {
    return variable.defs.length >= 1;
  }
  function isParseIntMethod(node) {
    return node.type === "MemberExpression" && !node.computed && node.property.type === "Identifier" && node.property.name === "parseInt";
  }
  function isValidRadix(radix) {
    return !(radix.type === "Literal" && !validRadixValues.has(radix.value) || radix.type === "Identifier" && radix.name === "undefined");
  }
  function isDefaultRadix(radix) {
    return radix.type === "Literal" && radix.value === 10;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce the consistent use of the radix argument when using `parseInt()`",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/radix"
      },
      schema: [
        {
          enum: ["always", "as-needed"]
        }
      ],
      messages: {
        missingParameters: "Missing parameters.",
        redundantRadix: "Redundant radix parameter.",
        missingRadix: "Missing radix parameter.",
        invalidRadix: "Invalid radix parameter, must be an integer between 2 and 36."
      }
    },
    create(context4) {
      const mode = context4.options[0] || MODE_ALWAYS;
      function checkArguments(node) {
        const args = node.arguments;
        switch (args.length) {
          case 0:
            context4.report({
              node,
              messageId: "missingParameters"
            });
            break;
          case 1:
            if (mode === MODE_ALWAYS) {
              context4.report({
                node,
                messageId: "missingRadix"
              });
            }
            break;
          default:
            if (mode === MODE_AS_NEEDED && isDefaultRadix(args[1])) {
              context4.report({
                node,
                messageId: "redundantRadix"
              });
            } else if (!isValidRadix(args[1])) {
              context4.report({
                node,
                messageId: "invalidRadix"
              });
            }
            break;
        }
      }
      return {
        "Program:exit"() {
          const scope = context4.getScope();
          let variable;
          variable = astUtils.getVariableByName(scope, "parseInt");
          if (variable && !isShadowed(variable)) {
            variable.references.forEach((reference) => {
              const node = reference.identifier;
              if (astUtils.isCallee(node)) {
                checkArguments(node.parent);
              }
            });
          }
          variable = astUtils.getVariableByName(scope, "Number");
          if (variable && !isShadowed(variable)) {
            variable.references.forEach((reference) => {
              const node = reference.identifier.parent;
              const maybeCallee = node.parent.type === "ChainExpression" ? node.parent : node;
              if (isParseIntMethod(node) && astUtils.isCallee(maybeCallee)) {
                checkArguments(maybeCallee.parent);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/require-atomic-updates.js
var require_require_atomic_updates = __commonJS((exports2, module2) => {
  "use strict";
  function createReferenceMap(scope, outReferenceMap = new Map()) {
    for (const reference of scope.references) {
      outReferenceMap.set(reference.identifier, reference);
    }
    for (const childScope of scope.childScopes) {
      if (childScope.type !== "function") {
        createReferenceMap(childScope, outReferenceMap);
      }
    }
    return outReferenceMap;
  }
  function getWriteExpr(reference) {
    if (reference.writeExpr) {
      return reference.writeExpr;
    }
    let node = reference.identifier;
    while (node) {
      const t = node.parent.type;
      if (t === "AssignmentExpression" && node.parent.left === node) {
        return node.parent.right;
      }
      if (t === "MemberExpression" && node.parent.object === node) {
        node = node.parent;
        continue;
      }
      break;
    }
    return null;
  }
  function isLocalVariableWithoutEscape(variable, isMemberAccess) {
    if (!variable) {
      return false;
    }
    if (isMemberAccess && variable.defs.some((d) => d.type === "Parameter")) {
      return false;
    }
    const functionScope = variable.scope.variableScope;
    return variable.references.every((reference) => reference.from.variableScope === functionScope);
  }
  var SegmentInfo = class {
    constructor() {
      this.info = new WeakMap();
    }
    initialize(segment) {
      const outdatedReadVariableNames = new Set();
      const freshReadVariableNames = new Set();
      for (const prevSegment of segment.prevSegments) {
        const info3 = this.info.get(prevSegment);
        if (info3) {
          info3.outdatedReadVariableNames.forEach(Set.prototype.add, outdatedReadVariableNames);
          info3.freshReadVariableNames.forEach(Set.prototype.add, freshReadVariableNames);
        }
      }
      this.info.set(segment, {outdatedReadVariableNames, freshReadVariableNames});
    }
    markAsRead(segments, variableName) {
      for (const segment of segments) {
        const info3 = this.info.get(segment);
        if (info3) {
          info3.freshReadVariableNames.add(variableName);
          info3.outdatedReadVariableNames.delete(variableName);
        }
      }
    }
    makeOutdated(segments) {
      for (const segment of segments) {
        const info3 = this.info.get(segment);
        if (info3) {
          info3.freshReadVariableNames.forEach(Set.prototype.add, info3.outdatedReadVariableNames);
          info3.freshReadVariableNames.clear();
        }
      }
    }
    isOutdated(segments, variableName) {
      for (const segment of segments) {
        const info3 = this.info.get(segment);
        if (info3 && info3.outdatedReadVariableNames.has(variableName)) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "disallow assignments that can lead to race conditions due to usage of `await` or `yield`",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/require-atomic-updates"
      },
      fixable: null,
      schema: [],
      messages: {
        nonAtomicUpdate: "Possible race condition: `{{value}}` might be reassigned based on an outdated value of `{{value}}`."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const assignmentReferences = new Map();
      const segmentInfo = new SegmentInfo();
      let stack = null;
      return {
        onCodePathStart(codePath) {
          const scope = context4.getScope();
          const shouldVerify = scope.type === "function" && (scope.block.async || scope.block.generator);
          stack = {
            upper: stack,
            codePath,
            referenceMap: shouldVerify ? createReferenceMap(scope) : null
          };
        },
        onCodePathEnd() {
          stack = stack.upper;
        },
        onCodePathSegmentStart(segment) {
          segmentInfo.initialize(segment);
        },
        Identifier(node) {
          const {codePath, referenceMap} = stack;
          const reference = referenceMap && referenceMap.get(node);
          if (!reference) {
            return;
          }
          const name = reference.identifier.name;
          const variable = reference.resolved;
          const writeExpr = getWriteExpr(reference);
          const isMemberAccess = reference.identifier.parent.type === "MemberExpression";
          if (reference.isRead() && !(writeExpr && writeExpr.parent.operator === "=")) {
            segmentInfo.markAsRead(codePath.currentSegments, name);
          }
          if (writeExpr && writeExpr.parent.right === writeExpr && !isLocalVariableWithoutEscape(variable, isMemberAccess)) {
            let refs = assignmentReferences.get(writeExpr);
            if (!refs) {
              refs = [];
              assignmentReferences.set(writeExpr, refs);
            }
            refs.push(reference);
          }
        },
        ":expression:exit"(node) {
          const {codePath, referenceMap} = stack;
          if (!referenceMap) {
            return;
          }
          if (node.type === "AwaitExpression" || node.type === "YieldExpression") {
            segmentInfo.makeOutdated(codePath.currentSegments);
          }
          const references = assignmentReferences.get(node);
          if (references) {
            assignmentReferences.delete(node);
            for (const reference of references) {
              const name = reference.identifier.name;
              if (segmentInfo.isOutdated(codePath.currentSegments, name)) {
                context4.report({
                  node: node.parent,
                  messageId: "nonAtomicUpdate",
                  data: {
                    value: sourceCode.getText(node.parent.left)
                  }
                });
              }
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/require-await.js
var require_require_await = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function capitalizeFirstLetter(text) {
    return text[0].toUpperCase() + text.slice(1);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "disallow async functions which have no `await` expression",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/require-await"
      },
      schema: [],
      messages: {
        missingAwait: "{{name}} has no 'await' expression."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      let scopeInfo = null;
      function enterFunction() {
        scopeInfo = {
          upper: scopeInfo,
          hasAwait: false
        };
      }
      function exitFunction(node) {
        if (!node.generator && node.async && !scopeInfo.hasAwait && !astUtils.isEmptyFunction(node)) {
          context4.report({
            node,
            loc: astUtils.getFunctionHeadLoc(node, sourceCode),
            messageId: "missingAwait",
            data: {
              name: capitalizeFirstLetter(astUtils.getFunctionNameWithKind(node))
            }
          });
        }
        scopeInfo = scopeInfo.upper;
      }
      return {
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression: enterFunction,
        "FunctionDeclaration:exit": exitFunction,
        "FunctionExpression:exit": exitFunction,
        "ArrowFunctionExpression:exit": exitFunction,
        AwaitExpression() {
          if (!scopeInfo) {
            return;
          }
          scopeInfo.hasAwait = true;
        },
        ForOfStatement(node) {
          if (!scopeInfo) {
            return;
          }
          if (node.await) {
            scopeInfo.hasAwait = true;
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/require-jsdoc.js
var require_require_jsdoc = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require JSDoc comments",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/require-jsdoc"
      },
      schema: [
        {
          type: "object",
          properties: {
            require: {
              type: "object",
              properties: {
                ClassDeclaration: {
                  type: "boolean",
                  default: false
                },
                MethodDefinition: {
                  type: "boolean",
                  default: false
                },
                FunctionDeclaration: {
                  type: "boolean",
                  default: true
                },
                ArrowFunctionExpression: {
                  type: "boolean",
                  default: false
                },
                FunctionExpression: {
                  type: "boolean",
                  default: false
                }
              },
              additionalProperties: false,
              default: {}
            }
          },
          additionalProperties: false
        }
      ],
      deprecated: true,
      replacedBy: [],
      messages: {
        missingJSDocComment: "Missing JSDoc comment."
      }
    },
    create(context4) {
      const source = context4.getSourceCode();
      const DEFAULT_OPTIONS = {
        FunctionDeclaration: true,
        MethodDefinition: false,
        ClassDeclaration: false,
        ArrowFunctionExpression: false,
        FunctionExpression: false
      };
      const options = Object.assign(DEFAULT_OPTIONS, context4.options[0] && context4.options[0].require);
      function report(node) {
        context4.report({node, messageId: "missingJSDocComment"});
      }
      function checkJsDoc(node) {
        const jsdocComment = source.getJSDocComment(node);
        if (!jsdocComment) {
          report(node);
        }
      }
      return {
        FunctionDeclaration(node) {
          if (options.FunctionDeclaration) {
            checkJsDoc(node);
          }
        },
        FunctionExpression(node) {
          if (options.MethodDefinition && node.parent.type === "MethodDefinition" || options.FunctionExpression && (node.parent.type === "VariableDeclarator" || node.parent.type === "Property" && node === node.parent.value)) {
            checkJsDoc(node);
          }
        },
        ClassDeclaration(node) {
          if (options.ClassDeclaration) {
            checkJsDoc(node);
          }
        },
        ArrowFunctionExpression(node) {
          if (options.ArrowFunctionExpression && node.parent.type === "VariableDeclarator") {
            checkJsDoc(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/require-unicode-regexp.js
var require_require_unicode_regexp = __commonJS((exports2, module2) => {
  "use strict";
  var {
    CALL,
    CONSTRUCT,
    ReferenceTracker,
    getStringIfConstant
  } = require_eslint_utils();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce the use of `u` flag on RegExp",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/require-unicode-regexp"
      },
      messages: {
        requireUFlag: "Use the 'u' flag."
      },
      schema: []
    },
    create(context4) {
      return {
        "Literal[regex]"(node) {
          const flags = node.regex.flags || "";
          if (!flags.includes("u")) {
            context4.report({node, messageId: "requireUFlag"});
          }
        },
        Program() {
          const scope = context4.getScope();
          const tracker = new ReferenceTracker(scope);
          const trackMap = {
            RegExp: {[CALL]: true, [CONSTRUCT]: true}
          };
          for (const {node} of tracker.iterateGlobalReferences(trackMap)) {
            const flagsNode = node.arguments[1];
            const flags = getStringIfConstant(flagsNode, scope);
            if (!flagsNode || typeof flags === "string" && !flags.includes("u")) {
              context4.report({node, messageId: "requireUFlag"});
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/require-yield.js
var require_require_yield = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require generator functions to contain `yield`",
        category: "ECMAScript 6",
        recommended: true,
        url: "https://eslint.org/docs/rules/require-yield"
      },
      schema: [],
      messages: {
        missingYield: "This generator function does not have 'yield'."
      }
    },
    create(context4) {
      const stack = [];
      function beginChecking(node) {
        if (node.generator) {
          stack.push(0);
        }
      }
      function endChecking(node) {
        if (!node.generator) {
          return;
        }
        const countYield = stack.pop();
        if (countYield === 0 && node.body.body.length > 0) {
          context4.report({node, messageId: "missingYield"});
        }
      }
      return {
        FunctionDeclaration: beginChecking,
        "FunctionDeclaration:exit": endChecking,
        FunctionExpression: beginChecking,
        "FunctionExpression:exit": endChecking,
        YieldExpression() {
          if (stack.length > 0) {
            stack[stack.length - 1] += 1;
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/rest-spread-spacing.js
var require_rest_spread_spacing = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce spacing between rest and spread operators and their expressions",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/rest-spread-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        unexpectedWhitespace: "Unexpected whitespace after {{type}} operator.",
        expectedWhitespace: "Expected whitespace after {{type}} operator."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode(), alwaysSpace = context4.options[0] === "always";
      function checkWhiteSpace(node) {
        const operator = sourceCode.getFirstToken(node), nextToken = sourceCode.getTokenAfter(operator), hasWhitespace = sourceCode.isSpaceBetweenTokens(operator, nextToken);
        let type;
        switch (node.type) {
          case "SpreadElement":
            type = "spread";
            if (node.parent.type === "ObjectExpression") {
              type += " property";
            }
            break;
          case "RestElement":
            type = "rest";
            if (node.parent.type === "ObjectPattern") {
              type += " property";
            }
            break;
          case "ExperimentalSpreadProperty":
            type = "spread property";
            break;
          case "ExperimentalRestProperty":
            type = "rest property";
            break;
          default:
            return;
        }
        if (alwaysSpace && !hasWhitespace) {
          context4.report({
            node,
            loc: operator.loc,
            messageId: "expectedWhitespace",
            data: {
              type
            },
            fix(fixer) {
              return fixer.replaceTextRange([operator.range[1], nextToken.range[0]], " ");
            }
          });
        } else if (!alwaysSpace && hasWhitespace) {
          context4.report({
            node,
            loc: {
              start: operator.loc.end,
              end: nextToken.loc.start
            },
            messageId: "unexpectedWhitespace",
            data: {
              type
            },
            fix(fixer) {
              return fixer.removeRange([operator.range[1], nextToken.range[0]]);
            }
          });
        }
      }
      return {
        SpreadElement: checkWhiteSpace,
        RestElement: checkWhiteSpace,
        ExperimentalSpreadProperty: checkWhiteSpace,
        ExperimentalRestProperty: checkWhiteSpace
      };
    }
  };
});

// node_modules/eslint/lib/rules/semi.js
var require_semi = __commonJS((exports2, module2) => {
  "use strict";
  var FixTracker = require_fix_tracker();
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow semicolons instead of ASI",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/semi"
      },
      fixable: "code",
      schema: {
        anyOf: [
          {
            type: "array",
            items: [
              {
                enum: ["never"]
              },
              {
                type: "object",
                properties: {
                  beforeStatementContinuationChars: {
                    enum: ["always", "any", "never"]
                  }
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          },
          {
            type: "array",
            items: [
              {
                enum: ["always"]
              },
              {
                type: "object",
                properties: {
                  omitLastInOneLineBlock: {type: "boolean"}
                },
                additionalProperties: false
              }
            ],
            minItems: 0,
            maxItems: 2
          }
        ]
      },
      messages: {
        missingSemi: "Missing semicolon.",
        extraSemi: "Extra semicolon."
      }
    },
    create(context4) {
      const OPT_OUT_PATTERN = /^[-[(/+`]/u;
      const options = context4.options[1];
      const never = context4.options[0] === "never";
      const exceptOneLine = Boolean(options && options.omitLastInOneLineBlock);
      const beforeStatementContinuationChars = options && options.beforeStatementContinuationChars || "any";
      const sourceCode = context4.getSourceCode();
      function report(node, missing) {
        const lastToken = sourceCode.getLastToken(node);
        let messageId, fix, loc;
        if (!missing) {
          messageId = "missingSemi";
          loc = {
            start: lastToken.loc.end,
            end: astUtils.getNextLocation(sourceCode, lastToken.loc.end)
          };
          fix = function(fixer) {
            return fixer.insertTextAfter(lastToken, ";");
          };
        } else {
          messageId = "extraSemi";
          loc = lastToken.loc;
          fix = function(fixer) {
            return new FixTracker(fixer, sourceCode).retainSurroundingTokens(lastToken).remove(lastToken);
          };
        }
        context4.report({
          node,
          loc,
          messageId,
          fix
        });
      }
      function isRedundantSemi(semiToken) {
        const nextToken = sourceCode.getTokenAfter(semiToken);
        return !nextToken || astUtils.isClosingBraceToken(nextToken) || astUtils.isSemicolonToken(nextToken);
      }
      function isEndOfArrowBlock(lastToken) {
        if (!astUtils.isClosingBraceToken(lastToken)) {
          return false;
        }
        const node = sourceCode.getNodeByRangeIndex(lastToken.range[0]);
        return node.type === "BlockStatement" && node.parent.type === "ArrowFunctionExpression";
      }
      function isOnSameLineWithNextToken(node) {
        const prevToken = sourceCode.getLastToken(node, 1);
        const nextToken = sourceCode.getTokenAfter(node);
        return !!nextToken && astUtils.isTokenOnSameLine(prevToken, nextToken);
      }
      function maybeAsiHazardAfter(node) {
        const t = node.type;
        if (t === "DoWhileStatement" || t === "BreakStatement" || t === "ContinueStatement" || t === "DebuggerStatement" || t === "ImportDeclaration" || t === "ExportAllDeclaration") {
          return false;
        }
        if (t === "ReturnStatement") {
          return Boolean(node.argument);
        }
        if (t === "ExportNamedDeclaration") {
          return Boolean(node.declaration);
        }
        if (isEndOfArrowBlock(sourceCode.getLastToken(node, 1))) {
          return false;
        }
        return true;
      }
      function maybeAsiHazardBefore(token) {
        return Boolean(token) && OPT_OUT_PATTERN.test(token.value) && token.value !== "++" && token.value !== "--";
      }
      function canRemoveSemicolon(node) {
        if (isRedundantSemi(sourceCode.getLastToken(node))) {
          return true;
        }
        if (isOnSameLineWithNextToken(node)) {
          return false;
        }
        if (beforeStatementContinuationChars === "never" && !maybeAsiHazardAfter(node)) {
          return true;
        }
        if (!maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
          return true;
        }
        return false;
      }
      function isOneLinerBlock(node) {
        const parent = node.parent;
        const nextToken = sourceCode.getTokenAfter(node);
        if (!nextToken || nextToken.value !== "}") {
          return false;
        }
        return !!parent && parent.type === "BlockStatement" && parent.loc.start.line === parent.loc.end.line;
      }
      function checkForSemicolon(node) {
        const isSemi = astUtils.isSemicolonToken(sourceCode.getLastToken(node));
        if (never) {
          if (isSemi && canRemoveSemicolon(node)) {
            report(node, true);
          } else if (!isSemi && beforeStatementContinuationChars === "always" && maybeAsiHazardBefore(sourceCode.getTokenAfter(node))) {
            report(node);
          }
        } else {
          const oneLinerBlock = exceptOneLine && isOneLinerBlock(node);
          if (isSemi && oneLinerBlock) {
            report(node, true);
          } else if (!isSemi && !oneLinerBlock) {
            report(node);
          }
        }
      }
      function checkForSemicolonForVariableDeclaration(node) {
        const parent = node.parent;
        if ((parent.type !== "ForStatement" || parent.init !== node) && (!/^For(?:In|Of)Statement/u.test(parent.type) || parent.left !== node)) {
          checkForSemicolon(node);
        }
      }
      return {
        VariableDeclaration: checkForSemicolonForVariableDeclaration,
        ExpressionStatement: checkForSemicolon,
        ReturnStatement: checkForSemicolon,
        ThrowStatement: checkForSemicolon,
        DoWhileStatement: checkForSemicolon,
        DebuggerStatement: checkForSemicolon,
        BreakStatement: checkForSemicolon,
        ContinueStatement: checkForSemicolon,
        ImportDeclaration: checkForSemicolon,
        ExportAllDeclaration: checkForSemicolon,
        ExportNamedDeclaration(node) {
          if (!node.declaration) {
            checkForSemicolon(node);
          }
        },
        ExportDefaultDeclaration(node) {
          if (!/(?:Class|Function)Declaration/u.test(node.declaration.type)) {
            checkForSemicolon(node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/semi-spacing.js
var require_semi_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before and after semicolons",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/semi-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            before: {
              type: "boolean",
              default: false
            },
            after: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedWhitespaceBefore: "Unexpected whitespace before semicolon.",
        unexpectedWhitespaceAfter: "Unexpected whitespace after semicolon.",
        missingWhitespaceBefore: "Missing whitespace before semicolon.",
        missingWhitespaceAfter: "Missing whitespace after semicolon."
      }
    },
    create(context4) {
      const config = context4.options[0], sourceCode = context4.getSourceCode();
      let requireSpaceBefore = false, requireSpaceAfter = true;
      if (typeof config === "object") {
        requireSpaceBefore = config.before;
        requireSpaceAfter = config.after;
      }
      function hasLeadingSpace(token) {
        const tokenBefore = sourceCode.getTokenBefore(token);
        return tokenBefore && astUtils.isTokenOnSameLine(tokenBefore, token) && sourceCode.isSpaceBetweenTokens(tokenBefore, token);
      }
      function hasTrailingSpace(token) {
        const tokenAfter = sourceCode.getTokenAfter(token);
        return tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter) && sourceCode.isSpaceBetweenTokens(token, tokenAfter);
      }
      function isLastTokenInCurrentLine(token) {
        const tokenAfter = sourceCode.getTokenAfter(token);
        return !(tokenAfter && astUtils.isTokenOnSameLine(token, tokenAfter));
      }
      function isFirstTokenInCurrentLine(token) {
        const tokenBefore = sourceCode.getTokenBefore(token);
        return !(tokenBefore && astUtils.isTokenOnSameLine(token, tokenBefore));
      }
      function isBeforeClosingParen(token) {
        const nextToken = sourceCode.getTokenAfter(token);
        return nextToken && astUtils.isClosingBraceToken(nextToken) || astUtils.isClosingParenToken(nextToken);
      }
      function checkSemicolonSpacing(token, node) {
        if (astUtils.isSemicolonToken(token)) {
          if (hasLeadingSpace(token)) {
            if (!requireSpaceBefore) {
              const tokenBefore = sourceCode.getTokenBefore(token);
              const loc = {
                start: tokenBefore.loc.end,
                end: token.loc.start
              };
              context4.report({
                node,
                loc,
                messageId: "unexpectedWhitespaceBefore",
                fix(fixer) {
                  return fixer.removeRange([tokenBefore.range[1], token.range[0]]);
                }
              });
            }
          } else {
            if (requireSpaceBefore) {
              const loc = token.loc;
              context4.report({
                node,
                loc,
                messageId: "missingWhitespaceBefore",
                fix(fixer) {
                  return fixer.insertTextBefore(token, " ");
                }
              });
            }
          }
          if (!isFirstTokenInCurrentLine(token) && !isLastTokenInCurrentLine(token) && !isBeforeClosingParen(token)) {
            if (hasTrailingSpace(token)) {
              if (!requireSpaceAfter) {
                const tokenAfter = sourceCode.getTokenAfter(token);
                const loc = {
                  start: token.loc.end,
                  end: tokenAfter.loc.start
                };
                context4.report({
                  node,
                  loc,
                  messageId: "unexpectedWhitespaceAfter",
                  fix(fixer) {
                    return fixer.removeRange([token.range[1], tokenAfter.range[0]]);
                  }
                });
              }
            } else {
              if (requireSpaceAfter) {
                const loc = token.loc;
                context4.report({
                  node,
                  loc,
                  messageId: "missingWhitespaceAfter",
                  fix(fixer) {
                    return fixer.insertTextAfter(token, " ");
                  }
                });
              }
            }
          }
        }
      }
      function checkNode(node) {
        const token = sourceCode.getLastToken(node);
        checkSemicolonSpacing(token, node);
      }
      return {
        VariableDeclaration: checkNode,
        ExpressionStatement: checkNode,
        BreakStatement: checkNode,
        ContinueStatement: checkNode,
        DebuggerStatement: checkNode,
        DoWhileStatement: checkNode,
        ReturnStatement: checkNode,
        ThrowStatement: checkNode,
        ImportDeclaration: checkNode,
        ExportNamedDeclaration: checkNode,
        ExportAllDeclaration: checkNode,
        ExportDefaultDeclaration: checkNode,
        ForStatement(node) {
          if (node.init) {
            checkSemicolonSpacing(sourceCode.getTokenAfter(node.init), node);
          }
          if (node.test) {
            checkSemicolonSpacing(sourceCode.getTokenAfter(node.test), node);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/semi-style.js
var require_semi_style = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var SELECTOR = `:matches(${[
    "BreakStatement",
    "ContinueStatement",
    "DebuggerStatement",
    "DoWhileStatement",
    "ExportAllDeclaration",
    "ExportDefaultDeclaration",
    "ExportNamedDeclaration",
    "ExpressionStatement",
    "ImportDeclaration",
    "ReturnStatement",
    "ThrowStatement",
    "VariableDeclaration"
  ].join(",")})`;
  function getChildren(node) {
    const t = node.type;
    if (t === "BlockStatement" || t === "Program") {
      return node.body;
    }
    if (t === "SwitchCase") {
      return node.consequent;
    }
    return null;
  }
  function isLastChild(node) {
    const t = node.parent.type;
    if (t === "IfStatement" && node.parent.consequent === node && node.parent.alternate) {
      return true;
    }
    if (t === "DoWhileStatement") {
      return true;
    }
    const nodeList = getChildren(node.parent);
    return nodeList !== null && nodeList[nodeList.length - 1] === node;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce location of semicolons",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/semi-style"
      },
      schema: [{enum: ["last", "first"]}],
      fixable: "whitespace",
      messages: {
        expectedSemiColon: "Expected this semicolon to be at {{pos}}."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const option = context4.options[0] || "last";
      function check(semiToken, expected) {
        const prevToken = sourceCode.getTokenBefore(semiToken);
        const nextToken = sourceCode.getTokenAfter(semiToken);
        const prevIsSameLine = !prevToken || astUtils.isTokenOnSameLine(prevToken, semiToken);
        const nextIsSameLine = !nextToken || astUtils.isTokenOnSameLine(semiToken, nextToken);
        if (expected === "last" && !prevIsSameLine || expected === "first" && !nextIsSameLine) {
          context4.report({
            loc: semiToken.loc,
            messageId: "expectedSemiColon",
            data: {
              pos: expected === "last" ? "the end of the previous line" : "the beginning of the next line"
            },
            fix(fixer) {
              if (prevToken && nextToken && sourceCode.commentsExistBetween(prevToken, nextToken)) {
                return null;
              }
              const start = prevToken ? prevToken.range[1] : semiToken.range[0];
              const end = nextToken ? nextToken.range[0] : semiToken.range[1];
              const text = expected === "last" ? ";\n" : "\n;";
              return fixer.replaceTextRange([start, end], text);
            }
          });
        }
      }
      return {
        [SELECTOR](node) {
          if (option === "first" && isLastChild(node)) {
            return;
          }
          const lastToken = sourceCode.getLastToken(node);
          if (astUtils.isSemicolonToken(lastToken)) {
            check(lastToken, option);
          }
        },
        ForStatement(node) {
          const firstSemi = node.init && sourceCode.getTokenAfter(node.init, astUtils.isSemicolonToken);
          const secondSemi = node.test && sourceCode.getTokenAfter(node.test, astUtils.isSemicolonToken);
          if (firstSemi) {
            check(firstSemi, "last");
          }
          if (secondSemi) {
            check(secondSemi, "last");
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/sort-imports.js
var require_sort_imports = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce sorted import declarations within modules",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/sort-imports"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean",
              default: false
            },
            memberSyntaxSortOrder: {
              type: "array",
              items: {
                enum: ["none", "all", "multiple", "single"]
              },
              uniqueItems: true,
              minItems: 4,
              maxItems: 4
            },
            ignoreDeclarationSort: {
              type: "boolean",
              default: false
            },
            ignoreMemberSort: {
              type: "boolean",
              default: false
            },
            allowSeparatedGroups: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        sortImportsAlphabetically: "Imports should be sorted alphabetically.",
        sortMembersAlphabetically: "Member '{{memberName}}' of the import declaration should be sorted alphabetically.",
        unexpectedSyntaxOrder: "Expected '{{syntaxA}}' syntax before '{{syntaxB}}' syntax."
      }
    },
    create(context4) {
      const configuration = context4.options[0] || {}, ignoreCase = configuration.ignoreCase || false, ignoreDeclarationSort = configuration.ignoreDeclarationSort || false, ignoreMemberSort = configuration.ignoreMemberSort || false, memberSyntaxSortOrder = configuration.memberSyntaxSortOrder || ["none", "all", "multiple", "single"], allowSeparatedGroups = configuration.allowSeparatedGroups || false, sourceCode = context4.getSourceCode();
      let previousDeclaration = null;
      function usedMemberSyntax(node) {
        if (node.specifiers.length === 0) {
          return "none";
        }
        if (node.specifiers[0].type === "ImportNamespaceSpecifier") {
          return "all";
        }
        if (node.specifiers.length === 1) {
          return "single";
        }
        return "multiple";
      }
      function getMemberParameterGroupIndex(node) {
        return memberSyntaxSortOrder.indexOf(usedMemberSyntax(node));
      }
      function getFirstLocalMemberName(node) {
        if (node.specifiers[0]) {
          return node.specifiers[0].local.name;
        }
        return null;
      }
      function getNumberOfLinesBetween(left, right) {
        return Math.max(right.loc.start.line - left.loc.end.line - 1, 0);
      }
      return {
        ImportDeclaration(node) {
          if (!ignoreDeclarationSort) {
            if (previousDeclaration && allowSeparatedGroups && getNumberOfLinesBetween(previousDeclaration, node) > 0) {
              previousDeclaration = null;
            }
            if (previousDeclaration) {
              const currentMemberSyntaxGroupIndex = getMemberParameterGroupIndex(node), previousMemberSyntaxGroupIndex = getMemberParameterGroupIndex(previousDeclaration);
              let currentLocalMemberName = getFirstLocalMemberName(node), previousLocalMemberName = getFirstLocalMemberName(previousDeclaration);
              if (ignoreCase) {
                previousLocalMemberName = previousLocalMemberName && previousLocalMemberName.toLowerCase();
                currentLocalMemberName = currentLocalMemberName && currentLocalMemberName.toLowerCase();
              }
              if (currentMemberSyntaxGroupIndex !== previousMemberSyntaxGroupIndex) {
                if (currentMemberSyntaxGroupIndex < previousMemberSyntaxGroupIndex) {
                  context4.report({
                    node,
                    messageId: "unexpectedSyntaxOrder",
                    data: {
                      syntaxA: memberSyntaxSortOrder[currentMemberSyntaxGroupIndex],
                      syntaxB: memberSyntaxSortOrder[previousMemberSyntaxGroupIndex]
                    }
                  });
                }
              } else {
                if (previousLocalMemberName && currentLocalMemberName && currentLocalMemberName < previousLocalMemberName) {
                  context4.report({
                    node,
                    messageId: "sortImportsAlphabetically"
                  });
                }
              }
            }
            previousDeclaration = node;
          }
          if (!ignoreMemberSort) {
            const importSpecifiers = node.specifiers.filter((specifier) => specifier.type === "ImportSpecifier");
            const getSortableName = ignoreCase ? (specifier) => specifier.local.name.toLowerCase() : (specifier) => specifier.local.name;
            const firstUnsortedIndex = importSpecifiers.map(getSortableName).findIndex((name, index, array) => array[index - 1] > name);
            if (firstUnsortedIndex !== -1) {
              context4.report({
                node: importSpecifiers[firstUnsortedIndex],
                messageId: "sortMembersAlphabetically",
                data: {memberName: importSpecifiers[firstUnsortedIndex].local.name},
                fix(fixer) {
                  if (importSpecifiers.some((specifier) => sourceCode.getCommentsBefore(specifier).length || sourceCode.getCommentsAfter(specifier).length)) {
                    return null;
                  }
                  return fixer.replaceTextRange([importSpecifiers[0].range[0], importSpecifiers[importSpecifiers.length - 1].range[1]], importSpecifiers.slice().sort((specifierA, specifierB) => {
                    const aName = getSortableName(specifierA);
                    const bName = getSortableName(specifierB);
                    return aName > bName ? 1 : -1;
                  }).reduce((sourceText, specifier, index) => {
                    const textAfterSpecifier = index === importSpecifiers.length - 1 ? "" : sourceCode.getText().slice(importSpecifiers[index].range[1], importSpecifiers[index + 1].range[0]);
                    return sourceText + sourceCode.getText(specifier) + textAfterSpecifier;
                  }, ""));
                }
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/natural-compare/index.js
var require_natural_compare = __commonJS((exports2, module2) => {
  /*
   * @version    1.4.0
   * @date       2015-10-26
   * @stability  3 - Stable
   * @author     Lauri Rooden (https://github.com/litejs/natural-compare-lite)
   * @license    MIT License
   */
  var naturalCompare = function(a, b) {
    var i, codeA, codeB = 1, posA = 0, posB = 0, alphabet = String.alphabet;
    function getCode(str, pos, code) {
      if (code) {
        for (i = pos; code = getCode(str, i), code < 76 && code > 65; )
          ++i;
        return +str.slice(pos - 1, i);
      }
      code = alphabet && alphabet.indexOf(str.charAt(pos));
      return code > -1 ? code + 76 : (code = str.charCodeAt(pos) || 0, code < 45 || code > 127) ? code : code < 46 ? 65 : code < 48 ? code - 1 : code < 58 ? code + 18 : code < 65 ? code - 11 : code < 91 ? code + 11 : code < 97 ? code - 37 : code < 123 ? code + 5 : code - 63;
    }
    if ((a += "") != (b += ""))
      for (; codeB; ) {
        codeA = getCode(a, posA++);
        codeB = getCode(b, posB++);
        if (codeA < 76 && codeB < 76 && codeA > 66 && codeB > 66) {
          codeA = getCode(a, posA, posA);
          codeB = getCode(b, posB, posA = i);
          posB = i;
        }
        if (codeA != codeB)
          return codeA < codeB ? -1 : 1;
      }
    return 0;
  };
  try {
    module2.exports = naturalCompare;
  } catch (e) {
    String.naturalCompare = naturalCompare;
  }
});

// node_modules/eslint/lib/rules/sort-keys.js
var require_sort_keys = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var naturalCompare = require_natural_compare();
  function getPropertyName(node) {
    const staticName = astUtils.getStaticPropertyName(node);
    if (staticName !== null) {
      return staticName;
    }
    return node.key.name || null;
  }
  var isValidOrders = {
    asc(a, b) {
      return a <= b;
    },
    ascI(a, b) {
      return a.toLowerCase() <= b.toLowerCase();
    },
    ascN(a, b) {
      return naturalCompare(a, b) <= 0;
    },
    ascIN(a, b) {
      return naturalCompare(a.toLowerCase(), b.toLowerCase()) <= 0;
    },
    desc(a, b) {
      return isValidOrders.asc(b, a);
    },
    descI(a, b) {
      return isValidOrders.ascI(b, a);
    },
    descN(a, b) {
      return isValidOrders.ascN(b, a);
    },
    descIN(a, b) {
      return isValidOrders.ascIN(b, a);
    }
  };
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require object keys to be sorted",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/sort-keys"
      },
      schema: [
        {
          enum: ["asc", "desc"]
        },
        {
          type: "object",
          properties: {
            caseSensitive: {
              type: "boolean",
              default: true
            },
            natural: {
              type: "boolean",
              default: false
            },
            minKeys: {
              type: "integer",
              minimum: 2,
              default: 2
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        sortKeys: "Expected object keys to be in {{natural}}{{insensitive}}{{order}}ending order. '{{thisName}}' should be before '{{prevName}}'."
      }
    },
    create(context4) {
      const order = context4.options[0] || "asc";
      const options = context4.options[1];
      const insensitive = options && options.caseSensitive === false;
      const natural = options && options.natural;
      const minKeys = options && options.minKeys;
      const isValidOrder = isValidOrders[order + (insensitive ? "I" : "") + (natural ? "N" : "")];
      let stack = null;
      return {
        ObjectExpression(node) {
          stack = {
            upper: stack,
            prevName: null,
            numKeys: node.properties.length
          };
        },
        "ObjectExpression:exit"() {
          stack = stack.upper;
        },
        SpreadElement(node) {
          if (node.parent.type === "ObjectExpression") {
            stack.prevName = null;
          }
        },
        Property(node) {
          if (node.parent.type === "ObjectPattern") {
            return;
          }
          const prevName = stack.prevName;
          const numKeys = stack.numKeys;
          const thisName = getPropertyName(node);
          if (thisName !== null) {
            stack.prevName = thisName;
          }
          if (prevName === null || thisName === null || numKeys < minKeys) {
            return;
          }
          if (!isValidOrder(prevName, thisName)) {
            context4.report({
              node,
              loc: node.key.loc,
              messageId: "sortKeys",
              data: {
                thisName,
                prevName,
                order,
                insensitive: insensitive ? "insensitive " : "",
                natural: natural ? "natural " : ""
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/sort-vars.js
var require_sort_vars = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require variables within the same declaration block to be sorted",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/sort-vars"
      },
      schema: [
        {
          type: "object",
          properties: {
            ignoreCase: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        sortVars: "Variables within the same declaration block should be sorted alphabetically."
      }
    },
    create(context4) {
      const configuration = context4.options[0] || {}, ignoreCase = configuration.ignoreCase || false, sourceCode = context4.getSourceCode();
      return {
        VariableDeclaration(node) {
          const idDeclarations = node.declarations.filter((decl) => decl.id.type === "Identifier");
          const getSortableName = ignoreCase ? (decl) => decl.id.name.toLowerCase() : (decl) => decl.id.name;
          const unfixable = idDeclarations.some((decl) => decl.init !== null && decl.init.type !== "Literal");
          let fixed = false;
          idDeclarations.slice(1).reduce((memo, decl) => {
            const lastVariableName = getSortableName(memo), currentVariableName = getSortableName(decl);
            if (currentVariableName < lastVariableName) {
              context4.report({
                node: decl,
                messageId: "sortVars",
                fix(fixer) {
                  if (unfixable || fixed) {
                    return null;
                  }
                  return fixer.replaceTextRange([idDeclarations[0].range[0], idDeclarations[idDeclarations.length - 1].range[1]], idDeclarations.slice().sort((declA, declB) => {
                    const aName = getSortableName(declA);
                    const bName = getSortableName(declB);
                    return aName > bName ? 1 : -1;
                  }).reduce((sourceText, identifier, index) => {
                    const textAfterIdentifier = index === idDeclarations.length - 1 ? "" : sourceCode.getText().slice(idDeclarations[index].range[1], idDeclarations[index + 1].range[0]);
                    return sourceText + sourceCode.getText(identifier) + textAfterIdentifier;
                  }, ""));
                }
              });
              fixed = true;
              return memo;
            }
            return decl;
          }, idDeclarations[0]);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/space-before-blocks.js
var require_space_before_blocks = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isFunctionBody(node) {
    const parent = node.parent;
    return node.type === "BlockStatement" && astUtils.isFunction(parent) && parent.body === node;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before blocks",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/space-before-blocks"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                keywords: {
                  enum: ["always", "never", "off"]
                },
                functions: {
                  enum: ["always", "never", "off"]
                },
                classes: {
                  enum: ["always", "never", "off"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before opening brace.",
        missingSpace: "Missing space before opening brace."
      }
    },
    create(context4) {
      const config = context4.options[0], sourceCode = context4.getSourceCode();
      let alwaysFunctions = true, alwaysKeywords = true, alwaysClasses = true, neverFunctions = false, neverKeywords = false, neverClasses = false;
      if (typeof config === "object") {
        alwaysFunctions = config.functions === "always";
        alwaysKeywords = config.keywords === "always";
        alwaysClasses = config.classes === "always";
        neverFunctions = config.functions === "never";
        neverKeywords = config.keywords === "never";
        neverClasses = config.classes === "never";
      } else if (config === "never") {
        alwaysFunctions = false;
        alwaysKeywords = false;
        alwaysClasses = false;
        neverFunctions = true;
        neverKeywords = true;
        neverClasses = true;
      }
      function isConflicted(precedingToken, node) {
        return astUtils.isArrowToken(precedingToken) || astUtils.isKeywordToken(precedingToken) && !isFunctionBody(node);
      }
      function checkPrecedingSpace(node) {
        const precedingToken = sourceCode.getTokenBefore(node);
        if (precedingToken && !isConflicted(precedingToken, node) && astUtils.isTokenOnSameLine(precedingToken, node)) {
          const hasSpace = sourceCode.isSpaceBetweenTokens(precedingToken, node);
          let requireSpace;
          let requireNoSpace;
          if (isFunctionBody(node)) {
            requireSpace = alwaysFunctions;
            requireNoSpace = neverFunctions;
          } else if (node.type === "ClassBody") {
            requireSpace = alwaysClasses;
            requireNoSpace = neverClasses;
          } else {
            requireSpace = alwaysKeywords;
            requireNoSpace = neverKeywords;
          }
          if (requireSpace && !hasSpace) {
            context4.report({
              node,
              messageId: "missingSpace",
              fix(fixer) {
                return fixer.insertTextBefore(node, " ");
              }
            });
          } else if (requireNoSpace && hasSpace) {
            context4.report({
              node,
              messageId: "unexpectedSpace",
              fix(fixer) {
                return fixer.removeRange([precedingToken.range[1], node.range[0]]);
              }
            });
          }
        }
      }
      function checkSpaceBeforeCaseBlock(node) {
        const cases = node.cases;
        let openingBrace;
        if (cases.length > 0) {
          openingBrace = sourceCode.getTokenBefore(cases[0]);
        } else {
          openingBrace = sourceCode.getLastToken(node, 1);
        }
        checkPrecedingSpace(openingBrace);
      }
      return {
        BlockStatement: checkPrecedingSpace,
        ClassBody: checkPrecedingSpace,
        SwitchStatement: checkSpaceBeforeCaseBlock
      };
    }
  };
});

// node_modules/eslint/lib/rules/space-before-function-paren.js
var require_space_before_function_paren = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before `function` definition opening parenthesis",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/space-before-function-paren"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["always", "never"]
            },
            {
              type: "object",
              properties: {
                anonymous: {
                  enum: ["always", "never", "ignore"]
                },
                named: {
                  enum: ["always", "never", "ignore"]
                },
                asyncArrow: {
                  enum: ["always", "never", "ignore"]
                }
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        unexpectedSpace: "Unexpected space before function parentheses.",
        missingSpace: "Missing space before function parentheses."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const baseConfig = typeof context4.options[0] === "string" ? context4.options[0] : "always";
      const overrideConfig = typeof context4.options[0] === "object" ? context4.options[0] : {};
      function isNamedFunction(node) {
        if (node.id) {
          return true;
        }
        const parent = node.parent;
        return parent.type === "MethodDefinition" || parent.type === "Property" && (parent.kind === "get" || parent.kind === "set" || parent.method);
      }
      function getConfigForFunction(node) {
        if (node.type === "ArrowFunctionExpression") {
          if (node.async && astUtils.isOpeningParenToken(sourceCode.getFirstToken(node, {skip: 1}))) {
            return overrideConfig.asyncArrow || baseConfig;
          }
        } else if (isNamedFunction(node)) {
          return overrideConfig.named || baseConfig;
        } else if (!node.generator) {
          return overrideConfig.anonymous || baseConfig;
        }
        return "ignore";
      }
      function checkFunction(node) {
        const functionConfig = getConfigForFunction(node);
        if (functionConfig === "ignore") {
          return;
        }
        const rightToken = sourceCode.getFirstToken(node, astUtils.isOpeningParenToken);
        const leftToken = sourceCode.getTokenBefore(rightToken);
        const hasSpacing = sourceCode.isSpaceBetweenTokens(leftToken, rightToken);
        if (hasSpacing && functionConfig === "never") {
          context4.report({
            node,
            loc: {
              start: leftToken.loc.end,
              end: rightToken.loc.start
            },
            messageId: "unexpectedSpace",
            fix(fixer) {
              const comments = sourceCode.getCommentsBefore(rightToken);
              if (comments.some((comment) => comment.type === "Line")) {
                return null;
              }
              return fixer.replaceTextRange([leftToken.range[1], rightToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
            }
          });
        } else if (!hasSpacing && functionConfig === "always") {
          context4.report({
            node,
            loc: rightToken.loc,
            messageId: "missingSpace",
            fix: (fixer) => fixer.insertTextAfter(leftToken, " ")
          });
        }
      }
      return {
        ArrowFunctionExpression: checkFunction,
        FunctionDeclaration: checkFunction,
        FunctionExpression: checkFunction
      };
    }
  };
});

// node_modules/eslint/lib/rules/space-in-parens.js
var require_space_in_parens = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing inside parentheses",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/space-in-parens"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                enum: ["{}", "[]", "()", "empty"]
              },
              uniqueItems: true
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingOpeningSpace: "There must be a space after this paren.",
        missingClosingSpace: "There must be a space before this paren.",
        rejectedOpeningSpace: "There should be no space after this paren.",
        rejectedClosingSpace: "There should be no space before this paren."
      }
    },
    create(context4) {
      const ALWAYS = context4.options[0] === "always", exceptionsArrayOptions = context4.options[1] && context4.options[1].exceptions || [], options = {};
      let exceptions;
      if (exceptionsArrayOptions.length) {
        options.braceException = exceptionsArrayOptions.includes("{}");
        options.bracketException = exceptionsArrayOptions.includes("[]");
        options.parenException = exceptionsArrayOptions.includes("()");
        options.empty = exceptionsArrayOptions.includes("empty");
      }
      function getExceptions() {
        const openers = [], closers = [];
        if (options.braceException) {
          openers.push("{");
          closers.push("}");
        }
        if (options.bracketException) {
          openers.push("[");
          closers.push("]");
        }
        if (options.parenException) {
          openers.push("(");
          closers.push(")");
        }
        if (options.empty) {
          openers.push(")");
          closers.push("(");
        }
        return {
          openers,
          closers
        };
      }
      const sourceCode = context4.getSourceCode();
      function isOpenerException(token) {
        return exceptions.openers.includes(token.value);
      }
      function isCloserException(token) {
        return exceptions.closers.includes(token.value);
      }
      function openerMissingSpace(openingParenToken, tokenAfterOpeningParen) {
        if (sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
          return false;
        }
        if (!options.empty && astUtils.isClosingParenToken(tokenAfterOpeningParen)) {
          return false;
        }
        if (ALWAYS) {
          return !isOpenerException(tokenAfterOpeningParen);
        }
        return isOpenerException(tokenAfterOpeningParen);
      }
      function openerRejectsSpace(openingParenToken, tokenAfterOpeningParen) {
        if (!astUtils.isTokenOnSameLine(openingParenToken, tokenAfterOpeningParen)) {
          return false;
        }
        if (tokenAfterOpeningParen.type === "Line") {
          return false;
        }
        if (!sourceCode.isSpaceBetweenTokens(openingParenToken, tokenAfterOpeningParen)) {
          return false;
        }
        if (ALWAYS) {
          return isOpenerException(tokenAfterOpeningParen);
        }
        return !isOpenerException(tokenAfterOpeningParen);
      }
      function closerMissingSpace(tokenBeforeClosingParen, closingParenToken) {
        if (sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
          return false;
        }
        if (!options.empty && astUtils.isOpeningParenToken(tokenBeforeClosingParen)) {
          return false;
        }
        if (ALWAYS) {
          return !isCloserException(tokenBeforeClosingParen);
        }
        return isCloserException(tokenBeforeClosingParen);
      }
      function closerRejectsSpace(tokenBeforeClosingParen, closingParenToken) {
        if (!astUtils.isTokenOnSameLine(tokenBeforeClosingParen, closingParenToken)) {
          return false;
        }
        if (!sourceCode.isSpaceBetweenTokens(tokenBeforeClosingParen, closingParenToken)) {
          return false;
        }
        if (ALWAYS) {
          return isCloserException(tokenBeforeClosingParen);
        }
        return !isCloserException(tokenBeforeClosingParen);
      }
      return {
        Program: function checkParenSpaces(node) {
          exceptions = getExceptions();
          const tokens = sourceCode.tokensAndComments;
          tokens.forEach((token, i) => {
            const prevToken = tokens[i - 1];
            const nextToken = tokens[i + 1];
            if (!astUtils.isOpeningParenToken(token) && !astUtils.isClosingParenToken(token)) {
              return;
            }
            if (token.value === "(" && openerMissingSpace(token, nextToken)) {
              context4.report({
                node,
                loc: token.loc,
                messageId: "missingOpeningSpace",
                fix(fixer) {
                  return fixer.insertTextAfter(token, " ");
                }
              });
            }
            if (token.value === "(" && openerRejectsSpace(token, nextToken)) {
              context4.report({
                node,
                loc: {start: token.loc.end, end: nextToken.loc.start},
                messageId: "rejectedOpeningSpace",
                fix(fixer) {
                  return fixer.removeRange([token.range[1], nextToken.range[0]]);
                }
              });
            }
            if (token.value === ")" && closerMissingSpace(prevToken, token)) {
              context4.report({
                node,
                loc: token.loc,
                messageId: "missingClosingSpace",
                fix(fixer) {
                  return fixer.insertTextBefore(token, " ");
                }
              });
            }
            if (token.value === ")" && closerRejectsSpace(prevToken, token)) {
              context4.report({
                node,
                loc: {start: prevToken.loc.end, end: token.loc.start},
                messageId: "rejectedClosingSpace",
                fix(fixer) {
                  return fixer.removeRange([prevToken.range[1], token.range[0]]);
                }
              });
            }
          });
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/space-infix-ops.js
var require_space_infix_ops = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require spacing around infix operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/space-infix-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            int32Hint: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        missingSpace: "Operator '{{operator}}' must be spaced."
      }
    },
    create(context4) {
      const int32Hint = context4.options[0] ? context4.options[0].int32Hint === true : false;
      const sourceCode = context4.getSourceCode();
      function getFirstNonSpacedToken(left, right, op) {
        const operator = sourceCode.getFirstTokenBetween(left, right, (token) => token.value === op);
        const prev = sourceCode.getTokenBefore(operator);
        const next = sourceCode.getTokenAfter(operator);
        if (!sourceCode.isSpaceBetweenTokens(prev, operator) || !sourceCode.isSpaceBetweenTokens(operator, next)) {
          return operator;
        }
        return null;
      }
      function report(mainNode, culpritToken) {
        context4.report({
          node: mainNode,
          loc: culpritToken.loc,
          messageId: "missingSpace",
          data: {
            operator: culpritToken.value
          },
          fix(fixer) {
            const previousToken = sourceCode.getTokenBefore(culpritToken);
            const afterToken = sourceCode.getTokenAfter(culpritToken);
            let fixString = "";
            if (culpritToken.range[0] - previousToken.range[1] === 0) {
              fixString = " ";
            }
            fixString += culpritToken.value;
            if (afterToken.range[0] - culpritToken.range[1] === 0) {
              fixString += " ";
            }
            return fixer.replaceText(culpritToken, fixString);
          }
        });
      }
      function checkBinary(node) {
        const leftNode = node.left.typeAnnotation ? node.left.typeAnnotation : node.left;
        const rightNode = node.right;
        const operator = node.operator || "=";
        const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, operator);
        if (nonSpacedNode) {
          if (!(int32Hint && sourceCode.getText(node).endsWith("|0"))) {
            report(node, nonSpacedNode);
          }
        }
      }
      function checkConditional(node) {
        const nonSpacedConsequentNode = getFirstNonSpacedToken(node.test, node.consequent, "?");
        const nonSpacedAlternateNode = getFirstNonSpacedToken(node.consequent, node.alternate, ":");
        if (nonSpacedConsequentNode) {
          report(node, nonSpacedConsequentNode);
        }
        if (nonSpacedAlternateNode) {
          report(node, nonSpacedAlternateNode);
        }
      }
      function checkVar(node) {
        const leftNode = node.id.typeAnnotation ? node.id.typeAnnotation : node.id;
        const rightNode = node.init;
        if (rightNode) {
          const nonSpacedNode = getFirstNonSpacedToken(leftNode, rightNode, "=");
          if (nonSpacedNode) {
            report(node, nonSpacedNode);
          }
        }
      }
      return {
        AssignmentExpression: checkBinary,
        AssignmentPattern: checkBinary,
        BinaryExpression: checkBinary,
        LogicalExpression: checkBinary,
        ConditionalExpression: checkConditional,
        VariableDeclarator: checkVar
      };
    }
  };
});

// node_modules/eslint/lib/rules/space-unary-ops.js
var require_space_unary_ops = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce consistent spacing before or after unary operators",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/space-unary-ops"
      },
      fixable: "whitespace",
      schema: [
        {
          type: "object",
          properties: {
            words: {
              type: "boolean",
              default: true
            },
            nonwords: {
              type: "boolean",
              default: false
            },
            overrides: {
              type: "object",
              additionalProperties: {
                type: "boolean"
              }
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedBefore: "Unexpected space before unary operator '{{operator}}'.",
        unexpectedAfter: "Unexpected space after unary operator '{{operator}}'.",
        unexpectedAfterWord: "Unexpected space after unary word operator '{{word}}'.",
        wordOperator: "Unary word operator '{{word}}' must be followed by whitespace.",
        operator: "Unary operator '{{operator}}' must be followed by whitespace.",
        beforeUnaryExpressions: "Space is required before unary expressions '{{token}}'."
      }
    },
    create(context4) {
      const options = context4.options[0] || {words: true, nonwords: false};
      const sourceCode = context4.getSourceCode();
      function isFirstBangInBangBangExpression(node) {
        return node && node.type === "UnaryExpression" && node.argument.operator === "!" && node.argument && node.argument.type === "UnaryExpression" && node.argument.operator === "!";
      }
      function overrideExistsForOperator(operator) {
        return options.overrides && Object.prototype.hasOwnProperty.call(options.overrides, operator);
      }
      function overrideEnforcesSpaces(operator) {
        return options.overrides[operator];
      }
      function verifyWordHasSpaces(node, firstToken, secondToken, word) {
        if (secondToken.range[0] === firstToken.range[1]) {
          context4.report({
            node,
            messageId: "wordOperator",
            data: {
              word
            },
            fix(fixer) {
              return fixer.insertTextAfter(firstToken, " ");
            }
          });
        }
      }
      function verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word) {
        if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
          if (secondToken.range[0] > firstToken.range[1]) {
            context4.report({
              node,
              messageId: "unexpectedAfterWord",
              data: {
                word
              },
              fix(fixer) {
                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
              }
            });
          }
        }
      }
      function checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, word) {
        if (overrideExistsForOperator(word)) {
          if (overrideEnforcesSpaces(word)) {
            verifyWordHasSpaces(node, firstToken, secondToken, word);
          } else {
            verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
          }
        } else if (options.words) {
          verifyWordHasSpaces(node, firstToken, secondToken, word);
        } else {
          verifyWordDoesntHaveSpaces(node, firstToken, secondToken, word);
        }
      }
      function checkForSpacesAfterYield(node) {
        const tokens = sourceCode.getFirstTokens(node, 3), word = "yield";
        if (!node.argument || node.delegate) {
          return;
        }
        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], word);
      }
      function checkForSpacesAfterAwait(node) {
        const tokens = sourceCode.getFirstTokens(node, 3);
        checkUnaryWordOperatorForSpaces(node, tokens[0], tokens[1], "await");
      }
      function verifyNonWordsHaveSpaces(node, firstToken, secondToken) {
        if (node.prefix) {
          if (isFirstBangInBangBangExpression(node)) {
            return;
          }
          if (firstToken.range[1] === secondToken.range[0]) {
            context4.report({
              node,
              messageId: "operator",
              data: {
                operator: firstToken.value
              },
              fix(fixer) {
                return fixer.insertTextAfter(firstToken, " ");
              }
            });
          }
        } else {
          if (firstToken.range[1] === secondToken.range[0]) {
            context4.report({
              node,
              messageId: "beforeUnaryExpressions",
              data: {
                token: secondToken.value
              },
              fix(fixer) {
                return fixer.insertTextBefore(secondToken, " ");
              }
            });
          }
        }
      }
      function verifyNonWordsDontHaveSpaces(node, firstToken, secondToken) {
        if (node.prefix) {
          if (secondToken.range[0] > firstToken.range[1]) {
            context4.report({
              node,
              messageId: "unexpectedAfter",
              data: {
                operator: firstToken.value
              },
              fix(fixer) {
                if (astUtils.canTokensBeAdjacent(firstToken, secondToken)) {
                  return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
                }
                return null;
              }
            });
          }
        } else {
          if (secondToken.range[0] > firstToken.range[1]) {
            context4.report({
              node,
              messageId: "unexpectedBefore",
              data: {
                operator: secondToken.value
              },
              fix(fixer) {
                return fixer.removeRange([firstToken.range[1], secondToken.range[0]]);
              }
            });
          }
        }
      }
      function checkForSpaces(node) {
        const tokens = node.type === "UpdateExpression" && !node.prefix ? sourceCode.getLastTokens(node, 2) : sourceCode.getFirstTokens(node, 2);
        const firstToken = tokens[0];
        const secondToken = tokens[1];
        if ((node.type === "NewExpression" || node.prefix) && firstToken.type === "Keyword") {
          checkUnaryWordOperatorForSpaces(node, firstToken, secondToken, firstToken.value);
          return;
        }
        const operator = node.prefix ? tokens[0].value : tokens[1].value;
        if (overrideExistsForOperator(operator)) {
          if (overrideEnforcesSpaces(operator)) {
            verifyNonWordsHaveSpaces(node, firstToken, secondToken);
          } else {
            verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
          }
        } else if (options.nonwords) {
          verifyNonWordsHaveSpaces(node, firstToken, secondToken);
        } else {
          verifyNonWordsDontHaveSpaces(node, firstToken, secondToken);
        }
      }
      return {
        UnaryExpression: checkForSpaces,
        UpdateExpression: checkForSpaces,
        NewExpression: checkForSpaces,
        YieldExpression: checkForSpacesAfterYield,
        AwaitExpression: checkForSpacesAfterAwait
      };
    }
  };
});

// node_modules/eslint/lib/rules/spaced-comment.js
var require_spaced_comment = __commonJS((exports2, module2) => {
  "use strict";
  var lodash = require_lodash();
  var astUtils = require_ast_utils2();
  function escape2(s) {
    return `(?:${lodash.escapeRegExp(s)})`;
  }
  function escapeAndRepeat(s) {
    return `${escape2(s)}+`;
  }
  function parseMarkersOption(markers) {
    if (markers.indexOf("*") === -1) {
      return markers.concat("*");
    }
    return markers;
  }
  function createExceptionsPattern(exceptions) {
    let pattern = "";
    if (exceptions.length === 0) {
      pattern += "\\s";
    } else {
      pattern += "(?:\\s|";
      if (exceptions.length === 1) {
        pattern += escapeAndRepeat(exceptions[0]);
      } else {
        pattern += "(?:";
        pattern += exceptions.map(escapeAndRepeat).join("|");
        pattern += ")";
      }
      pattern += `(?:$|[${Array.from(astUtils.LINEBREAKS).join("")}]))`;
    }
    return pattern;
  }
  function createAlwaysStylePattern(markers, exceptions) {
    let pattern = "^";
    if (markers.length === 1) {
      pattern += escape2(markers[0]);
    } else {
      pattern += "(?:";
      pattern += markers.map(escape2).join("|");
      pattern += ")";
    }
    pattern += "?";
    pattern += createExceptionsPattern(exceptions);
    return new RegExp(pattern, "u");
  }
  function createNeverStylePattern(markers) {
    const pattern = `^(${markers.map(escape2).join("|")})?[ 	]+`;
    return new RegExp(pattern, "u");
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce consistent spacing after the `//` or `/*` in a comment",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/spaced-comment"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptions: {
              type: "array",
              items: {
                type: "string"
              }
            },
            markers: {
              type: "array",
              items: {
                type: "string"
              }
            },
            line: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                }
              },
              additionalProperties: false
            },
            block: {
              type: "object",
              properties: {
                exceptions: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                markers: {
                  type: "array",
                  items: {
                    type: "string"
                  }
                },
                balanced: {
                  type: "boolean",
                  default: false
                }
              },
              additionalProperties: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        unexpectedSpaceAfterMarker: "Unexpected space or tab after marker ({{refChar}}) in comment.",
        expectedExceptionAfter: "Expected exception block, space or tab after '{{refChar}}' in comment.",
        unexpectedSpaceBefore: "Unexpected space or tab before '*/' in comment.",
        unexpectedSpaceAfter: "Unexpected space or tab after '{{refChar}}' in comment.",
        expectedSpaceBefore: "Expected space or tab before '*/' in comment.",
        expectedSpaceAfter: "Expected space or tab after '{{refChar}}' in comment."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const requireSpace = context4.options[0] !== "never";
      const config = context4.options[1] || {};
      const balanced = config.block && config.block.balanced;
      const styleRules = ["block", "line"].reduce((rule, type) => {
        const markers = parseMarkersOption(config[type] && config[type].markers || config.markers || []);
        const exceptions = config[type] && config[type].exceptions || config.exceptions || [];
        const endNeverPattern = "[ 	]+$";
        rule[type] = {
          beginRegex: requireSpace ? createAlwaysStylePattern(markers, exceptions) : createNeverStylePattern(markers),
          endRegex: balanced && requireSpace ? new RegExp(`${createExceptionsPattern(exceptions)}$`, "u") : new RegExp(endNeverPattern, "u"),
          hasExceptions: exceptions.length > 0,
          captureMarker: new RegExp(`^(${markers.map(escape2).join("|")})`, "u"),
          markers: new Set(markers)
        };
        return rule;
      }, {});
      function reportBegin(node, messageId, match, refChar) {
        const type = node.type.toLowerCase(), commentIdentifier = type === "block" ? "/*" : "//";
        context4.report({
          node,
          fix(fixer) {
            const start = node.range[0];
            let end = start + 2;
            if (requireSpace) {
              if (match) {
                end += match[0].length;
              }
              return fixer.insertTextAfterRange([start, end], " ");
            }
            end += match[0].length;
            return fixer.replaceTextRange([start, end], commentIdentifier + (match[1] ? match[1] : ""));
          },
          messageId,
          data: {refChar}
        });
      }
      function reportEnd(node, messageId, match) {
        context4.report({
          node,
          fix(fixer) {
            if (requireSpace) {
              return fixer.insertTextAfterRange([node.range[0], node.range[1] - 2], " ");
            }
            const end = node.range[1] - 2, start = end - match[0].length;
            return fixer.replaceTextRange([start, end], "");
          },
          messageId
        });
      }
      function checkCommentForSpace(node) {
        const type = node.type.toLowerCase(), rule = styleRules[type], commentIdentifier = type === "block" ? "/*" : "//";
        if (node.value.length === 0 || rule.markers.has(node.value)) {
          return;
        }
        const beginMatch = rule.beginRegex.exec(node.value);
        const endMatch = rule.endRegex.exec(node.value);
        if (requireSpace) {
          if (!beginMatch) {
            const hasMarker = rule.captureMarker.exec(node.value);
            const marker = hasMarker ? commentIdentifier + hasMarker[0] : commentIdentifier;
            if (rule.hasExceptions) {
              reportBegin(node, "expectedExceptionAfter", hasMarker, marker);
            } else {
              reportBegin(node, "expectedSpaceAfter", hasMarker, marker);
            }
          }
          if (balanced && type === "block" && !endMatch) {
            reportEnd(node, "expectedSpaceBefore");
          }
        } else {
          if (beginMatch) {
            if (!beginMatch[1]) {
              reportBegin(node, "unexpectedSpaceAfter", beginMatch, commentIdentifier);
            } else {
              reportBegin(node, "unexpectedSpaceAfterMarker", beginMatch, beginMatch[1]);
            }
          }
          if (balanced && type === "block" && endMatch) {
            reportEnd(node, "unexpectedSpaceBefore", endMatch);
          }
        }
      }
      return {
        Program() {
          const comments = sourceCode.getAllComments();
          comments.filter((token) => token.type !== "Shebang").forEach(checkCommentForSpace);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/strict.js
var require_strict = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function getUseStrictDirectives(statements) {
    const directives = [];
    for (let i = 0; i < statements.length; i++) {
      const statement = statements[i];
      if (statement.type === "ExpressionStatement" && statement.expression.type === "Literal" && statement.expression.value === "use strict") {
        directives[i] = statement;
      } else {
        break;
      }
    }
    return directives;
  }
  function isSimpleParameter(node) {
    return node.type === "Identifier";
  }
  function isSimpleParameterList(params) {
    return params.every(isSimpleParameter);
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require or disallow strict mode directives",
        category: "Strict Mode",
        recommended: false,
        url: "https://eslint.org/docs/rules/strict"
      },
      schema: [
        {
          enum: ["never", "global", "function", "safe"]
        }
      ],
      fixable: "code",
      messages: {
        function: "Use the function form of 'use strict'.",
        global: "Use the global form of 'use strict'.",
        multiple: "Multiple 'use strict' directives.",
        never: "Strict mode is not permitted.",
        unnecessary: "Unnecessary 'use strict' directive.",
        module: "'use strict' is unnecessary inside of modules.",
        implied: "'use strict' is unnecessary when implied strict mode is enabled.",
        unnecessaryInClasses: "'use strict' is unnecessary inside of classes.",
        nonSimpleParameterList: "'use strict' directive inside a function with non-simple parameter list throws a syntax error since ES2016.",
        wrap: "Wrap {{name}} in a function with 'use strict' directive."
      }
    },
    create(context4) {
      const ecmaFeatures = context4.parserOptions.ecmaFeatures || {}, scopes = [], classScopes = [];
      let mode = context4.options[0] || "safe";
      if (ecmaFeatures.impliedStrict) {
        mode = "implied";
      } else if (mode === "safe") {
        mode = ecmaFeatures.globalReturn ? "global" : "function";
      }
      function shouldFix(errorType) {
        return errorType === "multiple" || errorType === "unnecessary" || errorType === "module" || errorType === "implied" || errorType === "unnecessaryInClasses";
      }
      function getFixFunction(node) {
        return (fixer) => fixer.remove(node);
      }
      function reportSlice(nodes, start, end, messageId, fix) {
        nodes.slice(start, end).forEach((node) => {
          context4.report({node, messageId, fix: fix ? getFixFunction(node) : null});
        });
      }
      function reportAll(nodes, messageId, fix) {
        reportSlice(nodes, 0, nodes.length, messageId, fix);
      }
      function reportAllExceptFirst(nodes, messageId, fix) {
        reportSlice(nodes, 1, nodes.length, messageId, fix);
      }
      function enterFunctionInFunctionMode(node, useStrictDirectives) {
        const isInClass = classScopes.length > 0, isParentGlobal = scopes.length === 0 && classScopes.length === 0, isParentStrict = scopes.length > 0 && scopes[scopes.length - 1], isStrict = useStrictDirectives.length > 0;
        if (isStrict) {
          if (!isSimpleParameterList(node.params)) {
            context4.report({node: useStrictDirectives[0], messageId: "nonSimpleParameterList"});
          } else if (isParentStrict) {
            context4.report({node: useStrictDirectives[0], messageId: "unnecessary", fix: getFixFunction(useStrictDirectives[0])});
          } else if (isInClass) {
            context4.report({node: useStrictDirectives[0], messageId: "unnecessaryInClasses", fix: getFixFunction(useStrictDirectives[0])});
          }
          reportAllExceptFirst(useStrictDirectives, "multiple", true);
        } else if (isParentGlobal) {
          if (isSimpleParameterList(node.params)) {
            context4.report({node, messageId: "function"});
          } else {
            context4.report({
              node,
              messageId: "wrap",
              data: {name: astUtils.getFunctionNameWithKind(node)}
            });
          }
        }
        scopes.push(isParentStrict || isStrict);
      }
      function exitFunctionInFunctionMode() {
        scopes.pop();
      }
      function enterFunction(node) {
        const isBlock = node.body.type === "BlockStatement", useStrictDirectives = isBlock ? getUseStrictDirectives(node.body.body) : [];
        if (mode === "function") {
          enterFunctionInFunctionMode(node, useStrictDirectives);
        } else if (useStrictDirectives.length > 0) {
          if (isSimpleParameterList(node.params)) {
            reportAll(useStrictDirectives, mode, shouldFix(mode));
          } else {
            context4.report({node: useStrictDirectives[0], messageId: "nonSimpleParameterList"});
            reportAllExceptFirst(useStrictDirectives, "multiple", true);
          }
        }
      }
      const rule = {
        Program(node) {
          const useStrictDirectives = getUseStrictDirectives(node.body);
          if (node.sourceType === "module") {
            mode = "module";
          }
          if (mode === "global") {
            if (node.body.length > 0 && useStrictDirectives.length === 0) {
              context4.report({node, messageId: "global"});
            }
            reportAllExceptFirst(useStrictDirectives, "multiple", true);
          } else {
            reportAll(useStrictDirectives, mode, shouldFix(mode));
          }
        },
        FunctionDeclaration: enterFunction,
        FunctionExpression: enterFunction,
        ArrowFunctionExpression: enterFunction
      };
      if (mode === "function") {
        Object.assign(rule, {
          ClassBody() {
            classScopes.push(true);
          },
          "ClassBody:exit"() {
            classScopes.pop();
          },
          "FunctionDeclaration:exit": exitFunctionInFunctionMode,
          "FunctionExpression:exit": exitFunctionInFunctionMode,
          "ArrowFunctionExpression:exit": exitFunctionInFunctionMode
        });
      }
      return rule;
    }
  };
});

// node_modules/eslint/lib/rules/switch-colon-spacing.js
var require_switch_colon_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "enforce spacing around colons of switch statements",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/switch-colon-spacing"
      },
      schema: [
        {
          type: "object",
          properties: {
            before: {type: "boolean", default: false},
            after: {type: "boolean", default: true}
          },
          additionalProperties: false
        }
      ],
      fixable: "whitespace",
      messages: {
        expectedBefore: "Expected space(s) before this colon.",
        expectedAfter: "Expected space(s) after this colon.",
        unexpectedBefore: "Unexpected space(s) before this colon.",
        unexpectedAfter: "Unexpected space(s) after this colon."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const options = context4.options[0] || {};
      const beforeSpacing = options.before === true;
      const afterSpacing = options.after !== false;
      function getColonToken(node) {
        if (node.test) {
          return sourceCode.getTokenAfter(node.test, astUtils.isColonToken);
        }
        return sourceCode.getFirstToken(node, 1);
      }
      function isValidSpacing(left, right, expected) {
        return astUtils.isClosingBraceToken(right) || !astUtils.isTokenOnSameLine(left, right) || sourceCode.isSpaceBetweenTokens(left, right) === expected;
      }
      function commentsExistBetween(left, right) {
        return sourceCode.getFirstTokenBetween(left, right, {
          includeComments: true,
          filter: astUtils.isCommentToken
        }) !== null;
      }
      function fix(fixer, left, right, spacing) {
        if (commentsExistBetween(left, right)) {
          return null;
        }
        if (spacing) {
          return fixer.insertTextAfter(left, " ");
        }
        return fixer.removeRange([left.range[1], right.range[0]]);
      }
      return {
        SwitchCase(node) {
          const colonToken = getColonToken(node);
          const beforeToken = sourceCode.getTokenBefore(colonToken);
          const afterToken = sourceCode.getTokenAfter(colonToken);
          if (!isValidSpacing(beforeToken, colonToken, beforeSpacing)) {
            context4.report({
              node,
              loc: colonToken.loc,
              messageId: beforeSpacing ? "expectedBefore" : "unexpectedBefore",
              fix: (fixer) => fix(fixer, beforeToken, colonToken, beforeSpacing)
            });
          }
          if (!isValidSpacing(colonToken, afterToken, afterSpacing)) {
            context4.report({
              node,
              loc: colonToken.loc,
              messageId: afterSpacing ? "expectedAfter" : "unexpectedAfter",
              fix: (fixer) => fix(fixer, colonToken, afterToken, afterSpacing)
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/symbol-description.js
var require_symbol_description = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require symbol descriptions",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/symbol-description"
      },
      fixable: null,
      schema: [],
      messages: {
        expected: "Expected Symbol to have a description."
      }
    },
    create(context4) {
      function checkArgument(node) {
        if (node.arguments.length === 0) {
          context4.report({
            node,
            messageId: "expected"
          });
        }
      }
      return {
        "Program:exit"() {
          const scope = context4.getScope();
          const variable = astUtils.getVariableByName(scope, "Symbol");
          if (variable && variable.defs.length === 0) {
            variable.references.forEach((reference) => {
              const node = reference.identifier;
              if (astUtils.isCallee(node)) {
                checkArgument(node.parent);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/template-curly-spacing.js
var require_template_curly_spacing = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow spacing around embedded expressions of template strings",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/template-curly-spacing"
      },
      fixable: "whitespace",
      schema: [
        {enum: ["always", "never"]}
      ],
      messages: {
        expectedBefore: "Expected space(s) before '}'.",
        expectedAfter: "Expected space(s) after '${'.",
        unexpectedBefore: "Unexpected space(s) before '}'.",
        unexpectedAfter: "Unexpected space(s) after '${'."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const always = context4.options[0] === "always";
      function checkSpacingBefore(token) {
        if (!token.value.startsWith("}")) {
          return;
        }
        const prevToken = sourceCode.getTokenBefore(token, {includeComments: true}), hasSpace = sourceCode.isSpaceBetween(prevToken, token);
        if (!astUtils.isTokenOnSameLine(prevToken, token)) {
          return;
        }
        if (always && !hasSpace) {
          context4.report({
            loc: {
              start: token.loc.start,
              end: {
                line: token.loc.start.line,
                column: token.loc.start.column + 1
              }
            },
            messageId: "expectedBefore",
            fix: (fixer) => fixer.insertTextBefore(token, " ")
          });
        }
        if (!always && hasSpace) {
          context4.report({
            loc: {
              start: prevToken.loc.end,
              end: token.loc.start
            },
            messageId: "unexpectedBefore",
            fix: (fixer) => fixer.removeRange([prevToken.range[1], token.range[0]])
          });
        }
      }
      function checkSpacingAfter(token) {
        if (!token.value.endsWith("${")) {
          return;
        }
        const nextToken = sourceCode.getTokenAfter(token, {includeComments: true}), hasSpace = sourceCode.isSpaceBetween(token, nextToken);
        if (!astUtils.isTokenOnSameLine(token, nextToken)) {
          return;
        }
        if (always && !hasSpace) {
          context4.report({
            loc: {
              start: {
                line: token.loc.end.line,
                column: token.loc.end.column - 2
              },
              end: token.loc.end
            },
            messageId: "expectedAfter",
            fix: (fixer) => fixer.insertTextAfter(token, " ")
          });
        }
        if (!always && hasSpace) {
          context4.report({
            loc: {
              start: token.loc.end,
              end: nextToken.loc.start
            },
            messageId: "unexpectedAfter",
            fix: (fixer) => fixer.removeRange([token.range[1], nextToken.range[0]])
          });
        }
      }
      return {
        TemplateElement(node) {
          const token = sourceCode.getFirstToken(node);
          checkSpacingBefore(token);
          checkSpacingAfter(token);
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/template-tag-spacing.js
var require_template_tag_spacing = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow spacing between template tags and their literals",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/template-tag-spacing"
      },
      fixable: "whitespace",
      schema: [
        {enum: ["always", "never"]}
      ],
      messages: {
        unexpected: "Unexpected space between template tag and template literal.",
        missing: "Missing space between template tag and template literal."
      }
    },
    create(context4) {
      const never = context4.options[0] !== "always";
      const sourceCode = context4.getSourceCode();
      function checkSpacing(node) {
        const tagToken = sourceCode.getTokenBefore(node.quasi);
        const literalToken = sourceCode.getFirstToken(node.quasi);
        const hasWhitespace = sourceCode.isSpaceBetweenTokens(tagToken, literalToken);
        if (never && hasWhitespace) {
          context4.report({
            node,
            loc: {
              start: tagToken.loc.end,
              end: literalToken.loc.start
            },
            messageId: "unexpected",
            fix(fixer) {
              const comments = sourceCode.getCommentsBefore(node.quasi);
              if (comments.some((comment) => comment.type === "Line")) {
                return null;
              }
              return fixer.replaceTextRange([tagToken.range[1], literalToken.range[0]], comments.reduce((text, comment) => text + sourceCode.getText(comment), ""));
            }
          });
        } else if (!never && !hasWhitespace) {
          context4.report({
            node,
            loc: {
              start: node.loc.start,
              end: literalToken.loc.start
            },
            messageId: "missing",
            fix(fixer) {
              return fixer.insertTextAfter(tagToken, " ");
            }
          });
        }
      }
      return {
        TaggedTemplateExpression: checkSpacing
      };
    }
  };
});

// node_modules/eslint/lib/rules/unicode-bom.js
var require_unicode_bom = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow Unicode byte order mark (BOM)",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/unicode-bom"
      },
      fixable: "whitespace",
      schema: [
        {
          enum: ["always", "never"]
        }
      ],
      messages: {
        expected: "Expected Unicode BOM (Byte Order Mark).",
        unexpected: "Unexpected Unicode BOM (Byte Order Mark)."
      }
    },
    create(context4) {
      return {
        Program: function checkUnicodeBOM(node) {
          const sourceCode = context4.getSourceCode(), location = {column: 0, line: 1}, requireBOM = context4.options[0] || "never";
          if (!sourceCode.hasBOM && requireBOM === "always") {
            context4.report({
              node,
              loc: location,
              messageId: "expected",
              fix(fixer) {
                return fixer.insertTextBeforeRange([0, 1], "\uFEFF");
              }
            });
          } else if (sourceCode.hasBOM && requireBOM === "never") {
            context4.report({
              node,
              loc: location,
              messageId: "unexpected",
              fix(fixer) {
                return fixer.removeRange([-1, 0]);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/use-isnan.js
var require_use_isnan = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isNaNIdentifier(node) {
    return Boolean(node) && node.type === "Identifier" && node.name === "NaN";
  }
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "require calls to `isNaN()` when checking for `NaN`",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/use-isnan"
      },
      schema: [
        {
          type: "object",
          properties: {
            enforceForSwitchCase: {
              type: "boolean",
              default: true
            },
            enforceForIndexOf: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        comparisonWithNaN: "Use the isNaN function to compare with NaN.",
        switchNaN: "'switch(NaN)' can never match a case clause. Use Number.isNaN instead of the switch.",
        caseNaN: "'case NaN' can never match. Use Number.isNaN before the switch.",
        indexOfNaN: "Array prototype method '{{ methodName }}' cannot find NaN."
      }
    },
    create(context4) {
      const enforceForSwitchCase = !context4.options[0] || context4.options[0].enforceForSwitchCase;
      const enforceForIndexOf = context4.options[0] && context4.options[0].enforceForIndexOf;
      function checkBinaryExpression(node) {
        if (/^(?:[<>]|[!=]=)=?$/u.test(node.operator) && (isNaNIdentifier(node.left) || isNaNIdentifier(node.right))) {
          context4.report({node, messageId: "comparisonWithNaN"});
        }
      }
      function checkSwitchStatement(node) {
        if (isNaNIdentifier(node.discriminant)) {
          context4.report({node, messageId: "switchNaN"});
        }
        for (const switchCase of node.cases) {
          if (isNaNIdentifier(switchCase.test)) {
            context4.report({node: switchCase, messageId: "caseNaN"});
          }
        }
      }
      function checkCallExpression(node) {
        const callee = astUtils.skipChainExpression(node.callee);
        if (callee.type === "MemberExpression") {
          const methodName = astUtils.getStaticPropertyName(callee);
          if ((methodName === "indexOf" || methodName === "lastIndexOf") && node.arguments.length === 1 && isNaNIdentifier(node.arguments[0])) {
            context4.report({node, messageId: "indexOfNaN", data: {methodName}});
          }
        }
      }
      const listeners = {
        BinaryExpression: checkBinaryExpression
      };
      if (enforceForSwitchCase) {
        listeners.SwitchStatement = checkSwitchStatement;
      }
      if (enforceForIndexOf) {
        listeners.CallExpression = checkCallExpression;
      }
      return listeners;
    }
  };
});

// node_modules/doctrine/package.json
var require_package5 = __commonJS((exports2, module2) => {
  module2.exports = {
    _args: [
      [
        "doctrine@3.0.0",
        "/Users/abrown/code/eslint-action"
      ]
    ],
    _from: "doctrine@3.0.0",
    _id: "doctrine@3.0.0",
    _inBundle: false,
    _integrity: "sha512-yS+Q5i3hBf7GBkd4KG8a7eBNNWNGLTaEwwYWUijIYM7zrlYDM0BFXHjjPWlWZ1Rg7UaddZeIDmi9jF3HmqiQ2w==",
    _location: "/doctrine",
    _phantomChildren: {},
    _requested: {
      type: "version",
      registry: true,
      raw: "doctrine@3.0.0",
      name: "doctrine",
      escapedName: "doctrine",
      rawSpec: "3.0.0",
      saveSpec: null,
      fetchSpec: "3.0.0"
    },
    _requiredBy: [
      "/eslint"
    ],
    _resolved: "https://registry.npmjs.org/doctrine/-/doctrine-3.0.0.tgz",
    _spec: "3.0.0",
    _where: "/Users/abrown/code/eslint-action",
    bugs: {
      url: "https://github.com/eslint/doctrine/issues"
    },
    dependencies: {
      esutils: "^2.0.2"
    },
    description: "JSDoc parser",
    devDependencies: {
      coveralls: "^3.0.1",
      dateformat: "^1.0.11",
      eslint: "^1.10.3",
      "eslint-release": "^1.0.0",
      linefix: "^0.1.1",
      mocha: "^3.4.2",
      "npm-license": "^0.3.1",
      nyc: "^10.3.2",
      semver: "^5.0.3",
      shelljs: "^0.5.3",
      "shelljs-nodecli": "^0.1.1",
      should: "^5.0.1"
    },
    directories: {
      lib: "./lib"
    },
    engines: {
      node: ">=6.0.0"
    },
    files: [
      "lib"
    ],
    homepage: "https://github.com/eslint/doctrine",
    license: "Apache-2.0",
    main: "lib/doctrine.js",
    maintainers: [
      {
        name: "Nicholas C. Zakas",
        email: "nicholas+npm@nczconsulting.com",
        url: "https://www.nczonline.net"
      },
      {
        name: "Yusuke Suzuki",
        email: "utatane.tea@gmail.com",
        url: "https://github.com/Constellation"
      }
    ],
    name: "doctrine",
    repository: {
      type: "git",
      url: "git+https://github.com/eslint/doctrine.git"
    },
    scripts: {
      coveralls: "nyc report --reporter=text-lcov | coveralls",
      "generate-alpharelease": "eslint-generate-prerelease alpha",
      "generate-betarelease": "eslint-generate-prerelease beta",
      "generate-rcrelease": "eslint-generate-prerelease rc",
      "generate-release": "eslint-generate-release",
      lint: "eslint lib/",
      pretest: "npm run lint",
      "publish-release": "eslint-publish-release",
      test: "nyc mocha"
    },
    version: "3.0.0"
  };
});

// node_modules/doctrine/lib/utility.js
var require_utility = __commonJS((exports2) => {
  (function() {
    "use strict";
    var VERSION;
    VERSION = require_package5().version;
    exports2.VERSION = VERSION;
    function DoctrineError(message) {
      this.name = "DoctrineError";
      this.message = message;
    }
    DoctrineError.prototype = function() {
      var Middle = function() {
      };
      Middle.prototype = Error.prototype;
      return new Middle();
    }();
    DoctrineError.prototype.constructor = DoctrineError;
    exports2.DoctrineError = DoctrineError;
    function throwError(message) {
      throw new DoctrineError(message);
    }
    exports2.throwError = throwError;
    exports2.assert = require("assert");
  })();
});

// node_modules/doctrine/lib/typed.js
var require_typed = __commonJS((exports2) => {
  (function() {
    "use strict";
    var Syntax, Token, source, length, index, previous, token, value, esutils, utility, rangeOffset, addRange;
    esutils = require_utils7();
    utility = require_utility();
    Syntax = {
      NullableLiteral: "NullableLiteral",
      AllLiteral: "AllLiteral",
      NullLiteral: "NullLiteral",
      UndefinedLiteral: "UndefinedLiteral",
      VoidLiteral: "VoidLiteral",
      UnionType: "UnionType",
      ArrayType: "ArrayType",
      RecordType: "RecordType",
      FieldType: "FieldType",
      FunctionType: "FunctionType",
      ParameterType: "ParameterType",
      RestType: "RestType",
      NonNullableType: "NonNullableType",
      OptionalType: "OptionalType",
      NullableType: "NullableType",
      NameExpression: "NameExpression",
      TypeApplication: "TypeApplication",
      StringLiteralType: "StringLiteralType",
      NumericLiteralType: "NumericLiteralType",
      BooleanLiteralType: "BooleanLiteralType"
    };
    Token = {
      ILLEGAL: 0,
      DOT_LT: 1,
      REST: 2,
      LT: 3,
      GT: 4,
      LPAREN: 5,
      RPAREN: 6,
      LBRACE: 7,
      RBRACE: 8,
      LBRACK: 9,
      RBRACK: 10,
      COMMA: 11,
      COLON: 12,
      STAR: 13,
      PIPE: 14,
      QUESTION: 15,
      BANG: 16,
      EQUAL: 17,
      NAME: 18,
      STRING: 19,
      NUMBER: 20,
      EOF: 21
    };
    function isTypeName(ch) {
      return "><(){}[],:*|?!=".indexOf(String.fromCharCode(ch)) === -1 && !esutils.code.isWhiteSpace(ch) && !esutils.code.isLineTerminator(ch);
    }
    function Context(previous2, index2, token2, value2) {
      this._previous = previous2;
      this._index = index2;
      this._token = token2;
      this._value = value2;
    }
    Context.prototype.restore = function() {
      previous = this._previous;
      index = this._index;
      token = this._token;
      value = this._value;
    };
    Context.save = function() {
      return new Context(previous, index, token, value);
    };
    function maybeAddRange(node, range) {
      if (addRange) {
        node.range = [range[0] + rangeOffset, range[1] + rangeOffset];
      }
      return node;
    }
    function advance() {
      var ch = source.charAt(index);
      index += 1;
      return ch;
    }
    function scanHexEscape(prefix) {
      var i, len, ch, code = 0;
      len = prefix === "u" ? 4 : 2;
      for (i = 0; i < len; ++i) {
        if (index < length && esutils.code.isHexDigit(source.charCodeAt(index))) {
          ch = advance();
          code = code * 16 + "0123456789abcdef".indexOf(ch.toLowerCase());
        } else {
          return "";
        }
      }
      return String.fromCharCode(code);
    }
    function scanString() {
      var str = "", quote, ch, code, unescaped, restore;
      quote = source.charAt(index);
      ++index;
      while (index < length) {
        ch = advance();
        if (ch === quote) {
          quote = "";
          break;
        } else if (ch === "\\") {
          ch = advance();
          if (!esutils.code.isLineTerminator(ch.charCodeAt(0))) {
            switch (ch) {
              case "n":
                str += "\n";
                break;
              case "r":
                str += "\r";
                break;
              case "t":
                str += "	";
                break;
              case "u":
              case "x":
                restore = index;
                unescaped = scanHexEscape(ch);
                if (unescaped) {
                  str += unescaped;
                } else {
                  index = restore;
                  str += ch;
                }
                break;
              case "b":
                str += "\b";
                break;
              case "f":
                str += "\f";
                break;
              case "v":
                str += "\v";
                break;
              default:
                if (esutils.code.isOctalDigit(ch.charCodeAt(0))) {
                  code = "01234567".indexOf(ch);
                  if (index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                    code = code * 8 + "01234567".indexOf(advance());
                    if ("0123".indexOf(ch) >= 0 && index < length && esutils.code.isOctalDigit(source.charCodeAt(index))) {
                      code = code * 8 + "01234567".indexOf(advance());
                    }
                  }
                  str += String.fromCharCode(code);
                } else {
                  str += ch;
                }
                break;
            }
          } else {
            if (ch === "\r" && source.charCodeAt(index) === 10) {
              ++index;
            }
          }
        } else if (esutils.code.isLineTerminator(ch.charCodeAt(0))) {
          break;
        } else {
          str += ch;
        }
      }
      if (quote !== "") {
        utility.throwError("unexpected quote");
      }
      value = str;
      return Token.STRING;
    }
    function scanNumber() {
      var number, ch;
      number = "";
      ch = source.charCodeAt(index);
      if (ch !== 46) {
        number = advance();
        ch = source.charCodeAt(index);
        if (number === "0") {
          if (ch === 120 || ch === 88) {
            number += advance();
            while (index < length) {
              ch = source.charCodeAt(index);
              if (!esutils.code.isHexDigit(ch)) {
                break;
              }
              number += advance();
            }
            if (number.length <= 2) {
              utility.throwError("unexpected token");
            }
            if (index < length) {
              ch = source.charCodeAt(index);
              if (esutils.code.isIdentifierStartES5(ch)) {
                utility.throwError("unexpected token");
              }
            }
            value = parseInt(number, 16);
            return Token.NUMBER;
          }
          if (esutils.code.isOctalDigit(ch)) {
            number += advance();
            while (index < length) {
              ch = source.charCodeAt(index);
              if (!esutils.code.isOctalDigit(ch)) {
                break;
              }
              number += advance();
            }
            if (index < length) {
              ch = source.charCodeAt(index);
              if (esutils.code.isIdentifierStartES5(ch) || esutils.code.isDecimalDigit(ch)) {
                utility.throwError("unexpected token");
              }
            }
            value = parseInt(number, 8);
            return Token.NUMBER;
          }
          if (esutils.code.isDecimalDigit(ch)) {
            utility.throwError("unexpected token");
          }
        }
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!esutils.code.isDecimalDigit(ch)) {
            break;
          }
          number += advance();
        }
      }
      if (ch === 46) {
        number += advance();
        while (index < length) {
          ch = source.charCodeAt(index);
          if (!esutils.code.isDecimalDigit(ch)) {
            break;
          }
          number += advance();
        }
      }
      if (ch === 101 || ch === 69) {
        number += advance();
        ch = source.charCodeAt(index);
        if (ch === 43 || ch === 45) {
          number += advance();
        }
        ch = source.charCodeAt(index);
        if (esutils.code.isDecimalDigit(ch)) {
          number += advance();
          while (index < length) {
            ch = source.charCodeAt(index);
            if (!esutils.code.isDecimalDigit(ch)) {
              break;
            }
            number += advance();
          }
        } else {
          utility.throwError("unexpected token");
        }
      }
      if (index < length) {
        ch = source.charCodeAt(index);
        if (esutils.code.isIdentifierStartES5(ch)) {
          utility.throwError("unexpected token");
        }
      }
      value = parseFloat(number);
      return Token.NUMBER;
    }
    function scanTypeName() {
      var ch, ch2;
      value = advance();
      while (index < length && isTypeName(source.charCodeAt(index))) {
        ch = source.charCodeAt(index);
        if (ch === 46) {
          if (index + 1 >= length) {
            return Token.ILLEGAL;
          }
          ch2 = source.charCodeAt(index + 1);
          if (ch2 === 60) {
            break;
          }
        }
        value += advance();
      }
      return Token.NAME;
    }
    function next() {
      var ch;
      previous = index;
      while (index < length && esutils.code.isWhiteSpace(source.charCodeAt(index))) {
        advance();
      }
      if (index >= length) {
        token = Token.EOF;
        return token;
      }
      ch = source.charCodeAt(index);
      switch (ch) {
        case 39:
        case 34:
          token = scanString();
          return token;
        case 58:
          advance();
          token = Token.COLON;
          return token;
        case 44:
          advance();
          token = Token.COMMA;
          return token;
        case 40:
          advance();
          token = Token.LPAREN;
          return token;
        case 41:
          advance();
          token = Token.RPAREN;
          return token;
        case 91:
          advance();
          token = Token.LBRACK;
          return token;
        case 93:
          advance();
          token = Token.RBRACK;
          return token;
        case 123:
          advance();
          token = Token.LBRACE;
          return token;
        case 125:
          advance();
          token = Token.RBRACE;
          return token;
        case 46:
          if (index + 1 < length) {
            ch = source.charCodeAt(index + 1);
            if (ch === 60) {
              advance();
              advance();
              token = Token.DOT_LT;
              return token;
            }
            if (ch === 46 && index + 2 < length && source.charCodeAt(index + 2) === 46) {
              advance();
              advance();
              advance();
              token = Token.REST;
              return token;
            }
            if (esutils.code.isDecimalDigit(ch)) {
              token = scanNumber();
              return token;
            }
          }
          token = Token.ILLEGAL;
          return token;
        case 60:
          advance();
          token = Token.LT;
          return token;
        case 62:
          advance();
          token = Token.GT;
          return token;
        case 42:
          advance();
          token = Token.STAR;
          return token;
        case 124:
          advance();
          token = Token.PIPE;
          return token;
        case 63:
          advance();
          token = Token.QUESTION;
          return token;
        case 33:
          advance();
          token = Token.BANG;
          return token;
        case 61:
          advance();
          token = Token.EQUAL;
          return token;
        case 45:
          token = scanNumber();
          return token;
        default:
          if (esutils.code.isDecimalDigit(ch)) {
            token = scanNumber();
            return token;
          }
          utility.assert(isTypeName(ch));
          token = scanTypeName();
          return token;
      }
    }
    function consume(target, text) {
      utility.assert(token === target, text || "consumed token not matched");
      next();
    }
    function expect(target, message) {
      if (token !== target) {
        utility.throwError(message || "unexpected token");
      }
      next();
    }
    function parseUnionType() {
      var elements, startIndex = index - 1;
      consume(Token.LPAREN, "UnionType should start with (");
      elements = [];
      if (token !== Token.RPAREN) {
        while (true) {
          elements.push(parseTypeExpression());
          if (token === Token.RPAREN) {
            break;
          }
          expect(Token.PIPE);
        }
      }
      consume(Token.RPAREN, "UnionType should end with )");
      return maybeAddRange({
        type: Syntax.UnionType,
        elements
      }, [startIndex, previous]);
    }
    function parseArrayType() {
      var elements, startIndex = index - 1, restStartIndex;
      consume(Token.LBRACK, "ArrayType should start with [");
      elements = [];
      while (token !== Token.RBRACK) {
        if (token === Token.REST) {
          restStartIndex = index - 3;
          consume(Token.REST);
          elements.push(maybeAddRange({
            type: Syntax.RestType,
            expression: parseTypeExpression()
          }, [restStartIndex, previous]));
          break;
        } else {
          elements.push(parseTypeExpression());
        }
        if (token !== Token.RBRACK) {
          expect(Token.COMMA);
        }
      }
      expect(Token.RBRACK);
      return maybeAddRange({
        type: Syntax.ArrayType,
        elements
      }, [startIndex, previous]);
    }
    function parseFieldName() {
      var v = value;
      if (token === Token.NAME || token === Token.STRING) {
        next();
        return v;
      }
      if (token === Token.NUMBER) {
        consume(Token.NUMBER);
        return String(v);
      }
      utility.throwError("unexpected token");
    }
    function parseFieldType() {
      var key, rangeStart = previous;
      key = parseFieldName();
      if (token === Token.COLON) {
        consume(Token.COLON);
        return maybeAddRange({
          type: Syntax.FieldType,
          key,
          value: parseTypeExpression()
        }, [rangeStart, previous]);
      }
      return maybeAddRange({
        type: Syntax.FieldType,
        key,
        value: null
      }, [rangeStart, previous]);
    }
    function parseRecordType() {
      var fields, rangeStart = index - 1, rangeEnd;
      consume(Token.LBRACE, "RecordType should start with {");
      fields = [];
      if (token === Token.COMMA) {
        consume(Token.COMMA);
      } else {
        while (token !== Token.RBRACE) {
          fields.push(parseFieldType());
          if (token !== Token.RBRACE) {
            expect(Token.COMMA);
          }
        }
      }
      rangeEnd = index;
      expect(Token.RBRACE);
      return maybeAddRange({
        type: Syntax.RecordType,
        fields
      }, [rangeStart, rangeEnd]);
    }
    function parseNameExpression() {
      var name = value, rangeStart = index - name.length;
      expect(Token.NAME);
      if (token === Token.COLON && (name === "module" || name === "external" || name === "event")) {
        consume(Token.COLON);
        name += ":" + value;
        expect(Token.NAME);
      }
      return maybeAddRange({
        type: Syntax.NameExpression,
        name
      }, [rangeStart, previous]);
    }
    function parseTypeExpressionList() {
      var elements = [];
      elements.push(parseTop());
      while (token === Token.COMMA) {
        consume(Token.COMMA);
        elements.push(parseTop());
      }
      return elements;
    }
    function parseTypeName() {
      var expr, applications, startIndex = index - value.length;
      expr = parseNameExpression();
      if (token === Token.DOT_LT || token === Token.LT) {
        next();
        applications = parseTypeExpressionList();
        expect(Token.GT);
        return maybeAddRange({
          type: Syntax.TypeApplication,
          expression: expr,
          applications
        }, [startIndex, previous]);
      }
      return expr;
    }
    function parseResultType() {
      consume(Token.COLON, "ResultType should start with :");
      if (token === Token.NAME && value === "void") {
        consume(Token.NAME);
        return {
          type: Syntax.VoidLiteral
        };
      }
      return parseTypeExpression();
    }
    function parseParametersType() {
      var params = [], optionalSequence = false, expr, rest = false, startIndex, restStartIndex = index - 3, nameStartIndex;
      while (token !== Token.RPAREN) {
        if (token === Token.REST) {
          consume(Token.REST);
          rest = true;
        }
        startIndex = previous;
        expr = parseTypeExpression();
        if (expr.type === Syntax.NameExpression && token === Token.COLON) {
          nameStartIndex = previous - expr.name.length;
          consume(Token.COLON);
          expr = maybeAddRange({
            type: Syntax.ParameterType,
            name: expr.name,
            expression: parseTypeExpression()
          }, [nameStartIndex, previous]);
        }
        if (token === Token.EQUAL) {
          consume(Token.EQUAL);
          expr = maybeAddRange({
            type: Syntax.OptionalType,
            expression: expr
          }, [startIndex, previous]);
          optionalSequence = true;
        } else {
          if (optionalSequence) {
            utility.throwError("unexpected token");
          }
        }
        if (rest) {
          expr = maybeAddRange({
            type: Syntax.RestType,
            expression: expr
          }, [restStartIndex, previous]);
        }
        params.push(expr);
        if (token !== Token.RPAREN) {
          expect(Token.COMMA);
        }
      }
      return params;
    }
    function parseFunctionType() {
      var isNew, thisBinding, params, result, fnType, startIndex = index - value.length;
      utility.assert(token === Token.NAME && value === "function", "FunctionType should start with 'function'");
      consume(Token.NAME);
      expect(Token.LPAREN);
      isNew = false;
      params = [];
      thisBinding = null;
      if (token !== Token.RPAREN) {
        if (token === Token.NAME && (value === "this" || value === "new")) {
          isNew = value === "new";
          consume(Token.NAME);
          expect(Token.COLON);
          thisBinding = parseTypeName();
          if (token === Token.COMMA) {
            consume(Token.COMMA);
            params = parseParametersType();
          }
        } else {
          params = parseParametersType();
        }
      }
      expect(Token.RPAREN);
      result = null;
      if (token === Token.COLON) {
        result = parseResultType();
      }
      fnType = maybeAddRange({
        type: Syntax.FunctionType,
        params,
        result
      }, [startIndex, previous]);
      if (thisBinding) {
        fnType["this"] = thisBinding;
        if (isNew) {
          fnType["new"] = true;
        }
      }
      return fnType;
    }
    function parseBasicTypeExpression() {
      var context4, startIndex;
      switch (token) {
        case Token.STAR:
          consume(Token.STAR);
          return maybeAddRange({
            type: Syntax.AllLiteral
          }, [previous - 1, previous]);
        case Token.LPAREN:
          return parseUnionType();
        case Token.LBRACK:
          return parseArrayType();
        case Token.LBRACE:
          return parseRecordType();
        case Token.NAME:
          startIndex = index - value.length;
          if (value === "null") {
            consume(Token.NAME);
            return maybeAddRange({
              type: Syntax.NullLiteral
            }, [startIndex, previous]);
          }
          if (value === "undefined") {
            consume(Token.NAME);
            return maybeAddRange({
              type: Syntax.UndefinedLiteral
            }, [startIndex, previous]);
          }
          if (value === "true" || value === "false") {
            consume(Token.NAME);
            return maybeAddRange({
              type: Syntax.BooleanLiteralType,
              value: value === "true"
            }, [startIndex, previous]);
          }
          context4 = Context.save();
          if (value === "function") {
            try {
              return parseFunctionType();
            } catch (e) {
              context4.restore();
            }
          }
          return parseTypeName();
        case Token.STRING:
          next();
          return maybeAddRange({
            type: Syntax.StringLiteralType,
            value
          }, [previous - value.length - 2, previous]);
        case Token.NUMBER:
          next();
          return maybeAddRange({
            type: Syntax.NumericLiteralType,
            value
          }, [previous - String(value).length, previous]);
        default:
          utility.throwError("unexpected token");
      }
    }
    function parseTypeExpression() {
      var expr, rangeStart;
      if (token === Token.QUESTION) {
        rangeStart = index - 1;
        consume(Token.QUESTION);
        if (token === Token.COMMA || token === Token.EQUAL || token === Token.RBRACE || token === Token.RPAREN || token === Token.PIPE || token === Token.EOF || token === Token.RBRACK || token === Token.GT) {
          return maybeAddRange({
            type: Syntax.NullableLiteral
          }, [rangeStart, previous]);
        }
        return maybeAddRange({
          type: Syntax.NullableType,
          expression: parseBasicTypeExpression(),
          prefix: true
        }, [rangeStart, previous]);
      } else if (token === Token.BANG) {
        rangeStart = index - 1;
        consume(Token.BANG);
        return maybeAddRange({
          type: Syntax.NonNullableType,
          expression: parseBasicTypeExpression(),
          prefix: true
        }, [rangeStart, previous]);
      } else {
        rangeStart = previous;
      }
      expr = parseBasicTypeExpression();
      if (token === Token.BANG) {
        consume(Token.BANG);
        return maybeAddRange({
          type: Syntax.NonNullableType,
          expression: expr,
          prefix: false
        }, [rangeStart, previous]);
      }
      if (token === Token.QUESTION) {
        consume(Token.QUESTION);
        return maybeAddRange({
          type: Syntax.NullableType,
          expression: expr,
          prefix: false
        }, [rangeStart, previous]);
      }
      if (token === Token.LBRACK) {
        consume(Token.LBRACK);
        expect(Token.RBRACK, "expected an array-style type declaration (" + value + "[])");
        return maybeAddRange({
          type: Syntax.TypeApplication,
          expression: maybeAddRange({
            type: Syntax.NameExpression,
            name: "Array"
          }, [rangeStart, previous]),
          applications: [expr]
        }, [rangeStart, previous]);
      }
      return expr;
    }
    function parseTop() {
      var expr, elements;
      expr = parseTypeExpression();
      if (token !== Token.PIPE) {
        return expr;
      }
      elements = [expr];
      consume(Token.PIPE);
      while (true) {
        elements.push(parseTypeExpression());
        if (token !== Token.PIPE) {
          break;
        }
        consume(Token.PIPE);
      }
      return maybeAddRange({
        type: Syntax.UnionType,
        elements
      }, [0, index]);
    }
    function parseTopParamType() {
      var expr;
      if (token === Token.REST) {
        consume(Token.REST);
        return maybeAddRange({
          type: Syntax.RestType,
          expression: parseTop()
        }, [0, index]);
      }
      expr = parseTop();
      if (token === Token.EQUAL) {
        consume(Token.EQUAL);
        return maybeAddRange({
          type: Syntax.OptionalType,
          expression: expr
        }, [0, index]);
      }
      return expr;
    }
    function parseType(src, opt) {
      var expr;
      source = src;
      length = source.length;
      index = 0;
      previous = 0;
      addRange = opt && opt.range;
      rangeOffset = opt && opt.startIndex || 0;
      next();
      expr = parseTop();
      if (opt && opt.midstream) {
        return {
          expression: expr,
          index: previous
        };
      }
      if (token !== Token.EOF) {
        utility.throwError("not reach to EOF");
      }
      return expr;
    }
    function parseParamType(src, opt) {
      var expr;
      source = src;
      length = source.length;
      index = 0;
      previous = 0;
      addRange = opt && opt.range;
      rangeOffset = opt && opt.startIndex || 0;
      next();
      expr = parseTopParamType();
      if (opt && opt.midstream) {
        return {
          expression: expr,
          index: previous
        };
      }
      if (token !== Token.EOF) {
        utility.throwError("not reach to EOF");
      }
      return expr;
    }
    function stringifyImpl(node, compact, topLevel) {
      var result, i, iz;
      switch (node.type) {
        case Syntax.NullableLiteral:
          result = "?";
          break;
        case Syntax.AllLiteral:
          result = "*";
          break;
        case Syntax.NullLiteral:
          result = "null";
          break;
        case Syntax.UndefinedLiteral:
          result = "undefined";
          break;
        case Syntax.VoidLiteral:
          result = "void";
          break;
        case Syntax.UnionType:
          if (!topLevel) {
            result = "(";
          } else {
            result = "";
          }
          for (i = 0, iz = node.elements.length; i < iz; ++i) {
            result += stringifyImpl(node.elements[i], compact);
            if (i + 1 !== iz) {
              result += compact ? "|" : " | ";
            }
          }
          if (!topLevel) {
            result += ")";
          }
          break;
        case Syntax.ArrayType:
          result = "[";
          for (i = 0, iz = node.elements.length; i < iz; ++i) {
            result += stringifyImpl(node.elements[i], compact);
            if (i + 1 !== iz) {
              result += compact ? "," : ", ";
            }
          }
          result += "]";
          break;
        case Syntax.RecordType:
          result = "{";
          for (i = 0, iz = node.fields.length; i < iz; ++i) {
            result += stringifyImpl(node.fields[i], compact);
            if (i + 1 !== iz) {
              result += compact ? "," : ", ";
            }
          }
          result += "}";
          break;
        case Syntax.FieldType:
          if (node.value) {
            result = node.key + (compact ? ":" : ": ") + stringifyImpl(node.value, compact);
          } else {
            result = node.key;
          }
          break;
        case Syntax.FunctionType:
          result = compact ? "function(" : "function (";
          if (node["this"]) {
            if (node["new"]) {
              result += compact ? "new:" : "new: ";
            } else {
              result += compact ? "this:" : "this: ";
            }
            result += stringifyImpl(node["this"], compact);
            if (node.params.length !== 0) {
              result += compact ? "," : ", ";
            }
          }
          for (i = 0, iz = node.params.length; i < iz; ++i) {
            result += stringifyImpl(node.params[i], compact);
            if (i + 1 !== iz) {
              result += compact ? "," : ", ";
            }
          }
          result += ")";
          if (node.result) {
            result += (compact ? ":" : ": ") + stringifyImpl(node.result, compact);
          }
          break;
        case Syntax.ParameterType:
          result = node.name + (compact ? ":" : ": ") + stringifyImpl(node.expression, compact);
          break;
        case Syntax.RestType:
          result = "...";
          if (node.expression) {
            result += stringifyImpl(node.expression, compact);
          }
          break;
        case Syntax.NonNullableType:
          if (node.prefix) {
            result = "!" + stringifyImpl(node.expression, compact);
          } else {
            result = stringifyImpl(node.expression, compact) + "!";
          }
          break;
        case Syntax.OptionalType:
          result = stringifyImpl(node.expression, compact) + "=";
          break;
        case Syntax.NullableType:
          if (node.prefix) {
            result = "?" + stringifyImpl(node.expression, compact);
          } else {
            result = stringifyImpl(node.expression, compact) + "?";
          }
          break;
        case Syntax.NameExpression:
          result = node.name;
          break;
        case Syntax.TypeApplication:
          result = stringifyImpl(node.expression, compact) + ".<";
          for (i = 0, iz = node.applications.length; i < iz; ++i) {
            result += stringifyImpl(node.applications[i], compact);
            if (i + 1 !== iz) {
              result += compact ? "," : ", ";
            }
          }
          result += ">";
          break;
        case Syntax.StringLiteralType:
          result = '"' + node.value + '"';
          break;
        case Syntax.NumericLiteralType:
          result = String(node.value);
          break;
        case Syntax.BooleanLiteralType:
          result = String(node.value);
          break;
        default:
          utility.throwError("Unknown type " + node.type);
      }
      return result;
    }
    function stringify(node, options) {
      if (options == null) {
        options = {};
      }
      return stringifyImpl(node, options.compact, options.topLevel);
    }
    exports2.parseType = parseType;
    exports2.parseParamType = parseParamType;
    exports2.stringify = stringify;
    exports2.Syntax = Syntax;
  })();
});

// node_modules/doctrine/lib/doctrine.js
var require_doctrine = __commonJS((exports2) => {
  (function() {
    "use strict";
    var typed, utility, jsdoc, esutils, hasOwnProperty;
    esutils = require_utils7();
    typed = require_typed();
    utility = require_utility();
    function sliceSource(source, index, last) {
      return source.slice(index, last);
    }
    hasOwnProperty = function() {
      var func = Object.prototype.hasOwnProperty;
      return function hasOwnProperty2(obj, name) {
        return func.call(obj, name);
      };
    }();
    function shallowCopy(obj) {
      var ret = {}, key;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    function isASCIIAlphanumeric(ch) {
      return ch >= 97 && ch <= 122 || ch >= 65 && ch <= 90 || ch >= 48 && ch <= 57;
    }
    function isParamTitle(title) {
      return title === "param" || title === "argument" || title === "arg";
    }
    function isReturnTitle(title) {
      return title === "return" || title === "returns";
    }
    function isProperty(title) {
      return title === "property" || title === "prop";
    }
    function isNameParameterRequired(title) {
      return isParamTitle(title) || isProperty(title) || title === "alias" || title === "this" || title === "mixes" || title === "requires";
    }
    function isAllowedName(title) {
      return isNameParameterRequired(title) || title === "const" || title === "constant";
    }
    function isAllowedNested(title) {
      return isProperty(title) || isParamTitle(title);
    }
    function isAllowedOptional(title) {
      return isProperty(title) || isParamTitle(title);
    }
    function isTypeParameterRequired(title) {
      return isParamTitle(title) || isReturnTitle(title) || title === "define" || title === "enum" || title === "implements" || title === "this" || title === "type" || title === "typedef" || isProperty(title);
    }
    function isAllowedType(title) {
      return isTypeParameterRequired(title) || title === "throws" || title === "const" || title === "constant" || title === "namespace" || title === "member" || title === "var" || title === "module" || title === "constructor" || title === "class" || title === "extends" || title === "augments" || title === "public" || title === "private" || title === "protected";
    }
    var WHITESPACE = "[ \\f\\t\\v\\u00a0\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]";
    var STAR_MATCHER = "(" + WHITESPACE + "*(?:\\*" + WHITESPACE + "?)?)(.+|[\r\n\u2028\u2029])";
    function unwrapComment(doc) {
      return doc.replace(/^\/\*\*?/, "").replace(/\*\/$/, "").replace(new RegExp(STAR_MATCHER, "g"), "$2").replace(/\s*$/, "");
    }
    function convertUnwrappedCommentIndex(originalSource, unwrappedIndex) {
      var replacedSource = originalSource.replace(/^\/\*\*?/, "");
      var numSkippedChars = 0;
      var matcher = new RegExp(STAR_MATCHER, "g");
      var match;
      while (match = matcher.exec(replacedSource)) {
        numSkippedChars += match[1].length;
        if (match.index + match[0].length > unwrappedIndex + numSkippedChars) {
          return unwrappedIndex + numSkippedChars + originalSource.length - replacedSource.length;
        }
      }
      return originalSource.replace(/\*\/$/, "").replace(/\s*$/, "").length;
    }
    (function(exports3) {
      var Rules, index, lineNumber, length, source, originalSource, recoverable, sloppy, strict;
      function advance() {
        var ch = source.charCodeAt(index);
        index += 1;
        if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(index) === 10)) {
          lineNumber += 1;
        }
        return String.fromCharCode(ch);
      }
      function scanTitle() {
        var title = "";
        advance();
        while (index < length && isASCIIAlphanumeric(source.charCodeAt(index))) {
          title += advance();
        }
        return title;
      }
      function seekContent() {
        var ch, waiting, last = index;
        waiting = false;
        while (last < length) {
          ch = source.charCodeAt(last);
          if (esutils.code.isLineTerminator(ch) && !(ch === 13 && source.charCodeAt(last + 1) === 10)) {
            waiting = true;
          } else if (waiting) {
            if (ch === 64) {
              break;
            }
            if (!esutils.code.isWhiteSpace(ch)) {
              waiting = false;
            }
          }
          last += 1;
        }
        return last;
      }
      function parseType(title, last, addRange) {
        var ch, brace, type, startIndex, direct = false;
        while (index < last) {
          ch = source.charCodeAt(index);
          if (esutils.code.isWhiteSpace(ch)) {
            advance();
          } else if (ch === 123) {
            advance();
            break;
          } else {
            direct = true;
            break;
          }
        }
        if (direct) {
          return null;
        }
        brace = 1;
        type = "";
        while (index < last) {
          ch = source.charCodeAt(index);
          if (esutils.code.isLineTerminator(ch)) {
            advance();
          } else {
            if (ch === 125) {
              brace -= 1;
              if (brace === 0) {
                advance();
                break;
              }
            } else if (ch === 123) {
              brace += 1;
            }
            if (type === "") {
              startIndex = index;
            }
            type += advance();
          }
        }
        if (brace !== 0) {
          return utility.throwError("Braces are not balanced");
        }
        if (isAllowedOptional(title)) {
          return typed.parseParamType(type, {startIndex: convertIndex(startIndex), range: addRange});
        }
        return typed.parseType(type, {startIndex: convertIndex(startIndex), range: addRange});
      }
      function scanIdentifier(last) {
        var identifier;
        if (!esutils.code.isIdentifierStartES5(source.charCodeAt(index)) && !source[index].match(/[0-9]/)) {
          return null;
        }
        identifier = advance();
        while (index < last && esutils.code.isIdentifierPartES5(source.charCodeAt(index))) {
          identifier += advance();
        }
        return identifier;
      }
      function skipWhiteSpace(last) {
        while (index < last && (esutils.code.isWhiteSpace(source.charCodeAt(index)) || esutils.code.isLineTerminator(source.charCodeAt(index)))) {
          advance();
        }
      }
      function parseName(last, allowBrackets, allowNestedParams) {
        var name = "", useBrackets, insideString;
        skipWhiteSpace(last);
        if (index >= last) {
          return null;
        }
        if (source.charCodeAt(index) === 91) {
          if (allowBrackets) {
            useBrackets = true;
            name = advance();
          } else {
            return null;
          }
        }
        name += scanIdentifier(last);
        if (allowNestedParams) {
          if (source.charCodeAt(index) === 58 && (name === "module" || name === "external" || name === "event")) {
            name += advance();
            name += scanIdentifier(last);
          }
          if (source.charCodeAt(index) === 91 && source.charCodeAt(index + 1) === 93) {
            name += advance();
            name += advance();
          }
          while (source.charCodeAt(index) === 46 || source.charCodeAt(index) === 47 || source.charCodeAt(index) === 35 || source.charCodeAt(index) === 45 || source.charCodeAt(index) === 126) {
            name += advance();
            name += scanIdentifier(last);
          }
        }
        if (useBrackets) {
          skipWhiteSpace(last);
          if (source.charCodeAt(index) === 61) {
            name += advance();
            skipWhiteSpace(last);
            var ch;
            var bracketDepth = 1;
            while (index < last) {
              ch = source.charCodeAt(index);
              if (esutils.code.isWhiteSpace(ch)) {
                if (!insideString) {
                  skipWhiteSpace(last);
                  ch = source.charCodeAt(index);
                }
              }
              if (ch === 39) {
                if (!insideString) {
                  insideString = "'";
                } else {
                  if (insideString === "'") {
                    insideString = "";
                  }
                }
              }
              if (ch === 34) {
                if (!insideString) {
                  insideString = '"';
                } else {
                  if (insideString === '"') {
                    insideString = "";
                  }
                }
              }
              if (ch === 91) {
                bracketDepth++;
              } else if (ch === 93 && --bracketDepth === 0) {
                break;
              }
              name += advance();
            }
          }
          skipWhiteSpace(last);
          if (index >= last || source.charCodeAt(index) !== 93) {
            return null;
          }
          name += advance();
        }
        return name;
      }
      function skipToTag() {
        while (index < length && source.charCodeAt(index) !== 64) {
          advance();
        }
        if (index >= length) {
          return false;
        }
        utility.assert(source.charCodeAt(index) === 64);
        return true;
      }
      function convertIndex(rangeIndex) {
        if (source === originalSource) {
          return rangeIndex;
        }
        return convertUnwrappedCommentIndex(originalSource, rangeIndex);
      }
      function TagParser(options, title) {
        this._options = options;
        this._title = title.toLowerCase();
        this._tag = {
          title,
          description: null
        };
        if (this._options.lineNumbers) {
          this._tag.lineNumber = lineNumber;
        }
        this._first = index - title.length - 1;
        this._last = 0;
        this._extra = {};
      }
      TagParser.prototype.addError = function addError(errorText) {
        var args = Array.prototype.slice.call(arguments, 1), msg = errorText.replace(/%(\d)/g, function(whole, index2) {
          utility.assert(index2 < args.length, "Message reference must be in range");
          return args[index2];
        });
        if (!this._tag.errors) {
          this._tag.errors = [];
        }
        if (strict) {
          utility.throwError(msg);
        }
        this._tag.errors.push(msg);
        return recoverable;
      };
      TagParser.prototype.parseType = function() {
        if (isTypeParameterRequired(this._title)) {
          try {
            this._tag.type = parseType(this._title, this._last, this._options.range);
            if (!this._tag.type) {
              if (!isParamTitle(this._title) && !isReturnTitle(this._title)) {
                if (!this.addError("Missing or invalid tag type")) {
                  return false;
                }
              }
            }
          } catch (error5) {
            this._tag.type = null;
            if (!this.addError(error5.message)) {
              return false;
            }
          }
        } else if (isAllowedType(this._title)) {
          try {
            this._tag.type = parseType(this._title, this._last, this._options.range);
          } catch (e) {
          }
        }
        return true;
      };
      TagParser.prototype._parseNamePath = function(optional) {
        var name;
        name = parseName(this._last, sloppy && isAllowedOptional(this._title), true);
        if (!name) {
          if (!optional) {
            if (!this.addError("Missing or invalid tag name")) {
              return false;
            }
          }
        }
        this._tag.name = name;
        return true;
      };
      TagParser.prototype.parseNamePath = function() {
        return this._parseNamePath(false);
      };
      TagParser.prototype.parseNamePathOptional = function() {
        return this._parseNamePath(true);
      };
      TagParser.prototype.parseName = function() {
        var assign, name;
        if (isAllowedName(this._title)) {
          this._tag.name = parseName(this._last, sloppy && isAllowedOptional(this._title), isAllowedNested(this._title));
          if (!this._tag.name) {
            if (!isNameParameterRequired(this._title)) {
              return true;
            }
            if (isParamTitle(this._title) && this._tag.type && this._tag.type.name) {
              this._extra.name = this._tag.type;
              this._tag.name = this._tag.type.name;
              this._tag.type = null;
            } else {
              if (!this.addError("Missing or invalid tag name")) {
                return false;
              }
            }
          } else {
            name = this._tag.name;
            if (name.charAt(0) === "[" && name.charAt(name.length - 1) === "]") {
              assign = name.substring(1, name.length - 1).split("=");
              if (assign.length > 1) {
                this._tag["default"] = assign.slice(1).join("=");
              }
              this._tag.name = assign[0];
              if (this._tag.type && this._tag.type.type !== "OptionalType") {
                this._tag.type = {
                  type: "OptionalType",
                  expression: this._tag.type
                };
              }
            }
          }
        }
        return true;
      };
      TagParser.prototype.parseDescription = function parseDescription() {
        var description = sliceSource(source, index, this._last).trim();
        if (description) {
          if (/^-\s+/.test(description)) {
            description = description.substring(2);
          }
          this._tag.description = description;
        }
        return true;
      };
      TagParser.prototype.parseCaption = function parseDescription() {
        var description = sliceSource(source, index, this._last).trim();
        var captionStartTag = "<caption>";
        var captionEndTag = "</caption>";
        var captionStart = description.indexOf(captionStartTag);
        var captionEnd = description.indexOf(captionEndTag);
        if (captionStart >= 0 && captionEnd >= 0) {
          this._tag.caption = description.substring(captionStart + captionStartTag.length, captionEnd).trim();
          this._tag.description = description.substring(captionEnd + captionEndTag.length).trim();
        } else {
          this._tag.description = description;
        }
        return true;
      };
      TagParser.prototype.parseKind = function parseKind() {
        var kind, kinds;
        kinds = {
          class: true,
          constant: true,
          event: true,
          external: true,
          file: true,
          function: true,
          member: true,
          mixin: true,
          module: true,
          namespace: true,
          typedef: true
        };
        kind = sliceSource(source, index, this._last).trim();
        this._tag.kind = kind;
        if (!hasOwnProperty(kinds, kind)) {
          if (!this.addError("Invalid kind name '%0'", kind)) {
            return false;
          }
        }
        return true;
      };
      TagParser.prototype.parseAccess = function parseAccess() {
        var access;
        access = sliceSource(source, index, this._last).trim();
        this._tag.access = access;
        if (access !== "private" && access !== "protected" && access !== "public") {
          if (!this.addError("Invalid access name '%0'", access)) {
            return false;
          }
        }
        return true;
      };
      TagParser.prototype.parseThis = function parseThis() {
        var value = sliceSource(source, index, this._last).trim();
        if (value && value.charAt(0) === "{") {
          var gotType = this.parseType();
          if (gotType && this._tag.type.type === "NameExpression" || this._tag.type.type === "UnionType") {
            this._tag.name = this._tag.type.name;
            return true;
          } else {
            return this.addError("Invalid name for this");
          }
        } else {
          return this.parseNamePath();
        }
      };
      TagParser.prototype.parseVariation = function parseVariation() {
        var variation, text;
        text = sliceSource(source, index, this._last).trim();
        variation = parseFloat(text, 10);
        this._tag.variation = variation;
        if (isNaN(variation)) {
          if (!this.addError("Invalid variation '%0'", text)) {
            return false;
          }
        }
        return true;
      };
      TagParser.prototype.ensureEnd = function() {
        var shouldBeEmpty = sliceSource(source, index, this._last).trim();
        if (shouldBeEmpty) {
          if (!this.addError("Unknown content '%0'", shouldBeEmpty)) {
            return false;
          }
        }
        return true;
      };
      TagParser.prototype.epilogue = function epilogue() {
        var description;
        description = this._tag.description;
        if (isAllowedOptional(this._title) && !this._tag.type && description && description.charAt(0) === "[") {
          this._tag.type = this._extra.name;
          if (!this._tag.name) {
            this._tag.name = void 0;
          }
          if (!sloppy) {
            if (!this.addError("Missing or invalid tag name")) {
              return false;
            }
          }
        }
        return true;
      };
      Rules = {
        access: ["parseAccess"],
        alias: ["parseNamePath", "ensureEnd"],
        augments: ["parseType", "parseNamePathOptional", "ensureEnd"],
        constructor: ["parseType", "parseNamePathOptional", "ensureEnd"],
        class: ["parseType", "parseNamePathOptional", "ensureEnd"],
        extends: ["parseType", "parseNamePathOptional", "ensureEnd"],
        example: ["parseCaption"],
        deprecated: ["parseDescription"],
        global: ["ensureEnd"],
        inner: ["ensureEnd"],
        instance: ["ensureEnd"],
        kind: ["parseKind"],
        mixes: ["parseNamePath", "ensureEnd"],
        mixin: ["parseNamePathOptional", "ensureEnd"],
        member: ["parseType", "parseNamePathOptional", "ensureEnd"],
        method: ["parseNamePathOptional", "ensureEnd"],
        module: ["parseType", "parseNamePathOptional", "ensureEnd"],
        func: ["parseNamePathOptional", "ensureEnd"],
        function: ["parseNamePathOptional", "ensureEnd"],
        var: ["parseType", "parseNamePathOptional", "ensureEnd"],
        name: ["parseNamePath", "ensureEnd"],
        namespace: ["parseType", "parseNamePathOptional", "ensureEnd"],
        private: ["parseType", "parseDescription"],
        protected: ["parseType", "parseDescription"],
        public: ["parseType", "parseDescription"],
        readonly: ["ensureEnd"],
        requires: ["parseNamePath", "ensureEnd"],
        since: ["parseDescription"],
        static: ["ensureEnd"],
        summary: ["parseDescription"],
        this: ["parseThis", "ensureEnd"],
        todo: ["parseDescription"],
        typedef: ["parseType", "parseNamePathOptional"],
        variation: ["parseVariation"],
        version: ["parseDescription"]
      };
      TagParser.prototype.parse = function parse2() {
        var i, iz, sequences, method;
        if (!this._title) {
          if (!this.addError("Missing or invalid title")) {
            return null;
          }
        }
        this._last = seekContent(this._title);
        if (this._options.range) {
          this._tag.range = [this._first, source.slice(0, this._last).replace(/\s*$/, "").length].map(convertIndex);
        }
        if (hasOwnProperty(Rules, this._title)) {
          sequences = Rules[this._title];
        } else {
          sequences = ["parseType", "parseName", "parseDescription", "epilogue"];
        }
        for (i = 0, iz = sequences.length; i < iz; ++i) {
          method = sequences[i];
          if (!this[method]()) {
            return null;
          }
        }
        return this._tag;
      };
      function parseTag(options) {
        var title, parser, tag;
        if (!skipToTag()) {
          return null;
        }
        title = scanTitle();
        parser = new TagParser(options, title);
        tag = parser.parse();
        while (index < parser._last) {
          advance();
        }
        return tag;
      }
      function scanJSDocDescription(preserveWhitespace) {
        var description = "", ch, atAllowed;
        atAllowed = true;
        while (index < length) {
          ch = source.charCodeAt(index);
          if (atAllowed && ch === 64) {
            break;
          }
          if (esutils.code.isLineTerminator(ch)) {
            atAllowed = true;
          } else if (atAllowed && !esutils.code.isWhiteSpace(ch)) {
            atAllowed = false;
          }
          description += advance();
        }
        return preserveWhitespace ? description : description.trim();
      }
      function parse(comment, options) {
        var tags = [], tag, description, interestingTags, i, iz;
        if (options === void 0) {
          options = {};
        }
        if (typeof options.unwrap === "boolean" && options.unwrap) {
          source = unwrapComment(comment);
        } else {
          source = comment;
        }
        originalSource = comment;
        if (options.tags) {
          if (Array.isArray(options.tags)) {
            interestingTags = {};
            for (i = 0, iz = options.tags.length; i < iz; i++) {
              if (typeof options.tags[i] === "string") {
                interestingTags[options.tags[i]] = true;
              } else {
                utility.throwError('Invalid "tags" parameter: ' + options.tags);
              }
            }
          } else {
            utility.throwError('Invalid "tags" parameter: ' + options.tags);
          }
        }
        length = source.length;
        index = 0;
        lineNumber = 0;
        recoverable = options.recoverable;
        sloppy = options.sloppy;
        strict = options.strict;
        description = scanJSDocDescription(options.preserveWhitespace);
        while (true) {
          tag = parseTag(options);
          if (!tag) {
            break;
          }
          if (!interestingTags || interestingTags.hasOwnProperty(tag.title)) {
            tags.push(tag);
          }
        }
        return {
          description,
          tags
        };
      }
      exports3.parse = parse;
    })(jsdoc = {});
    exports2.version = utility.VERSION;
    exports2.parse = jsdoc.parse;
    exports2.parseType = typed.parseType;
    exports2.parseParamType = typed.parseParamType;
    exports2.unwrapComment = unwrapComment;
    exports2.Syntax = shallowCopy(typed.Syntax);
    exports2.Error = utility.DoctrineError;
    exports2.type = {
      Syntax: exports2.Syntax,
      parseType: typed.parseType,
      parseParamType: typed.parseParamType,
      stringify: typed.stringify
    };
  })();
});

// node_modules/eslint/lib/rules/valid-jsdoc.js
var require_valid_jsdoc = __commonJS((exports2, module2) => {
  "use strict";
  var doctrine = require_doctrine();
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "enforce valid JSDoc comments",
        category: "Possible Errors",
        recommended: false,
        url: "https://eslint.org/docs/rules/valid-jsdoc"
      },
      schema: [
        {
          type: "object",
          properties: {
            prefer: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            },
            preferType: {
              type: "object",
              additionalProperties: {
                type: "string"
              }
            },
            requireReturn: {
              type: "boolean",
              default: true
            },
            requireParamDescription: {
              type: "boolean",
              default: true
            },
            requireReturnDescription: {
              type: "boolean",
              default: true
            },
            matchDescription: {
              type: "string"
            },
            requireReturnType: {
              type: "boolean",
              default: true
            },
            requireParamType: {
              type: "boolean",
              default: true
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        unexpectedTag: "Unexpected @{{title}} tag; function has no return statement.",
        expected: "Expected JSDoc for '{{name}}' but found '{{jsdocName}}'.",
        use: "Use @{{name}} instead.",
        useType: "Use '{{expectedTypeName}}' instead of '{{currentTypeName}}'.",
        syntaxError: "JSDoc syntax error.",
        missingBrace: "JSDoc type missing brace.",
        missingParamDesc: "Missing JSDoc parameter description for '{{name}}'.",
        missingParamType: "Missing JSDoc parameter type for '{{name}}'.",
        missingReturnType: "Missing JSDoc return type.",
        missingReturnDesc: "Missing JSDoc return description.",
        missingReturn: "Missing JSDoc @{{returns}} for function.",
        missingParam: "Missing JSDoc for parameter '{{name}}'.",
        duplicateParam: "Duplicate JSDoc parameter '{{name}}'.",
        unsatisfiedDesc: "JSDoc description does not satisfy the regex pattern."
      },
      deprecated: true,
      replacedBy: []
    },
    create(context4) {
      const options = context4.options[0] || {}, prefer = options.prefer || {}, sourceCode = context4.getSourceCode(), requireReturn = options.requireReturn !== false, requireParamDescription = options.requireParamDescription !== false, requireReturnDescription = options.requireReturnDescription !== false, requireReturnType = options.requireReturnType !== false, requireParamType = options.requireParamType !== false, preferType = options.preferType || {}, checkPreferType = Object.keys(preferType).length !== 0;
      const fns = [];
      function isTypeClass(node) {
        return node.type === "ClassExpression" || node.type === "ClassDeclaration";
      }
      function startFunction(node) {
        fns.push({
          returnPresent: node.type === "ArrowFunctionExpression" && node.body.type !== "BlockStatement" || isTypeClass(node) || node.async
        });
      }
      function addReturn(node) {
        const functionState = fns[fns.length - 1];
        if (functionState && node.argument !== null) {
          functionState.returnPresent = true;
        }
      }
      function isValidReturnType(tag) {
        return tag.type === null || tag.type.name === "void" || tag.type.type === "UndefinedLiteral";
      }
      function canTypeBeValidated(type) {
        return type !== "UndefinedLiteral" && type !== "NullLiteral" && type !== "NullableLiteral" && type !== "FunctionType" && type !== "AllLiteral";
      }
      function getCurrentExpectedTypes(type) {
        let currentType;
        if (type.name) {
          currentType = type;
        } else if (type.expression) {
          currentType = type.expression;
        }
        return {
          currentType,
          expectedTypeName: currentType && preferType[currentType.name]
        };
      }
      function getAbsoluteRange(jsdocComment, parsedJsdocNode) {
        return {
          start: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[0]),
          end: sourceCode.getLocFromIndex(jsdocComment.range[0] + 2 + parsedJsdocNode.range[1])
        };
      }
      function validateType(jsdocNode, type) {
        if (!type || !canTypeBeValidated(type.type)) {
          return;
        }
        const typesToCheck = [];
        let elements = [];
        switch (type.type) {
          case "TypeApplication":
            elements = type.applications[0].type === "UnionType" ? type.applications[0].elements : type.applications;
            typesToCheck.push(getCurrentExpectedTypes(type));
            break;
          case "RecordType":
            elements = type.fields;
            break;
          case "UnionType":
          case "ArrayType":
            elements = type.elements;
            break;
          case "FieldType":
            if (type.value) {
              typesToCheck.push(getCurrentExpectedTypes(type.value));
            }
            break;
          default:
            typesToCheck.push(getCurrentExpectedTypes(type));
        }
        elements.forEach(validateType.bind(null, jsdocNode));
        typesToCheck.forEach((typeToCheck) => {
          if (typeToCheck.expectedTypeName && typeToCheck.expectedTypeName !== typeToCheck.currentType.name) {
            context4.report({
              node: jsdocNode,
              messageId: "useType",
              loc: getAbsoluteRange(jsdocNode, typeToCheck.currentType),
              data: {
                currentTypeName: typeToCheck.currentType.name,
                expectedTypeName: typeToCheck.expectedTypeName
              },
              fix(fixer) {
                return fixer.replaceTextRange(typeToCheck.currentType.range.map((indexInComment) => jsdocNode.range[0] + 2 + indexInComment), typeToCheck.expectedTypeName);
              }
            });
          }
        });
      }
      function checkJSDoc(node) {
        const jsdocNode = sourceCode.getJSDocComment(node), functionData = fns.pop(), paramTagsByName = Object.create(null), paramTags = [];
        let hasReturns = false, returnsTag, hasConstructor = false, isInterface = false, isOverride = false, isAbstract = false;
        if (jsdocNode) {
          let jsdoc;
          try {
            jsdoc = doctrine.parse(jsdocNode.value, {
              strict: true,
              unwrap: true,
              sloppy: true,
              range: true
            });
          } catch (ex) {
            if (/braces/iu.test(ex.message)) {
              context4.report({node: jsdocNode, messageId: "missingBrace"});
            } else {
              context4.report({node: jsdocNode, messageId: "syntaxError"});
            }
            return;
          }
          jsdoc.tags.forEach((tag) => {
            switch (tag.title.toLowerCase()) {
              case "param":
              case "arg":
              case "argument":
                paramTags.push(tag);
                break;
              case "return":
              case "returns":
                hasReturns = true;
                returnsTag = tag;
                break;
              case "constructor":
              case "class":
                hasConstructor = true;
                break;
              case "override":
              case "inheritdoc":
                isOverride = true;
                break;
              case "abstract":
              case "virtual":
                isAbstract = true;
                break;
              case "interface":
                isInterface = true;
                break;
            }
            if (Object.prototype.hasOwnProperty.call(prefer, tag.title) && tag.title !== prefer[tag.title]) {
              const entireTagRange = getAbsoluteRange(jsdocNode, tag);
              context4.report({
                node: jsdocNode,
                messageId: "use",
                loc: {
                  start: entireTagRange.start,
                  end: {
                    line: entireTagRange.start.line,
                    column: entireTagRange.start.column + `@${tag.title}`.length
                  }
                },
                data: {name: prefer[tag.title]},
                fix(fixer) {
                  return fixer.replaceTextRange([
                    jsdocNode.range[0] + tag.range[0] + 3,
                    jsdocNode.range[0] + tag.range[0] + tag.title.length + 3
                  ], prefer[tag.title]);
                }
              });
            }
            if (checkPreferType && tag.type) {
              validateType(jsdocNode, tag.type);
            }
          });
          paramTags.forEach((param) => {
            if (requireParamType && !param.type) {
              context4.report({
                node: jsdocNode,
                messageId: "missingParamType",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {name: param.name}
              });
            }
            if (!param.description && requireParamDescription) {
              context4.report({
                node: jsdocNode,
                messageId: "missingParamDesc",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {name: param.name}
              });
            }
            if (paramTagsByName[param.name]) {
              context4.report({
                node: jsdocNode,
                messageId: "duplicateParam",
                loc: getAbsoluteRange(jsdocNode, param),
                data: {name: param.name}
              });
            } else if (param.name.indexOf(".") === -1) {
              paramTagsByName[param.name] = param;
            }
          });
          if (hasReturns) {
            if (!requireReturn && !functionData.returnPresent && (returnsTag.type === null || !isValidReturnType(returnsTag)) && !isAbstract) {
              context4.report({
                node: jsdocNode,
                messageId: "unexpectedTag",
                loc: getAbsoluteRange(jsdocNode, returnsTag),
                data: {
                  title: returnsTag.title
                }
              });
            } else {
              if (requireReturnType && !returnsTag.type) {
                context4.report({node: jsdocNode, messageId: "missingReturnType"});
              }
              if (!isValidReturnType(returnsTag) && !returnsTag.description && requireReturnDescription) {
                context4.report({node: jsdocNode, messageId: "missingReturnDesc"});
              }
            }
          }
          if (!isOverride && !hasReturns && !hasConstructor && !isInterface && node.parent.kind !== "get" && node.parent.kind !== "constructor" && node.parent.kind !== "set" && !isTypeClass(node)) {
            if (requireReturn || functionData.returnPresent && !node.async) {
              context4.report({
                node: jsdocNode,
                messageId: "missingReturn",
                data: {
                  returns: prefer.returns || "returns"
                }
              });
            }
          }
          const jsdocParamNames = Object.keys(paramTagsByName);
          if (node.params) {
            node.params.forEach((param, paramsIndex) => {
              const bindingParam = param.type === "AssignmentPattern" ? param.left : param;
              if (bindingParam.type === "Identifier") {
                const name = bindingParam.name;
                if (jsdocParamNames[paramsIndex] && name !== jsdocParamNames[paramsIndex]) {
                  context4.report({
                    node: jsdocNode,
                    messageId: "expected",
                    loc: getAbsoluteRange(jsdocNode, paramTagsByName[jsdocParamNames[paramsIndex]]),
                    data: {
                      name,
                      jsdocName: jsdocParamNames[paramsIndex]
                    }
                  });
                } else if (!paramTagsByName[name] && !isOverride) {
                  context4.report({
                    node: jsdocNode,
                    messageId: "missingParam",
                    data: {
                      name
                    }
                  });
                }
              }
            });
          }
          if (options.matchDescription) {
            const regex = new RegExp(options.matchDescription, "u");
            if (!regex.test(jsdoc.description)) {
              context4.report({node: jsdocNode, messageId: "unsatisfiedDesc"});
            }
          }
        }
      }
      return {
        ArrowFunctionExpression: startFunction,
        FunctionExpression: startFunction,
        FunctionDeclaration: startFunction,
        ClassExpression: startFunction,
        ClassDeclaration: startFunction,
        "ArrowFunctionExpression:exit": checkJSDoc,
        "FunctionExpression:exit": checkJSDoc,
        "FunctionDeclaration:exit": checkJSDoc,
        "ClassExpression:exit": checkJSDoc,
        "ClassDeclaration:exit": checkJSDoc,
        ReturnStatement: addReturn
      };
    }
  };
});

// node_modules/eslint/lib/rules/valid-typeof.js
var require_valid_typeof = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "problem",
      docs: {
        description: "enforce comparing `typeof` expressions against valid strings",
        category: "Possible Errors",
        recommended: true,
        url: "https://eslint.org/docs/rules/valid-typeof"
      },
      schema: [
        {
          type: "object",
          properties: {
            requireStringLiterals: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      messages: {
        invalidValue: "Invalid typeof comparison value.",
        notString: "Typeof comparisons should be to string literals."
      }
    },
    create(context4) {
      const VALID_TYPES = ["symbol", "undefined", "object", "boolean", "number", "string", "function", "bigint"], OPERATORS = ["==", "===", "!=", "!=="];
      const requireStringLiterals = context4.options[0] && context4.options[0].requireStringLiterals;
      function isTypeofExpression(node) {
        return node.type === "UnaryExpression" && node.operator === "typeof";
      }
      return {
        UnaryExpression(node) {
          if (isTypeofExpression(node)) {
            const parent = context4.getAncestors().pop();
            if (parent.type === "BinaryExpression" && OPERATORS.indexOf(parent.operator) !== -1) {
              const sibling = parent.left === node ? parent.right : parent.left;
              if (sibling.type === "Literal" || sibling.type === "TemplateLiteral" && !sibling.expressions.length) {
                const value = sibling.type === "Literal" ? sibling.value : sibling.quasis[0].value.cooked;
                if (VALID_TYPES.indexOf(value) === -1) {
                  context4.report({node: sibling, messageId: "invalidValue"});
                }
              } else if (requireStringLiterals && !isTypeofExpression(sibling)) {
                context4.report({node: sibling, messageId: "notString"});
              }
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/vars-on-top.js
var require_vars_on_top = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: "require `var` declarations be placed at the top of their containing scope",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/vars-on-top"
      },
      schema: [],
      messages: {
        top: "All 'var' declarations must be at the top of the function scope."
      }
    },
    create(context4) {
      function looksLikeDirective(node) {
        return node.type === "ExpressionStatement" && node.expression.type === "Literal" && typeof node.expression.value === "string";
      }
      function looksLikeImport(node) {
        return node.type === "ImportDeclaration" || node.type === "ImportSpecifier" || node.type === "ImportDefaultSpecifier" || node.type === "ImportNamespaceSpecifier";
      }
      function isVariableDeclaration(node) {
        return node.type === "VariableDeclaration" || node.type === "ExportNamedDeclaration" && node.declaration && node.declaration.type === "VariableDeclaration";
      }
      function isVarOnTop(node, statements) {
        const l = statements.length;
        let i = 0;
        for (; i < l; ++i) {
          if (!looksLikeDirective(statements[i]) && !looksLikeImport(statements[i])) {
            break;
          }
        }
        for (; i < l; ++i) {
          if (!isVariableDeclaration(statements[i])) {
            return false;
          }
          if (statements[i] === node) {
            return true;
          }
        }
        return false;
      }
      function globalVarCheck(node, parent) {
        if (!isVarOnTop(node, parent.body)) {
          context4.report({node, messageId: "top"});
        }
      }
      function blockScopeVarCheck(node, parent, grandParent) {
        if (!(/Function/u.test(grandParent.type) && parent.type === "BlockStatement" && isVarOnTop(node, parent.body))) {
          context4.report({node, messageId: "top"});
        }
      }
      return {
        "VariableDeclaration[kind='var']"(node) {
          if (node.parent.type === "ExportNamedDeclaration") {
            globalVarCheck(node.parent, node.parent.parent);
          } else if (node.parent.type === "Program") {
            globalVarCheck(node, node.parent);
          } else {
            blockScopeVarCheck(node, node.parent, node.parent.parent);
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/wrap-iife.js
var require_wrap_iife = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  var eslintUtils = require_eslint_utils();
  function isCalleeOfNewExpression(node) {
    const maybeCallee = node.parent.type === "ChainExpression" ? node.parent : node;
    return maybeCallee.parent.type === "NewExpression" && maybeCallee.parent.callee === maybeCallee;
  }
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require parentheses around immediate `function` invocations",
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/wrap-iife"
      },
      schema: [
        {
          enum: ["outside", "inside", "any"]
        },
        {
          type: "object",
          properties: {
            functionPrototypeMethods: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        wrapInvocation: "Wrap an immediate function invocation in parentheses.",
        wrapExpression: "Wrap only the function expression in parens.",
        moveInvocation: "Move the invocation into the parens that contain the function."
      }
    },
    create(context4) {
      const style = context4.options[0] || "outside";
      const includeFunctionPrototypeMethods = context4.options[1] && context4.options[1].functionPrototypeMethods;
      const sourceCode = context4.getSourceCode();
      function isWrappedInAnyParens(node) {
        return astUtils.isParenthesised(sourceCode, node);
      }
      function isWrappedInGroupingParens(node) {
        return eslintUtils.isParenthesized(1, node, sourceCode);
      }
      function getFunctionNodeFromIIFE(node) {
        const callee = astUtils.skipChainExpression(node.callee);
        if (callee.type === "FunctionExpression") {
          return callee;
        }
        if (includeFunctionPrototypeMethods && callee.type === "MemberExpression" && callee.object.type === "FunctionExpression" && (astUtils.getStaticPropertyName(callee) === "call" || astUtils.getStaticPropertyName(callee) === "apply")) {
          return callee.object;
        }
        return null;
      }
      return {
        CallExpression(node) {
          const innerNode = getFunctionNodeFromIIFE(node);
          if (!innerNode) {
            return;
          }
          const isCallExpressionWrapped = isWrappedInAnyParens(node), isFunctionExpressionWrapped = isWrappedInAnyParens(innerNode);
          if (!isCallExpressionWrapped && !isFunctionExpressionWrapped) {
            context4.report({
              node,
              messageId: "wrapInvocation",
              fix(fixer) {
                const nodeToSurround = style === "inside" ? innerNode : node;
                return fixer.replaceText(nodeToSurround, `(${sourceCode.getText(nodeToSurround)})`);
              }
            });
          } else if (style === "inside" && !isFunctionExpressionWrapped) {
            context4.report({
              node,
              messageId: "wrapExpression",
              fix(fixer) {
                if (isWrappedInGroupingParens(node) && !isCalleeOfNewExpression(node)) {
                  const parenAfter = sourceCode.getTokenAfter(node);
                  return fixer.replaceTextRange([innerNode.range[1], parenAfter.range[1]], `)${sourceCode.getText().slice(innerNode.range[1], parenAfter.range[0])}`);
                }
                return fixer.replaceText(innerNode, `(${sourceCode.getText(innerNode)})`);
              }
            });
          } else if (style === "outside" && !isCallExpressionWrapped) {
            context4.report({
              node,
              messageId: "moveInvocation",
              fix(fixer) {
                const parenAfter = sourceCode.getTokenAfter(innerNode);
                return fixer.replaceTextRange([parenAfter.range[0], node.range[1]], `${sourceCode.getText().slice(parenAfter.range[1], node.range[1])})`);
              }
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/wrap-regex.js
var require_wrap_regex = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require parenthesis around regex literals",
        category: "Stylistic Issues",
        recommended: false,
        url: "https://eslint.org/docs/rules/wrap-regex"
      },
      schema: [],
      fixable: "code",
      messages: {
        requireParens: "Wrap the regexp literal in parens to disambiguate the slash."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      return {
        Literal(node) {
          const token = sourceCode.getFirstToken(node), nodeType = token.type;
          if (nodeType === "RegularExpression") {
            const beforeToken = sourceCode.getTokenBefore(node);
            const afterToken = sourceCode.getTokenAfter(node);
            const ancestors = context4.getAncestors();
            const grandparent = ancestors[ancestors.length - 1];
            if (grandparent.type === "MemberExpression" && grandparent.object === node && !(beforeToken && beforeToken.value === "(" && afterToken && afterToken.value === ")")) {
              context4.report({
                node,
                messageId: "requireParens",
                fix: (fixer) => fixer.replaceText(node, `(${sourceCode.getText(node)})`)
              });
            }
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/yield-star-spacing.js
var require_yield_star_spacing = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    meta: {
      type: "layout",
      docs: {
        description: "require or disallow spacing around the `*` in `yield*` expressions",
        category: "ECMAScript 6",
        recommended: false,
        url: "https://eslint.org/docs/rules/yield-star-spacing"
      },
      fixable: "whitespace",
      schema: [
        {
          oneOf: [
            {
              enum: ["before", "after", "both", "neither"]
            },
            {
              type: "object",
              properties: {
                before: {type: "boolean"},
                after: {type: "boolean"}
              },
              additionalProperties: false
            }
          ]
        }
      ],
      messages: {
        missingBefore: "Missing space before *.",
        missingAfter: "Missing space after *.",
        unexpectedBefore: "Unexpected space before *.",
        unexpectedAfter: "Unexpected space after *."
      }
    },
    create(context4) {
      const sourceCode = context4.getSourceCode();
      const mode = function(option) {
        if (!option || typeof option === "string") {
          return {
            before: {before: true, after: false},
            after: {before: false, after: true},
            both: {before: true, after: true},
            neither: {before: false, after: false}
          }[option || "after"];
        }
        return option;
      }(context4.options[0]);
      function checkSpacing(side, leftToken, rightToken) {
        if (sourceCode.isSpaceBetweenTokens(leftToken, rightToken) !== mode[side]) {
          const after = leftToken.value === "*";
          const spaceRequired = mode[side];
          const node = after ? leftToken : rightToken;
          let messageId = "";
          if (spaceRequired) {
            messageId = side === "before" ? "missingBefore" : "missingAfter";
          } else {
            messageId = side === "before" ? "unexpectedBefore" : "unexpectedAfter";
          }
          context4.report({
            node,
            messageId,
            fix(fixer) {
              if (spaceRequired) {
                if (after) {
                  return fixer.insertTextAfter(node, " ");
                }
                return fixer.insertTextBefore(node, " ");
              }
              return fixer.removeRange([leftToken.range[1], rightToken.range[0]]);
            }
          });
        }
      }
      function checkExpression(node) {
        if (!node.delegate) {
          return;
        }
        const tokens = sourceCode.getFirstTokens(node, 3);
        const yieldToken = tokens[0];
        const starToken = tokens[1];
        const nextToken = tokens[2];
        checkSpacing("before", yieldToken, starToken);
        checkSpacing("after", starToken, nextToken);
      }
      return {
        YieldExpression: checkExpression
      };
    }
  };
});

// node_modules/eslint/lib/rules/yoda.js
var require_yoda = __commonJS((exports2, module2) => {
  "use strict";
  var astUtils = require_ast_utils2();
  function isComparisonOperator(operator) {
    return /^(==|===|!=|!==|<|>|<=|>=)$/u.test(operator);
  }
  function isEqualityOperator(operator) {
    return /^(==|===)$/u.test(operator);
  }
  function isRangeTestOperator(operator) {
    return ["<", "<="].indexOf(operator) >= 0;
  }
  function isNegativeNumericLiteral(node) {
    return node.type === "UnaryExpression" && node.operator === "-" && node.prefix && astUtils.isNumericLiteral(node.argument);
  }
  function isStaticTemplateLiteral(node) {
    return node.type === "TemplateLiteral" && node.expressions.length === 0;
  }
  function looksLikeLiteral(node) {
    return isNegativeNumericLiteral(node) || isStaticTemplateLiteral(node);
  }
  function getNormalizedLiteral(node) {
    if (node.type === "Literal") {
      return node;
    }
    if (isNegativeNumericLiteral(node)) {
      return {
        type: "Literal",
        value: -node.argument.value,
        raw: `-${node.argument.value}`
      };
    }
    if (isStaticTemplateLiteral(node)) {
      return {
        type: "Literal",
        value: node.quasis[0].value.cooked,
        raw: node.quasis[0].value.raw
      };
    }
    return null;
  }
  module2.exports = {
    meta: {
      type: "suggestion",
      docs: {
        description: 'require or disallow "Yoda" conditions',
        category: "Best Practices",
        recommended: false,
        url: "https://eslint.org/docs/rules/yoda"
      },
      schema: [
        {
          enum: ["always", "never"]
        },
        {
          type: "object",
          properties: {
            exceptRange: {
              type: "boolean",
              default: false
            },
            onlyEquality: {
              type: "boolean",
              default: false
            }
          },
          additionalProperties: false
        }
      ],
      fixable: "code",
      messages: {
        expected: "Expected literal to be on the {{expectedSide}} side of {{operator}}."
      }
    },
    create(context4) {
      const always = context4.options[0] === "always";
      const exceptRange = context4.options[1] && context4.options[1].exceptRange;
      const onlyEquality = context4.options[1] && context4.options[1].onlyEquality;
      const sourceCode = context4.getSourceCode();
      function isRangeTest(node) {
        const left = node.left, right = node.right;
        function isBetweenTest() {
          if (node.operator === "&&" && astUtils.isSameReference(left.right, right.left)) {
            const leftLiteral = getNormalizedLiteral(left.left);
            const rightLiteral = getNormalizedLiteral(right.right);
            if (leftLiteral === null && rightLiteral === null) {
              return false;
            }
            if (rightLiteral === null || leftLiteral === null) {
              return true;
            }
            if (leftLiteral.value <= rightLiteral.value) {
              return true;
            }
          }
          return false;
        }
        function isOutsideTest() {
          if (node.operator === "||" && astUtils.isSameReference(left.left, right.right)) {
            const leftLiteral = getNormalizedLiteral(left.right);
            const rightLiteral = getNormalizedLiteral(right.left);
            if (leftLiteral === null && rightLiteral === null) {
              return false;
            }
            if (rightLiteral === null || leftLiteral === null) {
              return true;
            }
            if (leftLiteral.value <= rightLiteral.value) {
              return true;
            }
          }
          return false;
        }
        function isParenWrapped() {
          return astUtils.isParenthesised(sourceCode, node);
        }
        return node.type === "LogicalExpression" && left.type === "BinaryExpression" && right.type === "BinaryExpression" && isRangeTestOperator(left.operator) && isRangeTestOperator(right.operator) && (isBetweenTest() || isOutsideTest()) && isParenWrapped();
      }
      const OPERATOR_FLIP_MAP = {
        "===": "===",
        "!==": "!==",
        "==": "==",
        "!=": "!=",
        "<": ">",
        ">": "<",
        "<=": ">=",
        ">=": "<="
      };
      function getFlippedString(node) {
        const operatorToken = sourceCode.getFirstTokenBetween(node.left, node.right, (token) => token.value === node.operator);
        const lastLeftToken = sourceCode.getTokenBefore(operatorToken);
        const firstRightToken = sourceCode.getTokenAfter(operatorToken);
        const source = sourceCode.getText();
        const leftText = source.slice(node.range[0], lastLeftToken.range[1]);
        const textBeforeOperator = source.slice(lastLeftToken.range[1], operatorToken.range[0]);
        const textAfterOperator = source.slice(operatorToken.range[1], firstRightToken.range[0]);
        const rightText = source.slice(firstRightToken.range[0], node.range[1]);
        const tokenBefore = sourceCode.getTokenBefore(node);
        const tokenAfter = sourceCode.getTokenAfter(node);
        let prefix = "";
        let suffix = "";
        if (tokenBefore && tokenBefore.range[1] === node.range[0] && !astUtils.canTokensBeAdjacent(tokenBefore, firstRightToken)) {
          prefix = " ";
        }
        if (tokenAfter && node.range[1] === tokenAfter.range[0] && !astUtils.canTokensBeAdjacent(lastLeftToken, tokenAfter)) {
          suffix = " ";
        }
        return prefix + rightText + textBeforeOperator + OPERATOR_FLIP_MAP[operatorToken.value] + textAfterOperator + leftText + suffix;
      }
      return {
        BinaryExpression(node) {
          const expectedLiteral = always ? node.left : node.right;
          const expectedNonLiteral = always ? node.right : node.left;
          if ((expectedNonLiteral.type === "Literal" || looksLikeLiteral(expectedNonLiteral)) && !(expectedLiteral.type === "Literal" || looksLikeLiteral(expectedLiteral)) && !(!isEqualityOperator(node.operator) && onlyEquality) && isComparisonOperator(node.operator) && !(exceptRange && isRangeTest(context4.getAncestors().pop()))) {
            context4.report({
              node,
              messageId: "expected",
              data: {
                operator: node.operator,
                expectedSide: always ? "left" : "right"
              },
              fix: (fixer) => fixer.replaceText(node, getFlippedString(node))
            });
          }
        }
      };
    }
  };
});

// node_modules/eslint/lib/rules/index.js
var require_rules2 = __commonJS((exports2, module2) => {
  "use strict";
  var {LazyLoadingRuleMap} = require_lazy_loading_rule_map();
  module2.exports = new LazyLoadingRuleMap(Object.entries({
    "accessor-pairs": () => require_accessor_pairs(),
    "array-bracket-newline": () => require_array_bracket_newline(),
    "array-bracket-spacing": () => require_array_bracket_spacing(),
    "array-callback-return": () => require_array_callback_return(),
    "array-element-newline": () => require_array_element_newline(),
    "arrow-body-style": () => require_arrow_body_style(),
    "arrow-parens": () => require_arrow_parens(),
    "arrow-spacing": () => require_arrow_spacing(),
    "block-scoped-var": () => require_block_scoped_var(),
    "block-spacing": () => require_block_spacing(),
    "brace-style": () => require_brace_style(),
    "callback-return": () => require_callback_return(),
    camelcase: () => require_camelcase(),
    "capitalized-comments": () => require_capitalized_comments(),
    "class-methods-use-this": () => require_class_methods_use_this(),
    "comma-dangle": () => require_comma_dangle(),
    "comma-spacing": () => require_comma_spacing(),
    "comma-style": () => require_comma_style(),
    complexity: () => require_complexity(),
    "computed-property-spacing": () => require_computed_property_spacing(),
    "consistent-return": () => require_consistent_return(),
    "consistent-this": () => require_consistent_this(),
    "constructor-super": () => require_constructor_super(),
    curly: () => require_curly(),
    "default-case": () => require_default_case(),
    "default-case-last": () => require_default_case_last(),
    "default-param-last": () => require_default_param_last(),
    "dot-location": () => require_dot_location(),
    "dot-notation": () => require_dot_notation(),
    "eol-last": () => require_eol_last(),
    eqeqeq: () => require_eqeqeq(),
    "for-direction": () => require_for_direction(),
    "func-call-spacing": () => require_func_call_spacing(),
    "func-name-matching": () => require_func_name_matching(),
    "func-names": () => require_func_names(),
    "func-style": () => require_func_style(),
    "function-call-argument-newline": () => require_function_call_argument_newline(),
    "function-paren-newline": () => require_function_paren_newline(),
    "generator-star-spacing": () => require_generator_star_spacing(),
    "getter-return": () => require_getter_return(),
    "global-require": () => require_global_require(),
    "grouped-accessor-pairs": () => require_grouped_accessor_pairs(),
    "guard-for-in": () => require_guard_for_in(),
    "handle-callback-err": () => require_handle_callback_err(),
    "id-blacklist": () => require_id_blacklist(),
    "id-denylist": () => require_id_denylist(),
    "id-length": () => require_id_length(),
    "id-match": () => require_id_match(),
    "implicit-arrow-linebreak": () => require_implicit_arrow_linebreak(),
    indent: () => require_indent(),
    "indent-legacy": () => require_indent_legacy(),
    "init-declarations": () => require_init_declarations(),
    "jsx-quotes": () => require_jsx_quotes(),
    "key-spacing": () => require_key_spacing(),
    "keyword-spacing": () => require_keyword_spacing(),
    "line-comment-position": () => require_line_comment_position(),
    "linebreak-style": () => require_linebreak_style(),
    "lines-around-comment": () => require_lines_around_comment(),
    "lines-around-directive": () => require_lines_around_directive(),
    "lines-between-class-members": () => require_lines_between_class_members(),
    "max-classes-per-file": () => require_max_classes_per_file(),
    "max-depth": () => require_max_depth(),
    "max-len": () => require_max_len(),
    "max-lines": () => require_max_lines(),
    "max-lines-per-function": () => require_max_lines_per_function(),
    "max-nested-callbacks": () => require_max_nested_callbacks(),
    "max-params": () => require_max_params(),
    "max-statements": () => require_max_statements(),
    "max-statements-per-line": () => require_max_statements_per_line(),
    "multiline-comment-style": () => require_multiline_comment_style(),
    "multiline-ternary": () => require_multiline_ternary(),
    "new-cap": () => require_new_cap(),
    "new-parens": () => require_new_parens(),
    "newline-after-var": () => require_newline_after_var(),
    "newline-before-return": () => require_newline_before_return(),
    "newline-per-chained-call": () => require_newline_per_chained_call(),
    "no-alert": () => require_no_alert(),
    "no-array-constructor": () => require_no_array_constructor(),
    "no-async-promise-executor": () => require_no_async_promise_executor(),
    "no-await-in-loop": () => require_no_await_in_loop(),
    "no-bitwise": () => require_no_bitwise(),
    "no-buffer-constructor": () => require_no_buffer_constructor(),
    "no-caller": () => require_no_caller(),
    "no-case-declarations": () => require_no_case_declarations(),
    "no-catch-shadow": () => require_no_catch_shadow(),
    "no-class-assign": () => require_no_class_assign(),
    "no-compare-neg-zero": () => require_no_compare_neg_zero(),
    "no-cond-assign": () => require_no_cond_assign(),
    "no-confusing-arrow": () => require_no_confusing_arrow(),
    "no-console": () => require_no_console(),
    "no-const-assign": () => require_no_const_assign(),
    "no-constant-condition": () => require_no_constant_condition(),
    "no-constructor-return": () => require_no_constructor_return(),
    "no-continue": () => require_no_continue(),
    "no-control-regex": () => require_no_control_regex(),
    "no-debugger": () => require_no_debugger(),
    "no-delete-var": () => require_no_delete_var(),
    "no-div-regex": () => require_no_div_regex(),
    "no-dupe-args": () => require_no_dupe_args(),
    "no-dupe-class-members": () => require_no_dupe_class_members(),
    "no-dupe-else-if": () => require_no_dupe_else_if(),
    "no-dupe-keys": () => require_no_dupe_keys(),
    "no-duplicate-case": () => require_no_duplicate_case(),
    "no-duplicate-imports": () => require_no_duplicate_imports(),
    "no-else-return": () => require_no_else_return(),
    "no-empty": () => require_no_empty(),
    "no-empty-character-class": () => require_no_empty_character_class(),
    "no-empty-function": () => require_no_empty_function(),
    "no-empty-pattern": () => require_no_empty_pattern(),
    "no-eq-null": () => require_no_eq_null(),
    "no-eval": () => require_no_eval(),
    "no-ex-assign": () => require_no_ex_assign(),
    "no-extend-native": () => require_no_extend_native(),
    "no-extra-bind": () => require_no_extra_bind(),
    "no-extra-boolean-cast": () => require_no_extra_boolean_cast(),
    "no-extra-label": () => require_no_extra_label(),
    "no-extra-parens": () => require_no_extra_parens(),
    "no-extra-semi": () => require_no_extra_semi(),
    "no-fallthrough": () => require_no_fallthrough(),
    "no-floating-decimal": () => require_no_floating_decimal(),
    "no-func-assign": () => require_no_func_assign(),
    "no-global-assign": () => require_no_global_assign(),
    "no-implicit-coercion": () => require_no_implicit_coercion(),
    "no-implicit-globals": () => require_no_implicit_globals(),
    "no-implied-eval": () => require_no_implied_eval(),
    "no-import-assign": () => require_no_import_assign(),
    "no-inline-comments": () => require_no_inline_comments(),
    "no-inner-declarations": () => require_no_inner_declarations(),
    "no-invalid-regexp": () => require_no_invalid_regexp(),
    "no-invalid-this": () => require_no_invalid_this(),
    "no-irregular-whitespace": () => require_no_irregular_whitespace(),
    "no-iterator": () => require_no_iterator(),
    "no-label-var": () => require_no_label_var(),
    "no-labels": () => require_no_labels(),
    "no-lone-blocks": () => require_no_lone_blocks(),
    "no-lonely-if": () => require_no_lonely_if(),
    "no-loop-func": () => require_no_loop_func(),
    "no-loss-of-precision": () => require_no_loss_of_precision(),
    "no-magic-numbers": () => require_no_magic_numbers(),
    "no-misleading-character-class": () => require_no_misleading_character_class(),
    "no-mixed-operators": () => require_no_mixed_operators(),
    "no-mixed-requires": () => require_no_mixed_requires(),
    "no-mixed-spaces-and-tabs": () => require_no_mixed_spaces_and_tabs(),
    "no-multi-assign": () => require_no_multi_assign(),
    "no-multi-spaces": () => require_no_multi_spaces(),
    "no-multi-str": () => require_no_multi_str(),
    "no-multiple-empty-lines": () => require_no_multiple_empty_lines(),
    "no-native-reassign": () => require_no_native_reassign(),
    "no-negated-condition": () => require_no_negated_condition(),
    "no-negated-in-lhs": () => require_no_negated_in_lhs(),
    "no-nested-ternary": () => require_no_nested_ternary(),
    "no-new": () => require_no_new(),
    "no-new-func": () => require_no_new_func(),
    "no-new-object": () => require_no_new_object(),
    "no-new-require": () => require_no_new_require(),
    "no-new-symbol": () => require_no_new_symbol(),
    "no-new-wrappers": () => require_no_new_wrappers(),
    "no-nonoctal-decimal-escape": () => require_no_nonoctal_decimal_escape(),
    "no-obj-calls": () => require_no_obj_calls(),
    "no-octal": () => require_no_octal(),
    "no-octal-escape": () => require_no_octal_escape(),
    "no-param-reassign": () => require_no_param_reassign(),
    "no-path-concat": () => require_no_path_concat(),
    "no-plusplus": () => require_no_plusplus(),
    "no-process-env": () => require_no_process_env(),
    "no-process-exit": () => require_no_process_exit(),
    "no-promise-executor-return": () => require_no_promise_executor_return(),
    "no-proto": () => require_no_proto(),
    "no-prototype-builtins": () => require_no_prototype_builtins(),
    "no-redeclare": () => require_no_redeclare(),
    "no-regex-spaces": () => require_no_regex_spaces(),
    "no-restricted-exports": () => require_no_restricted_exports(),
    "no-restricted-globals": () => require_no_restricted_globals(),
    "no-restricted-imports": () => require_no_restricted_imports(),
    "no-restricted-modules": () => require_no_restricted_modules(),
    "no-restricted-properties": () => require_no_restricted_properties(),
    "no-restricted-syntax": () => require_no_restricted_syntax(),
    "no-return-assign": () => require_no_return_assign(),
    "no-return-await": () => require_no_return_await(),
    "no-script-url": () => require_no_script_url(),
    "no-self-assign": () => require_no_self_assign(),
    "no-self-compare": () => require_no_self_compare(),
    "no-sequences": () => require_no_sequences(),
    "no-setter-return": () => require_no_setter_return(),
    "no-shadow": () => require_no_shadow(),
    "no-shadow-restricted-names": () => require_no_shadow_restricted_names(),
    "no-spaced-func": () => require_no_spaced_func(),
    "no-sparse-arrays": () => require_no_sparse_arrays(),
    "no-sync": () => require_no_sync(),
    "no-tabs": () => require_no_tabs(),
    "no-template-curly-in-string": () => require_no_template_curly_in_string(),
    "no-ternary": () => require_no_ternary(),
    "no-this-before-super": () => require_no_this_before_super(),
    "no-throw-literal": () => require_no_throw_literal(),
    "no-trailing-spaces": () => require_no_trailing_spaces(),
    "no-undef": () => require_no_undef(),
    "no-undef-init": () => require_no_undef_init(),
    "no-undefined": () => require_no_undefined(),
    "no-underscore-dangle": () => require_no_underscore_dangle(),
    "no-unexpected-multiline": () => require_no_unexpected_multiline(),
    "no-unmodified-loop-condition": () => require_no_unmodified_loop_condition(),
    "no-unneeded-ternary": () => require_no_unneeded_ternary(),
    "no-unreachable": () => require_no_unreachable(),
    "no-unreachable-loop": () => require_no_unreachable_loop(),
    "no-unsafe-finally": () => require_no_unsafe_finally(),
    "no-unsafe-negation": () => require_no_unsafe_negation(),
    "no-unsafe-optional-chaining": () => require_no_unsafe_optional_chaining(),
    "no-unused-expressions": () => require_no_unused_expressions(),
    "no-unused-labels": () => require_no_unused_labels(),
    "no-unused-vars": () => require_no_unused_vars(),
    "no-use-before-define": () => require_no_use_before_define(),
    "no-useless-backreference": () => require_no_useless_backreference(),
    "no-useless-call": () => require_no_useless_call(),
    "no-useless-catch": () => require_no_useless_catch(),
    "no-useless-computed-key": () => require_no_useless_computed_key(),
    "no-useless-concat": () => require_no_useless_concat(),
    "no-useless-constructor": () => require_no_useless_constructor(),
    "no-useless-escape": () => require_no_useless_escape(),
    "no-useless-rename": () => require_no_useless_rename(),
    "no-useless-return": () => require_no_useless_return(),
    "no-var": () => require_no_var(),
    "no-void": () => require_no_void(),
    "no-warning-comments": () => require_no_warning_comments(),
    "no-whitespace-before-property": () => require_no_whitespace_before_property(),
    "no-with": () => require_no_with(),
    "nonblock-statement-body-position": () => require_nonblock_statement_body_position(),
    "object-curly-newline": () => require_object_curly_newline(),
    "object-curly-spacing": () => require_object_curly_spacing(),
    "object-property-newline": () => require_object_property_newline(),
    "object-shorthand": () => require_object_shorthand(),
    "one-var": () => require_one_var(),
    "one-var-declaration-per-line": () => require_one_var_declaration_per_line(),
    "operator-assignment": () => require_operator_assignment(),
    "operator-linebreak": () => require_operator_linebreak(),
    "padded-blocks": () => require_padded_blocks(),
    "padding-line-between-statements": () => require_padding_line_between_statements(),
    "prefer-arrow-callback": () => require_prefer_arrow_callback(),
    "prefer-const": () => require_prefer_const(),
    "prefer-destructuring": () => require_prefer_destructuring(),
    "prefer-exponentiation-operator": () => require_prefer_exponentiation_operator(),
    "prefer-named-capture-group": () => require_prefer_named_capture_group(),
    "prefer-numeric-literals": () => require_prefer_numeric_literals(),
    "prefer-object-spread": () => require_prefer_object_spread(),
    "prefer-promise-reject-errors": () => require_prefer_promise_reject_errors(),
    "prefer-reflect": () => require_prefer_reflect(),
    "prefer-regex-literals": () => require_prefer_regex_literals(),
    "prefer-rest-params": () => require_prefer_rest_params(),
    "prefer-spread": () => require_prefer_spread(),
    "prefer-template": () => require_prefer_template(),
    "quote-props": () => require_quote_props(),
    quotes: () => require_quotes(),
    radix: () => require_radix(),
    "require-atomic-updates": () => require_require_atomic_updates(),
    "require-await": () => require_require_await(),
    "require-jsdoc": () => require_require_jsdoc(),
    "require-unicode-regexp": () => require_require_unicode_regexp(),
    "require-yield": () => require_require_yield(),
    "rest-spread-spacing": () => require_rest_spread_spacing(),
    semi: () => require_semi(),
    "semi-spacing": () => require_semi_spacing(),
    "semi-style": () => require_semi_style(),
    "sort-imports": () => require_sort_imports(),
    "sort-keys": () => require_sort_keys(),
    "sort-vars": () => require_sort_vars(),
    "space-before-blocks": () => require_space_before_blocks(),
    "space-before-function-paren": () => require_space_before_function_paren(),
    "space-in-parens": () => require_space_in_parens(),
    "space-infix-ops": () => require_space_infix_ops(),
    "space-unary-ops": () => require_space_unary_ops(),
    "spaced-comment": () => require_spaced_comment(),
    strict: () => require_strict(),
    "switch-colon-spacing": () => require_switch_colon_spacing(),
    "symbol-description": () => require_symbol_description(),
    "template-curly-spacing": () => require_template_curly_spacing(),
    "template-tag-spacing": () => require_template_tag_spacing(),
    "unicode-bom": () => require_unicode_bom(),
    "use-isnan": () => require_use_isnan(),
    "valid-jsdoc": () => require_valid_jsdoc(),
    "valid-typeof": () => require_valid_typeof(),
    "vars-on-top": () => require_vars_on_top(),
    "wrap-iife": () => require_wrap_iife(),
    "wrap-regex": () => require_wrap_regex(),
    "yield-star-spacing": () => require_yield_star_spacing(),
    yoda: () => require_yoda()
  }));
});

// node_modules/eslint/lib/linter/rules.js
var require_rules3 = __commonJS((exports2, module2) => {
  "use strict";
  var builtInRules = require_rules2();
  function normalizeRule(rule) {
    return typeof rule === "function" ? Object.assign({create: rule}, rule) : rule;
  }
  var Rules = class {
    constructor() {
      this._rules = Object.create(null);
    }
    define(ruleId, ruleModule) {
      this._rules[ruleId] = normalizeRule(ruleModule);
    }
    get(ruleId) {
      if (typeof this._rules[ruleId] === "string") {
        this.define(ruleId, require(this._rules[ruleId]));
      }
      if (this._rules[ruleId]) {
        return this._rules[ruleId];
      }
      if (builtInRules.has(ruleId)) {
        return builtInRules.get(ruleId);
      }
      return null;
    }
    *[Symbol.iterator]() {
      yield* builtInRules;
      for (const ruleId of Object.keys(this._rules)) {
        yield [ruleId, this.get(ruleId)];
      }
    }
  };
  module2.exports = Rules;
});

// node_modules/eslint/lib/linter/safe-emitter.js
var require_safe_emitter = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = () => {
    const listeners = Object.create(null);
    return Object.freeze({
      on(eventName, listener) {
        if (eventName in listeners) {
          listeners[eventName].push(listener);
        } else {
          listeners[eventName] = [listener];
        }
      },
      emit(eventName, ...args) {
        if (eventName in listeners) {
          listeners[eventName].forEach((listener) => listener(...args));
        }
      },
      eventNames() {
        return Object.keys(listeners);
      }
    });
  };
});

// node_modules/eslint/lib/linter/source-code-fixer.js
var require_source_code_fixer = __commonJS((exports2, module2) => {
  "use strict";
  var debug5 = require_src()("eslint:source-code-fixer");
  var BOM = "\uFEFF";
  function compareMessagesByFixRange(a, b) {
    return a.fix.range[0] - b.fix.range[0] || a.fix.range[1] - b.fix.range[1];
  }
  function compareMessagesByLocation(a, b) {
    return a.line - b.line || a.column - b.column;
  }
  function SourceCodeFixer() {
    Object.freeze(this);
  }
  SourceCodeFixer.applyFixes = function(sourceText, messages, shouldFix) {
    debug5("Applying fixes");
    if (shouldFix === false) {
      debug5("shouldFix parameter was false, not attempting fixes");
      return {
        fixed: false,
        messages,
        output: sourceText
      };
    }
    const remainingMessages = [], fixes = [], bom = sourceText.startsWith(BOM) ? BOM : "", text = bom ? sourceText.slice(1) : sourceText;
    let lastPos = Number.NEGATIVE_INFINITY, output = bom;
    function attemptFix(problem) {
      const fix = problem.fix;
      const start = fix.range[0];
      const end = fix.range[1];
      if (lastPos >= start || start > end) {
        remainingMessages.push(problem);
        return false;
      }
      if (start < 0 && end >= 0 || start === 0 && fix.text.startsWith(BOM)) {
        output = "";
      }
      output += text.slice(Math.max(0, lastPos), Math.max(0, start));
      output += fix.text;
      lastPos = end;
      return true;
    }
    messages.forEach((problem) => {
      if (Object.prototype.hasOwnProperty.call(problem, "fix")) {
        fixes.push(problem);
      } else {
        remainingMessages.push(problem);
      }
    });
    if (fixes.length) {
      debug5("Found fixes to apply");
      let fixesWereApplied = false;
      for (const problem of fixes.sort(compareMessagesByFixRange)) {
        if (typeof shouldFix !== "function" || shouldFix(problem)) {
          attemptFix(problem);
          fixesWereApplied = true;
        } else {
          remainingMessages.push(problem);
        }
      }
      output += text.slice(Math.max(0, lastPos));
      return {
        fixed: fixesWereApplied,
        messages: remainingMessages.sort(compareMessagesByLocation),
        output
      };
    }
    debug5("No fixes to apply");
    return {
      fixed: false,
      messages,
      output: bom + text
    };
  };
  module2.exports = SourceCodeFixer;
});

// node_modules/eslint/lib/linter/timing.js
var require_timing = __commonJS((exports2, module2) => {
  "use strict";
  function alignLeft(str, len, ch) {
    return str + new Array(len - str.length + 1).join(ch || " ");
  }
  function alignRight(str, len, ch) {
    return new Array(len - str.length + 1).join(ch || " ") + str;
  }
  var enabled = !!process.env.TIMING;
  var HEADERS = ["Rule", "Time (ms)", "Relative"];
  var ALIGN = [alignLeft, alignRight, alignRight];
  function getListSize() {
    const MINIMUM_SIZE = 10;
    if (typeof process.env.TIMING !== "string") {
      return MINIMUM_SIZE;
    }
    if (process.env.TIMING.toLowerCase() === "all") {
      return Number.POSITIVE_INFINITY;
    }
    const TIMING_ENV_VAR_AS_INTEGER = Number.parseInt(process.env.TIMING, 10);
    return TIMING_ENV_VAR_AS_INTEGER > 10 ? TIMING_ENV_VAR_AS_INTEGER : MINIMUM_SIZE;
  }
  function display(data) {
    let total = 0;
    const rows = Object.keys(data).map((key) => {
      const time = data[key];
      total += time;
      return [key, time];
    }).sort((a, b) => b[1] - a[1]).slice(0, getListSize());
    rows.forEach((row) => {
      row.push(`${(row[1] * 100 / total).toFixed(1)}%`);
      row[1] = row[1].toFixed(3);
    });
    rows.unshift(HEADERS);
    const widths = [];
    rows.forEach((row) => {
      const len = row.length;
      for (let i = 0; i < len; i++) {
        const n = row[i].length;
        if (!widths[i] || n > widths[i]) {
          widths[i] = n;
        }
      }
    });
    const table = rows.map((row) => row.map((cell, index) => ALIGN[index](cell, widths[index])).join(" | "));
    table.splice(1, 0, widths.map((width, index) => {
      const extraAlignment = index !== 0 && index !== widths.length - 1 ? 2 : 1;
      return ALIGN[index](":", width + extraAlignment, "-");
    }).join("|"));
    console.log(table.join("\n"));
  }
  module2.exports = function() {
    const data = Object.create(null);
    function time(key, fn) {
      if (typeof data[key] === "undefined") {
        data[key] = 0;
      }
      return function(...args) {
        let t = process.hrtime();
        fn(...args);
        t = process.hrtime(t);
        data[key] += t[0] * 1e3 + t[1] / 1e6;
      };
    }
    if (enabled) {
      process.on("exit", () => {
        display(data);
      });
    }
    return {
      time,
      enabled,
      getListSize
    };
  }();
});

// node_modules/eslint/conf/replacements.json
var require_replacements = __commonJS((exports2, module2) => {
  module2.exports = {
    rules: {
      "generator-star": ["generator-star-spacing"],
      "global-strict": ["strict"],
      "no-arrow-condition": ["no-confusing-arrow", "no-constant-condition"],
      "no-comma-dangle": ["comma-dangle"],
      "no-empty-class": ["no-empty-character-class"],
      "no-empty-label": ["no-labels"],
      "no-extra-strict": ["strict"],
      "no-reserved-keys": ["quote-props"],
      "no-space-before-semi": ["semi-spacing"],
      "no-wrap-func": ["no-extra-parens"],
      "space-after-function-name": ["space-before-function-paren"],
      "space-after-keywords": ["keyword-spacing"],
      "space-before-function-parentheses": ["space-before-function-paren"],
      "space-before-keywords": ["keyword-spacing"],
      "space-in-brackets": ["object-curly-spacing", "array-bracket-spacing", "computed-property-spacing"],
      "space-return-throw-case": ["keyword-spacing"],
      "space-unary-word-ops": ["space-unary-ops"],
      "spaced-line-comment": ["spaced-comment"]
    }
  };
});

// node_modules/eslint/lib/linter/linter.js
var require_linter = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var eslintScope = require_lib3();
  var evk = require_lib4();
  var espree = require("espree");
  var lodash = require_lodash();
  var BuiltInEnvironments = require_environments();
  var pkg = require_package();
  var astUtils = require_ast_utils();
  var ConfigOps = require_config_ops();
  var ConfigValidator = require_config_validator();
  var Traverser = require_traverser();
  var {SourceCode} = require_source_code2();
  var CodePathAnalyzer = require_code_path_analyzer();
  var applyDisableDirectives = require_apply_disable_directives();
  var ConfigCommentParser = require_config_comment_parser();
  var NodeEventGenerator = require_node_event_generator();
  var createReportTranslator = require_report_translator();
  var Rules = require_rules3();
  var createEmitter = require_safe_emitter();
  var SourceCodeFixer = require_source_code_fixer();
  var timing = require_timing();
  var ruleReplacements = require_replacements();
  var debug5 = require_src()("eslint:linter");
  var MAX_AUTOFIX_PASSES = 10;
  var DEFAULT_PARSER_NAME = "espree";
  var commentParser = new ConfigCommentParser();
  var DEFAULT_ERROR_LOC = {start: {line: 1, column: 0}, end: {line: 1, column: 1}};
  function addDeclaredGlobals(globalScope, configGlobals, {exportedVariables, enabledGlobals}) {
    for (const id of new Set([...Object.keys(configGlobals), ...Object.keys(enabledGlobals)])) {
      const configValue = configGlobals[id] === void 0 ? void 0 : ConfigOps.normalizeConfigGlobal(configGlobals[id]);
      const commentValue = enabledGlobals[id] && enabledGlobals[id].value;
      const value = commentValue || configValue;
      const sourceComments = enabledGlobals[id] && enabledGlobals[id].comments;
      if (value === "off") {
        continue;
      }
      let variable = globalScope.set.get(id);
      if (!variable) {
        variable = new eslintScope.Variable(id, globalScope);
        globalScope.variables.push(variable);
        globalScope.set.set(id, variable);
      }
      variable.eslintImplicitGlobalSetting = configValue;
      variable.eslintExplicitGlobal = sourceComments !== void 0;
      variable.eslintExplicitGlobalComments = sourceComments;
      variable.writeable = value === "writable";
    }
    Object.keys(exportedVariables).forEach((name) => {
      const variable = globalScope.set.get(name);
      if (variable) {
        variable.eslintUsed = true;
      }
    });
    globalScope.through = globalScope.through.filter((reference) => {
      const name = reference.identifier.name;
      const variable = globalScope.set.get(name);
      if (variable) {
        reference.resolved = variable;
        variable.references.push(reference);
        return false;
      }
      return true;
    });
  }
  function createMissingRuleMessage(ruleId) {
    return Object.prototype.hasOwnProperty.call(ruleReplacements.rules, ruleId) ? `Rule '${ruleId}' was removed and replaced by: ${ruleReplacements.rules[ruleId].join(", ")}` : `Definition for rule '${ruleId}' was not found.`;
  }
  function createLintingProblem(options) {
    const {
      ruleId = null,
      loc = DEFAULT_ERROR_LOC,
      message = createMissingRuleMessage(options.ruleId),
      severity = 2
    } = options;
    return {
      ruleId,
      message,
      line: loc.start.line,
      column: loc.start.column + 1,
      endLine: loc.end.line,
      endColumn: loc.end.column + 1,
      severity,
      nodeType: null
    };
  }
  function createDisableDirectives(options) {
    const {type, loc, value, ruleMapper} = options;
    const ruleIds = Object.keys(commentParser.parseListConfig(value));
    const directiveRules = ruleIds.length ? ruleIds : [null];
    const result = {
      directives: [],
      directiveProblems: []
    };
    for (const ruleId of directiveRules) {
      if (ruleId === null || ruleMapper(ruleId) !== null) {
        result.directives.push({type, line: loc.start.line, column: loc.start.column + 1, ruleId});
      } else {
        result.directiveProblems.push(createLintingProblem({ruleId, loc}));
      }
    }
    return result;
  }
  function stripDirectiveComment(value) {
    return value.split(/\s-{2,}\s/u)[0].trim();
  }
  function getDirectiveComments(filename, ast, ruleMapper, warnInlineConfig) {
    const configuredRules = {};
    const enabledGlobals = Object.create(null);
    const exportedVariables = {};
    const problems = [];
    const disableDirectives = [];
    const validator = new ConfigValidator({
      builtInRules: Rules
    });
    ast.comments.filter((token) => token.type !== "Shebang").forEach((comment) => {
      const trimmedCommentText = stripDirectiveComment(comment.value);
      const match = /^(eslint(?:-env|-enable|-disable(?:(?:-next)?-line)?)?|exported|globals?)(?:\s|$)/u.exec(trimmedCommentText);
      if (!match) {
        return;
      }
      const directiveText = match[1];
      const lineCommentSupported = /^eslint-disable-(next-)?line$/u.test(directiveText);
      if (comment.type === "Line" && !lineCommentSupported) {
        return;
      }
      if (warnInlineConfig) {
        const kind = comment.type === "Block" ? `/*${directiveText}*/` : `//${directiveText}`;
        problems.push(createLintingProblem({
          ruleId: null,
          message: `'${kind}' has no effect because you have 'noInlineConfig' setting in ${warnInlineConfig}.`,
          loc: comment.loc,
          severity: 1
        }));
        return;
      }
      if (lineCommentSupported && comment.loc.start.line !== comment.loc.end.line) {
        const message = `${directiveText} comment should not span multiple lines.`;
        problems.push(createLintingProblem({
          ruleId: null,
          message,
          loc: comment.loc
        }));
        return;
      }
      const directiveValue = trimmedCommentText.slice(match.index + directiveText.length);
      switch (directiveText) {
        case "eslint-disable":
        case "eslint-enable":
        case "eslint-disable-next-line":
        case "eslint-disable-line": {
          const directiveType = directiveText.slice("eslint-".length);
          const options = {type: directiveType, loc: comment.loc, value: directiveValue, ruleMapper};
          const {directives, directiveProblems} = createDisableDirectives(options);
          disableDirectives.push(...directives);
          problems.push(...directiveProblems);
          break;
        }
        case "exported":
          Object.assign(exportedVariables, commentParser.parseStringConfig(directiveValue, comment));
          break;
        case "globals":
        case "global":
          for (const [id, {value}] of Object.entries(commentParser.parseStringConfig(directiveValue, comment))) {
            let normalizedValue;
            try {
              normalizedValue = ConfigOps.normalizeConfigGlobal(value);
            } catch (err) {
              problems.push(createLintingProblem({
                ruleId: null,
                loc: comment.loc,
                message: err.message
              }));
              continue;
            }
            if (enabledGlobals[id]) {
              enabledGlobals[id].comments.push(comment);
              enabledGlobals[id].value = normalizedValue;
            } else {
              enabledGlobals[id] = {
                comments: [comment],
                value: normalizedValue
              };
            }
          }
          break;
        case "eslint": {
          const parseResult = commentParser.parseJsonConfig(directiveValue, comment.loc);
          if (parseResult.success) {
            Object.keys(parseResult.config).forEach((name) => {
              const rule = ruleMapper(name);
              const ruleValue = parseResult.config[name];
              if (rule === null) {
                problems.push(createLintingProblem({ruleId: name, loc: comment.loc}));
                return;
              }
              try {
                validator.validateRuleOptions(rule, name, ruleValue);
              } catch (err) {
                problems.push(createLintingProblem({
                  ruleId: name,
                  message: err.message,
                  loc: comment.loc
                }));
                return;
              }
              configuredRules[name] = ruleValue;
            });
          } else {
            problems.push(parseResult.error);
          }
          break;
        }
      }
    });
    return {
      configuredRules,
      enabledGlobals,
      exportedVariables,
      problems,
      disableDirectives
    };
  }
  function normalizeEcmaVersion(ecmaVersion) {
    return ecmaVersion >= 2015 ? ecmaVersion - 2009 : ecmaVersion;
  }
  var eslintEnvPattern = /\/\*\s*eslint-env\s(.+?)\*\//gu;
  function findEslintEnv(text) {
    let match, retv;
    eslintEnvPattern.lastIndex = 0;
    while ((match = eslintEnvPattern.exec(text)) !== null) {
      retv = Object.assign(retv || {}, commentParser.parseListConfig(stripDirectiveComment(match[1])));
    }
    return retv;
  }
  function normalizeFilename(filename) {
    const parts = filename.split(path3.sep);
    const index = parts.lastIndexOf("<text>");
    return index === -1 ? filename : parts.slice(index).join(path3.sep);
  }
  function normalizeVerifyOptions(providedOptions, config) {
    const disableInlineConfig = config.noInlineConfig === true;
    const ignoreInlineConfig = providedOptions.allowInlineConfig === false;
    const configNameOfNoInlineConfig = config.configNameOfNoInlineConfig ? ` (${config.configNameOfNoInlineConfig})` : "";
    let reportUnusedDisableDirectives = providedOptions.reportUnusedDisableDirectives;
    if (typeof reportUnusedDisableDirectives === "boolean") {
      reportUnusedDisableDirectives = reportUnusedDisableDirectives ? "error" : "off";
    }
    if (typeof reportUnusedDisableDirectives !== "string") {
      reportUnusedDisableDirectives = config.reportUnusedDisableDirectives ? "warn" : "off";
    }
    return {
      filename: normalizeFilename(providedOptions.filename || "<input>"),
      allowInlineConfig: !ignoreInlineConfig,
      warnInlineConfig: disableInlineConfig && !ignoreInlineConfig ? `your config${configNameOfNoInlineConfig}` : null,
      reportUnusedDisableDirectives,
      disableFixes: Boolean(providedOptions.disableFixes)
    };
  }
  function resolveParserOptions(parserName, providedOptions, enabledEnvironments) {
    const parserOptionsFromEnv = enabledEnvironments.filter((env) => env.parserOptions).reduce((parserOptions, env) => lodash.merge(parserOptions, env.parserOptions), {});
    const mergedParserOptions = lodash.merge(parserOptionsFromEnv, providedOptions || {});
    const isModule = mergedParserOptions.sourceType === "module";
    if (isModule) {
      mergedParserOptions.ecmaFeatures = Object.assign({}, mergedParserOptions.ecmaFeatures, {globalReturn: false});
    }
    mergedParserOptions.ecmaVersion = normalizeEcmaVersion(mergedParserOptions.ecmaVersion);
    return mergedParserOptions;
  }
  function resolveGlobals(providedGlobals, enabledEnvironments) {
    return Object.assign({}, ...enabledEnvironments.filter((env) => env.globals).map((env) => env.globals), providedGlobals);
  }
  function stripUnicodeBOM(text) {
    if (text.charCodeAt(0) === 65279) {
      return text.slice(1);
    }
    return text;
  }
  function getRuleOptions(ruleConfig) {
    if (Array.isArray(ruleConfig)) {
      return ruleConfig.slice(1);
    }
    return [];
  }
  function analyzeScope(ast, parserOptions, visitorKeys) {
    const ecmaFeatures = parserOptions.ecmaFeatures || {};
    const ecmaVersion = parserOptions.ecmaVersion || 5;
    return eslintScope.analyze(ast, {
      ignoreEval: true,
      nodejsScope: ecmaFeatures.globalReturn,
      impliedStrict: ecmaFeatures.impliedStrict,
      ecmaVersion,
      sourceType: parserOptions.sourceType || "script",
      childVisitorKeys: visitorKeys || evk.KEYS,
      fallback: Traverser.getKeys
    });
  }
  function parse(text, parser, providedParserOptions, filePath) {
    const textToParse = stripUnicodeBOM(text).replace(astUtils.shebangPattern, (match, captured) => `//${captured}`);
    const parserOptions = Object.assign({}, providedParserOptions, {
      loc: true,
      range: true,
      raw: true,
      tokens: true,
      comment: true,
      eslintVisitorKeys: true,
      eslintScopeManager: true,
      filePath
    });
    try {
      const parseResult = typeof parser.parseForESLint === "function" ? parser.parseForESLint(textToParse, parserOptions) : {ast: parser.parse(textToParse, parserOptions)};
      const ast = parseResult.ast;
      const parserServices = parseResult.services || {};
      const visitorKeys = parseResult.visitorKeys || evk.KEYS;
      const scopeManager = parseResult.scopeManager || analyzeScope(ast, parserOptions, visitorKeys);
      return {
        success: true,
        sourceCode: new SourceCode({
          text,
          ast,
          parserServices,
          scopeManager,
          visitorKeys
        })
      };
    } catch (ex) {
      const message = `Parsing error: ${ex.message.replace(/^line \d+:/iu, "").trim()}`;
      debug5("%s\n%s", message, ex.stack);
      return {
        success: false,
        error: {
          ruleId: null,
          fatal: true,
          severity: 2,
          message,
          line: ex.lineNumber,
          column: ex.column
        }
      };
    }
  }
  function getScope(scopeManager, currentNode) {
    const inner = currentNode.type !== "Program";
    for (let node = currentNode; node; node = node.parent) {
      const scope = scopeManager.acquire(node, inner);
      if (scope) {
        if (scope.type === "function-expression-name") {
          return scope.childScopes[0];
        }
        return scope;
      }
    }
    return scopeManager.scopes[0];
  }
  function markVariableAsUsed(scopeManager, currentNode, parserOptions, name) {
    const hasGlobalReturn = parserOptions.ecmaFeatures && parserOptions.ecmaFeatures.globalReturn;
    const specialScope = hasGlobalReturn || parserOptions.sourceType === "module";
    const currentScope = getScope(scopeManager, currentNode);
    const initialScope = currentScope.type === "global" && specialScope ? currentScope.childScopes[0] : currentScope;
    for (let scope = initialScope; scope; scope = scope.upper) {
      const variable = scope.variables.find((scopeVar) => scopeVar.name === name);
      if (variable) {
        variable.eslintUsed = true;
        return true;
      }
    }
    return false;
  }
  function createRuleListeners(rule, ruleContext) {
    try {
      return rule.create(ruleContext);
    } catch (ex) {
      ex.message = `Error while loading rule '${ruleContext.id}': ${ex.message}`;
      throw ex;
    }
  }
  function getAncestors(node) {
    const ancestorsStartingAtParent = [];
    for (let ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
      ancestorsStartingAtParent.push(ancestor);
    }
    return ancestorsStartingAtParent.reverse();
  }
  var DEPRECATED_SOURCECODE_PASSTHROUGHS = {
    getSource: "getText",
    getSourceLines: "getLines",
    getAllComments: "getAllComments",
    getNodeByRangeIndex: "getNodeByRangeIndex",
    getComments: "getComments",
    getCommentsBefore: "getCommentsBefore",
    getCommentsAfter: "getCommentsAfter",
    getCommentsInside: "getCommentsInside",
    getJSDocComment: "getJSDocComment",
    getFirstToken: "getFirstToken",
    getFirstTokens: "getFirstTokens",
    getLastToken: "getLastToken",
    getLastTokens: "getLastTokens",
    getTokenAfter: "getTokenAfter",
    getTokenBefore: "getTokenBefore",
    getTokenByRangeStart: "getTokenByRangeStart",
    getTokens: "getTokens",
    getTokensAfter: "getTokensAfter",
    getTokensBefore: "getTokensBefore",
    getTokensBetween: "getTokensBetween"
  };
  var BASE_TRAVERSAL_CONTEXT = Object.freeze(Object.keys(DEPRECATED_SOURCECODE_PASSTHROUGHS).reduce((contextInfo, methodName) => Object.assign(contextInfo, {
    [methodName](...args) {
      return this.getSourceCode()[DEPRECATED_SOURCECODE_PASSTHROUGHS[methodName]](...args);
    }
  }), {}));
  function runRules(sourceCode, configuredRules, ruleMapper, parserOptions, parserName, settings, filename, disableFixes, cwd) {
    const emitter = createEmitter();
    const nodeQueue = [];
    let currentNode = sourceCode.ast;
    Traverser.traverse(sourceCode.ast, {
      enter(node, parent) {
        node.parent = parent;
        nodeQueue.push({isEntering: true, node});
      },
      leave(node) {
        nodeQueue.push({isEntering: false, node});
      },
      visitorKeys: sourceCode.visitorKeys
    });
    const sharedTraversalContext = Object.freeze(Object.assign(Object.create(BASE_TRAVERSAL_CONTEXT), {
      getAncestors: () => getAncestors(currentNode),
      getDeclaredVariables: sourceCode.scopeManager.getDeclaredVariables.bind(sourceCode.scopeManager),
      getCwd: () => cwd,
      getFilename: () => filename,
      getScope: () => getScope(sourceCode.scopeManager, currentNode),
      getSourceCode: () => sourceCode,
      markVariableAsUsed: (name) => markVariableAsUsed(sourceCode.scopeManager, currentNode, parserOptions, name),
      parserOptions,
      parserPath: parserName,
      parserServices: sourceCode.parserServices,
      settings
    }));
    const lintingProblems = [];
    Object.keys(configuredRules).forEach((ruleId) => {
      const severity = ConfigOps.getRuleSeverity(configuredRules[ruleId]);
      if (severity === 0) {
        return;
      }
      const rule = ruleMapper(ruleId);
      if (rule === null) {
        lintingProblems.push(createLintingProblem({ruleId}));
        return;
      }
      const messageIds = rule.meta && rule.meta.messages;
      let reportTranslator = null;
      const ruleContext = Object.freeze(Object.assign(Object.create(sharedTraversalContext), {
        id: ruleId,
        options: getRuleOptions(configuredRules[ruleId]),
        report(...args) {
          if (reportTranslator === null) {
            reportTranslator = createReportTranslator({
              ruleId,
              severity,
              sourceCode,
              messageIds,
              disableFixes
            });
          }
          const problem = reportTranslator(...args);
          if (problem.fix && rule.meta && !rule.meta.fixable) {
            throw new Error("Fixable rules should export a `meta.fixable` property.");
          }
          lintingProblems.push(problem);
        }
      }));
      const ruleListeners = createRuleListeners(rule, ruleContext);
      Object.keys(ruleListeners).forEach((selector) => {
        emitter.on(selector, timing.enabled ? timing.time(ruleId, ruleListeners[selector]) : ruleListeners[selector]);
      });
    });
    const eventGenerator = nodeQueue[0].node.type === "Program" ? new CodePathAnalyzer(new NodeEventGenerator(emitter, {visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys})) : new NodeEventGenerator(emitter, {visitorKeys: sourceCode.visitorKeys, fallback: Traverser.getKeys});
    nodeQueue.forEach((traversalInfo) => {
      currentNode = traversalInfo.node;
      try {
        if (traversalInfo.isEntering) {
          eventGenerator.enterNode(currentNode);
        } else {
          eventGenerator.leaveNode(currentNode);
        }
      } catch (err) {
        err.currentNode = currentNode;
        throw err;
      }
    });
    return lintingProblems;
  }
  function ensureText(textOrSourceCode) {
    if (typeof textOrSourceCode === "object") {
      const {hasBOM, text} = textOrSourceCode;
      const bom = hasBOM ? "\uFEFF" : "";
      return bom + text;
    }
    return String(textOrSourceCode);
  }
  function getEnv(slots, envId) {
    return slots.lastConfigArray && slots.lastConfigArray.pluginEnvironments.get(envId) || BuiltInEnvironments.get(envId) || null;
  }
  function getRule(slots, ruleId) {
    return slots.lastConfigArray && slots.lastConfigArray.pluginRules.get(ruleId) || slots.ruleMap.get(ruleId);
  }
  function normalizeCwd(cwd) {
    if (cwd) {
      return cwd;
    }
    if (typeof process === "object") {
      return process.cwd();
    }
    return void 0;
  }
  var internalSlotsMap = new WeakMap();
  var Linter = class {
    constructor({cwd} = {}) {
      internalSlotsMap.set(this, {
        cwd: normalizeCwd(cwd),
        lastConfigArray: null,
        lastSourceCode: null,
        parserMap: new Map([["espree", espree]]),
        ruleMap: new Rules()
      });
      this.version = pkg.version;
    }
    static get version() {
      return pkg.version;
    }
    _verifyWithoutProcessors(textOrSourceCode, providedConfig, providedOptions) {
      const slots = internalSlotsMap.get(this);
      const config = providedConfig || {};
      const options = normalizeVerifyOptions(providedOptions, config);
      let text;
      if (typeof textOrSourceCode === "string") {
        slots.lastSourceCode = null;
        text = textOrSourceCode;
      } else {
        slots.lastSourceCode = textOrSourceCode;
        text = textOrSourceCode.text;
      }
      let parserName = DEFAULT_PARSER_NAME;
      let parser = espree;
      if (typeof config.parser === "object" && config.parser !== null) {
        parserName = config.parser.filePath;
        parser = config.parser.definition;
      } else if (typeof config.parser === "string") {
        if (!slots.parserMap.has(config.parser)) {
          return [{
            ruleId: null,
            fatal: true,
            severity: 2,
            message: `Configured parser '${config.parser}' was not found.`,
            line: 0,
            column: 0
          }];
        }
        parserName = config.parser;
        parser = slots.parserMap.get(config.parser);
      }
      const envInFile = options.allowInlineConfig && !options.warnInlineConfig ? findEslintEnv(text) : {};
      const resolvedEnvConfig = Object.assign({builtin: true}, config.env, envInFile);
      const enabledEnvs = Object.keys(resolvedEnvConfig).filter((envName) => resolvedEnvConfig[envName]).map((envName) => getEnv(slots, envName)).filter((env) => env);
      const parserOptions = resolveParserOptions(parserName, config.parserOptions || {}, enabledEnvs);
      const configuredGlobals = resolveGlobals(config.globals || {}, enabledEnvs);
      const settings = config.settings || {};
      if (!slots.lastSourceCode) {
        const parseResult = parse(text, parser, parserOptions, options.filename);
        if (!parseResult.success) {
          return [parseResult.error];
        }
        slots.lastSourceCode = parseResult.sourceCode;
      } else {
        if (!slots.lastSourceCode.scopeManager) {
          slots.lastSourceCode = new SourceCode({
            text: slots.lastSourceCode.text,
            ast: slots.lastSourceCode.ast,
            parserServices: slots.lastSourceCode.parserServices,
            visitorKeys: slots.lastSourceCode.visitorKeys,
            scopeManager: analyzeScope(slots.lastSourceCode.ast, parserOptions)
          });
        }
      }
      const sourceCode = slots.lastSourceCode;
      const commentDirectives = options.allowInlineConfig ? getDirectiveComments(options.filename, sourceCode.ast, (ruleId) => getRule(slots, ruleId), options.warnInlineConfig) : {configuredRules: {}, enabledGlobals: {}, exportedVariables: {}, problems: [], disableDirectives: []};
      addDeclaredGlobals(sourceCode.scopeManager.scopes[0], configuredGlobals, {exportedVariables: commentDirectives.exportedVariables, enabledGlobals: commentDirectives.enabledGlobals});
      const configuredRules = Object.assign({}, config.rules, commentDirectives.configuredRules);
      let lintingProblems;
      try {
        lintingProblems = runRules(sourceCode, configuredRules, (ruleId) => getRule(slots, ruleId), parserOptions, parserName, settings, options.filename, options.disableFixes, slots.cwd);
      } catch (err) {
        err.message += `
Occurred while linting ${options.filename}`;
        debug5("An error occurred while traversing");
        debug5("Filename:", options.filename);
        if (err.currentNode) {
          const {line} = err.currentNode.loc.start;
          debug5("Line:", line);
          err.message += `:${line}`;
        }
        debug5("Parser Options:", parserOptions);
        debug5("Parser Path:", parserName);
        debug5("Settings:", settings);
        throw err;
      }
      return applyDisableDirectives({
        directives: commentDirectives.disableDirectives,
        problems: lintingProblems.concat(commentDirectives.problems).sort((problemA, problemB) => problemA.line - problemB.line || problemA.column - problemB.column),
        reportUnusedDisableDirectives: options.reportUnusedDisableDirectives
      });
    }
    verify(textOrSourceCode, config, filenameOrOptions) {
      debug5("Verify");
      const options = typeof filenameOrOptions === "string" ? {filename: filenameOrOptions} : filenameOrOptions || {};
      if (config && typeof config.extractConfig === "function") {
        return this._verifyWithConfigArray(textOrSourceCode, config, options);
      }
      if (options.preprocess || options.postprocess) {
        return this._verifyWithProcessor(textOrSourceCode, config, options);
      }
      return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    }
    _verifyWithConfigArray(textOrSourceCode, configArray, options) {
      debug5("With ConfigArray: %s", options.filename);
      internalSlotsMap.get(this).lastConfigArray = configArray;
      const config = configArray.extractConfig(options.filename);
      const processor = config.processor && configArray.pluginProcessors.get(config.processor);
      if (processor) {
        debug5("Apply the processor: %o", config.processor);
        const {preprocess, postprocess, supportsAutofix} = processor;
        const disableFixes = options.disableFixes || !supportsAutofix;
        return this._verifyWithProcessor(textOrSourceCode, config, __objSpread(__objSpread({}, options), {disableFixes, postprocess, preprocess}), configArray);
      }
      return this._verifyWithoutProcessors(textOrSourceCode, config, options);
    }
    _verifyWithProcessor(textOrSourceCode, config, options, configForRecursive) {
      const filename = options.filename || "<input>";
      const filenameToExpose = normalizeFilename(filename);
      const text = ensureText(textOrSourceCode);
      const preprocess = options.preprocess || ((rawText) => [rawText]);
      const postprocess = options.postprocess || lodash.flatten;
      const filterCodeBlock = options.filterCodeBlock || ((blockFilename) => blockFilename.endsWith(".js"));
      const originalExtname = path3.extname(filename);
      const messageLists = preprocess(text, filenameToExpose).map((block, i) => {
        debug5("A code block was found: %o", block.filename || "(unnamed)");
        if (typeof block === "string") {
          return this._verifyWithoutProcessors(block, config, options);
        }
        const blockText = block.text;
        const blockName = path3.join(filename, `${i}_${block.filename}`);
        if (!filterCodeBlock(blockName, blockText)) {
          debug5("This code block was skipped.");
          return [];
        }
        if (configForRecursive && path3.extname(blockName) !== originalExtname) {
          debug5("Resolving configuration again because the file extension was changed.");
          return this._verifyWithConfigArray(blockText, configForRecursive, __objSpread(__objSpread({}, options), {filename: blockName}));
        }
        return this._verifyWithoutProcessors(blockText, config, __objSpread(__objSpread({}, options), {filename: blockName}));
      });
      return postprocess(messageLists, filenameToExpose);
    }
    getSourceCode() {
      return internalSlotsMap.get(this).lastSourceCode;
    }
    defineRule(ruleId, ruleModule) {
      internalSlotsMap.get(this).ruleMap.define(ruleId, ruleModule);
    }
    defineRules(rulesToDefine) {
      Object.getOwnPropertyNames(rulesToDefine).forEach((ruleId) => {
        this.defineRule(ruleId, rulesToDefine[ruleId]);
      });
    }
    getRules() {
      const {lastConfigArray, ruleMap} = internalSlotsMap.get(this);
      return new Map(function* () {
        yield* ruleMap;
        if (lastConfigArray) {
          yield* lastConfigArray.pluginRules;
        }
      }());
    }
    defineParser(parserId, parserModule) {
      internalSlotsMap.get(this).parserMap.set(parserId, parserModule);
    }
    verifyAndFix(text, config, options) {
      let messages = [], fixedResult, fixed = false, passNumber = 0, currentText = text;
      const debugTextDescription = options && options.filename || `${text.slice(0, 10)}...`;
      const shouldFix = options && typeof options.fix !== "undefined" ? options.fix : true;
      do {
        passNumber++;
        debug5(`Linting code for ${debugTextDescription} (pass ${passNumber})`);
        messages = this.verify(currentText, config, options);
        debug5(`Generating fixed text for ${debugTextDescription} (pass ${passNumber})`);
        fixedResult = SourceCodeFixer.applyFixes(currentText, messages, shouldFix);
        if (messages.length === 1 && messages[0].fatal) {
          break;
        }
        fixed = fixed || fixedResult.fixed;
        currentText = fixedResult.output;
      } while (fixedResult.fixed && passNumber < MAX_AUTOFIX_PASSES);
      if (fixedResult.fixed) {
        fixedResult.messages = this.verify(currentText, config, options);
      }
      fixedResult.fixed = fixed;
      fixedResult.output = currentText;
      return fixedResult;
    }
  };
  module2.exports = {
    Linter,
    getLinterInternalSlots(instance) {
      return internalSlotsMap.get(instance);
    }
  };
});

// node_modules/eslint/lib/linter/index.js
var require_linter2 = __commonJS((exports2, module2) => {
  "use strict";
  var {Linter} = require_linter();
  var interpolate = require_interpolate();
  var SourceCodeFixer = require_source_code_fixer();
  module2.exports = {
    Linter,
    SourceCodeFixer,
    interpolate
  };
});

// node_modules/eslint/lib/cli-engine/load-rules.js
var require_load_rules = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path3 = require("path");
  var rulesDirCache = {};
  module2.exports = function(relativeRulesDir, cwd) {
    const rulesDir = path3.resolve(cwd, relativeRulesDir);
    if (rulesDirCache[rulesDir]) {
      return rulesDirCache[rulesDir];
    }
    const rules = Object.create(null);
    fs2.readdirSync(rulesDir).forEach((file) => {
      if (path3.extname(file) !== ".js") {
        return;
      }
      rules[file.slice(0, -3)] = require(path3.join(rulesDir, file));
    });
    rulesDirCache[rulesDir] = rules;
    return rules;
  };
});

// node_modules/imurmurhash/imurmurhash.js
var require_imurmurhash = __commonJS((exports2, module2) => {
  /**
   * @preserve
   * JS Implementation of incremental MurmurHash3 (r150) (as of May 10, 2013)
   *
   * @author <a href="mailto:jensyt@gmail.com">Jens Taylor</a>
   * @see http://github.com/homebrewing/brauhaus-diff
   * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
   * @see http://github.com/garycourt/murmurhash-js
   * @author <a href="mailto:aappleby@gmail.com">Austin Appleby</a>
   * @see http://sites.google.com/site/murmurhash/
   */
  (function() {
    var cache;
    function MurmurHash3(key, seed) {
      var m = this instanceof MurmurHash3 ? this : cache;
      m.reset(seed);
      if (typeof key === "string" && key.length > 0) {
        m.hash(key);
      }
      if (m !== this) {
        return m;
      }
    }
    ;
    MurmurHash3.prototype.hash = function(key) {
      var h1, k1, i, top, len;
      len = key.length;
      this.len += len;
      k1 = this.k1;
      i = 0;
      switch (this.rem) {
        case 0:
          k1 ^= len > i ? key.charCodeAt(i++) & 65535 : 0;
        case 1:
          k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 8 : 0;
        case 2:
          k1 ^= len > i ? (key.charCodeAt(i++) & 65535) << 16 : 0;
        case 3:
          k1 ^= len > i ? (key.charCodeAt(i) & 255) << 24 : 0;
          k1 ^= len > i ? (key.charCodeAt(i++) & 65280) >> 8 : 0;
      }
      this.rem = len + this.rem & 3;
      len -= this.rem;
      if (len > 0) {
        h1 = this.h1;
        while (1) {
          k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
          k1 = k1 << 15 | k1 >>> 17;
          k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
          h1 ^= k1;
          h1 = h1 << 13 | h1 >>> 19;
          h1 = h1 * 5 + 3864292196 & 4294967295;
          if (i >= len) {
            break;
          }
          k1 = key.charCodeAt(i++) & 65535 ^ (key.charCodeAt(i++) & 65535) << 8 ^ (key.charCodeAt(i++) & 65535) << 16;
          top = key.charCodeAt(i++);
          k1 ^= (top & 255) << 24 ^ (top & 65280) >> 8;
        }
        k1 = 0;
        switch (this.rem) {
          case 3:
            k1 ^= (key.charCodeAt(i + 2) & 65535) << 16;
          case 2:
            k1 ^= (key.charCodeAt(i + 1) & 65535) << 8;
          case 1:
            k1 ^= key.charCodeAt(i) & 65535;
        }
        this.h1 = h1;
      }
      this.k1 = k1;
      return this;
    };
    MurmurHash3.prototype.result = function() {
      var k1, h1;
      k1 = this.k1;
      h1 = this.h1;
      if (k1 > 0) {
        k1 = k1 * 11601 + (k1 & 65535) * 3432906752 & 4294967295;
        k1 = k1 << 15 | k1 >>> 17;
        k1 = k1 * 13715 + (k1 & 65535) * 461832192 & 4294967295;
        h1 ^= k1;
      }
      h1 ^= this.len;
      h1 ^= h1 >>> 16;
      h1 = h1 * 51819 + (h1 & 65535) * 2246770688 & 4294967295;
      h1 ^= h1 >>> 13;
      h1 = h1 * 44597 + (h1 & 65535) * 3266445312 & 4294967295;
      h1 ^= h1 >>> 16;
      return h1 >>> 0;
    };
    MurmurHash3.prototype.reset = function(seed) {
      this.h1 = typeof seed === "number" ? seed : 0;
      this.rem = this.k1 = this.len = 0;
      return this;
    };
    cache = new MurmurHash3();
    if (typeof module2 != "undefined") {
      module2.exports = MurmurHash3;
    } else {
      this.MurmurHash3 = MurmurHash3;
    }
  })();
});

// node_modules/eslint/lib/cli-engine/hash.js
var require_hash = __commonJS((exports2, module2) => {
  "use strict";
  var murmur = require_imurmurhash();
  function hash(str) {
    return murmur(str).result().toString(36);
  }
  module2.exports = hash;
});

// node_modules/flatted/cjs/index.js
var require_cjs = __commonJS((exports2) => {
  "use strict";
  /*! (c) 2020 Andrea Giammarchi */
  var {parse: $parse, stringify: $stringify} = JSON;
  var {keys} = Object;
  var Primitive = String;
  var primitive = "string";
  var ignore = {};
  var object = "object";
  var noop = (_, value) => value;
  var primitives = (value) => value instanceof Primitive ? Primitive(value) : value;
  var Primitives = (_, value) => typeof value === primitive ? new Primitive(value) : value;
  var revive = (input, parsed, output, $) => {
    const lazy = [];
    for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {
      const k = ke[y];
      const value = output[k];
      if (value instanceof Primitive) {
        const tmp = input[value];
        if (typeof tmp === object && !parsed.has(tmp)) {
          parsed.add(tmp);
          output[k] = ignore;
          lazy.push({k, a: [input, parsed, tmp, $]});
        } else
          output[k] = $.call(output, k, tmp);
      } else if (output[k] !== ignore)
        output[k] = $.call(output, k, value);
    }
    for (let {length} = lazy, i = 0; i < length; i++) {
      const {k, a} = lazy[i];
      output[k] = $.call(output, k, revive.apply(null, a));
    }
    return output;
  };
  var set = (known, input, value) => {
    const index = Primitive(input.push(value) - 1);
    known.set(value, index);
    return index;
  };
  var parse = (text, reviver) => {
    const input = $parse(text, Primitives).map(primitives);
    const value = input[0];
    const $ = reviver || noop;
    const tmp = typeof value === object && value ? revive(input, new Set(), value, $) : value;
    return $.call({"": tmp}, "", tmp);
  };
  exports2.parse = parse;
  var stringify = (value, replacer, space) => {
    const $ = replacer && typeof replacer === object ? (k, v) => k === "" || -1 < replacer.indexOf(k) ? v : void 0 : replacer || noop;
    const known = new Map();
    const input = [];
    const output = [];
    let i = +set(known, input, $.call({"": value}, "", value));
    let firstRun = !i;
    while (i < input.length) {
      firstRun = true;
      output[i] = $stringify(input[i++], replace, space);
    }
    return "[" + output.join(",") + "]";
    function replace(key, value2) {
      if (firstRun) {
        firstRun = !firstRun;
        return value2;
      }
      const after = $.call(this, key, value2);
      switch (typeof after) {
        case object:
          if (after === null)
            return after;
        case primitive:
          return known.get(after) || set(known, input, after);
      }
      return after;
    }
  };
  exports2.stringify = stringify;
});

// node_modules/flat-cache/src/utils.js
var require_utils8 = __commonJS((exports2, module2) => {
  var fs2 = require("fs");
  var path3 = require("path");
  var flatted = require_cjs();
  module2.exports = {
    tryParse: function(filePath, defaultValue) {
      var result;
      try {
        result = this.readJSON(filePath);
      } catch (ex) {
        result = defaultValue;
      }
      return result;
    },
    readJSON: function(filePath) {
      return flatted.parse(fs2.readFileSync(filePath, {
        encoding: "utf8"
      }));
    },
    writeJSON: function(filePath, data) {
      fs2.mkdirSync(path3.dirname(filePath), {
        recursive: true
      });
      fs2.writeFileSync(filePath, flatted.stringify(data));
    }
  };
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS((exports2) => {
  var pathModule = require("path");
  var isWindows = process.platform === "win32";
  var fs2 = require("fs");
  var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
  function rethrow() {
    var callback;
    if (DEBUG) {
      var backtrace = new Error();
      callback = debugCallback;
    } else
      callback = missingCallback;
    return callback;
    function debugCallback(err) {
      if (err) {
        backtrace.message = err.message;
        err = backtrace;
        missingCallback(err);
      }
    }
    function missingCallback(err) {
      if (err) {
        if (process.throwDeprecation)
          throw err;
        else if (!process.noDeprecation) {
          var msg = "fs: missing callback " + (err.stack || err.message);
          if (process.traceDeprecation)
            console.trace(msg);
          else
            console.error(msg);
        }
      }
    }
  }
  function maybeCallback(cb) {
    return typeof cb === "function" ? cb : rethrow();
  }
  var normalize = pathModule.normalize;
  if (isWindows) {
    nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
  } else {
    nextPartRe = /(.*?)(?:[\/]+|$)/g;
  }
  var nextPartRe;
  if (isWindows) {
    splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
  } else {
    splitRootRe = /^[\/]*/;
  }
  var splitRootRe;
  exports2.realpathSync = function realpathSync(p, cache) {
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return cache[p];
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstatSync(base);
        knownHard[base] = true;
      }
    }
    while (pos < p.length) {
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        continue;
      }
      var resolvedLink;
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        resolvedLink = cache[base];
      } else {
        var stat = fs2.lstatSync(base);
        if (!stat.isSymbolicLink()) {
          knownHard[base] = true;
          if (cache)
            cache[base] = base;
          continue;
        }
        var linkTarget = null;
        if (!isWindows) {
          var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
          if (seenLinks.hasOwnProperty(id)) {
            linkTarget = seenLinks[id];
          }
        }
        if (linkTarget === null) {
          fs2.statSync(base);
          linkTarget = fs2.readlinkSync(base);
        }
        resolvedLink = pathModule.resolve(previous, linkTarget);
        if (cache)
          cache[base] = resolvedLink;
        if (!isWindows)
          seenLinks[id] = linkTarget;
      }
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
    if (cache)
      cache[original] = p;
    return p;
  };
  exports2.realpath = function realpath(p, cache, cb) {
    if (typeof cb !== "function") {
      cb = maybeCallback(cache);
      cache = null;
    }
    p = pathModule.resolve(p);
    if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
      return process.nextTick(cb.bind(null, null, cache[p]));
    }
    var original = p, seenLinks = {}, knownHard = {};
    var pos;
    var current;
    var base;
    var previous;
    start();
    function start() {
      var m = splitRootRe.exec(p);
      pos = m[0].length;
      current = m[0];
      base = m[0];
      previous = "";
      if (isWindows && !knownHard[base]) {
        fs2.lstat(base, function(err) {
          if (err)
            return cb(err);
          knownHard[base] = true;
          LOOP();
        });
      } else {
        process.nextTick(LOOP);
      }
    }
    function LOOP() {
      if (pos >= p.length) {
        if (cache)
          cache[original] = p;
        return cb(null, p);
      }
      nextPartRe.lastIndex = pos;
      var result = nextPartRe.exec(p);
      previous = current;
      current += result[0];
      base = previous + result[1];
      pos = nextPartRe.lastIndex;
      if (knownHard[base] || cache && cache[base] === base) {
        return process.nextTick(LOOP);
      }
      if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
        return gotResolvedLink(cache[base]);
      }
      return fs2.lstat(base, gotStat);
    }
    function gotStat(err, stat) {
      if (err)
        return cb(err);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache)
          cache[base] = base;
        return process.nextTick(LOOP);
      }
      if (!isWindows) {
        var id = stat.dev.toString(32) + ":" + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          return gotTarget(null, seenLinks[id], base);
        }
      }
      fs2.stat(base, function(err2) {
        if (err2)
          return cb(err2);
        fs2.readlink(base, function(err3, target) {
          if (!isWindows)
            seenLinks[id] = target;
          gotTarget(err3, target);
        });
      });
    }
    function gotTarget(err, target, base2) {
      if (err)
        return cb(err);
      var resolvedLink = pathModule.resolve(previous, target);
      if (cache)
        cache[base2] = resolvedLink;
      gotResolvedLink(resolvedLink);
    }
    function gotResolvedLink(resolvedLink) {
      p = pathModule.resolve(resolvedLink, p.slice(pos));
      start();
    }
  };
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS((exports2, module2) => {
  module2.exports = realpath;
  realpath.realpath = realpath;
  realpath.sync = realpathSync;
  realpath.realpathSync = realpathSync;
  realpath.monkeypatch = monkeypatch;
  realpath.unmonkeypatch = unmonkeypatch;
  var fs2 = require("fs");
  var origRealpath = fs2.realpath;
  var origRealpathSync = fs2.realpathSync;
  var version = process.version;
  var ok = /^v[0-5]\./.test(version);
  var old = require_old();
  function newError(er) {
    return er && er.syscall === "realpath" && (er.code === "ELOOP" || er.code === "ENOMEM" || er.code === "ENAMETOOLONG");
  }
  function realpath(p, cache, cb) {
    if (ok) {
      return origRealpath(p, cache, cb);
    }
    if (typeof cache === "function") {
      cb = cache;
      cache = null;
    }
    origRealpath(p, cache, function(er, result) {
      if (newError(er)) {
        old.realpath(p, cache, cb);
      } else {
        cb(er, result);
      }
    });
  }
  function realpathSync(p, cache) {
    if (ok) {
      return origRealpathSync(p, cache);
    }
    try {
      return origRealpathSync(p, cache);
    } catch (er) {
      if (newError(er)) {
        return old.realpathSync(p, cache);
      } else {
        throw er;
      }
    }
  }
  function monkeypatch() {
    fs2.realpath = realpath;
    fs2.realpathSync = realpathSync;
  }
  function unmonkeypatch() {
    fs2.realpath = origRealpath;
    fs2.realpathSync = origRealpathSync;
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS((exports2, module2) => {
  try {
    util = require("util");
    if (typeof util.inherits !== "function")
      throw "";
    module2.exports = util.inherits;
  } catch (e) {
    module2.exports = require_inherits_browser();
  }
  var util;
});

// node_modules/path-is-absolute/index.js
var require_path_is_absolute = __commonJS((exports2, module2) => {
  "use strict";
  function posix(path3) {
    return path3.charAt(0) === "/";
  }
  function win32(path3) {
    var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
    var result = splitDeviceRe.exec(path3);
    var device = result[1] || "";
    var isUnc = Boolean(device && device.charAt(1) !== ":");
    return Boolean(result[2] || isUnc);
  }
  module2.exports = process.platform === "win32" ? win32 : posix;
  module2.exports.posix = posix;
  module2.exports.win32 = win32;
});

// node_modules/glob/common.js
var require_common3 = __commonJS((exports2) => {
  exports2.alphasort = alphasort;
  exports2.alphasorti = alphasorti;
  exports2.setopts = setopts;
  exports2.ownProp = ownProp;
  exports2.makeAbs = makeAbs;
  exports2.finish = finish;
  exports2.mark = mark;
  exports2.isIgnored = isIgnored;
  exports2.childrenIgnored = childrenIgnored;
  function ownProp(obj, field) {
    return Object.prototype.hasOwnProperty.call(obj, field);
  }
  var path3 = require("path");
  var minimatch = require_minimatch();
  var isAbsolute = require_path_is_absolute();
  var Minimatch = minimatch.Minimatch;
  function alphasorti(a, b) {
    return a.toLowerCase().localeCompare(b.toLowerCase());
  }
  function alphasort(a, b) {
    return a.localeCompare(b);
  }
  function setupIgnores(self2, options) {
    self2.ignore = options.ignore || [];
    if (!Array.isArray(self2.ignore))
      self2.ignore = [self2.ignore];
    if (self2.ignore.length) {
      self2.ignore = self2.ignore.map(ignoreMap);
    }
  }
  function ignoreMap(pattern) {
    var gmatcher = null;
    if (pattern.slice(-3) === "/**") {
      var gpattern = pattern.replace(/(\/\*\*)+$/, "");
      gmatcher = new Minimatch(gpattern, {dot: true});
    }
    return {
      matcher: new Minimatch(pattern, {dot: true}),
      gmatcher
    };
  }
  function setopts(self2, pattern, options) {
    if (!options)
      options = {};
    if (options.matchBase && pattern.indexOf("/") === -1) {
      if (options.noglobstar) {
        throw new Error("base matching requires globstar");
      }
      pattern = "**/" + pattern;
    }
    self2.silent = !!options.silent;
    self2.pattern = pattern;
    self2.strict = options.strict !== false;
    self2.realpath = !!options.realpath;
    self2.realpathCache = options.realpathCache || Object.create(null);
    self2.follow = !!options.follow;
    self2.dot = !!options.dot;
    self2.mark = !!options.mark;
    self2.nodir = !!options.nodir;
    if (self2.nodir)
      self2.mark = true;
    self2.sync = !!options.sync;
    self2.nounique = !!options.nounique;
    self2.nonull = !!options.nonull;
    self2.nosort = !!options.nosort;
    self2.nocase = !!options.nocase;
    self2.stat = !!options.stat;
    self2.noprocess = !!options.noprocess;
    self2.absolute = !!options.absolute;
    self2.maxLength = options.maxLength || Infinity;
    self2.cache = options.cache || Object.create(null);
    self2.statCache = options.statCache || Object.create(null);
    self2.symlinks = options.symlinks || Object.create(null);
    setupIgnores(self2, options);
    self2.changedCwd = false;
    var cwd = process.cwd();
    if (!ownProp(options, "cwd"))
      self2.cwd = cwd;
    else {
      self2.cwd = path3.resolve(options.cwd);
      self2.changedCwd = self2.cwd !== cwd;
    }
    self2.root = options.root || path3.resolve(self2.cwd, "/");
    self2.root = path3.resolve(self2.root);
    if (process.platform === "win32")
      self2.root = self2.root.replace(/\\/g, "/");
    self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
    if (process.platform === "win32")
      self2.cwdAbs = self2.cwdAbs.replace(/\\/g, "/");
    self2.nomount = !!options.nomount;
    options.nonegate = true;
    options.nocomment = true;
    self2.minimatch = new Minimatch(pattern, options);
    self2.options = self2.minimatch.options;
  }
  function finish(self2) {
    var nou = self2.nounique;
    var all = nou ? [] : Object.create(null);
    for (var i = 0, l = self2.matches.length; i < l; i++) {
      var matches = self2.matches[i];
      if (!matches || Object.keys(matches).length === 0) {
        if (self2.nonull) {
          var literal = self2.minimatch.globSet[i];
          if (nou)
            all.push(literal);
          else
            all[literal] = true;
        }
      } else {
        var m = Object.keys(matches);
        if (nou)
          all.push.apply(all, m);
        else
          m.forEach(function(m2) {
            all[m2] = true;
          });
      }
    }
    if (!nou)
      all = Object.keys(all);
    if (!self2.nosort)
      all = all.sort(self2.nocase ? alphasorti : alphasort);
    if (self2.mark) {
      for (var i = 0; i < all.length; i++) {
        all[i] = self2._mark(all[i]);
      }
      if (self2.nodir) {
        all = all.filter(function(e) {
          var notDir = !/\/$/.test(e);
          var c = self2.cache[e] || self2.cache[makeAbs(self2, e)];
          if (notDir && c)
            notDir = c !== "DIR" && !Array.isArray(c);
          return notDir;
        });
      }
    }
    if (self2.ignore.length)
      all = all.filter(function(m2) {
        return !isIgnored(self2, m2);
      });
    self2.found = all;
  }
  function mark(self2, p) {
    var abs = makeAbs(self2, p);
    var c = self2.cache[abs];
    var m = p;
    if (c) {
      var isDir = c === "DIR" || Array.isArray(c);
      var slash = p.slice(-1) === "/";
      if (isDir && !slash)
        m += "/";
      else if (!isDir && slash)
        m = m.slice(0, -1);
      if (m !== p) {
        var mabs = makeAbs(self2, m);
        self2.statCache[mabs] = self2.statCache[abs];
        self2.cache[mabs] = self2.cache[abs];
      }
    }
    return m;
  }
  function makeAbs(self2, f) {
    var abs = f;
    if (f.charAt(0) === "/") {
      abs = path3.join(self2.root, f);
    } else if (isAbsolute(f) || f === "") {
      abs = f;
    } else if (self2.changedCwd) {
      abs = path3.resolve(self2.cwd, f);
    } else {
      abs = path3.resolve(f);
    }
    if (process.platform === "win32")
      abs = abs.replace(/\\/g, "/");
    return abs;
  }
  function isIgnored(self2, path4) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return item.matcher.match(path4) || !!(item.gmatcher && item.gmatcher.match(path4));
    });
  }
  function childrenIgnored(self2, path4) {
    if (!self2.ignore.length)
      return false;
    return self2.ignore.some(function(item) {
      return !!(item.gmatcher && item.gmatcher.match(path4));
    });
  }
});

// node_modules/glob/sync.js
var require_sync = __commonJS((exports2, module2) => {
  module2.exports = globSync;
  globSync.GlobSync = GlobSync;
  var fs2 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var Glob = require_glob().Glob;
  var util = require("util");
  var path3 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var common = require_common3();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  function globSync(pattern, options) {
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    return new GlobSync(pattern, options).found;
  }
  function GlobSync(pattern, options) {
    if (!pattern)
      throw new Error("must provide pattern");
    if (typeof options === "function" || arguments.length === 3)
      throw new TypeError("callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167");
    if (!(this instanceof GlobSync))
      return new GlobSync(pattern, options);
    setopts(this, pattern, options);
    if (this.noprocess)
      return this;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false);
    }
    this._finish();
  }
  GlobSync.prototype._finish = function() {
    assert(this instanceof GlobSync);
    if (this.realpath) {
      var self2 = this;
      this.matches.forEach(function(matchset, index) {
        var set = self2.matches[index] = Object.create(null);
        for (var p in matchset) {
          try {
            p = self2._makeAbs(p);
            var real = rp.realpathSync(p, self2.realpathCache);
            set[real] = true;
          } catch (er) {
            if (er.syscall === "stat")
              set[self2._makeAbs(p)] = true;
            else
              throw er;
          }
        }
      });
    }
    common.finish(this);
  };
  GlobSync.prototype._process = function(pattern, index, inGlobStar) {
    assert(this instanceof GlobSync);
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return;
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar);
  };
  GlobSync.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return;
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix.slice(-1) !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path3.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return;
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix)
        newPattern = [prefix, e];
      else
        newPattern = [e];
      this._process(newPattern.concat(remain), index, inGlobStar);
    }
  };
  GlobSync.prototype._emitMatch = function(index, e) {
    if (isIgnored(this, e))
      return;
    var abs = this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute) {
      e = abs;
    }
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    if (this.stat)
      this._stat(e);
  };
  GlobSync.prototype._readdirInGlobStar = function(abs) {
    if (this.follow)
      return this._readdir(abs, false);
    var entries;
    var lstat;
    var stat;
    try {
      lstat = fs2.lstatSync(abs);
    } catch (er) {
      if (er.code === "ENOENT") {
        return null;
      }
    }
    var isSym = lstat && lstat.isSymbolicLink();
    this.symlinks[abs] = isSym;
    if (!isSym && lstat && !lstat.isDirectory())
      this.cache[abs] = "FILE";
    else
      entries = this._readdir(abs, false);
    return entries;
  };
  GlobSync.prototype._readdir = function(abs, inGlobStar) {
    var entries;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return null;
      if (Array.isArray(c))
        return c;
    }
    try {
      return this._readdirEntries(abs, fs2.readdirSync(abs));
    } catch (er) {
      this._readdirError(abs, er);
      return null;
    }
  };
  GlobSync.prototype._readdirEntries = function(abs, entries) {
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return entries;
  };
  GlobSync.prototype._readdirError = function(f, er) {
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error5 = new Error(er.code + " invalid cwd " + this.cwd);
          error5.path = this.cwd;
          error5.code = er.code;
          throw error5;
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict)
          throw er;
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
  };
  GlobSync.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar) {
    var entries = this._readdir(abs, inGlobStar);
    if (!entries)
      return;
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false);
    var len = entries.length;
    var isSym = this.symlinks[abs];
    if (isSym && inGlobStar)
      return;
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true);
    }
  };
  GlobSync.prototype._processSimple = function(prefix, index) {
    var exists = this._stat(prefix);
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return;
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path3.join(this.root, prefix);
      } else {
        prefix = path3.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
  };
  GlobSync.prototype._stat = function(f) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return false;
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return c;
      if (needDir && c === "FILE")
        return false;
    }
    var exists;
    var stat = this.statCache[abs];
    if (!stat) {
      var lstat;
      try {
        lstat = fs2.lstatSync(abs);
      } catch (er) {
        if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
          this.statCache[abs] = false;
          return false;
        }
      }
      if (lstat && lstat.isSymbolicLink()) {
        try {
          stat = fs2.statSync(abs);
        } catch (er) {
          stat = lstat;
        }
      } else {
        stat = lstat;
      }
    }
    this.statCache[abs] = stat;
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return false;
    return c;
  };
  GlobSync.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  GlobSync.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS((exports2, module2) => {
  var wrappy = require_wrappy();
  var reqs = Object.create(null);
  var once = require_once();
  module2.exports = wrappy(inflight);
  function inflight(key, cb) {
    if (reqs[key]) {
      reqs[key].push(cb);
      return null;
    } else {
      reqs[key] = [cb];
      return makeres(key);
    }
  }
  function makeres(key) {
    return once(function RES() {
      var cbs = reqs[key];
      var len = cbs.length;
      var args = slice(arguments);
      try {
        for (var i = 0; i < len; i++) {
          cbs[i].apply(null, args);
        }
      } finally {
        if (cbs.length > len) {
          cbs.splice(0, len);
          process.nextTick(function() {
            RES.apply(null, args);
          });
        } else {
          delete reqs[key];
        }
      }
    });
  }
  function slice(args) {
    var length = args.length;
    var array = [];
    for (var i = 0; i < length; i++)
      array[i] = args[i];
    return array;
  }
});

// node_modules/glob/glob.js
var require_glob = __commonJS((exports2, module2) => {
  module2.exports = glob;
  var fs2 = require("fs");
  var rp = require_fs();
  var minimatch = require_minimatch();
  var Minimatch = minimatch.Minimatch;
  var inherits = require_inherits();
  var EE = require("events").EventEmitter;
  var path3 = require("path");
  var assert = require("assert");
  var isAbsolute = require_path_is_absolute();
  var globSync = require_sync();
  var common = require_common3();
  var alphasort = common.alphasort;
  var alphasorti = common.alphasorti;
  var setopts = common.setopts;
  var ownProp = common.ownProp;
  var inflight = require_inflight();
  var util = require("util");
  var childrenIgnored = common.childrenIgnored;
  var isIgnored = common.isIgnored;
  var once = require_once();
  function glob(pattern, options, cb) {
    if (typeof options === "function")
      cb = options, options = {};
    if (!options)
      options = {};
    if (options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return globSync(pattern, options);
    }
    return new Glob(pattern, options, cb);
  }
  glob.sync = globSync;
  var GlobSync = glob.GlobSync = globSync.GlobSync;
  glob.glob = glob;
  function extend(origin, add) {
    if (add === null || typeof add !== "object") {
      return origin;
    }
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  }
  glob.hasMagic = function(pattern, options_) {
    var options = extend({}, options_);
    options.noprocess = true;
    var g = new Glob(pattern, options);
    var set = g.minimatch.set;
    if (!pattern)
      return false;
    if (set.length > 1)
      return true;
    for (var j = 0; j < set[0].length; j++) {
      if (typeof set[0][j] !== "string")
        return true;
    }
    return false;
  };
  glob.Glob = Glob;
  inherits(Glob, EE);
  function Glob(pattern, options, cb) {
    if (typeof options === "function") {
      cb = options;
      options = null;
    }
    if (options && options.sync) {
      if (cb)
        throw new TypeError("callback provided to sync glob");
      return new GlobSync(pattern, options);
    }
    if (!(this instanceof Glob))
      return new Glob(pattern, options, cb);
    setopts(this, pattern, options);
    this._didRealPath = false;
    var n = this.minimatch.set.length;
    this.matches = new Array(n);
    if (typeof cb === "function") {
      cb = once(cb);
      this.on("error", cb);
      this.on("end", function(matches) {
        cb(null, matches);
      });
    }
    var self2 = this;
    this._processing = 0;
    this._emitQueue = [];
    this._processQueue = [];
    this.paused = false;
    if (this.noprocess)
      return this;
    if (n === 0)
      return done();
    var sync = true;
    for (var i = 0; i < n; i++) {
      this._process(this.minimatch.set[i], i, false, done);
    }
    sync = false;
    function done() {
      --self2._processing;
      if (self2._processing <= 0) {
        if (sync) {
          process.nextTick(function() {
            self2._finish();
          });
        } else {
          self2._finish();
        }
      }
    }
  }
  Glob.prototype._finish = function() {
    assert(this instanceof Glob);
    if (this.aborted)
      return;
    if (this.realpath && !this._didRealpath)
      return this._realpath();
    common.finish(this);
    this.emit("end", this.found);
  };
  Glob.prototype._realpath = function() {
    if (this._didRealpath)
      return;
    this._didRealpath = true;
    var n = this.matches.length;
    if (n === 0)
      return this._finish();
    var self2 = this;
    for (var i = 0; i < this.matches.length; i++)
      this._realpathSet(i, next);
    function next() {
      if (--n === 0)
        self2._finish();
    }
  };
  Glob.prototype._realpathSet = function(index, cb) {
    var matchset = this.matches[index];
    if (!matchset)
      return cb();
    var found = Object.keys(matchset);
    var self2 = this;
    var n = found.length;
    if (n === 0)
      return cb();
    var set = this.matches[index] = Object.create(null);
    found.forEach(function(p, i) {
      p = self2._makeAbs(p);
      rp.realpath(p, self2.realpathCache, function(er, real) {
        if (!er)
          set[real] = true;
        else if (er.syscall === "stat")
          set[p] = true;
        else
          self2.emit("error", er);
        if (--n === 0) {
          self2.matches[index] = set;
          cb();
        }
      });
    });
  };
  Glob.prototype._mark = function(p) {
    return common.mark(this, p);
  };
  Glob.prototype._makeAbs = function(f) {
    return common.makeAbs(this, f);
  };
  Glob.prototype.abort = function() {
    this.aborted = true;
    this.emit("abort");
  };
  Glob.prototype.pause = function() {
    if (!this.paused) {
      this.paused = true;
      this.emit("pause");
    }
  };
  Glob.prototype.resume = function() {
    if (this.paused) {
      this.emit("resume");
      this.paused = false;
      if (this._emitQueue.length) {
        var eq = this._emitQueue.slice(0);
        this._emitQueue.length = 0;
        for (var i = 0; i < eq.length; i++) {
          var e = eq[i];
          this._emitMatch(e[0], e[1]);
        }
      }
      if (this._processQueue.length) {
        var pq = this._processQueue.slice(0);
        this._processQueue.length = 0;
        for (var i = 0; i < pq.length; i++) {
          var p = pq[i];
          this._processing--;
          this._process(p[0], p[1], p[2], p[3]);
        }
      }
    }
  };
  Glob.prototype._process = function(pattern, index, inGlobStar, cb) {
    assert(this instanceof Glob);
    assert(typeof cb === "function");
    if (this.aborted)
      return;
    this._processing++;
    if (this.paused) {
      this._processQueue.push([pattern, index, inGlobStar, cb]);
      return;
    }
    var n = 0;
    while (typeof pattern[n] === "string") {
      n++;
    }
    var prefix;
    switch (n) {
      case pattern.length:
        this._processSimple(pattern.join("/"), index, cb);
        return;
      case 0:
        prefix = null;
        break;
      default:
        prefix = pattern.slice(0, n).join("/");
        break;
    }
    var remain = pattern.slice(n);
    var read;
    if (prefix === null)
      read = ".";
    else if (isAbsolute(prefix) || isAbsolute(pattern.join("/"))) {
      if (!prefix || !isAbsolute(prefix))
        prefix = "/" + prefix;
      read = prefix;
    } else
      read = prefix;
    var abs = this._makeAbs(read);
    if (childrenIgnored(this, read))
      return cb();
    var isGlobStar = remain[0] === minimatch.GLOBSTAR;
    if (isGlobStar)
      this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb);
    else
      this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb);
  };
  Glob.prototype._processReaddir = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      return self2._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processReaddir2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var pn = remain[0];
    var negate = !!this.minimatch.negate;
    var rawGlob = pn._glob;
    var dotOk = this.dot || rawGlob.charAt(0) === ".";
    var matchedEntries = [];
    for (var i = 0; i < entries.length; i++) {
      var e = entries[i];
      if (e.charAt(0) !== "." || dotOk) {
        var m;
        if (negate && !prefix) {
          m = !e.match(pn);
        } else {
          m = e.match(pn);
        }
        if (m)
          matchedEntries.push(e);
      }
    }
    var len = matchedEntries.length;
    if (len === 0)
      return cb();
    if (remain.length === 1 && !this.mark && !this.stat) {
      if (!this.matches[index])
        this.matches[index] = Object.create(null);
      for (var i = 0; i < len; i++) {
        var e = matchedEntries[i];
        if (prefix) {
          if (prefix !== "/")
            e = prefix + "/" + e;
          else
            e = prefix + e;
        }
        if (e.charAt(0) === "/" && !this.nomount) {
          e = path3.join(this.root, e);
        }
        this._emitMatch(index, e);
      }
      return cb();
    }
    remain.shift();
    for (var i = 0; i < len; i++) {
      var e = matchedEntries[i];
      var newPattern;
      if (prefix) {
        if (prefix !== "/")
          e = prefix + "/" + e;
        else
          e = prefix + e;
      }
      this._process([e].concat(remain), index, inGlobStar, cb);
    }
    cb();
  };
  Glob.prototype._emitMatch = function(index, e) {
    if (this.aborted)
      return;
    if (isIgnored(this, e))
      return;
    if (this.paused) {
      this._emitQueue.push([index, e]);
      return;
    }
    var abs = isAbsolute(e) ? e : this._makeAbs(e);
    if (this.mark)
      e = this._mark(e);
    if (this.absolute)
      e = abs;
    if (this.matches[index][e])
      return;
    if (this.nodir) {
      var c = this.cache[abs];
      if (c === "DIR" || Array.isArray(c))
        return;
    }
    this.matches[index][e] = true;
    var st = this.statCache[abs];
    if (st)
      this.emit("stat", e, st);
    this.emit("match", e);
  };
  Glob.prototype._readdirInGlobStar = function(abs, cb) {
    if (this.aborted)
      return;
    if (this.follow)
      return this._readdir(abs, false, cb);
    var lstatkey = "lstat\0" + abs;
    var self2 = this;
    var lstatcb = inflight(lstatkey, lstatcb_);
    if (lstatcb)
      fs2.lstat(abs, lstatcb);
    function lstatcb_(er, lstat) {
      if (er && er.code === "ENOENT")
        return cb();
      var isSym = lstat && lstat.isSymbolicLink();
      self2.symlinks[abs] = isSym;
      if (!isSym && lstat && !lstat.isDirectory()) {
        self2.cache[abs] = "FILE";
        cb();
      } else
        self2._readdir(abs, false, cb);
    }
  };
  Glob.prototype._readdir = function(abs, inGlobStar, cb) {
    if (this.aborted)
      return;
    cb = inflight("readdir\0" + abs + "\0" + inGlobStar, cb);
    if (!cb)
      return;
    if (inGlobStar && !ownProp(this.symlinks, abs))
      return this._readdirInGlobStar(abs, cb);
    if (ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (!c || c === "FILE")
        return cb();
      if (Array.isArray(c))
        return cb(null, c);
    }
    var self2 = this;
    fs2.readdir(abs, readdirCb(this, abs, cb));
  };
  function readdirCb(self2, abs, cb) {
    return function(er, entries) {
      if (er)
        self2._readdirError(abs, er, cb);
      else
        self2._readdirEntries(abs, entries, cb);
    };
  }
  Glob.prototype._readdirEntries = function(abs, entries, cb) {
    if (this.aborted)
      return;
    if (!this.mark && !this.stat) {
      for (var i = 0; i < entries.length; i++) {
        var e = entries[i];
        if (abs === "/")
          e = abs + e;
        else
          e = abs + "/" + e;
        this.cache[e] = true;
      }
    }
    this.cache[abs] = entries;
    return cb(null, entries);
  };
  Glob.prototype._readdirError = function(f, er, cb) {
    if (this.aborted)
      return;
    switch (er.code) {
      case "ENOTSUP":
      case "ENOTDIR":
        var abs = this._makeAbs(f);
        this.cache[abs] = "FILE";
        if (abs === this.cwdAbs) {
          var error5 = new Error(er.code + " invalid cwd " + this.cwd);
          error5.path = this.cwd;
          error5.code = er.code;
          this.emit("error", error5);
          this.abort();
        }
        break;
      case "ENOENT":
      case "ELOOP":
      case "ENAMETOOLONG":
      case "UNKNOWN":
        this.cache[this._makeAbs(f)] = false;
        break;
      default:
        this.cache[this._makeAbs(f)] = false;
        if (this.strict) {
          this.emit("error", er);
          this.abort();
        }
        if (!this.silent)
          console.error("glob error", er);
        break;
    }
    return cb();
  };
  Glob.prototype._processGlobStar = function(prefix, read, abs, remain, index, inGlobStar, cb) {
    var self2 = this;
    this._readdir(abs, inGlobStar, function(er, entries) {
      self2._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb);
    });
  };
  Glob.prototype._processGlobStar2 = function(prefix, read, abs, remain, index, inGlobStar, entries, cb) {
    if (!entries)
      return cb();
    var remainWithoutGlobStar = remain.slice(1);
    var gspref = prefix ? [prefix] : [];
    var noGlobStar = gspref.concat(remainWithoutGlobStar);
    this._process(noGlobStar, index, false, cb);
    var isSym = this.symlinks[abs];
    var len = entries.length;
    if (isSym && inGlobStar)
      return cb();
    for (var i = 0; i < len; i++) {
      var e = entries[i];
      if (e.charAt(0) === "." && !this.dot)
        continue;
      var instead = gspref.concat(entries[i], remainWithoutGlobStar);
      this._process(instead, index, true, cb);
      var below = gspref.concat(entries[i], remain);
      this._process(below, index, true, cb);
    }
    cb();
  };
  Glob.prototype._processSimple = function(prefix, index, cb) {
    var self2 = this;
    this._stat(prefix, function(er, exists) {
      self2._processSimple2(prefix, index, er, exists, cb);
    });
  };
  Glob.prototype._processSimple2 = function(prefix, index, er, exists, cb) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null);
    if (!exists)
      return cb();
    if (prefix && isAbsolute(prefix) && !this.nomount) {
      var trail = /[\/\\]$/.test(prefix);
      if (prefix.charAt(0) === "/") {
        prefix = path3.join(this.root, prefix);
      } else {
        prefix = path3.resolve(this.root, prefix);
        if (trail)
          prefix += "/";
      }
    }
    if (process.platform === "win32")
      prefix = prefix.replace(/\\/g, "/");
    this._emitMatch(index, prefix);
    cb();
  };
  Glob.prototype._stat = function(f, cb) {
    var abs = this._makeAbs(f);
    var needDir = f.slice(-1) === "/";
    if (f.length > this.maxLength)
      return cb();
    if (!this.stat && ownProp(this.cache, abs)) {
      var c = this.cache[abs];
      if (Array.isArray(c))
        c = "DIR";
      if (!needDir || c === "DIR")
        return cb(null, c);
      if (needDir && c === "FILE")
        return cb();
    }
    var exists;
    var stat = this.statCache[abs];
    if (stat !== void 0) {
      if (stat === false)
        return cb(null, stat);
      else {
        var type = stat.isDirectory() ? "DIR" : "FILE";
        if (needDir && type === "FILE")
          return cb();
        else
          return cb(null, type, stat);
      }
    }
    var self2 = this;
    var statcb = inflight("stat\0" + abs, lstatcb_);
    if (statcb)
      fs2.lstat(abs, statcb);
    function lstatcb_(er, lstat) {
      if (lstat && lstat.isSymbolicLink()) {
        return fs2.stat(abs, function(er2, stat2) {
          if (er2)
            self2._stat2(f, abs, null, lstat, cb);
          else
            self2._stat2(f, abs, er2, stat2, cb);
        });
      } else {
        self2._stat2(f, abs, er, lstat, cb);
      }
    }
  };
  Glob.prototype._stat2 = function(f, abs, er, stat, cb) {
    if (er && (er.code === "ENOENT" || er.code === "ENOTDIR")) {
      this.statCache[abs] = false;
      return cb();
    }
    var needDir = f.slice(-1) === "/";
    this.statCache[abs] = stat;
    if (abs.slice(-1) === "/" && stat && !stat.isDirectory())
      return cb(null, false, stat);
    var c = true;
    if (stat)
      c = stat.isDirectory() ? "DIR" : "FILE";
    this.cache[abs] = this.cache[abs] || c;
    if (needDir && c === "FILE")
      return cb();
    return cb(null, c, stat);
  };
});

// node_modules/rimraf/rimraf.js
var require_rimraf = __commonJS((exports2, module2) => {
  var assert = require("assert");
  var path3 = require("path");
  var fs2 = require("fs");
  var glob = void 0;
  try {
    glob = require_glob();
  } catch (_err) {
  }
  var defaultGlobOpts = {
    nosort: true,
    silent: true
  };
  var timeout = 0;
  var isWindows = process.platform === "win32";
  var defaults = (options) => {
    const methods = [
      "unlink",
      "chmod",
      "stat",
      "lstat",
      "rmdir",
      "readdir"
    ];
    methods.forEach((m) => {
      options[m] = options[m] || fs2[m];
      m = m + "Sync";
      options[m] = options[m] || fs2[m];
    });
    options.maxBusyTries = options.maxBusyTries || 3;
    options.emfileWait = options.emfileWait || 1e3;
    if (options.glob === false) {
      options.disableGlob = true;
    }
    if (options.disableGlob !== true && glob === void 0) {
      throw Error("glob dependency not found, set `options.disableGlob = true` if intentional");
    }
    options.disableGlob = options.disableGlob || false;
    options.glob = options.glob || defaultGlobOpts;
  };
  var rimraf = (p, options, cb) => {
    if (typeof options === "function") {
      cb = options;
      options = {};
    }
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert.equal(typeof cb, "function", "rimraf: callback function required");
    assert(options, "rimraf: invalid options argument provided");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    defaults(options);
    let busyTries = 0;
    let errState = null;
    let n = 0;
    const next = (er) => {
      errState = errState || er;
      if (--n === 0)
        cb(errState);
    };
    const afterGlob = (er, results) => {
      if (er)
        return cb(er);
      n = results.length;
      if (n === 0)
        return cb();
      results.forEach((p2) => {
        const CB = (er2) => {
          if (er2) {
            if ((er2.code === "EBUSY" || er2.code === "ENOTEMPTY" || er2.code === "EPERM") && busyTries < options.maxBusyTries) {
              busyTries++;
              return setTimeout(() => rimraf_(p2, options, CB), busyTries * 100);
            }
            if (er2.code === "EMFILE" && timeout < options.emfileWait) {
              return setTimeout(() => rimraf_(p2, options, CB), timeout++);
            }
            if (er2.code === "ENOENT")
              er2 = null;
          }
          timeout = 0;
          next(er2);
        };
        rimraf_(p2, options, CB);
      });
    };
    if (options.disableGlob || !glob.hasMagic(p))
      return afterGlob(null, [p]);
    options.lstat(p, (er, stat) => {
      if (!er)
        return afterGlob(null, [p]);
      glob(p, options.glob, afterGlob);
    });
  };
  var rimraf_ = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.lstat(p, (er, st) => {
      if (er && er.code === "ENOENT")
        return cb(null);
      if (er && er.code === "EPERM" && isWindows)
        fixWinEPERM(p, options, er, cb);
      if (st && st.isDirectory())
        return rmdir(p, options, er, cb);
      options.unlink(p, (er2) => {
        if (er2) {
          if (er2.code === "ENOENT")
            return cb(null);
          if (er2.code === "EPERM")
            return isWindows ? fixWinEPERM(p, options, er2, cb) : rmdir(p, options, er2, cb);
          if (er2.code === "EISDIR")
            return rmdir(p, options, er2, cb);
        }
        return cb(er2);
      });
    });
  };
  var fixWinEPERM = (p, options, er, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.chmod(p, 438, (er2) => {
      if (er2)
        cb(er2.code === "ENOENT" ? null : er);
      else
        options.stat(p, (er3, stats) => {
          if (er3)
            cb(er3.code === "ENOENT" ? null : er);
          else if (stats.isDirectory())
            rmdir(p, options, er, cb);
          else
            options.unlink(p, cb);
        });
    });
  };
  var fixWinEPERMSync = (p, options, er) => {
    assert(p);
    assert(options);
    try {
      options.chmodSync(p, 438);
    } catch (er2) {
      if (er2.code === "ENOENT")
        return;
      else
        throw er;
    }
    let stats;
    try {
      stats = options.statSync(p);
    } catch (er3) {
      if (er3.code === "ENOENT")
        return;
      else
        throw er;
    }
    if (stats.isDirectory())
      rmdirSync(p, options, er);
    else
      options.unlinkSync(p);
  };
  var rmdir = (p, options, originalEr, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.rmdir(p, (er) => {
      if (er && (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM"))
        rmkids(p, options, cb);
      else if (er && er.code === "ENOTDIR")
        cb(originalEr);
      else
        cb(er);
    });
  };
  var rmkids = (p, options, cb) => {
    assert(p);
    assert(options);
    assert(typeof cb === "function");
    options.readdir(p, (er, files) => {
      if (er)
        return cb(er);
      let n = files.length;
      if (n === 0)
        return options.rmdir(p, cb);
      let errState;
      files.forEach((f) => {
        rimraf(path3.join(p, f), options, (er2) => {
          if (errState)
            return;
          if (er2)
            return cb(errState = er2);
          if (--n === 0)
            options.rmdir(p, cb);
        });
      });
    });
  };
  var rimrafSync = (p, options) => {
    options = options || {};
    defaults(options);
    assert(p, "rimraf: missing path");
    assert.equal(typeof p, "string", "rimraf: path should be a string");
    assert(options, "rimraf: missing options");
    assert.equal(typeof options, "object", "rimraf: options should be object");
    let results;
    if (options.disableGlob || !glob.hasMagic(p)) {
      results = [p];
    } else {
      try {
        options.lstatSync(p);
        results = [p];
      } catch (er) {
        results = glob.sync(p, options.glob);
      }
    }
    if (!results.length)
      return;
    for (let i = 0; i < results.length; i++) {
      const p2 = results[i];
      let st;
      try {
        st = options.lstatSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM" && isWindows)
          fixWinEPERMSync(p2, options, er);
      }
      try {
        if (st && st.isDirectory())
          rmdirSync(p2, options, null);
        else
          options.unlinkSync(p2);
      } catch (er) {
        if (er.code === "ENOENT")
          return;
        if (er.code === "EPERM")
          return isWindows ? fixWinEPERMSync(p2, options, er) : rmdirSync(p2, options, er);
        if (er.code !== "EISDIR")
          throw er;
        rmdirSync(p2, options, er);
      }
    }
  };
  var rmdirSync = (p, options, originalEr) => {
    assert(p);
    assert(options);
    try {
      options.rmdirSync(p);
    } catch (er) {
      if (er.code === "ENOENT")
        return;
      if (er.code === "ENOTDIR")
        throw originalEr;
      if (er.code === "ENOTEMPTY" || er.code === "EEXIST" || er.code === "EPERM")
        rmkidsSync(p, options);
    }
  };
  var rmkidsSync = (p, options) => {
    assert(p);
    assert(options);
    options.readdirSync(p).forEach((f) => rimrafSync(path3.join(p, f), options));
    const retries = isWindows ? 100 : 1;
    let i = 0;
    do {
      let threw = true;
      try {
        const ret = options.rmdirSync(p, options);
        threw = false;
        return ret;
      } finally {
        if (++i < retries && threw)
          continue;
      }
    } while (true);
  };
  module2.exports = rimraf;
  rimraf.sync = rimrafSync;
});

// node_modules/flat-cache/src/del.js
var require_del = __commonJS((exports2, module2) => {
  var rimraf = require_rimraf().sync;
  var fs2 = require("fs");
  module2.exports = function del(file) {
    if (fs2.existsSync(file)) {
      rimraf(file, {
        glob: false
      });
      return true;
    }
    return false;
  };
});

// node_modules/flat-cache/src/cache.js
var require_cache2 = __commonJS((exports2, module2) => {
  var path3 = require("path");
  var fs2 = require("fs");
  var utils = require_utils8();
  var del = require_del();
  var writeJSON = utils.writeJSON;
  var cache = {
    load: function(docId, cacheDir) {
      var me = this;
      me._visited = {};
      me._persisted = {};
      me._pathToFile = cacheDir ? path3.resolve(cacheDir, docId) : path3.resolve(__dirname, "../.cache/", docId);
      if (fs2.existsSync(me._pathToFile)) {
        me._persisted = utils.tryParse(me._pathToFile, {});
      }
    },
    loadFile: function(pathToFile) {
      var me = this;
      var dir = path3.dirname(pathToFile);
      var fName = path3.basename(pathToFile);
      me.load(fName, dir);
    },
    all: function() {
      return this._persisted;
    },
    keys: function() {
      return Object.keys(this._persisted);
    },
    setKey: function(key, value) {
      this._visited[key] = true;
      this._persisted[key] = value;
    },
    removeKey: function(key) {
      delete this._visited[key];
      delete this._persisted[key];
    },
    getKey: function(key) {
      this._visited[key] = true;
      return this._persisted[key];
    },
    _prune: function() {
      var me = this;
      var obj = {};
      var keys = Object.keys(me._visited);
      if (keys.length === 0) {
        return;
      }
      keys.forEach(function(key) {
        obj[key] = me._persisted[key];
      });
      me._visited = {};
      me._persisted = obj;
    },
    save: function(noPrune) {
      var me = this;
      !noPrune && me._prune();
      writeJSON(me._pathToFile, me._persisted);
    },
    removeCacheFile: function() {
      return del(this._pathToFile);
    },
    destroy: function() {
      var me = this;
      me._visited = {};
      me._persisted = {};
      me.removeCacheFile();
    }
  };
  module2.exports = {
    load: function(docId, cacheDir) {
      return this.create(docId, cacheDir);
    },
    create: function(docId, cacheDir) {
      var obj = Object.create(cache);
      obj.load(docId, cacheDir);
      return obj;
    },
    createFromFile: function(filePath) {
      var obj = Object.create(cache);
      obj.loadFile(filePath);
      return obj;
    },
    clearCacheById: function(docId, cacheDir) {
      var filePath = cacheDir ? path3.resolve(cacheDir, docId) : path3.resolve(__dirname, "../.cache/", docId);
      return del(filePath);
    },
    clearAll: function(cacheDir) {
      var filePath = cacheDir ? path3.resolve(cacheDir) : path3.resolve(__dirname, "../.cache/");
      return del(filePath);
    }
  };
});

// node_modules/file-entry-cache/cache.js
var require_cache3 = __commonJS((exports2, module2) => {
  var path3 = require("path");
  var crypto = require("crypto");
  module2.exports = {
    createFromFile: function(filePath, useChecksum) {
      var fname = path3.basename(filePath);
      var dir = path3.dirname(filePath);
      return this.create(fname, dir, useChecksum);
    },
    create: function(cacheId, _path, useChecksum) {
      var fs2 = require("fs");
      var flatCache = require_cache2();
      var cache = flatCache.load(cacheId, _path);
      var normalizedEntries = {};
      var removeNotFoundFiles = function removeNotFoundFiles2() {
        const cachedEntries = cache.keys();
        cachedEntries.forEach(function remover(fPath) {
          try {
            fs2.statSync(fPath);
          } catch (err) {
            if (err.code === "ENOENT") {
              cache.removeKey(fPath);
            }
          }
        });
      };
      removeNotFoundFiles();
      return {
        cache,
        getHash: function(buffer) {
          return crypto.createHash("md5").update(buffer).digest("hex");
        },
        hasFileChanged: function(file) {
          return this.getFileDescriptor(file).changed;
        },
        analyzeFiles: function(files) {
          var me = this;
          files = files || [];
          var res = {
            changedFiles: [],
            notFoundFiles: [],
            notChangedFiles: []
          };
          me.normalizeEntries(files).forEach(function(entry) {
            if (entry.changed) {
              res.changedFiles.push(entry.key);
              return;
            }
            if (entry.notFound) {
              res.notFoundFiles.push(entry.key);
              return;
            }
            res.notChangedFiles.push(entry.key);
          });
          return res;
        },
        getFileDescriptor: function(file) {
          var fstat;
          try {
            fstat = fs2.statSync(file);
          } catch (ex) {
            this.removeEntry(file);
            return {key: file, notFound: true, err: ex};
          }
          if (useChecksum) {
            return this._getFileDescriptorUsingChecksum(file);
          }
          return this._getFileDescriptorUsingMtimeAndSize(file, fstat);
        },
        _getFileDescriptorUsingMtimeAndSize: function(file, fstat) {
          var meta = cache.getKey(file);
          var cacheExists = !!meta;
          var cSize = fstat.size;
          var cTime = fstat.mtime.getTime();
          var isDifferentDate;
          var isDifferentSize;
          if (!meta) {
            meta = {size: cSize, mtime: cTime};
          } else {
            isDifferentDate = cTime !== meta.mtime;
            isDifferentSize = cSize !== meta.size;
          }
          var nEntry = normalizedEntries[file] = {
            key: file,
            changed: !cacheExists || isDifferentDate || isDifferentSize,
            meta
          };
          return nEntry;
        },
        _getFileDescriptorUsingChecksum: function(file) {
          var meta = cache.getKey(file);
          var cacheExists = !!meta;
          var contentBuffer;
          try {
            contentBuffer = fs2.readFileSync(file);
          } catch (ex) {
            contentBuffer = "";
          }
          var isDifferent = true;
          var hash = this.getHash(contentBuffer);
          if (!meta) {
            meta = {hash};
          } else {
            isDifferent = hash !== meta.hash;
          }
          var nEntry = normalizedEntries[file] = {
            key: file,
            changed: !cacheExists || isDifferent,
            meta
          };
          return nEntry;
        },
        getUpdatedFiles: function(files) {
          var me = this;
          files = files || [];
          return me.normalizeEntries(files).filter(function(entry) {
            return entry.changed;
          }).map(function(entry) {
            return entry.key;
          });
        },
        normalizeEntries: function(files) {
          files = files || [];
          var me = this;
          var nEntries = files.map(function(file) {
            return me.getFileDescriptor(file);
          });
          return nEntries;
        },
        removeEntry: function(entryName) {
          delete normalizedEntries[entryName];
          cache.removeKey(entryName);
        },
        deleteCacheFile: function() {
          cache.removeCacheFile();
        },
        destroy: function() {
          normalizedEntries = {};
          cache.destroy();
        },
        _getMetaForFileUsingCheckSum: function(cacheEntry) {
          var contentBuffer = fs2.readFileSync(cacheEntry.key);
          var hash = this.getHash(contentBuffer);
          var meta = Object.assign(cacheEntry.meta, {hash});
          delete meta.size;
          delete meta.mtime;
          return meta;
        },
        _getMetaForFileUsingMtimeAndSize: function(cacheEntry) {
          var stat = fs2.statSync(cacheEntry.key);
          var meta = Object.assign(cacheEntry.meta, {
            size: stat.size,
            mtime: stat.mtime.getTime()
          });
          delete meta.hash;
          return meta;
        },
        reconcile: function(noPrune) {
          removeNotFoundFiles();
          noPrune = typeof noPrune === "undefined" ? true : noPrune;
          var entries = normalizedEntries;
          var keys = Object.keys(entries);
          if (keys.length === 0) {
            return;
          }
          var me = this;
          keys.forEach(function(entryName) {
            var cacheEntry = entries[entryName];
            try {
              var meta = useChecksum ? me._getMetaForFileUsingCheckSum(cacheEntry) : me._getMetaForFileUsingMtimeAndSize(cacheEntry);
              cache.setKey(entryName, meta);
            } catch (err) {
              if (err.code !== "ENOENT") {
                throw err;
              }
            }
          });
          cache.save(noPrune);
        }
      };
    }
  };
});

// node_modules/json-stable-stringify-without-jsonify/index.js
var require_json_stable_stringify_without_jsonify = __commonJS((exports2, module2) => {
  module2.exports = function(obj, opts) {
    if (!opts)
      opts = {};
    if (typeof opts === "function")
      opts = {cmp: opts};
    var space = opts.space || "";
    if (typeof space === "number")
      space = Array(space + 1).join(" ");
    var cycles = typeof opts.cycles === "boolean" ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) {
      return value;
    };
    var cmp = opts.cmp && function(f) {
      return function(node) {
        return function(a, b) {
          var aobj = {key: a, value: node[a]};
          var bobj = {key: b, value: node[b]};
          return f(aobj, bobj);
        };
      };
    }(opts.cmp);
    var seen = [];
    return function stringify(parent, key, node, level) {
      var indent = space ? "\n" + new Array(level + 1).join(space) : "";
      var colonSeparator = space ? ": " : ":";
      if (node && node.toJSON && typeof node.toJSON === "function") {
        node = node.toJSON();
      }
      node = replacer.call(parent, key, node);
      if (node === void 0) {
        return;
      }
      if (typeof node !== "object" || node === null) {
        return JSON.stringify(node);
      }
      if (isArray(node)) {
        var out = [];
        for (var i = 0; i < node.length; i++) {
          var item = stringify(node, i, node[i], level + 1) || JSON.stringify(null);
          out.push(indent + space + item);
        }
        return "[" + out.join(",") + indent + "]";
      } else {
        if (seen.indexOf(node) !== -1) {
          if (cycles)
            return JSON.stringify("__cycle__");
          throw new TypeError("Converting circular structure to JSON");
        } else
          seen.push(node);
        var keys = objectKeys(node).sort(cmp && cmp(node));
        var out = [];
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node, key, node[key], level + 1);
          if (!value)
            continue;
          var keyValue = JSON.stringify(key) + colonSeparator + value;
          ;
          out.push(indent + space + keyValue);
        }
        seen.splice(seen.indexOf(node), 1);
        return "{" + out.join(",") + indent + "}";
      }
    }({"": obj}, "", obj, 0);
  };
  var isArray = Array.isArray || function(x) {
    return {}.toString.call(x) === "[object Array]";
  };
  var objectKeys = Object.keys || function(obj) {
    var has = Object.prototype.hasOwnProperty || function() {
      return true;
    };
    var keys = [];
    for (var key in obj) {
      if (has.call(obj, key))
        keys.push(key);
    }
    return keys;
  };
});

// node_modules/eslint/lib/cli-engine/lint-result-cache.js
var require_lint_result_cache = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var fs2 = require("fs");
  var fileEntryCache = require_cache3();
  var stringify = require_json_stable_stringify_without_jsonify();
  var pkg = require_package();
  var hash = require_hash();
  var debug5 = require_src()("eslint:lint-result-cache");
  var configHashCache = new WeakMap();
  var nodeVersion = process && process.version;
  var validCacheStrategies = ["metadata", "content"];
  var invalidCacheStrategyErrorMessage = `Cache strategy must be one of: ${validCacheStrategies.map((strategy) => `"${strategy}"`).join(", ")}`;
  function isValidCacheStrategy(cacheStrategy) {
    return validCacheStrategies.indexOf(cacheStrategy) !== -1;
  }
  function hashOfConfigFor(config) {
    if (!configHashCache.has(config)) {
      configHashCache.set(config, hash(`${pkg.version}_${nodeVersion}_${stringify(config)}`));
    }
    return configHashCache.get(config);
  }
  var LintResultCache = class {
    constructor(cacheFileLocation, cacheStrategy) {
      assert(cacheFileLocation, "Cache file location is required");
      assert(cacheStrategy, "Cache strategy is required");
      assert(isValidCacheStrategy(cacheStrategy), invalidCacheStrategyErrorMessage);
      debug5(`Caching results to ${cacheFileLocation}`);
      const useChecksum = cacheStrategy === "content";
      debug5(`Using "${cacheStrategy}" strategy to detect changes`);
      this.fileEntryCache = fileEntryCache.create(cacheFileLocation, void 0, useChecksum);
      this.cacheFileLocation = cacheFileLocation;
    }
    getCachedLintResults(filePath, config) {
      const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);
      const hashOfConfig = hashOfConfigFor(config);
      const changed = fileDescriptor.changed || fileDescriptor.meta.hashOfConfig !== hashOfConfig;
      if (fileDescriptor.notFound) {
        debug5(`File not found on the file system: ${filePath}`);
        return null;
      }
      if (changed) {
        debug5(`Cache entry not found or no longer valid: ${filePath}`);
        return null;
      }
      if (fileDescriptor.meta.results && fileDescriptor.meta.results.source === null) {
        debug5(`Rereading cached result source from filesystem: ${filePath}`);
        fileDescriptor.meta.results.source = fs2.readFileSync(filePath, "utf-8");
      }
      return fileDescriptor.meta.results;
    }
    setCachedLintResults(filePath, config, result) {
      if (result && Object.prototype.hasOwnProperty.call(result, "output")) {
        return;
      }
      const fileDescriptor = this.fileEntryCache.getFileDescriptor(filePath);
      if (fileDescriptor && !fileDescriptor.notFound) {
        debug5(`Updating cached result: ${filePath}`);
        const resultToSerialize = Object.assign({}, result);
        if (Object.prototype.hasOwnProperty.call(resultToSerialize, "source")) {
          resultToSerialize.source = null;
        }
        fileDescriptor.meta.results = resultToSerialize;
        fileDescriptor.meta.hashOfConfig = hashOfConfigFor(config);
      }
    }
    reconcile() {
      debug5(`Persisting cached results: ${this.cacheFileLocation}`);
      this.fileEntryCache.reconcile();
    }
  };
  module2.exports = LintResultCache;
});

// node_modules/eslint/lib/cli-engine/cli-engine.js
var require_cli_engine = __commonJS((exports2, module2) => {
  "use strict";
  var fs2 = require("fs");
  var path3 = require("path");
  var defaultOptions = require_default_cli_options();
  var pkg = require_package();
  var {
    Legacy: {
      ConfigOps,
      naming,
      CascadingConfigArrayFactory,
      IgnorePattern,
      getUsedExtractedConfigs
    }
  } = require_lib2();
  var ModuleResolver = require_relative_module_resolver();
  var {FileEnumerator} = require_file_enumerator();
  var {Linter} = require_linter2();
  var builtInRules = require_rules2();
  var loadRules = require_load_rules();
  var hash = require_hash();
  var LintResultCache = require_lint_result_cache();
  var debug5 = require_src()("eslint:cli-engine");
  var validFixTypes = new Set(["problem", "suggestion", "layout"]);
  var internalSlotsMap = new WeakMap();
  function validateFixTypes(fixTypes) {
    for (const fixType of fixTypes) {
      if (!validFixTypes.has(fixType)) {
        throw new Error(`Invalid fix type "${fixType}" found.`);
      }
    }
  }
  function calculateStatsPerFile(messages) {
    return messages.reduce((stat, message) => {
      if (message.fatal || message.severity === 2) {
        stat.errorCount++;
        if (message.fix) {
          stat.fixableErrorCount++;
        }
      } else {
        stat.warningCount++;
        if (message.fix) {
          stat.fixableWarningCount++;
        }
      }
      return stat;
    }, {
      errorCount: 0,
      warningCount: 0,
      fixableErrorCount: 0,
      fixableWarningCount: 0
    });
  }
  function calculateStatsPerRun(results) {
    return results.reduce((stat, result) => {
      stat.errorCount += result.errorCount;
      stat.warningCount += result.warningCount;
      stat.fixableErrorCount += result.fixableErrorCount;
      stat.fixableWarningCount += result.fixableWarningCount;
      return stat;
    }, {
      errorCount: 0,
      warningCount: 0,
      fixableErrorCount: 0,
      fixableWarningCount: 0
    });
  }
  function verifyText({
    text,
    cwd,
    filePath: providedFilePath,
    config,
    fix,
    allowInlineConfig,
    reportUnusedDisableDirectives,
    fileEnumerator,
    linter
  }) {
    const filePath = providedFilePath || "<text>";
    debug5(`Lint ${filePath}`);
    const filePathToVerify = filePath === "<text>" ? path3.join(cwd, filePath) : filePath;
    const {fixed, messages, output} = linter.verifyAndFix(text, config, {
      allowInlineConfig,
      filename: filePathToVerify,
      fix,
      reportUnusedDisableDirectives,
      filterCodeBlock(blockFilename) {
        return fileEnumerator.isTargetPath(blockFilename);
      }
    });
    const result = __objSpread({
      filePath,
      messages
    }, calculateStatsPerFile(messages));
    if (fixed) {
      result.output = output;
    }
    if (result.errorCount + result.warningCount > 0 && typeof result.output === "undefined") {
      result.source = text;
    }
    return result;
  }
  function createIgnoreResult(filePath, baseDir) {
    let message;
    const isHidden = filePath.split(path3.sep).find((segment) => /^\./u.test(segment));
    const isInNodeModules = baseDir && path3.relative(baseDir, filePath).startsWith("node_modules");
    if (isHidden) {
      message = `File ignored by default.  Use a negated ignore pattern (like "--ignore-pattern '!<relative/path/to/filename>'") to override.`;
    } else if (isInNodeModules) {
      message = `File ignored by default. Use "--ignore-pattern '!node_modules/*'" to override.`;
    } else {
      message = 'File ignored because of a matching ignore pattern. Use "--no-ignore" to override.';
    }
    return {
      filePath: path3.resolve(filePath),
      messages: [
        {
          fatal: false,
          severity: 1,
          message
        }
      ],
      errorCount: 0,
      warningCount: 1,
      fixableErrorCount: 0,
      fixableWarningCount: 0
    };
  }
  function getRule(ruleId, configArrays) {
    for (const configArray of configArrays) {
      const rule = configArray.pluginRules.get(ruleId);
      if (rule) {
        return rule;
      }
    }
    return builtInRules.get(ruleId) || null;
  }
  function* iterateRuleDeprecationWarnings(usedConfigArrays) {
    const processedRuleIds = new Set();
    const configs = [].concat(...usedConfigArrays.map(getUsedExtractedConfigs));
    for (const config of configs) {
      for (const [ruleId, ruleConfig] of Object.entries(config.rules)) {
        if (processedRuleIds.has(ruleId)) {
          continue;
        }
        processedRuleIds.add(ruleId);
        if (!ConfigOps.getRuleSeverity(ruleConfig)) {
          continue;
        }
        const rule = getRule(ruleId, usedConfigArrays);
        if (!(rule && rule.meta && rule.meta.deprecated)) {
          continue;
        }
        yield {
          ruleId,
          replacedBy: rule.meta.replacedBy || []
        };
      }
    }
  }
  function isErrorMessage(message) {
    return message.severity === 2;
  }
  function getCacheFile(cacheFile, cwd) {
    const normalizedCacheFile = path3.normalize(cacheFile);
    const resolvedCacheFile = path3.resolve(cwd, normalizedCacheFile);
    const looksLikeADirectory = normalizedCacheFile.slice(-1) === path3.sep;
    function getCacheFileForDirectory() {
      return path3.join(resolvedCacheFile, `.cache_${hash(cwd)}`);
    }
    let fileStats;
    try {
      fileStats = fs2.lstatSync(resolvedCacheFile);
    } catch (e) {
      fileStats = null;
    }
    if (fileStats) {
      if (fileStats.isDirectory() || looksLikeADirectory) {
        return getCacheFileForDirectory();
      }
      return resolvedCacheFile;
    }
    if (looksLikeADirectory) {
      return getCacheFileForDirectory();
    }
    return resolvedCacheFile;
  }
  function toBooleanMap(keys, defaultValue, displayName) {
    if (keys && !Array.isArray(keys)) {
      throw new Error(`${displayName} must be an array.`);
    }
    if (keys && keys.length > 0) {
      return keys.reduce((map, def) => {
        const [key, value] = def.split(":");
        if (key !== "__proto__") {
          map[key] = value === void 0 ? defaultValue : value === "true";
        }
        return map;
      }, {});
    }
    return void 0;
  }
  function createConfigDataFromOptions(options) {
    const {
      ignorePattern,
      parser,
      parserOptions,
      plugins,
      rules
    } = options;
    const env = toBooleanMap(options.envs, true, "envs");
    const globals = toBooleanMap(options.globals, false, "globals");
    if (env === void 0 && globals === void 0 && (ignorePattern === void 0 || ignorePattern.length === 0) && parser === void 0 && parserOptions === void 0 && plugins === void 0 && rules === void 0) {
      return null;
    }
    return {
      env,
      globals,
      ignorePatterns: ignorePattern,
      parser,
      parserOptions,
      plugins,
      rules
    };
  }
  function directoryExists(resolvedPath) {
    try {
      return fs2.statSync(resolvedPath).isDirectory();
    } catch (error5) {
      if (error5 && (error5.code === "ENOENT" || error5.code === "ENOTDIR")) {
        return false;
      }
      throw error5;
    }
  }
  var CLIEngine = class {
    constructor(providedOptions) {
      const options = Object.assign(Object.create(null), defaultOptions, {cwd: process.cwd()}, providedOptions);
      if (options.fix === void 0) {
        options.fix = false;
      }
      const additionalPluginPool = new Map();
      const cacheFilePath = getCacheFile(options.cacheLocation || options.cacheFile, options.cwd);
      const configArrayFactory = new CascadingConfigArrayFactory({
        additionalPluginPool,
        baseConfig: options.baseConfig || null,
        cliConfig: createConfigDataFromOptions(options),
        cwd: options.cwd,
        ignorePath: options.ignorePath,
        resolvePluginsRelativeTo: options.resolvePluginsRelativeTo,
        rulePaths: options.rulePaths,
        specificConfigPath: options.configFile,
        useEslintrc: options.useEslintrc,
        builtInRules,
        loadRules,
        eslintRecommendedPath: path3.resolve(__dirname, "../../conf/eslint-recommended.js"),
        eslintAllPath: path3.resolve(__dirname, "../../conf/eslint-all.js")
      });
      const fileEnumerator = new FileEnumerator({
        configArrayFactory,
        cwd: options.cwd,
        extensions: options.extensions,
        globInputPaths: options.globInputPaths,
        errorOnUnmatchedPattern: options.errorOnUnmatchedPattern,
        ignore: options.ignore
      });
      const lintResultCache = options.cache ? new LintResultCache(cacheFilePath, options.cacheStrategy) : null;
      const linter = new Linter({cwd: options.cwd});
      const lastConfigArrays = [configArrayFactory.getConfigArrayForFile()];
      internalSlotsMap.set(this, {
        additionalPluginPool,
        cacheFilePath,
        configArrayFactory,
        defaultIgnores: IgnorePattern.createDefaultIgnore(options.cwd),
        fileEnumerator,
        lastConfigArrays,
        lintResultCache,
        linter,
        options
      });
      if (options.fix && options.fixTypes && options.fixTypes.length > 0) {
        debug5(`Using fix types ${options.fixTypes}`);
        validateFixTypes(options.fixTypes);
        const fixTypes = new Set(options.fixTypes);
        const originalFix = typeof options.fix === "function" ? options.fix : () => true;
        options.fix = (message) => {
          const rule = message.ruleId && getRule(message.ruleId, lastConfigArrays);
          const matches = rule && rule.meta && fixTypes.has(rule.meta.type);
          return matches && originalFix(message);
        };
      }
    }
    getRules() {
      const {lastConfigArrays} = internalSlotsMap.get(this);
      return new Map(function* () {
        yield* builtInRules;
        for (const configArray of lastConfigArrays) {
          yield* configArray.pluginRules;
        }
      }());
    }
    static getErrorResults(results) {
      const filtered = [];
      results.forEach((result) => {
        const filteredMessages = result.messages.filter(isErrorMessage);
        if (filteredMessages.length > 0) {
          filtered.push(__objSpread(__objSpread({}, result), {
            messages: filteredMessages,
            errorCount: filteredMessages.length,
            warningCount: 0,
            fixableErrorCount: result.fixableErrorCount,
            fixableWarningCount: 0
          }));
        }
      });
      return filtered;
    }
    static outputFixes(report) {
      report.results.filter((result) => Object.prototype.hasOwnProperty.call(result, "output")).forEach((result) => {
        fs2.writeFileSync(result.filePath, result.output);
      });
    }
    addPlugin(name, pluginObject) {
      const {
        additionalPluginPool,
        configArrayFactory,
        lastConfigArrays
      } = internalSlotsMap.get(this);
      additionalPluginPool.set(name, pluginObject);
      configArrayFactory.clearCache();
      lastConfigArrays.length = 1;
      lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();
    }
    resolveFileGlobPatterns(patterns) {
      const {options} = internalSlotsMap.get(this);
      if (options.globInputPaths === false) {
        return patterns.filter(Boolean);
      }
      const extensions = (options.extensions || [".js"]).map((ext) => ext.replace(/^\./u, ""));
      const dirSuffix = `/**/*.{${extensions.join(",")}}`;
      return patterns.filter(Boolean).map((pathname) => {
        const resolvedPath = path3.resolve(options.cwd, pathname);
        const newPath = directoryExists(resolvedPath) ? pathname.replace(/[/\\]$/u, "") + dirSuffix : pathname;
        return path3.normalize(newPath).replace(/\\/gu, "/");
      });
    }
    executeOnFiles(patterns) {
      const {
        cacheFilePath,
        fileEnumerator,
        lastConfigArrays,
        lintResultCache,
        linter,
        options: {
          allowInlineConfig,
          cache,
          cwd,
          fix,
          reportUnusedDisableDirectives
        }
      } = internalSlotsMap.get(this);
      const results = [];
      const startTime = Date.now();
      lastConfigArrays.length = 0;
      if (!cache) {
        try {
          fs2.unlinkSync(cacheFilePath);
        } catch (error5) {
          const errorCode = error5 && error5.code;
          if (errorCode !== "ENOENT" && !(errorCode === "EROFS" && !fs2.existsSync(cacheFilePath))) {
            throw error5;
          }
        }
      }
      for (const {config, filePath, ignored} of fileEnumerator.iterateFiles(patterns)) {
        if (ignored) {
          results.push(createIgnoreResult(filePath, cwd));
          continue;
        }
        if (!lastConfigArrays.includes(config)) {
          lastConfigArrays.push(config);
        }
        if (lintResultCache) {
          const cachedResult = lintResultCache.getCachedLintResults(filePath, config);
          if (cachedResult) {
            const hadMessages = cachedResult.messages && cachedResult.messages.length > 0;
            if (hadMessages && fix) {
              debug5(`Reprocessing cached file to allow autofix: ${filePath}`);
            } else {
              debug5(`Skipping file since it hasn't changed: ${filePath}`);
              results.push(cachedResult);
              continue;
            }
          }
        }
        const result = verifyText({
          text: fs2.readFileSync(filePath, "utf8"),
          filePath,
          config,
          cwd,
          fix,
          allowInlineConfig,
          reportUnusedDisableDirectives,
          fileEnumerator,
          linter
        });
        results.push(result);
        if (lintResultCache) {
          lintResultCache.setCachedLintResults(filePath, config, result);
        }
      }
      if (lintResultCache) {
        lintResultCache.reconcile();
      }
      debug5(`Linting complete in: ${Date.now() - startTime}ms`);
      let usedDeprecatedRules;
      return __objSpread(__objSpread({
        results
      }, calculateStatsPerRun(results)), {
        get usedDeprecatedRules() {
          if (!usedDeprecatedRules) {
            usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));
          }
          return usedDeprecatedRules;
        }
      });
    }
    executeOnText(text, filename, warnIgnored) {
      const {
        configArrayFactory,
        fileEnumerator,
        lastConfigArrays,
        linter,
        options: {
          allowInlineConfig,
          cwd,
          fix,
          reportUnusedDisableDirectives
        }
      } = internalSlotsMap.get(this);
      const results = [];
      const startTime = Date.now();
      const resolvedFilename = filename && path3.resolve(cwd, filename);
      lastConfigArrays.length = 0;
      if (resolvedFilename && this.isPathIgnored(resolvedFilename)) {
        if (warnIgnored) {
          results.push(createIgnoreResult(resolvedFilename, cwd));
        }
      } else {
        const config = configArrayFactory.getConfigArrayForFile(resolvedFilename || "__placeholder__.js");
        lastConfigArrays.push(config);
        results.push(verifyText({
          text,
          filePath: resolvedFilename,
          config,
          cwd,
          fix,
          allowInlineConfig,
          reportUnusedDisableDirectives,
          fileEnumerator,
          linter
        }));
      }
      debug5(`Linting complete in: ${Date.now() - startTime}ms`);
      let usedDeprecatedRules;
      return __objSpread(__objSpread({
        results
      }, calculateStatsPerRun(results)), {
        get usedDeprecatedRules() {
          if (!usedDeprecatedRules) {
            usedDeprecatedRules = Array.from(iterateRuleDeprecationWarnings(lastConfigArrays));
          }
          return usedDeprecatedRules;
        }
      });
    }
    getConfigForFile(filePath) {
      const {configArrayFactory, options} = internalSlotsMap.get(this);
      const absolutePath = path3.resolve(options.cwd, filePath);
      if (directoryExists(absolutePath)) {
        throw Object.assign(new Error("'filePath' should not be a directory path."), {messageTemplate: "print-config-with-directory-path"});
      }
      return configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath).toCompatibleObjectAsConfigFileContent();
    }
    isPathIgnored(filePath) {
      const {
        configArrayFactory,
        defaultIgnores,
        options: {cwd, ignore}
      } = internalSlotsMap.get(this);
      const absolutePath = path3.resolve(cwd, filePath);
      if (ignore) {
        const config = configArrayFactory.getConfigArrayForFile(absolutePath).extractConfig(absolutePath);
        const ignores = config.ignores || defaultIgnores;
        return ignores(absolutePath);
      }
      return defaultIgnores(absolutePath);
    }
    getFormatter(format) {
      const resolvedFormatName = format || "stylish";
      if (typeof resolvedFormatName === "string") {
        const normalizedFormatName = resolvedFormatName.replace(/\\/gu, "/");
        const slots = internalSlotsMap.get(this);
        const cwd = slots ? slots.options.cwd : process.cwd();
        const namespace = naming.getNamespaceFromTerm(normalizedFormatName);
        let formatterPath;
        if (!namespace && normalizedFormatName.indexOf("/") > -1) {
          formatterPath = path3.resolve(cwd, normalizedFormatName);
        } else {
          try {
            const npmFormat = naming.normalizePackageName(normalizedFormatName, "eslint-formatter");
            formatterPath = ModuleResolver.resolve(npmFormat, path3.join(cwd, "__placeholder__.js"));
          } catch (e) {
            formatterPath = path3.resolve(__dirname, "formatters", normalizedFormatName);
          }
        }
        try {
          return require(formatterPath);
        } catch (ex) {
          ex.message = `There was a problem loading formatter: ${formatterPath}
Error: ${ex.message}`;
          throw ex;
        }
      } else {
        return null;
      }
    }
  };
  CLIEngine.version = pkg.version;
  CLIEngine.getFormatter = CLIEngine.prototype.getFormatter;
  module2.exports = {
    CLIEngine,
    getCLIEngineInternalSlots(instance) {
      return internalSlotsMap.get(instance);
    }
  };
});

// node_modules/eslint/lib/cli-engine/index.js
var require_cli_engine2 = __commonJS((exports2, module2) => {
  "use strict";
  var {CLIEngine} = require_cli_engine();
  module2.exports = {
    CLIEngine
  };
});

// node_modules/eslint/lib/eslint/eslint.js
var require_eslint = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var fs2 = require("fs");
  var {promisify} = require("util");
  var {CLIEngine, getCLIEngineInternalSlots} = require_cli_engine();
  var BuiltinRules = require_rules2();
  var {
    Legacy: {
      ConfigOps: {
        getRuleSeverity
      }
    }
  } = require_lib2();
  var {version} = require_package();
  var writeFile = promisify(fs2.writeFile);
  var privateMembersMap = new WeakMap();
  function isNonEmptyString(x) {
    return typeof x === "string" && x.trim() !== "";
  }
  function isArrayOfNonEmptyString(x) {
    return Array.isArray(x) && x.every(isNonEmptyString);
  }
  function isFixType(x) {
    return x === "problem" || x === "suggestion" || x === "layout";
  }
  function isFixTypeArray(x) {
    return Array.isArray(x) && x.every(isFixType);
  }
  var ESLintInvalidOptionsError = class extends Error {
    constructor(messages) {
      super(`Invalid Options:
- ${messages.join("\n- ")}`);
      this.code = "ESLINT_INVALID_OPTIONS";
      Error.captureStackTrace(this, ESLintInvalidOptionsError);
    }
  };
  function processOptions(_a) {
    var _b = _a, {
      allowInlineConfig = true,
      baseConfig = null,
      cache = false,
      cacheLocation = ".eslintcache",
      cacheStrategy = "metadata",
      cwd = process.cwd(),
      errorOnUnmatchedPattern = true,
      extensions = null,
      fix = false,
      fixTypes = null,
      globInputPaths = true,
      ignore = true,
      ignorePath = null,
      overrideConfig = null,
      overrideConfigFile = null,
      plugins = {},
      reportUnusedDisableDirectives = null,
      resolvePluginsRelativeTo = null,
      rulePaths = [],
      useEslintrc = true
    } = _b, unknownOptions = __objRest(_b, [
      "allowInlineConfig",
      "baseConfig",
      "cache",
      "cacheLocation",
      "cacheStrategy",
      "cwd",
      "errorOnUnmatchedPattern",
      "extensions",
      "fix",
      "fixTypes",
      "globInputPaths",
      "ignore",
      "ignorePath",
      "overrideConfig",
      "overrideConfigFile",
      "plugins",
      "reportUnusedDisableDirectives",
      "resolvePluginsRelativeTo",
      "rulePaths",
      "useEslintrc"
    ]);
    const errors = [];
    const unknownOptionKeys = Object.keys(unknownOptions);
    if (unknownOptionKeys.length >= 1) {
      errors.push(`Unknown options: ${unknownOptionKeys.join(", ")}`);
      if (unknownOptionKeys.includes("cacheFile")) {
        errors.push("'cacheFile' has been removed. Please use the 'cacheLocation' option instead.");
      }
      if (unknownOptionKeys.includes("configFile")) {
        errors.push("'configFile' has been removed. Please use the 'overrideConfigFile' option instead.");
      }
      if (unknownOptionKeys.includes("envs")) {
        errors.push("'envs' has been removed. Please use the 'overrideConfig.env' option instead.");
      }
      if (unknownOptionKeys.includes("globals")) {
        errors.push("'globals' has been removed. Please use the 'overrideConfig.globals' option instead.");
      }
      if (unknownOptionKeys.includes("ignorePattern")) {
        errors.push("'ignorePattern' has been removed. Please use the 'overrideConfig.ignorePatterns' option instead.");
      }
      if (unknownOptionKeys.includes("parser")) {
        errors.push("'parser' has been removed. Please use the 'overrideConfig.parser' option instead.");
      }
      if (unknownOptionKeys.includes("parserOptions")) {
        errors.push("'parserOptions' has been removed. Please use the 'overrideConfig.parserOptions' option instead.");
      }
      if (unknownOptionKeys.includes("rules")) {
        errors.push("'rules' has been removed. Please use the 'overrideConfig.rules' option instead.");
      }
    }
    if (typeof allowInlineConfig !== "boolean") {
      errors.push("'allowInlineConfig' must be a boolean.");
    }
    if (typeof baseConfig !== "object") {
      errors.push("'baseConfig' must be an object or null.");
    }
    if (typeof cache !== "boolean") {
      errors.push("'cache' must be a boolean.");
    }
    if (!isNonEmptyString(cacheLocation)) {
      errors.push("'cacheLocation' must be a non-empty string.");
    }
    if (cacheStrategy !== "metadata" && cacheStrategy !== "content") {
      errors.push(`'cacheStrategy' must be any of "metadata", "content".`);
    }
    if (!isNonEmptyString(cwd) || !path3.isAbsolute(cwd)) {
      errors.push("'cwd' must be an absolute path.");
    }
    if (typeof errorOnUnmatchedPattern !== "boolean") {
      errors.push("'errorOnUnmatchedPattern' must be a boolean.");
    }
    if (!isArrayOfNonEmptyString(extensions) && extensions !== null) {
      errors.push("'extensions' must be an array of non-empty strings or null.");
    }
    if (typeof fix !== "boolean" && typeof fix !== "function") {
      errors.push("'fix' must be a boolean or a function.");
    }
    if (fixTypes !== null && !isFixTypeArray(fixTypes)) {
      errors.push(`'fixTypes' must be an array of any of "problem", "suggestion", and "layout".`);
    }
    if (typeof globInputPaths !== "boolean") {
      errors.push("'globInputPaths' must be a boolean.");
    }
    if (typeof ignore !== "boolean") {
      errors.push("'ignore' must be a boolean.");
    }
    if (!isNonEmptyString(ignorePath) && ignorePath !== null) {
      errors.push("'ignorePath' must be a non-empty string or null.");
    }
    if (typeof overrideConfig !== "object") {
      errors.push("'overrideConfig' must be an object or null.");
    }
    if (!isNonEmptyString(overrideConfigFile) && overrideConfigFile !== null) {
      errors.push("'overrideConfigFile' must be a non-empty string or null.");
    }
    if (typeof plugins !== "object") {
      errors.push("'plugins' must be an object or null.");
    } else if (plugins !== null && Object.keys(plugins).includes("")) {
      errors.push("'plugins' must not include an empty string.");
    }
    if (Array.isArray(plugins)) {
      errors.push("'plugins' doesn't add plugins to configuration to load. Please use the 'overrideConfig.plugins' option instead.");
    }
    if (reportUnusedDisableDirectives !== "error" && reportUnusedDisableDirectives !== "warn" && reportUnusedDisableDirectives !== "off" && reportUnusedDisableDirectives !== null) {
      errors.push(`'reportUnusedDisableDirectives' must be any of "error", "warn", "off", and null.`);
    }
    if (!isNonEmptyString(resolvePluginsRelativeTo) && resolvePluginsRelativeTo !== null) {
      errors.push("'resolvePluginsRelativeTo' must be a non-empty string or null.");
    }
    if (!isArrayOfNonEmptyString(rulePaths)) {
      errors.push("'rulePaths' must be an array of non-empty strings.");
    }
    if (typeof useEslintrc !== "boolean") {
      errors.push("'useEslintrc' must be a boolean.");
    }
    if (errors.length > 0) {
      throw new ESLintInvalidOptionsError(errors);
    }
    return {
      allowInlineConfig,
      baseConfig,
      cache,
      cacheLocation,
      cacheStrategy,
      configFile: overrideConfigFile,
      cwd,
      errorOnUnmatchedPattern,
      extensions,
      fix,
      fixTypes,
      globInputPaths,
      ignore,
      ignorePath,
      reportUnusedDisableDirectives,
      resolvePluginsRelativeTo,
      rulePaths,
      useEslintrc
    };
  }
  function hasDefinedProperty(obj) {
    if (typeof obj === "object" && obj !== null) {
      for (const key in obj) {
        if (typeof obj[key] !== "undefined") {
          return true;
        }
      }
    }
    return false;
  }
  function createRulesMeta(rules) {
    return Array.from(rules).reduce((retVal, [id, rule]) => {
      retVal[id] = rule.meta;
      return retVal;
    }, {});
  }
  var usedDeprecatedRulesCache = new WeakMap();
  function getOrFindUsedDeprecatedRules(cliEngine, maybeFilePath) {
    const {
      configArrayFactory,
      options: {cwd}
    } = getCLIEngineInternalSlots(cliEngine);
    const filePath = path3.isAbsolute(maybeFilePath) ? maybeFilePath : path3.join(cwd, "__placeholder__.js");
    const configArray = configArrayFactory.getConfigArrayForFile(filePath);
    const config = configArray.extractConfig(filePath);
    if (!usedDeprecatedRulesCache.has(config)) {
      const pluginRules = configArray.pluginRules;
      const retv = [];
      for (const [ruleId, ruleConf] of Object.entries(config.rules)) {
        if (getRuleSeverity(ruleConf) === 0) {
          continue;
        }
        const rule = pluginRules.get(ruleId) || BuiltinRules.get(ruleId);
        const meta = rule && rule.meta;
        if (meta && meta.deprecated) {
          retv.push({ruleId, replacedBy: meta.replacedBy || []});
        }
      }
      usedDeprecatedRulesCache.set(config, Object.freeze(retv));
    }
    return usedDeprecatedRulesCache.get(config);
  }
  function processCLIEngineLintReport(cliEngine, {results}) {
    const descriptor = {
      configurable: true,
      enumerable: true,
      get() {
        return getOrFindUsedDeprecatedRules(cliEngine, this.filePath);
      }
    };
    for (const result of results) {
      Object.defineProperty(result, "usedDeprecatedRules", descriptor);
    }
    return results;
  }
  function compareResultsByFilePath(a, b) {
    if (a.filePath < b.filePath) {
      return -1;
    }
    if (a.filePath > b.filePath) {
      return 1;
    }
    return 0;
  }
  var ESLint2 = class {
    constructor(options = {}) {
      const processedOptions = processOptions(options);
      const cliEngine = new CLIEngine(processedOptions);
      const {
        additionalPluginPool,
        configArrayFactory,
        lastConfigArrays
      } = getCLIEngineInternalSlots(cliEngine);
      let updated = false;
      if (options.plugins) {
        for (const [id, plugin] of Object.entries(options.plugins)) {
          additionalPluginPool.set(id, plugin);
          updated = true;
        }
      }
      if (hasDefinedProperty(options.overrideConfig)) {
        configArrayFactory.setOverrideConfig(options.overrideConfig);
        updated = true;
      }
      if (updated) {
        configArrayFactory.clearCache();
        lastConfigArrays[0] = configArrayFactory.getConfigArrayForFile();
      }
      privateMembersMap.set(this, {
        cliEngine,
        options: processedOptions
      });
    }
    static get version() {
      return version;
    }
    static outputFixes(results) {
      return __async(this, null, function* () {
        if (!Array.isArray(results)) {
          throw new Error("'results' must be an array");
        }
        yield Promise.all(results.filter((result) => {
          if (typeof result !== "object" || result === null) {
            throw new Error("'results' must include only objects");
          }
          return typeof result.output === "string" && path3.isAbsolute(result.filePath);
        }).map((r) => writeFile(r.filePath, r.output)));
      });
    }
    static getErrorResults(results) {
      return CLIEngine.getErrorResults(results);
    }
    lintFiles(patterns) {
      return __async(this, null, function* () {
        if (!isNonEmptyString(patterns) && !isArrayOfNonEmptyString(patterns)) {
          throw new Error("'patterns' must be a non-empty string or an array of non-empty strings");
        }
        const {cliEngine} = privateMembersMap.get(this);
        return processCLIEngineLintReport(cliEngine, cliEngine.executeOnFiles(patterns));
      });
    }
    lintText(_0) {
      return __async(this, arguments, function* (code, options = {}) {
        if (typeof code !== "string") {
          throw new Error("'code' must be a string");
        }
        if (typeof options !== "object") {
          throw new Error("'options' must be an object, null, or undefined");
        }
        const _a = options || {}, {
          filePath,
          warnIgnored = false
        } = _a, unknownOptions = __objRest(_a, [
          "filePath",
          "warnIgnored"
        ]);
        for (const key of Object.keys(unknownOptions)) {
          throw new Error(`'options' must not include the unknown option '${key}'`);
        }
        if (filePath !== void 0 && !isNonEmptyString(filePath)) {
          throw new Error("'options.filePath' must be a non-empty string or undefined");
        }
        if (typeof warnIgnored !== "boolean") {
          throw new Error("'options.warnIgnored' must be a boolean or undefined");
        }
        const {cliEngine} = privateMembersMap.get(this);
        return processCLIEngineLintReport(cliEngine, cliEngine.executeOnText(code, filePath, warnIgnored));
      });
    }
    loadFormatter(name = "stylish") {
      return __async(this, null, function* () {
        if (typeof name !== "string") {
          throw new Error("'name' must be a string");
        }
        const {cliEngine} = privateMembersMap.get(this);
        const formatter = cliEngine.getFormatter(name);
        if (typeof formatter !== "function") {
          throw new Error(`Formatter must be a function, but got a ${typeof formatter}.`);
        }
        return {
          format(results) {
            let rulesMeta = null;
            results.sort(compareResultsByFilePath);
            return formatter(results, {
              get rulesMeta() {
                if (!rulesMeta) {
                  rulesMeta = createRulesMeta(cliEngine.getRules());
                }
                return rulesMeta;
              }
            });
          }
        };
      });
    }
    calculateConfigForFile(filePath) {
      return __async(this, null, function* () {
        if (!isNonEmptyString(filePath)) {
          throw new Error("'filePath' must be a non-empty string");
        }
        const {cliEngine} = privateMembersMap.get(this);
        return cliEngine.getConfigForFile(filePath);
      });
    }
    isPathIgnored(filePath) {
      return __async(this, null, function* () {
        if (!isNonEmptyString(filePath)) {
          throw new Error("'filePath' must be a non-empty string");
        }
        const {cliEngine} = privateMembersMap.get(this);
        return cliEngine.isPathIgnored(filePath);
      });
    }
  };
  module2.exports = {
    ESLint: ESLint2,
    getESLintPrivateMembers(instance) {
      return privateMembersMap.get(instance);
    }
  };
});

// node_modules/eslint/lib/eslint/index.js
var require_eslint2 = __commonJS((exports2, module2) => {
  "use strict";
  var {ESLint: ESLint2} = require_eslint();
  module2.exports = {
    ESLint: ESLint2
  };
});

// node_modules/eslint/conf/config-schema.js
var require_config_schema2 = __commonJS((exports2, module2) => {
  "use strict";
  var baseConfigProperties = {
    $schema: {type: "string"},
    env: {type: "object"},
    extends: {$ref: "#/definitions/stringOrStrings"},
    globals: {type: "object"},
    overrides: {
      type: "array",
      items: {$ref: "#/definitions/overrideConfig"},
      additionalItems: false
    },
    parser: {type: ["string", "null"]},
    parserOptions: {type: "object"},
    plugins: {type: "array"},
    processor: {type: "string"},
    rules: {type: "object"},
    settings: {type: "object"},
    noInlineConfig: {type: "boolean"},
    reportUnusedDisableDirectives: {type: "boolean"},
    ecmaFeatures: {type: "object"}
  };
  var configSchema = {
    definitions: {
      stringOrStrings: {
        oneOf: [
          {type: "string"},
          {
            type: "array",
            items: {type: "string"},
            additionalItems: false
          }
        ]
      },
      stringOrStringsRequired: {
        oneOf: [
          {type: "string"},
          {
            type: "array",
            items: {type: "string"},
            additionalItems: false,
            minItems: 1
          }
        ]
      },
      objectConfig: {
        type: "object",
        properties: __objSpread({
          root: {type: "boolean"},
          ignorePatterns: {$ref: "#/definitions/stringOrStrings"}
        }, baseConfigProperties),
        additionalProperties: false
      },
      overrideConfig: {
        type: "object",
        properties: __objSpread({
          excludedFiles: {$ref: "#/definitions/stringOrStrings"},
          files: {$ref: "#/definitions/stringOrStringsRequired"}
        }, baseConfigProperties),
        required: ["files"],
        additionalProperties: false
      }
    },
    $ref: "#/definitions/objectConfig"
  };
  module2.exports = configSchema;
});

// node_modules/eslint/lib/shared/deprecation-warnings.js
var require_deprecation_warnings2 = __commonJS((exports2, module2) => {
  "use strict";
  var path3 = require("path");
  var lodash = require_lodash();
  var deprecationWarningMessages = {
    ESLINT_LEGACY_ECMAFEATURES: "The 'ecmaFeatures' config file property is deprecated and has no effect.",
    ESLINT_PERSONAL_CONFIG_LOAD: "'~/.eslintrc.*' config files have been deprecated. Please use a config file per project or the '--config' option.",
    ESLINT_PERSONAL_CONFIG_SUPPRESS: "'~/.eslintrc.*' config files have been deprecated. Please remove it or add 'root:true' to the config files in your projects in order to avoid loading '~/.eslintrc.*' accidentally."
  };
  var emitDeprecationWarning = lodash.memoize((source, errorCode) => {
    const rel = path3.relative(process.cwd(), source);
    const message = deprecationWarningMessages[errorCode];
    process.emitWarning(`${message} (found in "${rel}")`, "DeprecationWarning", errorCode);
  }, (...args) => JSON.stringify(args));
  module2.exports = {
    emitDeprecationWarning
  };
});

// node_modules/eslint/lib/shared/ajv.js
var require_ajv3 = __commonJS((exports2, module2) => {
  "use strict";
  var Ajv = require_ajv();
  var metaSchema = require_json_schema_draft_04();
  module2.exports = (additionalOptions = {}) => {
    const ajv = new Ajv(__objSpread({
      meta: false,
      useDefaults: true,
      validateSchema: false,
      missingRefs: "ignore",
      verbose: true,
      schemaId: "auto"
    }, additionalOptions));
    ajv.addMetaSchema(metaSchema);
    ajv._opts.defaultMeta = metaSchema.id;
    return ajv;
  };
});

// node_modules/eslint/lib/shared/config-validator.js
var require_config_validator2 = __commonJS((exports2, module2) => {
  "use strict";
  var util = require("util");
  var configSchema = require_config_schema2();
  var BuiltInEnvironments = require_environments();
  var BuiltInRules = require_rules2();
  var ConfigOps = require_config_ops();
  var {emitDeprecationWarning} = require_deprecation_warnings2();
  var ajv = require_ajv3()();
  var ruleValidators = new WeakMap();
  var noop = Function.prototype;
  var validateSchema;
  var severityMap = {
    error: 2,
    warn: 1,
    off: 0
  };
  function getRuleOptionsSchema(rule) {
    if (!rule) {
      return null;
    }
    const schema = rule.schema || rule.meta && rule.meta.schema;
    if (Array.isArray(schema)) {
      if (schema.length) {
        return {
          type: "array",
          items: schema,
          minItems: 0,
          maxItems: schema.length
        };
      }
      return {
        type: "array",
        minItems: 0,
        maxItems: 0
      };
    }
    return schema || null;
  }
  function validateRuleSeverity(options) {
    const severity = Array.isArray(options) ? options[0] : options;
    const normSeverity = typeof severity === "string" ? severityMap[severity.toLowerCase()] : severity;
    if (normSeverity === 0 || normSeverity === 1 || normSeverity === 2) {
      return normSeverity;
    }
    throw new Error(`	Severity should be one of the following: 0 = off, 1 = warn, 2 = error (you passed '${util.inspect(severity).replace(/'/gu, '"').replace(/\n/gu, "")}').
`);
  }
  function validateRuleSchema(rule, localOptions) {
    if (!ruleValidators.has(rule)) {
      const schema = getRuleOptionsSchema(rule);
      if (schema) {
        ruleValidators.set(rule, ajv.compile(schema));
      }
    }
    const validateRule = ruleValidators.get(rule);
    if (validateRule) {
      validateRule(localOptions);
      if (validateRule.errors) {
        throw new Error(validateRule.errors.map((error5) => `	Value ${JSON.stringify(error5.data)} ${error5.message}.
`).join(""));
      }
    }
  }
  function validateRuleOptions(rule, ruleId, options, source = null) {
    try {
      const severity = validateRuleSeverity(options);
      if (severity !== 0) {
        validateRuleSchema(rule, Array.isArray(options) ? options.slice(1) : []);
      }
    } catch (err) {
      const enhancedMessage = `Configuration for rule "${ruleId}" is invalid:
${err.message}`;
      if (typeof source === "string") {
        throw new Error(`${source}:
	${enhancedMessage}`);
      } else {
        throw new Error(enhancedMessage);
      }
    }
  }
  function validateEnvironment(environment, source, getAdditionalEnv = noop) {
    if (!environment) {
      return;
    }
    Object.keys(environment).forEach((id) => {
      const env = getAdditionalEnv(id) || BuiltInEnvironments.get(id) || null;
      if (!env) {
        const message = `${source}:
	Environment key "${id}" is unknown
`;
        throw new Error(message);
      }
    });
  }
  function validateRules(rulesConfig, source, getAdditionalRule = noop) {
    if (!rulesConfig) {
      return;
    }
    Object.keys(rulesConfig).forEach((id) => {
      const rule = getAdditionalRule(id) || BuiltInRules.get(id) || null;
      validateRuleOptions(rule, id, rulesConfig[id], source);
    });
  }
  function validateGlobals(globalsConfig, source = null) {
    if (!globalsConfig) {
      return;
    }
    Object.entries(globalsConfig).forEach(([configuredGlobal, configuredValue]) => {
      try {
        ConfigOps.normalizeConfigGlobal(configuredValue);
      } catch (err) {
        throw new Error(`ESLint configuration of global '${configuredGlobal}' in ${source} is invalid:
${err.message}`);
      }
    });
  }
  function validateProcessor(processorName, source, getProcessor) {
    if (processorName && !getProcessor(processorName)) {
      throw new Error(`ESLint configuration of processor in '${source}' is invalid: '${processorName}' was not found.`);
    }
  }
  function formatErrors(errors) {
    return errors.map((error5) => {
      if (error5.keyword === "additionalProperties") {
        const formattedPropertyPath = error5.dataPath.length ? `${error5.dataPath.slice(1)}.${error5.params.additionalProperty}` : error5.params.additionalProperty;
        return `Unexpected top-level property "${formattedPropertyPath}"`;
      }
      if (error5.keyword === "type") {
        const formattedField = error5.dataPath.slice(1);
        const formattedExpectedType = Array.isArray(error5.schema) ? error5.schema.join("/") : error5.schema;
        const formattedValue = JSON.stringify(error5.data);
        return `Property "${formattedField}" is the wrong type (expected ${formattedExpectedType} but got \`${formattedValue}\`)`;
      }
      const field = error5.dataPath[0] === "." ? error5.dataPath.slice(1) : error5.dataPath;
      return `"${field}" ${error5.message}. Value: ${JSON.stringify(error5.data)}`;
    }).map((message) => `	- ${message}.
`).join("");
  }
  function validateConfigSchema(config, source = null) {
    validateSchema = validateSchema || ajv.compile(configSchema);
    if (!validateSchema(config)) {
      throw new Error(`ESLint configuration in ${source} is invalid:
${formatErrors(validateSchema.errors)}`);
    }
    if (Object.hasOwnProperty.call(config, "ecmaFeatures")) {
      emitDeprecationWarning(source, "ESLINT_LEGACY_ECMAFEATURES");
    }
  }
  function validate(config, source, getAdditionalRule, getAdditionalEnv) {
    validateConfigSchema(config, source);
    validateRules(config.rules, source, getAdditionalRule);
    validateEnvironment(config.env, source, getAdditionalEnv);
    validateGlobals(config.globals, source);
    for (const override of config.overrides || []) {
      validateRules(override.rules, source, getAdditionalRule);
      validateEnvironment(override.env, source, getAdditionalEnv);
      validateGlobals(config.globals, source);
    }
  }
  var validated = new WeakSet();
  function validateConfigArray(configArray) {
    const getPluginEnv = Map.prototype.get.bind(configArray.pluginEnvironments);
    const getPluginProcessor = Map.prototype.get.bind(configArray.pluginProcessors);
    const getPluginRule = Map.prototype.get.bind(configArray.pluginRules);
    for (const element of configArray) {
      if (validated.has(element)) {
        continue;
      }
      validated.add(element);
      validateEnvironment(element.env, element.name, getPluginEnv);
      validateGlobals(element.globals, element.name);
      validateProcessor(element.processor, element.name, getPluginProcessor);
      validateRules(element.rules, element.name, getPluginRule);
    }
  }
  module2.exports = {
    getRuleOptionsSchema,
    validate,
    validateConfigArray,
    validateConfigSchema,
    validateRuleOptions
  };
});

// node_modules/eslint/lib/rule-tester/rule-tester.js
var require_rule_tester = __commonJS((exports2, module2) => {
  "use strict";
  var assert = require("assert");
  var path3 = require("path");
  var util = require("util");
  var lodash = require_lodash();
  var Traverser = require_traverser();
  var {getRuleOptionsSchema, validate} = require_config_validator2();
  var {Linter, SourceCodeFixer, interpolate} = require_linter2();
  var ajv = require_ajv3()({strictDefaults: true});
  var espreePath = require.resolve("espree");
  var testerDefaultConfig = {rules: {}};
  var defaultConfig = {rules: {}};
  var RuleTesterParameters = [
    "code",
    "filename",
    "options",
    "errors",
    "output"
  ];
  var errorObjectParameters = new Set([
    "message",
    "messageId",
    "data",
    "type",
    "line",
    "column",
    "endLine",
    "endColumn",
    "suggestions"
  ]);
  var friendlyErrorObjectParameterList = `[${[...errorObjectParameters].map((key) => `'${key}'`).join(", ")}]`;
  var suggestionObjectParameters = new Set([
    "desc",
    "messageId",
    "data",
    "output"
  ]);
  var friendlySuggestionObjectParameterList = `[${[...suggestionObjectParameters].map((key) => `'${key}'`).join(", ")}]`;
  var hasOwnProperty = Function.call.bind(Object.hasOwnProperty);
  function cloneDeeplyExcludesParent(x) {
    if (typeof x === "object" && x !== null) {
      if (Array.isArray(x)) {
        return x.map(cloneDeeplyExcludesParent);
      }
      const retv = {};
      for (const key in x) {
        if (key !== "parent" && hasOwnProperty(x, key)) {
          retv[key] = cloneDeeplyExcludesParent(x[key]);
        }
      }
      return retv;
    }
    return x;
  }
  function freezeDeeply(x) {
    if (typeof x === "object" && x !== null) {
      if (Array.isArray(x)) {
        x.forEach(freezeDeeply);
      } else {
        for (const key in x) {
          if (key !== "parent" && hasOwnProperty(x, key)) {
            freezeDeeply(x[key]);
          }
        }
      }
      Object.freeze(x);
    }
  }
  function sanitize(text) {
    return text.replace(/[\u0000-\u0009\u000b-\u001a]/gu, (c) => `\\u${c.codePointAt(0).toString(16).padStart(4, "0")}`);
  }
  function defineStartEndAsError(objName, node) {
    Object.defineProperties(node, {
      start: {
        get() {
          throw new Error(`Use ${objName}.range[0] instead of ${objName}.start`);
        },
        configurable: true,
        enumerable: false
      },
      end: {
        get() {
          throw new Error(`Use ${objName}.range[1] instead of ${objName}.end`);
        },
        configurable: true,
        enumerable: false
      }
    });
  }
  function defineStartEndAsErrorInTree(ast, visitorKeys) {
    Traverser.traverse(ast, {visitorKeys, enter: defineStartEndAsError.bind(null, "node")});
    ast.tokens.forEach(defineStartEndAsError.bind(null, "token"));
    ast.comments.forEach(defineStartEndAsError.bind(null, "token"));
  }
  function wrapParser(parser) {
    if (typeof parser.parseForESLint === "function") {
      return {
        parseForESLint(...args) {
          const ret = parser.parseForESLint(...args);
          defineStartEndAsErrorInTree(ret.ast, ret.visitorKeys);
          return ret;
        }
      };
    }
    return {
      parse(...args) {
        const ast = parser.parse(...args);
        defineStartEndAsErrorInTree(ast);
        return ast;
      }
    };
  }
  var DESCRIBE = Symbol("describe");
  var IT = Symbol("it");
  function itDefaultHandler(text, method) {
    try {
      return method.call(this);
    } catch (err) {
      if (err instanceof assert.AssertionError) {
        err.message += ` (${util.inspect(err.actual)} ${err.operator} ${util.inspect(err.expected)})`;
      }
      throw err;
    }
  }
  function describeDefaultHandler(text, method) {
    return method.call(this);
  }
  var RuleTester = class {
    constructor(testerConfig) {
      this.testerConfig = lodash.merge(lodash.cloneDeep(defaultConfig), testerConfig, {rules: {"rule-tester/validate-ast": "error"}});
      this.rules = {};
      this.linter = new Linter();
    }
    static setDefaultConfig(config) {
      if (typeof config !== "object") {
        throw new TypeError("RuleTester.setDefaultConfig: config must be an object");
      }
      defaultConfig = config;
      defaultConfig.rules = defaultConfig.rules || {};
    }
    static getDefaultConfig() {
      return defaultConfig;
    }
    static resetDefaultConfig() {
      defaultConfig = lodash.cloneDeep(testerDefaultConfig);
    }
    static get describe() {
      return this[DESCRIBE] || (typeof describe === "function" ? describe : describeDefaultHandler);
    }
    static set describe(value) {
      this[DESCRIBE] = value;
    }
    static get it() {
      return this[IT] || (typeof it === "function" ? it : itDefaultHandler);
    }
    static set it(value) {
      this[IT] = value;
    }
    defineRule(name, rule) {
      this.rules[name] = rule;
    }
    run(ruleName, rule, test) {
      const testerConfig = this.testerConfig, requiredScenarios = ["valid", "invalid"], scenarioErrors = [], linter = this.linter;
      if (!test || typeof test !== "object") {
        throw new TypeError(`Test Scenarios for rule ${ruleName} : Could not find test scenario object`);
      }
      requiredScenarios.forEach((scenarioType) => {
        if (!test[scenarioType]) {
          scenarioErrors.push(`Could not find any ${scenarioType} test scenarios`);
        }
      });
      if (scenarioErrors.length > 0) {
        throw new Error([
          `Test Scenarios for rule ${ruleName} is invalid:`
        ].concat(scenarioErrors).join("\n"));
      }
      linter.defineRule(ruleName, Object.assign({}, rule, {
        create(context4) {
          freezeDeeply(context4.options);
          freezeDeeply(context4.settings);
          freezeDeeply(context4.parserOptions);
          return (typeof rule === "function" ? rule : rule.create)(context4);
        }
      }));
      linter.defineRules(this.rules);
      function runRuleForItem(item) {
        let config = lodash.cloneDeep(testerConfig), code, filename, output, beforeAST, afterAST;
        if (typeof item === "string") {
          code = item;
        } else {
          code = item.code;
          const itemConfig = lodash.omit(item, RuleTesterParameters);
          config = lodash.merge(config, itemConfig);
        }
        if (item.filename) {
          filename = item.filename;
        }
        if (hasOwnProperty(item, "options")) {
          assert(Array.isArray(item.options), "options must be an array");
          config.rules[ruleName] = [1].concat(item.options);
        } else {
          config.rules[ruleName] = 1;
        }
        const schema = getRuleOptionsSchema(rule);
        linter.defineRule("rule-tester/validate-ast", () => ({
          Program(node) {
            beforeAST = cloneDeeplyExcludesParent(node);
          },
          "Program:exit"(node) {
            afterAST = node;
          }
        }));
        if (typeof config.parser === "string") {
          assert(path3.isAbsolute(config.parser), "Parsers provided as strings to RuleTester must be absolute paths");
        } else {
          config.parser = espreePath;
        }
        linter.defineParser(config.parser, wrapParser(require(config.parser)));
        if (schema) {
          ajv.validateSchema(schema);
          if (ajv.errors) {
            const errors = ajv.errors.map((error5) => {
              const field = error5.dataPath[0] === "." ? error5.dataPath.slice(1) : error5.dataPath;
              return `	${field}: ${error5.message}`;
            }).join("\n");
            throw new Error([`Schema for rule ${ruleName} is invalid:`, errors]);
          }
          try {
            ajv.compile(schema);
          } catch (err) {
            throw new Error(`Schema for rule ${ruleName} is invalid: ${err.message}`);
          }
        }
        validate(config, "rule-tester", (id) => id === ruleName ? rule : null);
        const messages = linter.verify(code, config, filename);
        const fatalErrorMessage = messages.find((m) => m.fatal);
        assert(!fatalErrorMessage, `A fatal parsing error occurred: ${fatalErrorMessage && fatalErrorMessage.message}`);
        if (messages.some((m) => m.fix)) {
          output = SourceCodeFixer.applyFixes(code, messages).output;
          const errorMessageInFix = linter.verify(output, config, filename).find((m) => m.fatal);
          assert(!errorMessageInFix, [
            "A fatal parsing error occurred in autofix.",
            `Error: ${errorMessageInFix && errorMessageInFix.message}`,
            "Autofix output:",
            output
          ].join("\n"));
        } else {
          output = code;
        }
        return {
          messages,
          output,
          beforeAST,
          afterAST: cloneDeeplyExcludesParent(afterAST)
        };
      }
      function assertASTDidntChange(beforeAST, afterAST) {
        if (!lodash.isEqual(beforeAST, afterAST)) {
          assert.fail("Rule should not modify AST.");
        }
      }
      function testValidTemplate(item) {
        const result = runRuleForItem(item);
        const messages = result.messages;
        assert.strictEqual(messages.length, 0, util.format("Should have no errors but had %d: %s", messages.length, util.inspect(messages)));
        assertASTDidntChange(result.beforeAST, result.afterAST);
      }
      function assertMessageMatches(actual, expected) {
        if (expected instanceof RegExp) {
          assert.ok(expected.test(actual), `Expected '${actual}' to match ${expected}`);
        } else {
          assert.strictEqual(actual, expected);
        }
      }
      function testInvalidTemplate(item) {
        assert.ok(item.errors || item.errors === 0, `Did not specify errors for an invalid test of ${ruleName}`);
        if (Array.isArray(item.errors) && item.errors.length === 0) {
          assert.fail("Invalid cases must have at least one error");
        }
        const ruleHasMetaMessages = hasOwnProperty(rule, "meta") && hasOwnProperty(rule.meta, "messages");
        const friendlyIDList = ruleHasMetaMessages ? `[${Object.keys(rule.meta.messages).map((key) => `'${key}'`).join(", ")}]` : null;
        const result = runRuleForItem(item);
        const messages = result.messages;
        if (typeof item.errors === "number") {
          if (item.errors === 0) {
            assert.fail("Invalid cases must have 'error' value greater than 0");
          }
          assert.strictEqual(messages.length, item.errors, util.format("Should have %d error%s but had %d: %s", item.errors, item.errors === 1 ? "" : "s", messages.length, util.inspect(messages)));
        } else {
          assert.strictEqual(messages.length, item.errors.length, util.format("Should have %d error%s but had %d: %s", item.errors.length, item.errors.length === 1 ? "" : "s", messages.length, util.inspect(messages)));
          const hasMessageOfThisRule = messages.some((m) => m.ruleId === ruleName);
          for (let i = 0, l = item.errors.length; i < l; i++) {
            const error5 = item.errors[i];
            const message = messages[i];
            assert(hasMessageOfThisRule, "Error rule name should be the same as the name of the rule being tested");
            if (typeof error5 === "string" || error5 instanceof RegExp) {
              assertMessageMatches(message.message, error5);
            } else if (typeof error5 === "object" && error5 !== null) {
              Object.keys(error5).forEach((propertyName) => {
                assert.ok(errorObjectParameters.has(propertyName), `Invalid error property name '${propertyName}'. Expected one of ${friendlyErrorObjectParameterList}.`);
              });
              if (hasOwnProperty(error5, "message")) {
                assert.ok(!hasOwnProperty(error5, "messageId"), "Error should not specify both 'message' and a 'messageId'.");
                assert.ok(!hasOwnProperty(error5, "data"), "Error should not specify both 'data' and 'message'.");
                assertMessageMatches(message.message, error5.message);
              } else if (hasOwnProperty(error5, "messageId")) {
                assert.ok(ruleHasMetaMessages, "Error can not use 'messageId' if rule under test doesn't define 'meta.messages'.");
                if (!hasOwnProperty(rule.meta.messages, error5.messageId)) {
                  assert(false, `Invalid messageId '${error5.messageId}'. Expected one of ${friendlyIDList}.`);
                }
                assert.strictEqual(message.messageId, error5.messageId, `messageId '${message.messageId}' does not match expected messageId '${error5.messageId}'.`);
                if (hasOwnProperty(error5, "data")) {
                  const unformattedOriginalMessage = rule.meta.messages[error5.messageId];
                  const rehydratedMessage = interpolate(unformattedOriginalMessage, error5.data);
                  assert.strictEqual(message.message, rehydratedMessage, `Hydrated message "${rehydratedMessage}" does not match "${message.message}"`);
                }
              }
              assert.ok(hasOwnProperty(error5, "data") ? hasOwnProperty(error5, "messageId") : true, "Error must specify 'messageId' if 'data' is used.");
              if (error5.type) {
                assert.strictEqual(message.nodeType, error5.type, `Error type should be ${error5.type}, found ${message.nodeType}`);
              }
              if (hasOwnProperty(error5, "line")) {
                assert.strictEqual(message.line, error5.line, `Error line should be ${error5.line}`);
              }
              if (hasOwnProperty(error5, "column")) {
                assert.strictEqual(message.column, error5.column, `Error column should be ${error5.column}`);
              }
              if (hasOwnProperty(error5, "endLine")) {
                assert.strictEqual(message.endLine, error5.endLine, `Error endLine should be ${error5.endLine}`);
              }
              if (hasOwnProperty(error5, "endColumn")) {
                assert.strictEqual(message.endColumn, error5.endColumn, `Error endColumn should be ${error5.endColumn}`);
              }
              if (hasOwnProperty(error5, "suggestions")) {
                if (!error5.suggestions || Array.isArray(error5.suggestions) && error5.suggestions.length === 0) {
                  if (Array.isArray(message.suggestions) && message.suggestions.length > 0) {
                    assert.fail(`Error should have no suggestions on error with message: "${message.message}"`);
                  }
                } else {
                  assert.strictEqual(Array.isArray(message.suggestions), true, `Error should have an array of suggestions. Instead received "${message.suggestions}" on error with message: "${message.message}"`);
                  assert.strictEqual(message.suggestions.length, error5.suggestions.length, `Error should have ${error5.suggestions.length} suggestions. Instead found ${message.suggestions.length} suggestions`);
                  error5.suggestions.forEach((expectedSuggestion, index) => {
                    assert.ok(typeof expectedSuggestion === "object" && expectedSuggestion !== null, "Test suggestion in 'suggestions' array must be an object.");
                    Object.keys(expectedSuggestion).forEach((propertyName) => {
                      assert.ok(suggestionObjectParameters.has(propertyName), `Invalid suggestion property name '${propertyName}'. Expected one of ${friendlySuggestionObjectParameterList}.`);
                    });
                    const actualSuggestion = message.suggestions[index];
                    const suggestionPrefix = `Error Suggestion at index ${index} :`;
                    if (hasOwnProperty(expectedSuggestion, "desc")) {
                      assert.ok(!hasOwnProperty(expectedSuggestion, "data"), `${suggestionPrefix} Test should not specify both 'desc' and 'data'.`);
                      assert.strictEqual(actualSuggestion.desc, expectedSuggestion.desc, `${suggestionPrefix} desc should be "${expectedSuggestion.desc}" but got "${actualSuggestion.desc}" instead.`);
                    }
                    if (hasOwnProperty(expectedSuggestion, "messageId")) {
                      assert.ok(ruleHasMetaMessages, `${suggestionPrefix} Test can not use 'messageId' if rule under test doesn't define 'meta.messages'.`);
                      assert.ok(hasOwnProperty(rule.meta.messages, expectedSuggestion.messageId), `${suggestionPrefix} Test has invalid messageId '${expectedSuggestion.messageId}', the rule under test allows only one of ${friendlyIDList}.`);
                      assert.strictEqual(actualSuggestion.messageId, expectedSuggestion.messageId, `${suggestionPrefix} messageId should be '${expectedSuggestion.messageId}' but got '${actualSuggestion.messageId}' instead.`);
                      if (hasOwnProperty(expectedSuggestion, "data")) {
                        const unformattedMetaMessage = rule.meta.messages[expectedSuggestion.messageId];
                        const rehydratedDesc = interpolate(unformattedMetaMessage, expectedSuggestion.data);
                        assert.strictEqual(actualSuggestion.desc, rehydratedDesc, `${suggestionPrefix} Hydrated test desc "${rehydratedDesc}" does not match received desc "${actualSuggestion.desc}".`);
                      }
                    } else {
                      assert.ok(!hasOwnProperty(expectedSuggestion, "data"), `${suggestionPrefix} Test must specify 'messageId' if 'data' is used.`);
                    }
                    if (hasOwnProperty(expectedSuggestion, "output")) {
                      const codeWithAppliedSuggestion = SourceCodeFixer.applyFixes(item.code, [actualSuggestion]).output;
                      assert.strictEqual(codeWithAppliedSuggestion, expectedSuggestion.output, `Expected the applied suggestion fix to match the test suggestion output for suggestion at index: ${index} on error with message: "${message.message}"`);
                    }
                  });
                }
              }
            } else {
              assert.fail(`Error should be a string, object, or RegExp, but found (${util.inspect(message)})`);
            }
          }
        }
        if (hasOwnProperty(item, "output")) {
          if (item.output === null) {
            assert.strictEqual(result.output, item.code, "Expected no autofixes to be suggested");
          } else {
            assert.strictEqual(result.output, item.output, "Output is incorrect.");
          }
        } else {
          assert.strictEqual(result.output, item.code, "The rule fixed the code. Please add 'output' property.");
        }
        if (result.output !== item.code) {
          assert.ok(hasOwnProperty(rule, "meta"), "Fixable rules should export a `meta.fixable` property.");
        }
        assertASTDidntChange(result.beforeAST, result.afterAST);
      }
      RuleTester.describe(ruleName, () => {
        RuleTester.describe("valid", () => {
          test.valid.forEach((valid) => {
            RuleTester.it(sanitize(typeof valid === "object" ? valid.code : valid), () => {
              testValidTemplate(valid);
            });
          });
        });
        RuleTester.describe("invalid", () => {
          test.invalid.forEach((invalid) => {
            RuleTester.it(sanitize(invalid.code), () => {
              testInvalidTemplate(invalid);
            });
          });
        });
      });
    }
  };
  RuleTester[DESCRIBE] = RuleTester[IT] = null;
  module2.exports = RuleTester;
});

// node_modules/eslint/lib/rule-tester/index.js
var require_rule_tester2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    RuleTester: require_rule_tester()
  };
});

// node_modules/eslint/lib/api.js
var require_api = __commonJS((exports2, module2) => {
  "use strict";
  var {CLIEngine} = require_cli_engine2();
  var {ESLint: ESLint2} = require_eslint2();
  var {Linter} = require_linter2();
  var {RuleTester} = require_rule_tester2();
  var {SourceCode} = require_source_code2();
  module2.exports = {
    Linter,
    CLIEngine,
    ESLint: ESLint2,
    RuleTester,
    SourceCode
  };
  var deprecatedLinterInstance = null;
  Object.defineProperty(module2.exports, "linter", {
    enumerable: false,
    get() {
      if (!deprecatedLinterInstance) {
        deprecatedLinterInstance = new Linter();
      }
      return deprecatedLinterInstance;
    }
  });
});

// src/eslint-action.ts
var core6 = __toModule(require_core());
var github3 = __toModule(require_github());
var import_rest = __toModule(require_dist_node12());

// src/fileUtils.ts
var import_fs = __toModule(require("fs"));
var import_path = __toModule(require("path"));
var core2 = __toModule(require_core());
var github = __toModule(require_github());
var import_micromatch = __toModule(require_micromatch());

// src/api.ts
var core = __toModule(require_core());
function fetchFilesBatchPR(client, prNumber, owner, repo, startCursor) {
  return __async(this, null, function* () {
    const {repository} = yield client.graphql(`
    query ChangedFilesBatch($owner: String!, $repo: String!, $prNumber: Int!, $startCursor: String) {
      repository(owner: $owner, name: $repo) {
        pullRequest(number: $prNumber) {
          files(first: 100, after: $startCursor) {
            pageInfo {
              hasNextPage
              endCursor
            }
            totalCount
            edges {
              cursor
              node {
                path
              }
            }
          }
        }
      }
    }
  `, {owner, repo, prNumber, startCursor});
    const pr = repository.pullRequest;
    if (!pr || !pr.files) {
      core.info(`No PR or PR files detected`);
      return {files: []};
    }
    core.info(`PR with files detected: ${pr.files.edges.map((e) => e.node.path)}`);
    return __objSpread(__objSpread({}, pr.files.pageInfo), {
      files: pr.files.edges.map((e) => e.node.path)
    });
  });
}
function fetchFilesBatchCommit(client, sha, owner, repo) {
  return __async(this, null, function* () {
    try {
      core.debug(`Getting commit data for ${owner}/${repo}#${sha}`);
      const resp = yield client.repos.getCommit({
        owner,
        repo,
        ref: sha
      });
      const filesChanged = resp.data.files.map((f) => f.filename);
      core.info(`Files changed: ${filesChanged}`);
      return filesChanged;
    } catch (err) {
      core.error(err);
      core.setFailed("Error occurred getting files from commit.");
      return [];
    }
  });
}

// src/fileUtils.ts
var getOwner = () => {
  var _a, _b;
  return (_b = (_a = github.context) == null ? void 0 : _a.repo) == null ? void 0 : _b.owner;
};
var getRepo = () => {
  var _a, _b;
  return (_b = (_a = github.context) == null ? void 0 : _a.repo) == null ? void 0 : _b.repo;
};
var filterFiles = (files, globs) => {
  const result = [];
  const filtered = (0, import_micromatch.default)(files, globs);
  for (const file of filtered) {
    if (import_fs.default.existsSync(import_path.default.resolve(file))) {
      result.push(import_path.default.resolve(file));
    }
  }
  return result;
};
function getFilesFromPR(client, prNumber) {
  return __async(this, null, function* () {
    let files = [];
    let hasNextPage = true;
    let startCursor = void 0;
    core2.debug(`Getting files from pull request #${prNumber}`);
    while (hasNextPage) {
      try {
        const result = yield fetchFilesBatchPR(client, prNumber, getOwner(), getRepo(), startCursor);
        files = files.concat(result.files);
        hasNextPage = result.hasNextPage;
        startCursor = result.endCursor;
      } catch (err) {
        core2.error(err);
        core2.setFailed("Error occurred getting changed files.");
        hasNextPage = false;
      }
    }
    return files;
  });
}
function getChangedFiles(client, filesGlob, prNumber, sha) {
  return __async(this, null, function* () {
    let files = [];
    if (prNumber) {
      files = yield getFilesFromPR(client, prNumber);
    } else {
      files = yield fetchFilesBatchCommit(client, sha, getOwner(), getRepo());
    }
    return filterFiles(files, filesGlob);
  });
}

// src/githubUtils.ts
var github2 = __toModule(require_github());
function getPrNumber() {
  const pullRequest = github2.context.payload.pull_request;
  if (!pullRequest) {
    return;
  }
  return pullRequest.number;
}
function getSha() {
  const pullRequest = github2.context.payload.pull_request;
  if (!pullRequest) {
    return github2.context.sha;
  }
  return pullRequest.head.sha;
}

// src/inputs.ts
var core3 = __toModule(require_core());
var processArrayInput = (key, required = false) => {
  return core3.getInput(key, {required}).split(",").map((e) => e.trim());
};
var processBooleanInput = (key) => {
  const value = core3.getInput(key).toLowerCase();
  return value === "true";
};
var inputs = {
  get token() {
    return core3.getInput("repo-token", {required: true});
  },
  get extensions() {
    return processArrayInput("extensions", true);
  },
  get ignore() {
    return processArrayInput("ignore");
  },
  get files() {
    return processArrayInput("files");
  },
  get cwd() {
    return core3.getInput("working-directory");
  },
  get quiet() {
    return processBooleanInput("quiet");
  }
};
var inputs_default = inputs;

// src/lint.ts
var import_path2 = __toModule(require("path"));
var core4 = __toModule(require_core());
var import_eslint = __toModule(require_api());
function lint(files) {
  return __async(this, null, function* () {
    let cwd = inputs_default.cwd;
    if (cwd && !import_path2.default.isAbsolute(cwd)) {
      cwd = import_path2.default.resolve(cwd);
    } else if (!cwd) {
      cwd = process.cwd();
    }
    core4.debug(`Starting lint engine with cwd: ${cwd}`);
    const linter = new import_eslint.ESLint({
      cwd,
      extensions: inputs_default.extensions,
      overrideConfig: {
        ignorePatterns: inputs_default.ignore
      }
    });
    const result = yield linter.lintFiles(files);
    return result;
  });
}

// src/processResults.ts
var core5 = __toModule(require_core());
var {GITHUB_WORKSPACE} = process.env;
var CHECK_NAME = "ESLint";
function logFileAnnotations(filePath, annotations) {
  core5.startGroup(filePath);
  annotations.forEach((a) => {
    const {message, annotation_level, start_line} = a;
    if (annotation_level === "warning") {
      core5.warning(`${message} (Line ${start_line})`);
    } else {
      core5.error(`${message} (Line ${start_line})`);
    }
  });
  core5.endGroup();
}
function processResults(results) {
  const annotations = [];
  let errorCount = 0;
  for (const result of results) {
    const {filePath, messages} = result;
    const relFilePath = filePath.replace(`${GITHUB_WORKSPACE}/`, "");
    const fileAnnotations = [];
    for (const lintMessage of messages) {
      const {line, severity, ruleId, message} = lintMessage;
      if (!ruleId) {
        continue;
      }
      if (severity === 2) {
        errorCount++;
      } else if (inputs_default.quiet) {
        continue;
      }
      fileAnnotations.push({
        path: relFilePath,
        start_line: line,
        end_line: line,
        annotation_level: severity === 2 ? "failure" : "warning",
        message: `[${ruleId}] ${message}`
      });
    }
    annotations.push(...fileAnnotations);
    if (core5.isDebug()) {
      logFileAnnotations(relFilePath, fileAnnotations);
    }
  }
  return {
    conclusion: errorCount > 0 ? "failure" : "success",
    output: {
      title: CHECK_NAME,
      summary: `${errorCount} error(s) found`,
      annotations
    }
  };
}

// src/eslint-action.ts
var OWNER = github3.context.repo.owner;
var REPO = github3.context.repo.repo;
function run() {
  return __async(this, null, function* () {
    var _a, _b, _c, _d, _e;
    const prNumber = getPrNumber();
    try {
      const octokit = new import_rest.Octokit({
        auth: inputs_default.token,
        log: {
          debug: core6.debug,
          info: core6.info,
          warn: core6.warning,
          error: core6.error
        }
      });
      core6.info(`PR: ${prNumber}, SHA: ${getSha()}, OWNER: ${OWNER}, REPO: ${REPO}`);
      core6.debug("Fetching files to lint.");
      const files = yield getChangedFiles(octokit, inputs_default.files, prNumber, getSha());
      core6.debug(`${files.length} files match ${inputs_default.files}.`);
      if (files.length > 0) {
        const {
          data: {id: checkId}
        } = yield octokit.checks.create({
          owner: OWNER,
          repo: REPO,
          started_at: new Date().toISOString(),
          head_sha: getSha(),
          status: "in_progress",
          name: CHECK_NAME
        });
        const report = yield lint(files);
        const payload = processResults(report);
        const maxChunk = 50;
        const annotationLength = (_c = (_b = (_a = payload == null ? void 0 : payload.output) == null ? void 0 : _a.annotations) == null ? void 0 : _b.length) != null ? _c : 0;
        if (payload == null ? void 0 : payload.output) {
          if (annotationLength > maxChunk) {
            const chunks = Math.ceil(annotationLength / maxChunk);
            core6.info(`There were ${annotationLength} annotations, splitting into ${chunks} requests`);
            for (let index = 0; index < chunks; index++) {
              const startIndex = index * maxChunk;
              const endIndex = startIndex + maxChunk;
              core6.info(`Applying annotations ${startIndex} to ${startIndex + maxChunk}...`);
              const returnValue = yield octokit.checks.update({
                owner: OWNER,
                repo: REPO,
                completed_at: new Date().toISOString(),
                status: endIndex <= annotationLength ? "in_progress" : "completed",
                check_run_id: checkId,
                conclusion: payload.conclusion,
                output: __objSpread(__objSpread({}, payload.output), {
                  annotations: (_e = (_d = payload == null ? void 0 : payload.output) == null ? void 0 : _d.annotations) == null ? void 0 : _e.slice(startIndex, endIndex)
                })
              });
              core6.debug(`Got response with status of ${returnValue.status}, ${returnValue.data}`);
            }
          } else if (annotationLength <= maxChunk) {
            yield octokit.checks.update(__objSpread({
              owner: OWNER,
              repo: REPO,
              completed_at: new Date().toISOString(),
              status: "completed",
              check_run_id: checkId
            }, payload));
          }
        }
      } else {
        core6.info("No files to lint.");
      }
    } catch (err) {
      core6.setFailed(err.message ? err.message : "Error linting files.");
    }
  });
}
run();
